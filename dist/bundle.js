(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (factory((global.THREE = global.THREE || {})));
}(this, (function (exports) { 'use strict';

    // Polyfills

    if ( Number.EPSILON === undefined ) {

    	Number.EPSILON = Math.pow( 2, - 52 );

    }

    //

    if ( Math.sign === undefined ) {

    	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign

    	Math.sign = function ( x ) {

    		return ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;

    	};

    }

    if ( Function.prototype.name === undefined ) {

    	// Missing in IE9-11.
    	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name

    	Object.defineProperty( Function.prototype, 'name', {

    		get: function () {

    			return this.toString().match( /^\s*function\s*(\S*)\s*\(/ )[ 1 ];

    		}

    	} );

    }

    if ( Object.assign === undefined ) {

    	// Missing in IE.
    	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign

    	( function () {

    		Object.assign = function ( target ) {

    			'use strict';

    			if ( target === undefined || target === null ) {

    				throw new TypeError( 'Cannot convert undefined or null to object' );

    			}

    			var output = Object( target );

    			for ( var index = 1; index < arguments.length; index ++ ) {

    				var source = arguments[ index ];

    				if ( source !== undefined && source !== null ) {

    					for ( var nextKey in source ) {

    						if ( Object.prototype.hasOwnProperty.call( source, nextKey ) ) {

    							output[ nextKey ] = source[ nextKey ];

    						}

    					}

    				}

    			}

    			return output;

    		};

    	} )();

    }

    /**
     * https://github.com/mrdoob/eventdispatcher.js/
     */

    function EventDispatcher() {}

    Object.assign( EventDispatcher.prototype, {

    	addEventListener: function ( type, listener ) {

    		if ( this._listeners === undefined ) this._listeners = {};

    		var listeners = this._listeners;

    		if ( listeners[ type ] === undefined ) {

    			listeners[ type ] = [];

    		}

    		if ( listeners[ type ].indexOf( listener ) === - 1 ) {

    			listeners[ type ].push( listener );

    		}

    	},

    	hasEventListener: function ( type, listener ) {

    		if ( this._listeners === undefined ) return false;

    		var listeners = this._listeners;

    		if ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {

    			return true;

    		}

    		return false;

    	},

    	removeEventListener: function ( type, listener ) {

    		if ( this._listeners === undefined ) return;

    		var listeners = this._listeners;
    		var listenerArray = listeners[ type ];

    		if ( listenerArray !== undefined ) {

    			var index = listenerArray.indexOf( listener );

    			if ( index !== - 1 ) {

    				listenerArray.splice( index, 1 );

    			}

    		}

    	},

    	dispatchEvent: function ( event ) {

    		if ( this._listeners === undefined ) return;

    		var listeners = this._listeners;
    		var listenerArray = listeners[ event.type ];

    		if ( listenerArray !== undefined ) {

    			event.target = this;

    			var array = [], i = 0;
    			var length = listenerArray.length;

    			for ( i = 0; i < length; i ++ ) {

    				array[ i ] = listenerArray[ i ];

    			}

    			for ( i = 0; i < length; i ++ ) {

    				array[ i ].call( this, event );

    			}

    		}

    	}

    } );

    var REVISION = '81';
    var MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };
    var CullFaceNone = 0;
    var CullFaceBack = 1;
    var CullFaceFront = 2;
    var CullFaceFrontBack = 3;
    var FrontFaceDirectionCW = 0;
    var FrontFaceDirectionCCW = 1;
    var BasicShadowMap = 0;
    var PCFShadowMap = 1;
    var PCFSoftShadowMap = 2;
    var FrontSide = 0;
    var BackSide = 1;
    var DoubleSide = 2;
    var FlatShading = 1;
    var SmoothShading = 2;
    var NoColors = 0;
    var FaceColors = 1;
    var VertexColors = 2;
    var NoBlending = 0;
    var NormalBlending = 1;
    var AdditiveBlending = 2;
    var SubtractiveBlending = 3;
    var MultiplyBlending = 4;
    var CustomBlending = 5;
    var BlendingMode = {
        NoBlending: NoBlending,
        NormalBlending: NormalBlending,
        AdditiveBlending: AdditiveBlending,
        SubtractiveBlending: SubtractiveBlending,
        MultiplyBlending: MultiplyBlending,
        CustomBlending: CustomBlending
    };
    var AddEquation = 100;
    var SubtractEquation = 101;
    var ReverseSubtractEquation = 102;
    var MinEquation = 103;
    var MaxEquation = 104;
    var ZeroFactor = 200;
    var OneFactor = 201;
    var SrcColorFactor = 202;
    var OneMinusSrcColorFactor = 203;
    var SrcAlphaFactor = 204;
    var OneMinusSrcAlphaFactor = 205;
    var DstAlphaFactor = 206;
    var OneMinusDstAlphaFactor = 207;
    var DstColorFactor = 208;
    var OneMinusDstColorFactor = 209;
    var SrcAlphaSaturateFactor = 210;
    var NeverDepth = 0;
    var AlwaysDepth = 1;
    var LessDepth = 2;
    var LessEqualDepth = 3;
    var EqualDepth = 4;
    var GreaterEqualDepth = 5;
    var GreaterDepth = 6;
    var NotEqualDepth = 7;
    var MultiplyOperation = 0;
    var MixOperation = 1;
    var AddOperation = 2;
    var NoToneMapping = 0;
    var LinearToneMapping = 1;
    var ReinhardToneMapping = 2;
    var Uncharted2ToneMapping = 3;
    var CineonToneMapping = 4;
    var UVMapping = 300;
    var CubeReflectionMapping = 301;
    var CubeRefractionMapping = 302;
    var EquirectangularReflectionMapping = 303;
    var EquirectangularRefractionMapping = 304;
    var SphericalReflectionMapping = 305;
    var CubeUVReflectionMapping = 306;
    var CubeUVRefractionMapping = 307;
    var TextureMapping = {
        UVMapping: UVMapping,
        CubeReflectionMapping: CubeReflectionMapping,
        CubeRefractionMapping: CubeRefractionMapping,
        EquirectangularReflectionMapping: EquirectangularReflectionMapping,
        EquirectangularRefractionMapping: EquirectangularRefractionMapping,
        SphericalReflectionMapping: SphericalReflectionMapping,
        CubeUVReflectionMapping: CubeUVReflectionMapping,
        CubeUVRefractionMapping: CubeUVRefractionMapping
    };
    var RepeatWrapping = 1000;
    var ClampToEdgeWrapping = 1001;
    var MirroredRepeatWrapping = 1002;
    var TextureWrapping = {
        RepeatWrapping: RepeatWrapping,
        ClampToEdgeWrapping: ClampToEdgeWrapping,
        MirroredRepeatWrapping: MirroredRepeatWrapping
    };
    var NearestFilter = 1003;
    var NearestMipMapNearestFilter = 1004;
    var NearestMipMapLinearFilter = 1005;
    var LinearFilter = 1006;
    var LinearMipMapNearestFilter = 1007;
    var LinearMipMapLinearFilter = 1008;
    var TextureFilter = {
        NearestFilter: NearestFilter,
        NearestMipMapNearestFilter: NearestMipMapNearestFilter,
        NearestMipMapLinearFilter: NearestMipMapLinearFilter,
        LinearFilter: LinearFilter,
        LinearMipMapNearestFilter: LinearMipMapNearestFilter,
        LinearMipMapLinearFilter: LinearMipMapLinearFilter
    };
    var UnsignedByteType = 1009;
    var ByteType = 1010;
    var ShortType = 1011;
    var UnsignedShortType = 1012;
    var IntType = 1013;
    var UnsignedIntType = 1014;
    var FloatType = 1015;
    var HalfFloatType = 1016;
    var UnsignedShort4444Type = 1017;
    var UnsignedShort5551Type = 1018;
    var UnsignedShort565Type = 1019;
    var UnsignedInt248Type = 1020;
    var AlphaFormat = 1021;
    var RGBFormat = 1022;
    var RGBAFormat = 1023;
    var LuminanceFormat = 1024;
    var LuminanceAlphaFormat = 1025;
    var RGBEFormat = RGBAFormat;
    var DepthFormat = 1026;
    var DepthStencilFormat = 1027;
    var RGB_S3TC_DXT1_Format = 2001;
    var RGBA_S3TC_DXT1_Format = 2002;
    var RGBA_S3TC_DXT3_Format = 2003;
    var RGBA_S3TC_DXT5_Format = 2004;
    var RGB_PVRTC_4BPPV1_Format = 2100;
    var RGB_PVRTC_2BPPV1_Format = 2101;
    var RGBA_PVRTC_4BPPV1_Format = 2102;
    var RGBA_PVRTC_2BPPV1_Format = 2103;
    var RGB_ETC1_Format = 2151;
    var LoopOnce = 2200;
    var LoopRepeat = 2201;
    var LoopPingPong = 2202;
    var InterpolateDiscrete = 2300;
    var InterpolateLinear = 2301;
    var InterpolateSmooth = 2302;
    var ZeroCurvatureEnding = 2400;
    var ZeroSlopeEnding = 2401;
    var WrapAroundEnding = 2402;
    var TrianglesDrawMode = 0;
    var TriangleStripDrawMode = 1;
    var TriangleFanDrawMode = 2;
    var LinearEncoding = 3000;
    var sRGBEncoding = 3001;
    var GammaEncoding = 3007;
    var RGBEEncoding = 3002;
    var LogLuvEncoding = 3003;
    var RGBM7Encoding = 3004;
    var RGBM16Encoding = 3005;
    var RGBDEncoding = 3006;
    var BasicDepthPacking = 3200;
    var RGBADepthPacking = 3201;

    /**
     * @author alteredq / http://alteredqualia.com/
     * @author mrdoob / http://mrdoob.com/
     */

    exports.Math = {

    	DEG2RAD: Math.PI / 180,
    	RAD2DEG: 180 / Math.PI,

    	generateUUID: function () {

    		// http://www.broofa.com/Tools/Math.uuid.htm

    		var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );
    		var uuid = new Array( 36 );
    		var rnd = 0, r;

    		return function generateUUID() {

    			for ( var i = 0; i < 36; i ++ ) {

    				if ( i === 8 || i === 13 || i === 18 || i === 23 ) {

    					uuid[ i ] = '-';

    				} else if ( i === 14 ) {

    					uuid[ i ] = '4';

    				} else {

    					if ( rnd <= 0x02 ) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;
    					r = rnd & 0xf;
    					rnd = rnd >> 4;
    					uuid[ i ] = chars[ ( i === 19 ) ? ( r & 0x3 ) | 0x8 : r ];

    				}

    			}

    			return uuid.join( '' );

    		};

    	}(),

    	clamp: function ( value, min, max ) {

    		return Math.max( min, Math.min( max, value ) );

    	},

    	// compute euclidian modulo of m % n
    	// https://en.wikipedia.org/wiki/Modulo_operation

    	euclideanModulo: function ( n, m ) {

    		return ( ( n % m ) + m ) % m;

    	},

    	// Linear mapping from range <a1, a2> to range <b1, b2>

    	mapLinear: function ( x, a1, a2, b1, b2 ) {

    		return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

    	},

    	// http://en.wikipedia.org/wiki/Smoothstep

    	smoothstep: function ( x, min, max ) {

    		if ( x <= min ) return 0;
    		if ( x >= max ) return 1;

    		x = ( x - min ) / ( max - min );

    		return x * x * ( 3 - 2 * x );

    	},

    	smootherstep: function ( x, min, max ) {

    		if ( x <= min ) return 0;
    		if ( x >= max ) return 1;

    		x = ( x - min ) / ( max - min );

    		return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

    	},

    	random16: function () {

    		console.warn( 'THREE.Math.random16() has been deprecated. Use Math.random() instead.' );
    		return Math.random();

    	},

    	// Random integer from <low, high> interval

    	randInt: function ( low, high ) {

    		return low + Math.floor( Math.random() * ( high - low + 1 ) );

    	},

    	// Random float from <low, high> interval

    	randFloat: function ( low, high ) {

    		return low + Math.random() * ( high - low );

    	},

    	// Random float from <-range/2, range/2> interval

    	randFloatSpread: function ( range ) {

    		return range * ( 0.5 - Math.random() );

    	},

    	degToRad: function ( degrees ) {

    		return degrees * exports.Math.DEG2RAD;

    	},

    	radToDeg: function ( radians ) {

    		return radians * exports.Math.RAD2DEG;

    	},

    	isPowerOfTwo: function ( value ) {

    		return ( value & ( value - 1 ) ) === 0 && value !== 0;

    	},

    	nearestPowerOfTwo: function ( value ) {

    		return Math.pow( 2, Math.round( Math.log( value ) / Math.LN2 ) );

    	},

    	nextPowerOfTwo: function ( value ) {

    		value --;
    		value |= value >> 1;
    		value |= value >> 2;
    		value |= value >> 4;
    		value |= value >> 8;
    		value |= value >> 16;
    		value ++;

    		return value;

    	}

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author philogb / http://blog.thejit.org/
     * @author egraether / http://egraether.com/
     * @author zz85 / http://www.lab4games.net/zz85/blog
     */

    function Vector2( x, y ) {

    	this.x = x || 0;
    	this.y = y || 0;

    }

    Vector2.prototype = {

    	constructor: Vector2,

    	isVector2: true,

    	get width() {

    		return this.x;

    	},

    	set width( value ) {

    		this.x = value;

    	},

    	get height() {

    		return this.y;

    	},

    	set height( value ) {

    		this.y = value;

    	},

    	//

    	set: function ( x, y ) {

    		this.x = x;
    		this.y = y;

    		return this;

    	},

    	setScalar: function ( scalar ) {

    		this.x = scalar;
    		this.y = scalar;

    		return this;

    	},

    	setX: function ( x ) {

    		this.x = x;

    		return this;

    	},

    	setY: function ( y ) {

    		this.y = y;

    		return this;

    	},

    	setComponent: function ( index, value ) {

    		switch ( index ) {

    			case 0: this.x = value; break;
    			case 1: this.y = value; break;
    			default: throw new Error( 'index is out of range: ' + index );

    		}

    	},

    	getComponent: function ( index ) {

    		switch ( index ) {

    			case 0: return this.x;
    			case 1: return this.y;
    			default: throw new Error( 'index is out of range: ' + index );

    		}

    	},

    	clone: function () {

    		return new this.constructor( this.x, this.y );

    	},

    	copy: function ( v ) {

    		this.x = v.x;
    		this.y = v.y;

    		return this;

    	},

    	add: function ( v, w ) {

    		if ( w !== undefined ) {

    			console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
    			return this.addVectors( v, w );

    		}

    		this.x += v.x;
    		this.y += v.y;

    		return this;

    	},

    	addScalar: function ( s ) {

    		this.x += s;
    		this.y += s;

    		return this;

    	},

    	addVectors: function ( a, b ) {

    		this.x = a.x + b.x;
    		this.y = a.y + b.y;

    		return this;

    	},

    	addScaledVector: function ( v, s ) {

    		this.x += v.x * s;
    		this.y += v.y * s;

    		return this;

    	},

    	sub: function ( v, w ) {

    		if ( w !== undefined ) {

    			console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
    			return this.subVectors( v, w );

    		}

    		this.x -= v.x;
    		this.y -= v.y;

    		return this;

    	},

    	subScalar: function ( s ) {

    		this.x -= s;
    		this.y -= s;

    		return this;

    	},

    	subVectors: function ( a, b ) {

    		this.x = a.x - b.x;
    		this.y = a.y - b.y;

    		return this;

    	},

    	multiply: function ( v ) {

    		this.x *= v.x;
    		this.y *= v.y;

    		return this;

    	},

    	multiplyScalar: function ( scalar ) {

    		if ( isFinite( scalar ) ) {

    			this.x *= scalar;
    			this.y *= scalar;

    		} else {

    			this.x = 0;
    			this.y = 0;

    		}

    		return this;

    	},

    	divide: function ( v ) {

    		this.x /= v.x;
    		this.y /= v.y;

    		return this;

    	},

    	divideScalar: function ( scalar ) {

    		return this.multiplyScalar( 1 / scalar );

    	},

    	min: function ( v ) {

    		this.x = Math.min( this.x, v.x );
    		this.y = Math.min( this.y, v.y );

    		return this;

    	},

    	max: function ( v ) {

    		this.x = Math.max( this.x, v.x );
    		this.y = Math.max( this.y, v.y );

    		return this;

    	},

    	clamp: function ( min, max ) {

    		// This function assumes min < max, if this assumption isn't true it will not operate correctly

    		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
    		this.y = Math.max( min.y, Math.min( max.y, this.y ) );

    		return this;

    	},

    	clampScalar: function () {

    		var min, max;

    		return function clampScalar( minVal, maxVal ) {

    			if ( min === undefined ) {

    				min = new Vector2();
    				max = new Vector2();

    			}

    			min.set( minVal, minVal );
    			max.set( maxVal, maxVal );

    			return this.clamp( min, max );

    		};

    	}(),

    	clampLength: function ( min, max ) {

    		var length = this.length();

    		return this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );

    	},

    	floor: function () {

    		this.x = Math.floor( this.x );
    		this.y = Math.floor( this.y );

    		return this;

    	},

    	ceil: function () {

    		this.x = Math.ceil( this.x );
    		this.y = Math.ceil( this.y );

    		return this;

    	},

    	round: function () {

    		this.x = Math.round( this.x );
    		this.y = Math.round( this.y );

    		return this;

    	},

    	roundToZero: function () {

    		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
    		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );

    		return this;

    	},

    	negate: function () {

    		this.x = - this.x;
    		this.y = - this.y;

    		return this;

    	},

    	dot: function ( v ) {

    		return this.x * v.x + this.y * v.y;

    	},

    	lengthSq: function () {

    		return this.x * this.x + this.y * this.y;

    	},

    	length: function () {

    		return Math.sqrt( this.x * this.x + this.y * this.y );

    	},

    	lengthManhattan: function() {

    		return Math.abs( this.x ) + Math.abs( this.y );

    	},

    	normalize: function () {

    		return this.divideScalar( this.length() );

    	},

    	angle: function () {

    		// computes the angle in radians with respect to the positive x-axis

    		var angle = Math.atan2( this.y, this.x );

    		if ( angle < 0 ) angle += 2 * Math.PI;

    		return angle;

    	},

    	distanceTo: function ( v ) {

    		return Math.sqrt( this.distanceToSquared( v ) );

    	},

    	distanceToSquared: function ( v ) {

    		var dx = this.x - v.x, dy = this.y - v.y;
    		return dx * dx + dy * dy;

    	},

    	distanceToManhattan: function ( v ) {

    		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );

    	},

    	setLength: function ( length ) {

    		return this.multiplyScalar( length / this.length() );

    	},

    	lerp: function ( v, alpha ) {

    		this.x += ( v.x - this.x ) * alpha;
    		this.y += ( v.y - this.y ) * alpha;

    		return this;

    	},

    	lerpVectors: function ( v1, v2, alpha ) {

    		return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

    	},

    	equals: function ( v ) {

    		return ( ( v.x === this.x ) && ( v.y === this.y ) );

    	},

    	fromArray: function ( array, offset ) {

    		if ( offset === undefined ) offset = 0;

    		this.x = array[ offset ];
    		this.y = array[ offset + 1 ];

    		return this;

    	},

    	toArray: function ( array, offset ) {

    		if ( array === undefined ) array = [];
    		if ( offset === undefined ) offset = 0;

    		array[ offset ] = this.x;
    		array[ offset + 1 ] = this.y;

    		return array;

    	},

    	fromAttribute: function ( attribute, index, offset ) {

    		if ( offset === undefined ) offset = 0;

    		index = index * attribute.itemSize + offset;

    		this.x = attribute.array[ index ];
    		this.y = attribute.array[ index + 1 ];

    		return this;

    	},

    	rotateAround: function ( center, angle ) {

    		var c = Math.cos( angle ), s = Math.sin( angle );

    		var x = this.x - center.x;
    		var y = this.y - center.y;

    		this.x = x * c - y * s + center.x;
    		this.y = x * s + y * c + center.y;

    		return this;

    	}

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     * @author szimek / https://github.com/szimek/
     */

    function Texture( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {

    	Object.defineProperty( this, 'id', { value: TextureIdCount() } );

    	this.uuid = exports.Math.generateUUID();

    	this.name = '';
    	this.sourceFile = '';

    	this.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;
    	this.mipmaps = [];

    	this.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;

    	this.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping;
    	this.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping;

    	this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
    	this.minFilter = minFilter !== undefined ? minFilter : LinearMipMapLinearFilter;

    	this.anisotropy = anisotropy !== undefined ? anisotropy : 1;

    	this.format = format !== undefined ? format : RGBAFormat;
    	this.type = type !== undefined ? type : UnsignedByteType;

    	this.offset = new Vector2( 0, 0 );
    	this.repeat = new Vector2( 1, 1 );

    	this.generateMipmaps = true;
    	this.premultiplyAlpha = false;
    	this.flipY = true;
    	this.unpackAlignment = 4;	// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)


    	// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
    	//
    	// Also changing the encoding after already used by a Material will not automatically make the Material
    	// update.  You need to explicitly call Material.needsUpdate to trigger it to recompile.
    	this.encoding = encoding !== undefined ? encoding :  LinearEncoding;

    	this.version = 0;
    	this.onUpdate = null;

    }

    Texture.DEFAULT_IMAGE = undefined;
    Texture.DEFAULT_MAPPING = UVMapping;

    Texture.prototype = {

    	constructor: Texture,

    	isTexture: true,

    	set needsUpdate( value ) {

    		if ( value === true ) this.version ++;

    	},

    	clone: function () {

    		return new this.constructor().copy( this );

    	},

    	copy: function ( source ) {

    		this.image = source.image;
    		this.mipmaps = source.mipmaps.slice( 0 );

    		this.mapping = source.mapping;

    		this.wrapS = source.wrapS;
    		this.wrapT = source.wrapT;

    		this.magFilter = source.magFilter;
    		this.minFilter = source.minFilter;

    		this.anisotropy = source.anisotropy;

    		this.format = source.format;
    		this.type = source.type;

    		this.offset.copy( source.offset );
    		this.repeat.copy( source.repeat );

    		this.generateMipmaps = source.generateMipmaps;
    		this.premultiplyAlpha = source.premultiplyAlpha;
    		this.flipY = source.flipY;
    		this.unpackAlignment = source.unpackAlignment;
    		this.encoding = source.encoding;

    		return this;

    	},

    	toJSON: function ( meta ) {

    		if ( meta.textures[ this.uuid ] !== undefined ) {

    			return meta.textures[ this.uuid ];

    		}

    		function getDataURL( image ) {

    			var canvas;

    			if ( image.toDataURL !== undefined ) {

    				canvas = image;

    			} else {

    				canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
    				canvas.width = image.width;
    				canvas.height = image.height;

    				canvas.getContext( '2d' ).drawImage( image, 0, 0, image.width, image.height );

    			}

    			if ( canvas.width > 2048 || canvas.height > 2048 ) {

    				return canvas.toDataURL( 'image/jpeg', 0.6 );

    			} else {

    				return canvas.toDataURL( 'image/png' );

    			}

    		}

    		var output = {
    			metadata: {
    				version: 4.4,
    				type: 'Texture',
    				generator: 'Texture.toJSON'
    			},

    			uuid: this.uuid,
    			name: this.name,

    			mapping: this.mapping,

    			repeat: [ this.repeat.x, this.repeat.y ],
    			offset: [ this.offset.x, this.offset.y ],
    			wrap: [ this.wrapS, this.wrapT ],

    			minFilter: this.minFilter,
    			magFilter: this.magFilter,
    			anisotropy: this.anisotropy,

    			flipY: this.flipY
    		};

    		if ( this.image !== undefined ) {

    			// TODO: Move to THREE.Image

    			var image = this.image;

    			if ( image.uuid === undefined ) {

    				image.uuid = exports.Math.generateUUID(); // UGH

    			}

    			if ( meta.images[ image.uuid ] === undefined ) {

    				meta.images[ image.uuid ] = {
    					uuid: image.uuid,
    					url: getDataURL( image )
    				};

    			}

    			output.image = image.uuid;

    		}

    		meta.textures[ this.uuid ] = output;

    		return output;

    	},

    	dispose: function () {

    		this.dispatchEvent( { type: 'dispose' } );

    	},

    	transformUv: function ( uv ) {

    		if ( this.mapping !== UVMapping )  return;

    		uv.multiply( this.repeat );
    		uv.add( this.offset );

    		if ( uv.x < 0 || uv.x > 1 ) {

    			switch ( this.wrapS ) {

    				case RepeatWrapping:

    					uv.x = uv.x - Math.floor( uv.x );
    					break;

    				case ClampToEdgeWrapping:

    					uv.x = uv.x < 0 ? 0 : 1;
    					break;

    				case MirroredRepeatWrapping:

    					if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {

    						uv.x = Math.ceil( uv.x ) - uv.x;

    					} else {

    						uv.x = uv.x - Math.floor( uv.x );

    					}
    					break;

    			}

    		}

    		if ( uv.y < 0 || uv.y > 1 ) {

    			switch ( this.wrapT ) {

    				case RepeatWrapping:

    					uv.y = uv.y - Math.floor( uv.y );
    					break;

    				case ClampToEdgeWrapping:

    					uv.y = uv.y < 0 ? 0 : 1;
    					break;

    				case MirroredRepeatWrapping:

    					if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {

    						uv.y = Math.ceil( uv.y ) - uv.y;

    					} else {

    						uv.y = uv.y - Math.floor( uv.y );

    					}
    					break;

    			}

    		}

    		if ( this.flipY ) {

    			uv.y = 1 - uv.y;

    		}

    	}

    };

    Object.assign( Texture.prototype, EventDispatcher.prototype );

    var count = 0;
    function TextureIdCount() { return count++; };

    /**
     * @author supereggbert / http://www.paulbrunt.co.uk/
     * @author philogb / http://blog.thejit.org/
     * @author mikael emtinger / http://gomo.se/
     * @author egraether / http://egraether.com/
     * @author WestLangley / http://github.com/WestLangley
     */

    function Vector4( x, y, z, w ) {

    	this.x = x || 0;
    	this.y = y || 0;
    	this.z = z || 0;
    	this.w = ( w !== undefined ) ? w : 1;

    }

    Vector4.prototype = {

    	constructor: Vector4,

    	isVector4: true,

    	set: function ( x, y, z, w ) {

    		this.x = x;
    		this.y = y;
    		this.z = z;
    		this.w = w;

    		return this;

    	},

    	setScalar: function ( scalar ) {

    		this.x = scalar;
    		this.y = scalar;
    		this.z = scalar;
    		this.w = scalar;

    		return this;

    	},

    	setX: function ( x ) {

    		this.x = x;

    		return this;

    	},

    	setY: function ( y ) {

    		this.y = y;

    		return this;

    	},

    	setZ: function ( z ) {

    		this.z = z;

    		return this;

    	},

    	setW: function ( w ) {

    		this.w = w;

    		return this;

    	},

    	setComponent: function ( index, value ) {

    		switch ( index ) {

    			case 0: this.x = value; break;
    			case 1: this.y = value; break;
    			case 2: this.z = value; break;
    			case 3: this.w = value; break;
    			default: throw new Error( 'index is out of range: ' + index );

    		}

    	},

    	getComponent: function ( index ) {

    		switch ( index ) {

    			case 0: return this.x;
    			case 1: return this.y;
    			case 2: return this.z;
    			case 3: return this.w;
    			default: throw new Error( 'index is out of range: ' + index );

    		}

    	},

    	clone: function () {

    		return new this.constructor( this.x, this.y, this.z, this.w );

    	},

    	copy: function ( v ) {

    		this.x = v.x;
    		this.y = v.y;
    		this.z = v.z;
    		this.w = ( v.w !== undefined ) ? v.w : 1;

    		return this;

    	},

    	add: function ( v, w ) {

    		if ( w !== undefined ) {

    			console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
    			return this.addVectors( v, w );

    		}

    		this.x += v.x;
    		this.y += v.y;
    		this.z += v.z;
    		this.w += v.w;

    		return this;

    	},

    	addScalar: function ( s ) {

    		this.x += s;
    		this.y += s;
    		this.z += s;
    		this.w += s;

    		return this;

    	},

    	addVectors: function ( a, b ) {

    		this.x = a.x + b.x;
    		this.y = a.y + b.y;
    		this.z = a.z + b.z;
    		this.w = a.w + b.w;

    		return this;

    	},

    	addScaledVector: function ( v, s ) {

    		this.x += v.x * s;
    		this.y += v.y * s;
    		this.z += v.z * s;
    		this.w += v.w * s;

    		return this;

    	},

    	sub: function ( v, w ) {

    		if ( w !== undefined ) {

    			console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
    			return this.subVectors( v, w );

    		}

    		this.x -= v.x;
    		this.y -= v.y;
    		this.z -= v.z;
    		this.w -= v.w;

    		return this;

    	},

    	subScalar: function ( s ) {

    		this.x -= s;
    		this.y -= s;
    		this.z -= s;
    		this.w -= s;

    		return this;

    	},

    	subVectors: function ( a, b ) {

    		this.x = a.x - b.x;
    		this.y = a.y - b.y;
    		this.z = a.z - b.z;
    		this.w = a.w - b.w;

    		return this;

    	},

    	multiplyScalar: function ( scalar ) {

    		if ( isFinite( scalar ) ) {

    			this.x *= scalar;
    			this.y *= scalar;
    			this.z *= scalar;
    			this.w *= scalar;

    		} else {

    			this.x = 0;
    			this.y = 0;
    			this.z = 0;
    			this.w = 0;

    		}

    		return this;

    	},

    	applyMatrix4: function ( m ) {

    		var x = this.x, y = this.y, z = this.z, w = this.w;
    		var e = m.elements;

    		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
    		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
    		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
    		this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

    		return this;

    	},

    	divideScalar: function ( scalar ) {

    		return this.multiplyScalar( 1 / scalar );

    	},

    	setAxisAngleFromQuaternion: function ( q ) {

    		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

    		// q is assumed to be normalized

    		this.w = 2 * Math.acos( q.w );

    		var s = Math.sqrt( 1 - q.w * q.w );

    		if ( s < 0.0001 ) {

    			 this.x = 1;
    			 this.y = 0;
    			 this.z = 0;

    		} else {

    			 this.x = q.x / s;
    			 this.y = q.y / s;
    			 this.z = q.z / s;

    		}

    		return this;

    	},

    	setAxisAngleFromRotationMatrix: function ( m ) {

    		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

    		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

    		var angle, x, y, z,		// variables for result
    			epsilon = 0.01,		// margin to allow for rounding errors
    			epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

    			te = m.elements,

    			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
    			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
    			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

    		if ( ( Math.abs( m12 - m21 ) < epsilon ) &&
    		     ( Math.abs( m13 - m31 ) < epsilon ) &&
    		     ( Math.abs( m23 - m32 ) < epsilon ) ) {

    			// singularity found
    			// first check for identity matrix which must have +1 for all terms
    			// in leading diagonal and zero in other terms

    			if ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&
    			     ( Math.abs( m13 + m31 ) < epsilon2 ) &&
    			     ( Math.abs( m23 + m32 ) < epsilon2 ) &&
    			     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

    				// this singularity is identity matrix so angle = 0

    				this.set( 1, 0, 0, 0 );

    				return this; // zero angle, arbitrary axis

    			}

    			// otherwise this singularity is angle = 180

    			angle = Math.PI;

    			var xx = ( m11 + 1 ) / 2;
    			var yy = ( m22 + 1 ) / 2;
    			var zz = ( m33 + 1 ) / 2;
    			var xy = ( m12 + m21 ) / 4;
    			var xz = ( m13 + m31 ) / 4;
    			var yz = ( m23 + m32 ) / 4;

    			if ( ( xx > yy ) && ( xx > zz ) ) {

    				// m11 is the largest diagonal term

    				if ( xx < epsilon ) {

    					x = 0;
    					y = 0.707106781;
    					z = 0.707106781;

    				} else {

    					x = Math.sqrt( xx );
    					y = xy / x;
    					z = xz / x;

    				}

    			} else if ( yy > zz ) {

    				// m22 is the largest diagonal term

    				if ( yy < epsilon ) {

    					x = 0.707106781;
    					y = 0;
    					z = 0.707106781;

    				} else {

    					y = Math.sqrt( yy );
    					x = xy / y;
    					z = yz / y;

    				}

    			} else {

    				// m33 is the largest diagonal term so base result on this

    				if ( zz < epsilon ) {

    					x = 0.707106781;
    					y = 0.707106781;
    					z = 0;

    				} else {

    					z = Math.sqrt( zz );
    					x = xz / z;
    					y = yz / z;

    				}

    			}

    			this.set( x, y, z, angle );

    			return this; // return 180 deg rotation

    		}

    		// as we have reached here there are no singularities so we can handle normally

    		var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +
    		                   ( m13 - m31 ) * ( m13 - m31 ) +
    		                   ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

    		if ( Math.abs( s ) < 0.001 ) s = 1;

    		// prevent divide by zero, should not happen if matrix is orthogonal and should be
    		// caught by singularity test above, but I've left it in just in case

    		this.x = ( m32 - m23 ) / s;
    		this.y = ( m13 - m31 ) / s;
    		this.z = ( m21 - m12 ) / s;
    		this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

    		return this;

    	},

    	min: function ( v ) {

    		this.x = Math.min( this.x, v.x );
    		this.y = Math.min( this.y, v.y );
    		this.z = Math.min( this.z, v.z );
    		this.w = Math.min( this.w, v.w );

    		return this;

    	},

    	max: function ( v ) {

    		this.x = Math.max( this.x, v.x );
    		this.y = Math.max( this.y, v.y );
    		this.z = Math.max( this.z, v.z );
    		this.w = Math.max( this.w, v.w );

    		return this;

    	},

    	clamp: function ( min, max ) {

    		// This function assumes min < max, if this assumption isn't true it will not operate correctly

    		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
    		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
    		this.z = Math.max( min.z, Math.min( max.z, this.z ) );
    		this.w = Math.max( min.w, Math.min( max.w, this.w ) );

    		return this;

    	},

    	clampScalar: function () {

    		var min, max;

    		return function clampScalar( minVal, maxVal ) {

    			if ( min === undefined ) {

    				min = new Vector4();
    				max = new Vector4();

    			}

    			min.set( minVal, minVal, minVal, minVal );
    			max.set( maxVal, maxVal, maxVal, maxVal );

    			return this.clamp( min, max );

    		};

    	}(),

    	floor: function () {

    		this.x = Math.floor( this.x );
    		this.y = Math.floor( this.y );
    		this.z = Math.floor( this.z );
    		this.w = Math.floor( this.w );

    		return this;

    	},

    	ceil: function () {

    		this.x = Math.ceil( this.x );
    		this.y = Math.ceil( this.y );
    		this.z = Math.ceil( this.z );
    		this.w = Math.ceil( this.w );

    		return this;

    	},

    	round: function () {

    		this.x = Math.round( this.x );
    		this.y = Math.round( this.y );
    		this.z = Math.round( this.z );
    		this.w = Math.round( this.w );

    		return this;

    	},

    	roundToZero: function () {

    		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
    		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
    		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
    		this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );

    		return this;

    	},

    	negate: function () {

    		this.x = - this.x;
    		this.y = - this.y;
    		this.z = - this.z;
    		this.w = - this.w;

    		return this;

    	},

    	dot: function ( v ) {

    		return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

    	},

    	lengthSq: function () {

    		return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

    	},

    	length: function () {

    		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

    	},

    	lengthManhattan: function () {

    		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

    	},

    	normalize: function () {

    		return this.divideScalar( this.length() );

    	},

    	setLength: function ( length ) {

    		return this.multiplyScalar( length / this.length() );

    	},

    	lerp: function ( v, alpha ) {

    		this.x += ( v.x - this.x ) * alpha;
    		this.y += ( v.y - this.y ) * alpha;
    		this.z += ( v.z - this.z ) * alpha;
    		this.w += ( v.w - this.w ) * alpha;

    		return this;

    	},

    	lerpVectors: function ( v1, v2, alpha ) {

    		return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

    	},

    	equals: function ( v ) {

    		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

    	},

    	fromArray: function ( array, offset ) {

    		if ( offset === undefined ) offset = 0;

    		this.x = array[ offset ];
    		this.y = array[ offset + 1 ];
    		this.z = array[ offset + 2 ];
    		this.w = array[ offset + 3 ];

    		return this;

    	},

    	toArray: function ( array, offset ) {

    		if ( array === undefined ) array = [];
    		if ( offset === undefined ) offset = 0;

    		array[ offset ] = this.x;
    		array[ offset + 1 ] = this.y;
    		array[ offset + 2 ] = this.z;
    		array[ offset + 3 ] = this.w;

    		return array;

    	},

    	fromAttribute: function ( attribute, index, offset ) {

    		if ( offset === undefined ) offset = 0;

    		index = index * attribute.itemSize + offset;

    		this.x = attribute.array[ index ];
    		this.y = attribute.array[ index + 1 ];
    		this.z = attribute.array[ index + 2 ];
    		this.w = attribute.array[ index + 3 ];

    		return this;

    	}

    };

    /**
     * @author szimek / https://github.com/szimek/
     * @author alteredq / http://alteredqualia.com/
     * @author Marius Kintel / https://github.com/kintel
     */

    /*
     In options, we can specify:
     * Texture parameters for an auto-generated target texture
     * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
    */
    function WebGLRenderTarget( width, height, options ) {

    	this.uuid = exports.Math.generateUUID();

    	this.width = width;
    	this.height = height;

    	this.scissor = new Vector4( 0, 0, width, height );
    	this.scissorTest = false;

    	this.viewport = new Vector4( 0, 0, width, height );

    	options = options || {};

    	if ( options.minFilter === undefined ) options.minFilter = LinearFilter;

    	this.texture = new Texture( undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );

    	this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
    	this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;
    	this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;

    }

    Object.assign( WebGLRenderTarget.prototype, EventDispatcher.prototype, {

    	isWebGLRenderTarget: true,

    	setSize: function ( width, height ) {

    		if ( this.width !== width || this.height !== height ) {

    			this.width = width;
    			this.height = height;

    			this.dispose();

    		}

    		this.viewport.set( 0, 0, width, height );
    		this.scissor.set( 0, 0, width, height );

    	},

    	clone: function () {

    		return new this.constructor().copy( this );

    	},

    	copy: function ( source ) {

    		this.width = source.width;
    		this.height = source.height;

    		this.viewport.copy( source.viewport );

    		this.texture = source.texture.clone();

    		this.depthBuffer = source.depthBuffer;
    		this.stencilBuffer = source.stencilBuffer;
    		this.depthTexture = source.depthTexture;

    		return this;

    	},

    	dispose: function () {

    		this.dispatchEvent( { type: 'dispose' } );

    	}

    } );

    /**
     * @author alteredq / http://alteredqualia.com
     */

    function WebGLRenderTargetCube( width, height, options ) {

    	WebGLRenderTarget.call( this, width, height, options );

    	this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5
    	this.activeMipMapLevel = 0;

    }

    WebGLRenderTargetCube.prototype = Object.create( WebGLRenderTarget.prototype );
    WebGLRenderTargetCube.prototype.constructor = WebGLRenderTargetCube;

    WebGLRenderTargetCube.prototype.isWebGLRenderTargetCube = true;

    /**
     * @author mikael emtinger / http://gomo.se/
     * @author alteredq / http://alteredqualia.com/
     * @author WestLangley / http://github.com/WestLangley
     * @author bhouston / http://clara.io
     */

    function Quaternion( x, y, z, w ) {

    	this._x = x || 0;
    	this._y = y || 0;
    	this._z = z || 0;
    	this._w = ( w !== undefined ) ? w : 1;

    }

    Quaternion.prototype = {

    	constructor: Quaternion,

    	get x () {

    		return this._x;

    	},

    	set x ( value ) {

    		this._x = value;
    		this.onChangeCallback();

    	},

    	get y () {

    		return this._y;

    	},

    	set y ( value ) {

    		this._y = value;
    		this.onChangeCallback();

    	},

    	get z () {

    		return this._z;

    	},

    	set z ( value ) {

    		this._z = value;
    		this.onChangeCallback();

    	},

    	get w () {

    		return this._w;

    	},

    	set w ( value ) {

    		this._w = value;
    		this.onChangeCallback();

    	},

    	set: function ( x, y, z, w ) {

    		this._x = x;
    		this._y = y;
    		this._z = z;
    		this._w = w;

    		this.onChangeCallback();

    		return this;

    	},

    	clone: function () {

    		return new this.constructor( this._x, this._y, this._z, this._w );

    	},

    	copy: function ( quaternion ) {

    		this._x = quaternion.x;
    		this._y = quaternion.y;
    		this._z = quaternion.z;
    		this._w = quaternion.w;

    		this.onChangeCallback();

    		return this;

    	},

    	setFromEuler: function ( euler, update ) {

    		if ( (euler && euler.isEuler) === false ) {

    			throw new Error( 'THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

    		}

    		// http://www.mathworks.com/matlabcentral/fileexchange/
    		// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
    		//	content/SpinCalc.m

    		var c1 = Math.cos( euler._x / 2 );
    		var c2 = Math.cos( euler._y / 2 );
    		var c3 = Math.cos( euler._z / 2 );
    		var s1 = Math.sin( euler._x / 2 );
    		var s2 = Math.sin( euler._y / 2 );
    		var s3 = Math.sin( euler._z / 2 );

    		var order = euler.order;

    		if ( order === 'XYZ' ) {

    			this._x = s1 * c2 * c3 + c1 * s2 * s3;
    			this._y = c1 * s2 * c3 - s1 * c2 * s3;
    			this._z = c1 * c2 * s3 + s1 * s2 * c3;
    			this._w = c1 * c2 * c3 - s1 * s2 * s3;

    		} else if ( order === 'YXZ' ) {

    			this._x = s1 * c2 * c3 + c1 * s2 * s3;
    			this._y = c1 * s2 * c3 - s1 * c2 * s3;
    			this._z = c1 * c2 * s3 - s1 * s2 * c3;
    			this._w = c1 * c2 * c3 + s1 * s2 * s3;

    		} else if ( order === 'ZXY' ) {

    			this._x = s1 * c2 * c3 - c1 * s2 * s3;
    			this._y = c1 * s2 * c3 + s1 * c2 * s3;
    			this._z = c1 * c2 * s3 + s1 * s2 * c3;
    			this._w = c1 * c2 * c3 - s1 * s2 * s3;

    		} else if ( order === 'ZYX' ) {

    			this._x = s1 * c2 * c3 - c1 * s2 * s3;
    			this._y = c1 * s2 * c3 + s1 * c2 * s3;
    			this._z = c1 * c2 * s3 - s1 * s2 * c3;
    			this._w = c1 * c2 * c3 + s1 * s2 * s3;

    		} else if ( order === 'YZX' ) {

    			this._x = s1 * c2 * c3 + c1 * s2 * s3;
    			this._y = c1 * s2 * c3 + s1 * c2 * s3;
    			this._z = c1 * c2 * s3 - s1 * s2 * c3;
    			this._w = c1 * c2 * c3 - s1 * s2 * s3;

    		} else if ( order === 'XZY' ) {

    			this._x = s1 * c2 * c3 - c1 * s2 * s3;
    			this._y = c1 * s2 * c3 - s1 * c2 * s3;
    			this._z = c1 * c2 * s3 + s1 * s2 * c3;
    			this._w = c1 * c2 * c3 + s1 * s2 * s3;

    		}

    		if ( update !== false ) this.onChangeCallback();

    		return this;

    	},

    	setFromAxisAngle: function ( axis, angle ) {

    		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

    		// assumes axis is normalized

    		var halfAngle = angle / 2, s = Math.sin( halfAngle );

    		this._x = axis.x * s;
    		this._y = axis.y * s;
    		this._z = axis.z * s;
    		this._w = Math.cos( halfAngle );

    		this.onChangeCallback();

    		return this;

    	},

    	setFromRotationMatrix: function ( m ) {

    		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

    		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

    		var te = m.elements,

    			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
    			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
    			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

    			trace = m11 + m22 + m33,
    			s;

    		if ( trace > 0 ) {

    			s = 0.5 / Math.sqrt( trace + 1.0 );

    			this._w = 0.25 / s;
    			this._x = ( m32 - m23 ) * s;
    			this._y = ( m13 - m31 ) * s;
    			this._z = ( m21 - m12 ) * s;

    		} else if ( m11 > m22 && m11 > m33 ) {

    			s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

    			this._w = ( m32 - m23 ) / s;
    			this._x = 0.25 * s;
    			this._y = ( m12 + m21 ) / s;
    			this._z = ( m13 + m31 ) / s;

    		} else if ( m22 > m33 ) {

    			s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

    			this._w = ( m13 - m31 ) / s;
    			this._x = ( m12 + m21 ) / s;
    			this._y = 0.25 * s;
    			this._z = ( m23 + m32 ) / s;

    		} else {

    			s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

    			this._w = ( m21 - m12 ) / s;
    			this._x = ( m13 + m31 ) / s;
    			this._y = ( m23 + m32 ) / s;
    			this._z = 0.25 * s;

    		}

    		this.onChangeCallback();

    		return this;

    	},

    	setFromUnitVectors: function () {

    		// http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final

    		// assumes direction vectors vFrom and vTo are normalized

    		var v1, r;

    		var EPS = 0.000001;

    		return function setFromUnitVectors( vFrom, vTo ) {

    			if ( v1 === undefined ) v1 = new Vector3();

    			r = vFrom.dot( vTo ) + 1;

    			if ( r < EPS ) {

    				r = 0;

    				if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

    					v1.set( - vFrom.y, vFrom.x, 0 );

    				} else {

    					v1.set( 0, - vFrom.z, vFrom.y );

    				}

    			} else {

    				v1.crossVectors( vFrom, vTo );

    			}

    			this._x = v1.x;
    			this._y = v1.y;
    			this._z = v1.z;
    			this._w = r;

    			return this.normalize();

    		};

    	}(),

    	inverse: function () {

    		return this.conjugate().normalize();

    	},

    	conjugate: function () {

    		this._x *= - 1;
    		this._y *= - 1;
    		this._z *= - 1;

    		this.onChangeCallback();

    		return this;

    	},

    	dot: function ( v ) {

    		return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

    	},

    	lengthSq: function () {

    		return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

    	},

    	length: function () {

    		return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

    	},

    	normalize: function () {

    		var l = this.length();

    		if ( l === 0 ) {

    			this._x = 0;
    			this._y = 0;
    			this._z = 0;
    			this._w = 1;

    		} else {

    			l = 1 / l;

    			this._x = this._x * l;
    			this._y = this._y * l;
    			this._z = this._z * l;
    			this._w = this._w * l;

    		}

    		this.onChangeCallback();

    		return this;

    	},

    	multiply: function ( q, p ) {

    		if ( p !== undefined ) {

    			console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
    			return this.multiplyQuaternions( q, p );

    		}

    		return this.multiplyQuaternions( this, q );

    	},

    	premultiply: function ( q ) {

    		return this.multiplyQuaternions( q, this );

    	},

    	multiplyQuaternions: function ( a, b ) {

    		// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

    		var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
    		var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

    		this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
    		this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
    		this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
    		this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

    		this.onChangeCallback();

    		return this;

    	},

    	slerp: function ( qb, t ) {

    		if ( t === 0 ) return this;
    		if ( t === 1 ) return this.copy( qb );

    		var x = this._x, y = this._y, z = this._z, w = this._w;

    		// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

    		var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

    		if ( cosHalfTheta < 0 ) {

    			this._w = - qb._w;
    			this._x = - qb._x;
    			this._y = - qb._y;
    			this._z = - qb._z;

    			cosHalfTheta = - cosHalfTheta;

    		} else {

    			this.copy( qb );

    		}

    		if ( cosHalfTheta >= 1.0 ) {

    			this._w = w;
    			this._x = x;
    			this._y = y;
    			this._z = z;

    			return this;

    		}

    		var sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );

    		if ( Math.abs( sinHalfTheta ) < 0.001 ) {

    			this._w = 0.5 * ( w + this._w );
    			this._x = 0.5 * ( x + this._x );
    			this._y = 0.5 * ( y + this._y );
    			this._z = 0.5 * ( z + this._z );

    			return this;

    		}

    		var halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
    		var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
    		ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

    		this._w = ( w * ratioA + this._w * ratioB );
    		this._x = ( x * ratioA + this._x * ratioB );
    		this._y = ( y * ratioA + this._y * ratioB );
    		this._z = ( z * ratioA + this._z * ratioB );

    		this.onChangeCallback();

    		return this;

    	},

    	equals: function ( quaternion ) {

    		return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

    	},

    	fromArray: function ( array, offset ) {

    		if ( offset === undefined ) offset = 0;

    		this._x = array[ offset ];
    		this._y = array[ offset + 1 ];
    		this._z = array[ offset + 2 ];
    		this._w = array[ offset + 3 ];

    		this.onChangeCallback();

    		return this;

    	},

    	toArray: function ( array, offset ) {

    		if ( array === undefined ) array = [];
    		if ( offset === undefined ) offset = 0;

    		array[ offset ] = this._x;
    		array[ offset + 1 ] = this._y;
    		array[ offset + 2 ] = this._z;
    		array[ offset + 3 ] = this._w;

    		return array;

    	},

    	onChange: function ( callback ) {

    		this.onChangeCallback = callback;

    		return this;

    	},

    	onChangeCallback: function () {}

    };

    Object.assign( Quaternion, {

    	slerp: function( qa, qb, qm, t ) {

    		return qm.copy( qa ).slerp( qb, t );

    	},

    	slerpFlat: function(
    			dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {

    		// fuzz-free, array-based Quaternion SLERP operation

    		var x0 = src0[ srcOffset0 + 0 ],
    			y0 = src0[ srcOffset0 + 1 ],
    			z0 = src0[ srcOffset0 + 2 ],
    			w0 = src0[ srcOffset0 + 3 ],

    			x1 = src1[ srcOffset1 + 0 ],
    			y1 = src1[ srcOffset1 + 1 ],
    			z1 = src1[ srcOffset1 + 2 ],
    			w1 = src1[ srcOffset1 + 3 ];

    		if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {

    			var s = 1 - t,

    				cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,

    				dir = ( cos >= 0 ? 1 : - 1 ),
    				sqrSin = 1 - cos * cos;

    			// Skip the Slerp for tiny steps to avoid numeric problems:
    			if ( sqrSin > Number.EPSILON ) {

    				var sin = Math.sqrt( sqrSin ),
    					len = Math.atan2( sin, cos * dir );

    				s = Math.sin( s * len ) / sin;
    				t = Math.sin( t * len ) / sin;

    			}

    			var tDir = t * dir;

    			x0 = x0 * s + x1 * tDir;
    			y0 = y0 * s + y1 * tDir;
    			z0 = z0 * s + z1 * tDir;
    			w0 = w0 * s + w1 * tDir;

    			// Normalize in case we just did a lerp:
    			if ( s === 1 - t ) {

    				var f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );

    				x0 *= f;
    				y0 *= f;
    				z0 *= f;
    				w0 *= f;

    			}

    		}

    		dst[ dstOffset ] = x0;
    		dst[ dstOffset + 1 ] = y0;
    		dst[ dstOffset + 2 ] = z0;
    		dst[ dstOffset + 3 ] = w0;

    	}

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author *kile / http://kile.stravaganza.org/
     * @author philogb / http://blog.thejit.org/
     * @author mikael emtinger / http://gomo.se/
     * @author egraether / http://egraether.com/
     * @author WestLangley / http://github.com/WestLangley
     */

    function Vector3( x, y, z ) {

    	this.x = x || 0;
    	this.y = y || 0;
    	this.z = z || 0;

    }

    Vector3.prototype = {

    	constructor: Vector3,

    	isVector3: true,

    	set: function ( x, y, z ) {

    		this.x = x;
    		this.y = y;
    		this.z = z;

    		return this;

    	},

    	setScalar: function ( scalar ) {

    		this.x = scalar;
    		this.y = scalar;
    		this.z = scalar;

    		return this;

    	},

    	setX: function ( x ) {

    		this.x = x;

    		return this;

    	},

    	setY: function ( y ) {

    		this.y = y;

    		return this;

    	},

    	setZ: function ( z ) {

    		this.z = z;

    		return this;

    	},

    	setComponent: function ( index, value ) {

    		switch ( index ) {

    			case 0: this.x = value; break;
    			case 1: this.y = value; break;
    			case 2: this.z = value; break;
    			default: throw new Error( 'index is out of range: ' + index );

    		}

    	},

    	getComponent: function ( index ) {

    		switch ( index ) {

    			case 0: return this.x;
    			case 1: return this.y;
    			case 2: return this.z;
    			default: throw new Error( 'index is out of range: ' + index );

    		}

    	},

    	clone: function () {

    		return new this.constructor( this.x, this.y, this.z );

    	},

    	copy: function ( v ) {

    		this.x = v.x;
    		this.y = v.y;
    		this.z = v.z;

    		return this;

    	},

    	add: function ( v, w ) {

    		if ( w !== undefined ) {

    			console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
    			return this.addVectors( v, w );

    		}

    		this.x += v.x;
    		this.y += v.y;
    		this.z += v.z;

    		return this;

    	},

    	addScalar: function ( s ) {

    		this.x += s;
    		this.y += s;
    		this.z += s;

    		return this;

    	},

    	addVectors: function ( a, b ) {

    		this.x = a.x + b.x;
    		this.y = a.y + b.y;
    		this.z = a.z + b.z;

    		return this;

    	},

    	addScaledVector: function ( v, s ) {

    		this.x += v.x * s;
    		this.y += v.y * s;
    		this.z += v.z * s;

    		return this;

    	},

    	sub: function ( v, w ) {

    		if ( w !== undefined ) {

    			console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
    			return this.subVectors( v, w );

    		}

    		this.x -= v.x;
    		this.y -= v.y;
    		this.z -= v.z;

    		return this;

    	},

    	subScalar: function ( s ) {

    		this.x -= s;
    		this.y -= s;
    		this.z -= s;

    		return this;

    	},

    	subVectors: function ( a, b ) {

    		this.x = a.x - b.x;
    		this.y = a.y - b.y;
    		this.z = a.z - b.z;

    		return this;

    	},

    	multiply: function ( v, w ) {

    		if ( w !== undefined ) {

    			console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
    			return this.multiplyVectors( v, w );

    		}

    		this.x *= v.x;
    		this.y *= v.y;
    		this.z *= v.z;

    		return this;

    	},

    	multiplyScalar: function ( scalar ) {

    		if ( isFinite( scalar ) ) {

    			this.x *= scalar;
    			this.y *= scalar;
    			this.z *= scalar;

    		} else {

    			this.x = 0;
    			this.y = 0;
    			this.z = 0;

    		}

    		return this;

    	},

    	multiplyVectors: function ( a, b ) {

    		this.x = a.x * b.x;
    		this.y = a.y * b.y;
    		this.z = a.z * b.z;

    		return this;

    	},

    	applyEuler: function () {

    		var quaternion;

    		return function applyEuler( euler ) {

    			if ( (euler && euler.isEuler) === false ) {

    				console.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );

    			}

    			if ( quaternion === undefined ) quaternion = new Quaternion();

    			return this.applyQuaternion( quaternion.setFromEuler( euler ) );

    		};

    	}(),

    	applyAxisAngle: function () {

    		var quaternion;

    		return function applyAxisAngle( axis, angle ) {

    			if ( quaternion === undefined ) quaternion = new Quaternion();

    			return this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );

    		};

    	}(),

    	applyMatrix3: function ( m ) {

    		var x = this.x, y = this.y, z = this.z;
    		var e = m.elements;

    		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
    		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
    		this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

    		return this;

    	},

    	applyMatrix4: function ( m ) {

    		// input: THREE.Matrix4 affine matrix

    		var x = this.x, y = this.y, z = this.z;
    		var e = m.elements;

    		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ];
    		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ];
    		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ];

    		return this;

    	},

    	applyProjection: function ( m ) {

    		// input: THREE.Matrix4 projection matrix

    		var x = this.x, y = this.y, z = this.z;
    		var e = m.elements;
    		var d = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] ); // perspective divide

    		this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ] ) * d;
    		this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ] ) * d;
    		this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * d;

    		return this;

    	},

    	applyQuaternion: function ( q ) {

    		var x = this.x, y = this.y, z = this.z;
    		var qx = q.x, qy = q.y, qz = q.z, qw = q.w;

    		// calculate quat * vector

    		var ix =  qw * x + qy * z - qz * y;
    		var iy =  qw * y + qz * x - qx * z;
    		var iz =  qw * z + qx * y - qy * x;
    		var iw = - qx * x - qy * y - qz * z;

    		// calculate result * inverse quat

    		this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
    		this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
    		this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

    		return this;

    	},

    	project: function () {

    		var matrix;

    		return function project( camera ) {

    			if ( matrix === undefined ) matrix = new Matrix4();

    			matrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );
    			return this.applyProjection( matrix );

    		};

    	}(),

    	unproject: function () {

    		var matrix;

    		return function unproject( camera ) {

    			if ( matrix === undefined ) matrix = new Matrix4();

    			matrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );
    			return this.applyProjection( matrix );

    		};

    	}(),

    	transformDirection: function ( m ) {

    		// input: THREE.Matrix4 affine matrix
    		// vector interpreted as a direction

    		var x = this.x, y = this.y, z = this.z;
    		var e = m.elements;

    		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z;
    		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z;
    		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

    		return this.normalize();

    	},

    	divide: function ( v ) {

    		this.x /= v.x;
    		this.y /= v.y;
    		this.z /= v.z;

    		return this;

    	},

    	divideScalar: function ( scalar ) {

    		return this.multiplyScalar( 1 / scalar );

    	},

    	min: function ( v ) {

    		this.x = Math.min( this.x, v.x );
    		this.y = Math.min( this.y, v.y );
    		this.z = Math.min( this.z, v.z );

    		return this;

    	},

    	max: function ( v ) {

    		this.x = Math.max( this.x, v.x );
    		this.y = Math.max( this.y, v.y );
    		this.z = Math.max( this.z, v.z );

    		return this;

    	},

    	clamp: function ( min, max ) {

    		// This function assumes min < max, if this assumption isn't true it will not operate correctly

    		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
    		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
    		this.z = Math.max( min.z, Math.min( max.z, this.z ) );

    		return this;

    	},

    	clampScalar: function () {

    		var min, max;

    		return function clampScalar( minVal, maxVal ) {

    			if ( min === undefined ) {

    				min = new Vector3();
    				max = new Vector3();

    			}

    			min.set( minVal, minVal, minVal );
    			max.set( maxVal, maxVal, maxVal );

    			return this.clamp( min, max );

    		};

    	}(),

    	clampLength: function ( min, max ) {

    		var length = this.length();

    		return this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );

    	},

    	floor: function () {

    		this.x = Math.floor( this.x );
    		this.y = Math.floor( this.y );
    		this.z = Math.floor( this.z );

    		return this;

    	},

    	ceil: function () {

    		this.x = Math.ceil( this.x );
    		this.y = Math.ceil( this.y );
    		this.z = Math.ceil( this.z );

    		return this;

    	},

    	round: function () {

    		this.x = Math.round( this.x );
    		this.y = Math.round( this.y );
    		this.z = Math.round( this.z );

    		return this;

    	},

    	roundToZero: function () {

    		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
    		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
    		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

    		return this;

    	},

    	negate: function () {

    		this.x = - this.x;
    		this.y = - this.y;
    		this.z = - this.z;

    		return this;

    	},

    	dot: function ( v ) {

    		return this.x * v.x + this.y * v.y + this.z * v.z;

    	},

    	lengthSq: function () {

    		return this.x * this.x + this.y * this.y + this.z * this.z;

    	},

    	length: function () {

    		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

    	},

    	lengthManhattan: function () {

    		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

    	},

    	normalize: function () {

    		return this.divideScalar( this.length() );

    	},

    	setLength: function ( length ) {

    		return this.multiplyScalar( length / this.length() );

    	},

    	lerp: function ( v, alpha ) {

    		this.x += ( v.x - this.x ) * alpha;
    		this.y += ( v.y - this.y ) * alpha;
    		this.z += ( v.z - this.z ) * alpha;

    		return this;

    	},

    	lerpVectors: function ( v1, v2, alpha ) {

    		return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

    	},

    	cross: function ( v, w ) {

    		if ( w !== undefined ) {

    			console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
    			return this.crossVectors( v, w );

    		}

    		var x = this.x, y = this.y, z = this.z;

    		this.x = y * v.z - z * v.y;
    		this.y = z * v.x - x * v.z;
    		this.z = x * v.y - y * v.x;

    		return this;

    	},

    	crossVectors: function ( a, b ) {

    		var ax = a.x, ay = a.y, az = a.z;
    		var bx = b.x, by = b.y, bz = b.z;

    		this.x = ay * bz - az * by;
    		this.y = az * bx - ax * bz;
    		this.z = ax * by - ay * bx;

    		return this;

    	},

    	projectOnVector: function ( vector ) {

    		var scalar = vector.dot( this ) / vector.lengthSq();

    		return this.copy( vector ).multiplyScalar( scalar );

    	},

    	projectOnPlane: function () {

    		var v1;

    		return function projectOnPlane( planeNormal ) {

    			if ( v1 === undefined ) v1 = new Vector3();

    			v1.copy( this ).projectOnVector( planeNormal );

    			return this.sub( v1 );

    		};

    	}(),

    	reflect: function () {

    		// reflect incident vector off plane orthogonal to normal
    		// normal is assumed to have unit length

    		var v1;

    		return function reflect( normal ) {

    			if ( v1 === undefined ) v1 = new Vector3();

    			return this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

    		};

    	}(),

    	angleTo: function ( v ) {

    		var theta = this.dot( v ) / ( Math.sqrt( this.lengthSq() * v.lengthSq() ) );

    		// clamp, to handle numerical problems

    		return Math.acos( exports.Math.clamp( theta, - 1, 1 ) );

    	},

    	distanceTo: function ( v ) {

    		return Math.sqrt( this.distanceToSquared( v ) );

    	},

    	distanceToSquared: function ( v ) {

    		var dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;

    		return dx * dx + dy * dy + dz * dz;

    	},

    	distanceToManhattan: function ( v ) {

    		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );

    	},

    	setFromSpherical: function( s ) {

    		var sinPhiRadius = Math.sin( s.phi ) * s.radius;

    		this.x = sinPhiRadius * Math.sin( s.theta );
    		this.y = Math.cos( s.phi ) * s.radius;
    		this.z = sinPhiRadius * Math.cos( s.theta );

    		return this;

    	},

    	setFromMatrixPosition: function ( m ) {

    		return this.setFromMatrixColumn( m, 3 );

    	},

    	setFromMatrixScale: function ( m ) {

    		var sx = this.setFromMatrixColumn( m, 0 ).length();
    		var sy = this.setFromMatrixColumn( m, 1 ).length();
    		var sz = this.setFromMatrixColumn( m, 2 ).length();

    		this.x = sx;
    		this.y = sy;
    		this.z = sz;

    		return this;

    	},

    	setFromMatrixColumn: function ( m, index ) {

    		if ( typeof m === 'number' ) {

    			console.warn( 'THREE.Vector3: setFromMatrixColumn now expects ( matrix, index ).' );
    			var temp = m
    			m = index;
    			index = temp;

    		}

    		return this.fromArray( m.elements, index * 4 );

    	},

    	equals: function ( v ) {

    		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

    	},

    	fromArray: function ( array, offset ) {

    		if ( offset === undefined ) offset = 0;

    		this.x = array[ offset ];
    		this.y = array[ offset + 1 ];
    		this.z = array[ offset + 2 ];

    		return this;

    	},

    	toArray: function ( array, offset ) {

    		if ( array === undefined ) array = [];
    		if ( offset === undefined ) offset = 0;

    		array[ offset ] = this.x;
    		array[ offset + 1 ] = this.y;
    		array[ offset + 2 ] = this.z;

    		return array;

    	},

    	fromAttribute: function ( attribute, index, offset ) {

    		if ( offset === undefined ) offset = 0;

    		index = index * attribute.itemSize + offset;

    		this.x = attribute.array[ index ];
    		this.y = attribute.array[ index + 1 ];
    		this.z = attribute.array[ index + 2 ];

    		return this;

    	}

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author supereggbert / http://www.paulbrunt.co.uk/
     * @author philogb / http://blog.thejit.org/
     * @author jordi_ros / http://plattsoft.com
     * @author D1plo1d / http://github.com/D1plo1d
     * @author alteredq / http://alteredqualia.com/
     * @author mikael emtinger / http://gomo.se/
     * @author timknip / http://www.floorplanner.com/
     * @author bhouston / http://clara.io
     * @author WestLangley / http://github.com/WestLangley
     */

    function Matrix4() {

    	this.elements = new Float32Array( [

    		1, 0, 0, 0,
    		0, 1, 0, 0,
    		0, 0, 1, 0,
    		0, 0, 0, 1

    	] );

    	if ( arguments.length > 0 ) {

    		console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );

    	}

    }

    Matrix4.prototype = {

    	constructor: Matrix4,

    	isMatrix4: true,

    	set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

    		var te = this.elements;

    		te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
    		te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
    		te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
    		te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

    		return this;

    	},

    	identity: function () {

    		this.set(

    			1, 0, 0, 0,
    			0, 1, 0, 0,
    			0, 0, 1, 0,
    			0, 0, 0, 1

    		);

    		return this;

    	},

    	clone: function () {

    		return new Matrix4().fromArray( this.elements );

    	},

    	copy: function ( m ) {

    		this.elements.set( m.elements );

    		return this;

    	},

    	copyPosition: function ( m ) {

    		var te = this.elements;
    		var me = m.elements;

    		te[ 12 ] = me[ 12 ];
    		te[ 13 ] = me[ 13 ];
    		te[ 14 ] = me[ 14 ];

    		return this;

    	},

    	extractBasis: function ( xAxis, yAxis, zAxis ) {

    		xAxis.setFromMatrixColumn( this, 0 );
    		yAxis.setFromMatrixColumn( this, 1 );
    		zAxis.setFromMatrixColumn( this, 2 );

    		return this;

    	},

    	makeBasis: function ( xAxis, yAxis, zAxis ) {

    		this.set(
    			xAxis.x, yAxis.x, zAxis.x, 0,
    			xAxis.y, yAxis.y, zAxis.y, 0,
    			xAxis.z, yAxis.z, zAxis.z, 0,
    			0,       0,       0,       1
    		);

    		return this;

    	},

    	extractRotation: function () {

    		var v1;

    		return function extractRotation( m ) {

    			if ( v1 === undefined ) v1 = new Vector3();

    			var te = this.elements;
    			var me = m.elements;

    			var scaleX = 1 / v1.setFromMatrixColumn( m, 0 ).length();
    			var scaleY = 1 / v1.setFromMatrixColumn( m, 1 ).length();
    			var scaleZ = 1 / v1.setFromMatrixColumn( m, 2 ).length();

    			te[ 0 ] = me[ 0 ] * scaleX;
    			te[ 1 ] = me[ 1 ] * scaleX;
    			te[ 2 ] = me[ 2 ] * scaleX;

    			te[ 4 ] = me[ 4 ] * scaleY;
    			te[ 5 ] = me[ 5 ] * scaleY;
    			te[ 6 ] = me[ 6 ] * scaleY;

    			te[ 8 ] = me[ 8 ] * scaleZ;
    			te[ 9 ] = me[ 9 ] * scaleZ;
    			te[ 10 ] = me[ 10 ] * scaleZ;

    			return this;

    		};

    	}(),

    	makeRotationFromEuler: function ( euler ) {

    		if ( (euler && euler.isEuler) === false ) {

    			console.error( 'THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

    		}

    		var te = this.elements;

    		var x = euler.x, y = euler.y, z = euler.z;
    		var a = Math.cos( x ), b = Math.sin( x );
    		var c = Math.cos( y ), d = Math.sin( y );
    		var e = Math.cos( z ), f = Math.sin( z );

    		if ( euler.order === 'XYZ' ) {

    			var ae = a * e, af = a * f, be = b * e, bf = b * f;

    			te[ 0 ] = c * e;
    			te[ 4 ] = - c * f;
    			te[ 8 ] = d;

    			te[ 1 ] = af + be * d;
    			te[ 5 ] = ae - bf * d;
    			te[ 9 ] = - b * c;

    			te[ 2 ] = bf - ae * d;
    			te[ 6 ] = be + af * d;
    			te[ 10 ] = a * c;

    		} else if ( euler.order === 'YXZ' ) {

    			var ce = c * e, cf = c * f, de = d * e, df = d * f;

    			te[ 0 ] = ce + df * b;
    			te[ 4 ] = de * b - cf;
    			te[ 8 ] = a * d;

    			te[ 1 ] = a * f;
    			te[ 5 ] = a * e;
    			te[ 9 ] = - b;

    			te[ 2 ] = cf * b - de;
    			te[ 6 ] = df + ce * b;
    			te[ 10 ] = a * c;

    		} else if ( euler.order === 'ZXY' ) {

    			var ce = c * e, cf = c * f, de = d * e, df = d * f;

    			te[ 0 ] = ce - df * b;
    			te[ 4 ] = - a * f;
    			te[ 8 ] = de + cf * b;

    			te[ 1 ] = cf + de * b;
    			te[ 5 ] = a * e;
    			te[ 9 ] = df - ce * b;

    			te[ 2 ] = - a * d;
    			te[ 6 ] = b;
    			te[ 10 ] = a * c;

    		} else if ( euler.order === 'ZYX' ) {

    			var ae = a * e, af = a * f, be = b * e, bf = b * f;

    			te[ 0 ] = c * e;
    			te[ 4 ] = be * d - af;
    			te[ 8 ] = ae * d + bf;

    			te[ 1 ] = c * f;
    			te[ 5 ] = bf * d + ae;
    			te[ 9 ] = af * d - be;

    			te[ 2 ] = - d;
    			te[ 6 ] = b * c;
    			te[ 10 ] = a * c;

    		} else if ( euler.order === 'YZX' ) {

    			var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

    			te[ 0 ] = c * e;
    			te[ 4 ] = bd - ac * f;
    			te[ 8 ] = bc * f + ad;

    			te[ 1 ] = f;
    			te[ 5 ] = a * e;
    			te[ 9 ] = - b * e;

    			te[ 2 ] = - d * e;
    			te[ 6 ] = ad * f + bc;
    			te[ 10 ] = ac - bd * f;

    		} else if ( euler.order === 'XZY' ) {

    			var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

    			te[ 0 ] = c * e;
    			te[ 4 ] = - f;
    			te[ 8 ] = d * e;

    			te[ 1 ] = ac * f + bd;
    			te[ 5 ] = a * e;
    			te[ 9 ] = ad * f - bc;

    			te[ 2 ] = bc * f - ad;
    			te[ 6 ] = b * e;
    			te[ 10 ] = bd * f + ac;

    		}

    		// last column
    		te[ 3 ] = 0;
    		te[ 7 ] = 0;
    		te[ 11 ] = 0;

    		// bottom row
    		te[ 12 ] = 0;
    		te[ 13 ] = 0;
    		te[ 14 ] = 0;
    		te[ 15 ] = 1;

    		return this;

    	},

    	makeRotationFromQuaternion: function ( q ) {

    		var te = this.elements;

    		var x = q.x, y = q.y, z = q.z, w = q.w;
    		var x2 = x + x, y2 = y + y, z2 = z + z;
    		var xx = x * x2, xy = x * y2, xz = x * z2;
    		var yy = y * y2, yz = y * z2, zz = z * z2;
    		var wx = w * x2, wy = w * y2, wz = w * z2;

    		te[ 0 ] = 1 - ( yy + zz );
    		te[ 4 ] = xy - wz;
    		te[ 8 ] = xz + wy;

    		te[ 1 ] = xy + wz;
    		te[ 5 ] = 1 - ( xx + zz );
    		te[ 9 ] = yz - wx;

    		te[ 2 ] = xz - wy;
    		te[ 6 ] = yz + wx;
    		te[ 10 ] = 1 - ( xx + yy );

    		// last column
    		te[ 3 ] = 0;
    		te[ 7 ] = 0;
    		te[ 11 ] = 0;

    		// bottom row
    		te[ 12 ] = 0;
    		te[ 13 ] = 0;
    		te[ 14 ] = 0;
    		te[ 15 ] = 1;

    		return this;

    	},

    	lookAt: function () {

    		var x, y, z;

    		return function lookAt( eye, target, up ) {

    			if ( x === undefined ) {

    				x = new Vector3();
    				y = new Vector3();
    				z = new Vector3();

    			}

    			var te = this.elements;

    			z.subVectors( eye, target ).normalize();

    			if ( z.lengthSq() === 0 ) {

    				z.z = 1;

    			}

    			x.crossVectors( up, z ).normalize();

    			if ( x.lengthSq() === 0 ) {

    				z.z += 0.0001;
    				x.crossVectors( up, z ).normalize();

    			}

    			y.crossVectors( z, x );


    			te[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;
    			te[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;
    			te[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;

    			return this;

    		};

    	}(),

    	multiply: function ( m, n ) {

    		if ( n !== undefined ) {

    			console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
    			return this.multiplyMatrices( m, n );

    		}

    		return this.multiplyMatrices( this, m );

    	},

    	premultiply: function ( m ) {

    		return this.multiplyMatrices( m, this );

    	},

    	multiplyMatrices: function ( a, b ) {

    		var ae = a.elements;
    		var be = b.elements;
    		var te = this.elements;

    		var a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
    		var a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
    		var a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
    		var a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

    		var b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
    		var b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
    		var b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
    		var b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

    		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
    		te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
    		te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
    		te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

    		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
    		te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
    		te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
    		te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

    		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
    		te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
    		te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
    		te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

    		te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
    		te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
    		te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
    		te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

    		return this;

    	},

    	multiplyToArray: function ( a, b, r ) {

    		var te = this.elements;

    		this.multiplyMatrices( a, b );

    		r[ 0 ] = te[ 0 ]; r[ 1 ] = te[ 1 ]; r[ 2 ] = te[ 2 ]; r[ 3 ] = te[ 3 ];
    		r[ 4 ] = te[ 4 ]; r[ 5 ] = te[ 5 ]; r[ 6 ] = te[ 6 ]; r[ 7 ] = te[ 7 ];
    		r[ 8 ]  = te[ 8 ]; r[ 9 ]  = te[ 9 ]; r[ 10 ] = te[ 10 ]; r[ 11 ] = te[ 11 ];
    		r[ 12 ] = te[ 12 ]; r[ 13 ] = te[ 13 ]; r[ 14 ] = te[ 14 ]; r[ 15 ] = te[ 15 ];

    		return this;

    	},

    	multiplyScalar: function ( s ) {

    		var te = this.elements;

    		te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
    		te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
    		te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
    		te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

    		return this;

    	},

    	applyToVector3Array: function () {

    		var v1;

    		return function applyToVector3Array( array, offset, length ) {

    			if ( v1 === undefined ) v1 = new Vector3();
    			if ( offset === undefined ) offset = 0;
    			if ( length === undefined ) length = array.length;

    			for ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {

    				v1.fromArray( array, j );
    				v1.applyMatrix4( this );
    				v1.toArray( array, j );

    			}

    			return array;

    		};

    	}(),

    	applyToBuffer: function () {

    		var v1;

    		return function applyToBuffer( buffer, offset, length ) {

    			if ( v1 === undefined ) v1 = new Vector3();
    			if ( offset === undefined ) offset = 0;
    			if ( length === undefined ) length = buffer.length / buffer.itemSize;

    			for ( var i = 0, j = offset; i < length; i ++, j ++ ) {

    				v1.x = buffer.getX( j );
    				v1.y = buffer.getY( j );
    				v1.z = buffer.getZ( j );

    				v1.applyMatrix4( this );

    				buffer.setXYZ( v1.x, v1.y, v1.z );

    			}

    			return buffer;

    		};

    	}(),

    	determinant: function () {

    		var te = this.elements;

    		var n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
    		var n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
    		var n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
    		var n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

    		//TODO: make this more efficient
    		//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

    		return (
    			n41 * (
    				+ n14 * n23 * n32
    				 - n13 * n24 * n32
    				 - n14 * n22 * n33
    				 + n12 * n24 * n33
    				 + n13 * n22 * n34
    				 - n12 * n23 * n34
    			) +
    			n42 * (
    				+ n11 * n23 * n34
    				 - n11 * n24 * n33
    				 + n14 * n21 * n33
    				 - n13 * n21 * n34
    				 + n13 * n24 * n31
    				 - n14 * n23 * n31
    			) +
    			n43 * (
    				+ n11 * n24 * n32
    				 - n11 * n22 * n34
    				 - n14 * n21 * n32
    				 + n12 * n21 * n34
    				 + n14 * n22 * n31
    				 - n12 * n24 * n31
    			) +
    			n44 * (
    				- n13 * n22 * n31
    				 - n11 * n23 * n32
    				 + n11 * n22 * n33
    				 + n13 * n21 * n32
    				 - n12 * n21 * n33
    				 + n12 * n23 * n31
    			)

    		);

    	},

    	transpose: function () {

    		var te = this.elements;
    		var tmp;

    		tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
    		tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
    		tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

    		tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
    		tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
    		tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

    		return this;

    	},

    	flattenToArrayOffset: function ( array, offset ) {

    		console.warn( "THREE.Matrix3: .flattenToArrayOffset is deprecated " +
    				"- just use .toArray instead." );

    		return this.toArray( array, offset );

    	},

    	getPosition: function () {

    		var v1;

    		return function getPosition() {

    			if ( v1 === undefined ) v1 = new Vector3();
    			console.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );

    			return v1.setFromMatrixColumn( this, 3 );

    		};

    	}(),

    	setPosition: function ( v ) {

    		var te = this.elements;

    		te[ 12 ] = v.x;
    		te[ 13 ] = v.y;
    		te[ 14 ] = v.z;

    		return this;

    	},

    	getInverse: function ( m, throwOnDegenerate ) {

    		// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
    		var te = this.elements,
    			me = m.elements,

    			n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],
    			n12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],
    			n13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],
    			n14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],

    			t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
    			t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
    			t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
    			t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

    		var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

    		if ( det === 0 ) {

    			var msg = "THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0";

    			if ( throwOnDegenerate === true ) {

    				throw new Error( msg );

    			} else {

    				console.warn( msg );

    			}

    			return this.identity();

    		}

    		var detInv = 1 / det;

    		te[ 0 ] = t11 * detInv;
    		te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
    		te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
    		te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;

    		te[ 4 ] = t12 * detInv;
    		te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
    		te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
    		te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;

    		te[ 8 ] = t13 * detInv;
    		te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
    		te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
    		te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;

    		te[ 12 ] = t14 * detInv;
    		te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
    		te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
    		te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;

    		return this;

    	},

    	scale: function ( v ) {

    		var te = this.elements;
    		var x = v.x, y = v.y, z = v.z;

    		te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
    		te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
    		te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
    		te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

    		return this;

    	},

    	getMaxScaleOnAxis: function () {

    		var te = this.elements;

    		var scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
    		var scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
    		var scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

    		return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );

    	},

    	makeTranslation: function ( x, y, z ) {

    		this.set(

    			1, 0, 0, x,
    			0, 1, 0, y,
    			0, 0, 1, z,
    			0, 0, 0, 1

    		);

    		return this;

    	},

    	makeRotationX: function ( theta ) {

    		var c = Math.cos( theta ), s = Math.sin( theta );

    		this.set(

    			1, 0,  0, 0,
    			0, c, - s, 0,
    			0, s,  c, 0,
    			0, 0,  0, 1

    		);

    		return this;

    	},

    	makeRotationY: function ( theta ) {

    		var c = Math.cos( theta ), s = Math.sin( theta );

    		this.set(

    			 c, 0, s, 0,
    			 0, 1, 0, 0,
    			- s, 0, c, 0,
    			 0, 0, 0, 1

    		);

    		return this;

    	},

    	makeRotationZ: function ( theta ) {

    		var c = Math.cos( theta ), s = Math.sin( theta );

    		this.set(

    			c, - s, 0, 0,
    			s,  c, 0, 0,
    			0,  0, 1, 0,
    			0,  0, 0, 1

    		);

    		return this;

    	},

    	makeRotationAxis: function ( axis, angle ) {

    		// Based on http://www.gamedev.net/reference/articles/article1199.asp

    		var c = Math.cos( angle );
    		var s = Math.sin( angle );
    		var t = 1 - c;
    		var x = axis.x, y = axis.y, z = axis.z;
    		var tx = t * x, ty = t * y;

    		this.set(

    			tx * x + c, tx * y - s * z, tx * z + s * y, 0,
    			tx * y + s * z, ty * y + c, ty * z - s * x, 0,
    			tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
    			0, 0, 0, 1

    		);

    		 return this;

    	},

    	makeScale: function ( x, y, z ) {

    		this.set(

    			x, 0, 0, 0,
    			0, y, 0, 0,
    			0, 0, z, 0,
    			0, 0, 0, 1

    		);

    		return this;

    	},

    	compose: function ( position, quaternion, scale ) {

    		this.makeRotationFromQuaternion( quaternion );
    		this.scale( scale );
    		this.setPosition( position );

    		return this;

    	},

    	decompose: function () {

    		var vector, matrix;

    		return function decompose( position, quaternion, scale ) {

    			if ( vector === undefined ) {

    				vector = new Vector3();
    				matrix = new Matrix4();

    			}

    			var te = this.elements;

    			var sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
    			var sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
    			var sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

    			// if determine is negative, we need to invert one scale
    			var det = this.determinant();
    			if ( det < 0 ) {

    				sx = - sx;

    			}

    			position.x = te[ 12 ];
    			position.y = te[ 13 ];
    			position.z = te[ 14 ];

    			// scale the rotation part

    			matrix.elements.set( this.elements ); // at this point matrix is incomplete so we can't use .copy()

    			var invSX = 1 / sx;
    			var invSY = 1 / sy;
    			var invSZ = 1 / sz;

    			matrix.elements[ 0 ] *= invSX;
    			matrix.elements[ 1 ] *= invSX;
    			matrix.elements[ 2 ] *= invSX;

    			matrix.elements[ 4 ] *= invSY;
    			matrix.elements[ 5 ] *= invSY;
    			matrix.elements[ 6 ] *= invSY;

    			matrix.elements[ 8 ] *= invSZ;
    			matrix.elements[ 9 ] *= invSZ;
    			matrix.elements[ 10 ] *= invSZ;

    			quaternion.setFromRotationMatrix( matrix );

    			scale.x = sx;
    			scale.y = sy;
    			scale.z = sz;

    			return this;

    		};

    	}(),

    	makeFrustum: function ( left, right, bottom, top, near, far ) {

    		var te = this.elements;
    		var x = 2 * near / ( right - left );
    		var y = 2 * near / ( top - bottom );

    		var a = ( right + left ) / ( right - left );
    		var b = ( top + bottom ) / ( top - bottom );
    		var c = - ( far + near ) / ( far - near );
    		var d = - 2 * far * near / ( far - near );

    		te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
    		te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
    		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
    		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;

    		return this;

    	},

    	makePerspective: function ( fov, aspect, near, far ) {

    		var ymax = near * Math.tan( exports.Math.DEG2RAD * fov * 0.5 );
    		var ymin = - ymax;
    		var xmin = ymin * aspect;
    		var xmax = ymax * aspect;

    		return this.makeFrustum( xmin, xmax, ymin, ymax, near, far );

    	},

    	makeOrthographic: function ( left, right, top, bottom, near, far ) {

    		var te = this.elements;
    		var w = 1.0 / ( right - left );
    		var h = 1.0 / ( top - bottom );
    		var p = 1.0 / ( far - near );

    		var x = ( right + left ) * w;
    		var y = ( top + bottom ) * h;
    		var z = ( far + near ) * p;

    		te[ 0 ] = 2 * w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
    		te[ 1 ] = 0;	te[ 5 ] = 2 * h;	te[ 9 ] = 0;	te[ 13 ] = - y;
    		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 * p;	te[ 14 ] = - z;
    		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;

    		return this;

    	},

    	equals: function ( matrix ) {

    		var te = this.elements;
    		var me = matrix.elements;

    		for ( var i = 0; i < 16; i ++ ) {

    			if ( te[ i ] !== me[ i ] ) return false;

    		}

    		return true;

    	},

    	fromArray: function ( array, offset ) {

    		if ( offset === undefined ) offset = 0;

    		for( var i = 0; i < 16; i ++ ) {

    			this.elements[ i ] = array[ i + offset ];

    		}

    		return this;

    	},

    	toArray: function ( array, offset ) {

    		if ( array === undefined ) array = [];
    		if ( offset === undefined ) offset = 0;

    		var te = this.elements;

    		array[ offset ] = te[ 0 ];
    		array[ offset + 1 ] = te[ 1 ];
    		array[ offset + 2 ] = te[ 2 ];
    		array[ offset + 3 ] = te[ 3 ];

    		array[ offset + 4 ] = te[ 4 ];
    		array[ offset + 5 ] = te[ 5 ];
    		array[ offset + 6 ] = te[ 6 ];
    		array[ offset + 7 ] = te[ 7 ];

    		array[ offset + 8 ]  = te[ 8 ];
    		array[ offset + 9 ]  = te[ 9 ];
    		array[ offset + 10 ] = te[ 10 ];
    		array[ offset + 11 ] = te[ 11 ];

    		array[ offset + 12 ] = te[ 12 ];
    		array[ offset + 13 ] = te[ 13 ];
    		array[ offset + 14 ] = te[ 14 ];
    		array[ offset + 15 ] = te[ 15 ];

    		return array;

    	}

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function CubeTexture( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {

    	images = images !== undefined ? images : [];
    	mapping = mapping !== undefined ? mapping : CubeReflectionMapping;

    	Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

    	this.flipY = false;

    }

    CubeTexture.prototype = Object.create( Texture.prototype );
    CubeTexture.prototype.constructor = CubeTexture;

    CubeTexture.prototype.isCubeTexture = true;

    Object.defineProperty( CubeTexture.prototype, 'images', {

    	get: function () {

    		return this.image;

    	},

    	set: function ( value ) {

    		this.image = value;

    	}

    } );

    var emptyTexture = new Texture();
    var emptyCubeTexture = new CubeTexture();

    // --- Base for inner nodes (including the root) ---

    function UniformContainer() {

    	this.seq = [];
    	this.map = {};

    }

    // --- Utilities ---

    // Array Caches (provide typed arrays for temporary by size)

    var arrayCacheF32 = [];
    var arrayCacheI32 = [];

    // Flattening for arrays of vectors and matrices

    function flatten( array, nBlocks, blockSize ) {

    	var firstElem = array[ 0 ];

    	if ( firstElem <= 0 || firstElem > 0 ) return array;
    	// unoptimized: ! isNaN( firstElem )
    	// see http://jacksondunstan.com/articles/983

    	var n = nBlocks * blockSize,
    		r = arrayCacheF32[ n ];

    	if ( r === undefined ) {

    		r = new Float32Array( n );
    		arrayCacheF32[ n ] = r;

    	}

    	if ( nBlocks !== 0 ) {

    		firstElem.toArray( r, 0 );

    		for ( var i = 1, offset = 0; i !== nBlocks; ++ i ) {

    			offset += blockSize;
    			array[ i ].toArray( r, offset );

    		}

    	}

    	return r;

    }

    // Texture unit allocation

    function allocTexUnits( renderer, n ) {

    	var r = arrayCacheI32[ n ];

    	if ( r === undefined ) {

    		r = new Int32Array( n );
    		arrayCacheI32[ n ] = r;

    	}

    	for ( var i = 0; i !== n; ++ i )
    		r[ i ] = renderer.allocTextureUnit();

    	return r;

    }

    // --- Setters ---

    // Note: Defining these methods externally, because they come in a bunch
    // and this way their names minify.

    // Single scalar

    function setValue1f( gl, v ) { gl.uniform1f( this.addr, v ); }
    function setValue1i( gl, v ) { gl.uniform1i( this.addr, v ); }

    // Single float vector (from flat array or THREE.VectorN)

    function setValue2fv( gl, v ) {

    	if ( v.x === undefined ) gl.uniform2fv( this.addr, v );
    	else gl.uniform2f( this.addr, v.x, v.y );

    }

    function setValue3fv( gl, v ) {

    	if ( v.x !== undefined )
    		gl.uniform3f( this.addr, v.x, v.y, v.z );
    	else if ( v.r !== undefined )
    		gl.uniform3f( this.addr, v.r, v.g, v.b );
    	else
    		gl.uniform3fv( this.addr, v );

    }

    function setValue4fv( gl, v ) {

    	if ( v.x === undefined ) gl.uniform4fv( this.addr, v );
    	else gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );

    }

    // Single matrix (from flat array or MatrixN)

    function setValue2fm( gl, v ) {

    	gl.uniformMatrix2fv( this.addr, false, v.elements || v );

    }

    function setValue3fm( gl, v ) {

    	gl.uniformMatrix3fv( this.addr, false, v.elements || v );

    }

    function setValue4fm( gl, v ) {

    	gl.uniformMatrix4fv( this.addr, false, v.elements || v );

    }

    // Single texture (2D / Cube)

    function setValueT1( gl, v, renderer ) {

    	var unit = renderer.allocTextureUnit();
    	gl.uniform1i( this.addr, unit );
    	renderer.setTexture2D( v || emptyTexture, unit );

    }

    function setValueT6( gl, v, renderer ) {

    	var unit = renderer.allocTextureUnit();
    	gl.uniform1i( this.addr, unit );
    	renderer.setTextureCube( v || emptyCubeTexture, unit );

    }

    // Integer / Boolean vectors or arrays thereof (always flat arrays)

    function setValue2iv( gl, v ) { gl.uniform2iv( this.addr, v ); }
    function setValue3iv( gl, v ) { gl.uniform3iv( this.addr, v ); }
    function setValue4iv( gl, v ) { gl.uniform4iv( this.addr, v ); }

    // Helper to pick the right setter for the singular case

    function getSingularSetter( type ) {

    	switch ( type ) {

    		case 0x1406: return setValue1f; // FLOAT
    		case 0x8b50: return setValue2fv; // _VEC2
    		case 0x8b51: return setValue3fv; // _VEC3
    		case 0x8b52: return setValue4fv; // _VEC4

    		case 0x8b5a: return setValue2fm; // _MAT2
    		case 0x8b5b: return setValue3fm; // _MAT3
    		case 0x8b5c: return setValue4fm; // _MAT4

    		case 0x8b5e: return setValueT1; // SAMPLER_2D
    		case 0x8b60: return setValueT6; // SAMPLER_CUBE

    		case 0x1404: case 0x8b56: return setValue1i; // INT, BOOL
    		case 0x8b53: case 0x8b57: return setValue2iv; // _VEC2
    		case 0x8b54: case 0x8b58: return setValue3iv; // _VEC3
    		case 0x8b55: case 0x8b59: return setValue4iv; // _VEC4

    	}

    }

    // Array of scalars

    function setValue1fv( gl, v ) { gl.uniform1fv( this.addr, v ); }
    function setValue1iv( gl, v ) { gl.uniform1iv( this.addr, v ); }

    // Array of vectors (flat or from THREE classes)

    function setValueV2a( gl, v ) {

    	gl.uniform2fv( this.addr, flatten( v, this.size, 2 ) );

    }

    function setValueV3a( gl, v ) {

    	gl.uniform3fv( this.addr, flatten( v, this.size, 3 ) );

    }

    function setValueV4a( gl, v ) {

    	gl.uniform4fv( this.addr, flatten( v, this.size, 4 ) );

    }

    // Array of matrices (flat or from THREE clases)

    function setValueM2a( gl, v ) {

    	gl.uniformMatrix2fv( this.addr, false, flatten( v, this.size, 4 ) );

    }

    function setValueM3a( gl, v ) {

    	gl.uniformMatrix3fv( this.addr, false, flatten( v, this.size, 9 ) );

    }

    function setValueM4a( gl, v ) {

    	gl.uniformMatrix4fv( this.addr, false, flatten( v, this.size, 16 ) );

    }

    // Array of textures (2D / Cube)

    function setValueT1a( gl, v, renderer ) {

    	var n = v.length,
    		units = allocTexUnits( renderer, n );

    	gl.uniform1iv( this.addr, units );

    	for ( var i = 0; i !== n; ++ i ) {

    		renderer.setTexture2D( v[ i ] || emptyTexture, units[ i ] );

    	}

    }

    function setValueT6a( gl, v, renderer ) {

    	var n = v.length,
    		units = allocTexUnits( renderer, n );

    	gl.uniform1iv( this.addr, units );

    	for ( var i = 0; i !== n; ++ i ) {

    		renderer.setTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );

    	}

    }

    // Helper to pick the right setter for a pure (bottom-level) array

    function getPureArraySetter( type ) {

    	switch ( type ) {

    		case 0x1406: return setValue1fv; // FLOAT
    		case 0x8b50: return setValueV2a; // _VEC2
    		case 0x8b51: return setValueV3a; // _VEC3
    		case 0x8b52: return setValueV4a; // _VEC4

    		case 0x8b5a: return setValueM2a; // _MAT2
    		case 0x8b5b: return setValueM3a; // _MAT3
    		case 0x8b5c: return setValueM4a; // _MAT4

    		case 0x8b5e: return setValueT1a; // SAMPLER_2D
    		case 0x8b60: return setValueT6a; // SAMPLER_CUBE

    		case 0x1404: case 0x8b56: return setValue1iv; // INT, BOOL
    		case 0x8b53: case 0x8b57: return setValue2iv; // _VEC2
    		case 0x8b54: case 0x8b58: return setValue3iv; // _VEC3
    		case 0x8b55: case 0x8b59: return setValue4iv; // _VEC4

    	}

    }

    // --- Uniform Classes ---

    function SingleUniform( id, activeInfo, addr ) {

    	this.id = id;
    	this.addr = addr;
    	this.setValue = getSingularSetter( activeInfo.type );

    	// this.path = activeInfo.name; // DEBUG

    }

    function PureArrayUniform( id, activeInfo, addr ) {

    	this.id = id;
    	this.addr = addr;
    	this.size = activeInfo.size;
    	this.setValue = getPureArraySetter( activeInfo.type );

    	// this.path = activeInfo.name; // DEBUG

    }

    function StructuredUniform( id ) {

    	this.id = id;

    	UniformContainer.call( this ); // mix-in

    }

    StructuredUniform.prototype.setValue = function( gl, value ) {

    	// Note: Don't need an extra 'renderer' parameter, since samplers
    	// are not allowed in structured uniforms.

    	var seq = this.seq;

    	for ( var i = 0, n = seq.length; i !== n; ++ i ) {

    		var u = seq[ i ];
    		u.setValue( gl, value[ u.id ] );

    	}

    };

    // --- Top-level ---

    // Parser - builds up the property tree from the path strings

    var RePathPart = /([\w\d_]+)(\])?(\[|\.)?/g;

    // extracts
    // 	- the identifier (member name or array index)
    //  - followed by an optional right bracket (found when array index)
    //  - followed by an optional left bracket or dot (type of subscript)
    //
    // Note: These portions can be read in a non-overlapping fashion and
    // allow straightforward parsing of the hierarchy that WebGL encodes
    // in the uniform names.

    function addUniform( container, uniformObject ) {

    	container.seq.push( uniformObject );
    	container.map[ uniformObject.id ] = uniformObject;

    }

    function parseUniform( activeInfo, addr, container ) {

    	var path = activeInfo.name,
    		pathLength = path.length;

    	// reset RegExp object, because of the early exit of a previous run
    	RePathPart.lastIndex = 0;

    	for (; ;) {

    		var match = RePathPart.exec( path ),
    			matchEnd = RePathPart.lastIndex,

    			id = match[ 1 ],
    			idIsIndex = match[ 2 ] === ']',
    			subscript = match[ 3 ];

    		if ( idIsIndex ) id = id | 0; // convert to integer

    		if ( subscript === undefined ||
    				subscript === '[' && matchEnd + 2 === pathLength ) {
    			// bare name or "pure" bottom-level array "[0]" suffix

    			addUniform( container, subscript === undefined ?
    					new SingleUniform( id, activeInfo, addr ) :
    					new PureArrayUniform( id, activeInfo, addr ) );

    			break;

    		} else {
    			// step into inner node / create it in case it doesn't exist

    			var map = container.map,
    				next = map[ id ];

    			if ( next === undefined ) {

    				next = new StructuredUniform( id );
    				addUniform( container, next );

    			}

    			container = next;

    		}

    	}

    }

    // Root Container

    function WebGLUniforms( gl, program, renderer ) {

    	UniformContainer.call( this );

    	this.renderer = renderer;

    	var n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );

    	for ( var i = 0; i !== n; ++ i ) {

    		var info = gl.getActiveUniform( program, i ),
    			path = info.name,
    			addr = gl.getUniformLocation( program, path );

    		parseUniform( info, addr, this );

    	}

    }

    WebGLUniforms.prototype.setValue = function( gl, name, value ) {

    	var u = this.map[ name ];

    	if ( u !== undefined ) u.setValue( gl, value, this.renderer );

    };

    WebGLUniforms.prototype.set = function( gl, object, name ) {

    	var u = this.map[ name ];

    	if ( u !== undefined ) u.setValue( gl, object[ name ], this.renderer );

    };

    WebGLUniforms.prototype.setOptional = function( gl, object, name ) {

    	var v = object[ name ];

    	if ( v !== undefined ) this.setValue( gl, name, v );

    };


    // Static interface

    WebGLUniforms.upload = function( gl, seq, values, renderer ) {

    	for ( var i = 0, n = seq.length; i !== n; ++ i ) {

    		var u = seq[ i ],
    			v = values[ u.id ];

    		if ( v.needsUpdate !== false ) {
    			// note: always updating when .needsUpdate is undefined

    			u.setValue( gl, v.value, renderer );

    		}

    	}

    };

    WebGLUniforms.seqWithValue = function( seq, values ) {

    	var r = [];

    	for ( var i = 0, n = seq.length; i !== n; ++ i ) {

    		var u = seq[ i ];
    		if ( u.id in values ) r.push( u );

    	}

    	return r;

    };

    WebGLUniforms.splitDynamic = function( seq, values ) {

    	var r = null,
    		n = seq.length,
    		w = 0;

    	for ( var i = 0; i !== n; ++ i ) {

    		var u = seq[ i ],
    			v = values[ u.id ];

    		if ( v && v.dynamic === true ) {

    			if ( r === null ) r = [];
    			r.push( u );

    		} else {

    			// in-place compact 'seq', removing the matches
    			if ( w < i ) seq[ w ] = u;
    			++ w;

    		}

    	}

    	if ( w < n ) seq.length = w;

    	return r;

    };

    WebGLUniforms.evalDynamic = function( seq, values, object, material, camera ) {

    	for ( var i = 0, n = seq.length; i !== n; ++ i ) {

    		var v = values[ seq[ i ].id ],
    			f = v.onUpdateCallback;

    		if ( f !== undefined ) f.call( v, object, material, camera );

    	}

    };

    /**
     * Uniform Utilities
     */

    exports.UniformsUtils = {

    	merge: function ( uniforms ) {

    		var merged = {};

    		for ( var u = 0; u < uniforms.length; u ++ ) {

    			var tmp = this.clone( uniforms[ u ] );

    			for ( var p in tmp ) {

    				merged[ p ] = tmp[ p ];

    			}

    		}

    		return merged;

    	},

    	clone: function ( uniforms_src ) {

    		var uniforms_dst = {};

    		for ( var u in uniforms_src ) {

    			uniforms_dst[ u ] = {};

    			for ( var p in uniforms_src[ u ] ) {

    				var parameter_src = uniforms_src[ u ][ p ];

    				if ( (parameter_src && parameter_src.isColor) ||
    					 (parameter_src && parameter_src.isVector2) ||
    					 (parameter_src && parameter_src.isVector3) ||
    					 (parameter_src && parameter_src.isVector4) ||
    					 (parameter_src && parameter_src.isMatrix3) ||
    					 (parameter_src && parameter_src.isMatrix4) ||
    					 (parameter_src && parameter_src.isTexture) ) {

    					uniforms_dst[ u ][ p ] = parameter_src.clone();

    				} else if ( Array.isArray( parameter_src ) ) {

    					uniforms_dst[ u ][ p ] = parameter_src.slice();

    				} else {

    					uniforms_dst[ u ][ p ] = parameter_src;

    				}

    			}

    		}

    		return uniforms_dst;

    	}

    };

    var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n";

    var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n";

    var alphatest_fragment = "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n";

    var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n";

    var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";

    var begin_vertex = "\nvec3 transformed = vec3( position );\n";

    var beginnormal_vertex = "\nvec3 objectNormal = vec3( normal );\n";

    var bsdfs = "bool testLightInRange( const in float lightDistance, const in float cutoffDistance ) {\n\treturn any( bvec2( cutoffDistance == 0.0, lightDistance < cutoffDistance ) );\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t\tif( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n#else\n\t\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n\t\t}\n\t\treturn 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n";

    var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos );\n\t\tvec3 vSigmaY = dFdy( surf_pos );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n";

    var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tfor ( int i = 0; i < NUM_CLIPPING_PLANES; ++ i ) {\n\t\tvec4 plane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n#endif\n";

    var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n";

    var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvarying vec3 vViewPosition;\n#endif\n";

    var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n";

    var color_fragment = "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif";

    var color_pars_fragment = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n";

    var color_pars_vertex = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif";

    var color_vertex = "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif";

    var common = "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\n";

    var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n";

    var defaultnormal_vertex = "#ifdef FLIP_SIDED\n\tobjectNormal = -objectNormal;\n#endif\nvec3 transformedNormal = normalMatrix * objectNormal;\n";

    var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n";

    var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n";

    var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n";

    var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n";

    var encodings_fragment = "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n";

    var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n  return value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n  return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n  return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n  float maxComponent = max( max( value.r, value.g ), value.b );\n  float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n  return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n  return vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n  float maxRGB = max( value.x, max( value.g, value.b ) );\n  float M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n  M            = ceil( M * 255.0 ) / 255.0;\n  return vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n    return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n    float maxRGB = max( value.x, max( value.g, value.b ) );\n    float D      = max( maxRange / maxRGB, 1.0 );\n    D            = min( floor( D ) / 255.0, 1.0 );\n    return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n  vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n  Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n  vec4 vResult;\n  vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n  float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n  vResult.w = fract(Le);\n  vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n  return vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n  float Le = value.z * 255.0 + value.w;\n  vec3 Xp_Y_XYZp;\n  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n  Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n  Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n  vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n  return vec4( max(vRGB, 0.0), 1.0 );\n}\n";

    var envmap_fragment = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n";

    var envmap_pars_fragment = "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntenstiy;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n";

    var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n";

    var envmap_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n";

    var fog_fragment = "#ifdef USE_FOG\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\n\t#else\n\t\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n\t#endif\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, depth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n";

    var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";

    var lightmap_fragment = "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n";

    var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";

    var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n";

    var lights_pars = "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tif ( testLightInRange( lightDistance, pointLight.distance ) ) {\n\t\t\tdirectLight.color = pointLight.color;\n\t\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( all( bvec2( angleCos > spotLight.coneCos, testLightInRange( lightDistance, spotLight.distance ) ) ) ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\t#include <normal_flip>\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\t#include <normal_flip>\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n\t\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n";

    var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n";

    var lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n";

    var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n";

    var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n";

    var lights_template = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t \tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\n\t#endif\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\n\t#ifndef STANDARD\n\t\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\n\t#else\n\t\tvec3 clearCoatRadiance = vec3( 0.0 );\n\t#endif\n\t\t\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n";

    var logdepthbuf_fragment = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n#endif";

    var logdepthbuf_pars_fragment = "#ifdef USE_LOGDEPTHBUF\n\tuniform float logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n#endif\n";

    var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n\tuniform float logDepthBufFC;\n#endif";

    var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\t#endif\n#endif\n";

    var map_fragment = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n";

    var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n";

    var map_particle_fragment = "#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n";

    var map_particle_pars_fragment = "#ifdef USE_MAP\n\tuniform vec4 offsetRepeat;\n\tuniform sampler2D map;\n#endif\n";

    var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.r;\n#endif\n";

    var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";

    var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n";

    var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif";

    var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n";

    var normal_flip = "#ifdef DOUBLE_SIDED\n\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n#else\n\tfloat flipNormal = 1.0;\n#endif\n";

    var normal_fragment = "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal ) * flipNormal;\n#endif\n#ifdef USE_NORMALMAP\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n";

    var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n\t\tvec3 N = normalize( surf_norm );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif\n";

    var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n  return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n  return 1.0 - 2.0 * rgb.xyz;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n  return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n  return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n  return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n  return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n";

    var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n";

    var project_vertex = "#ifdef USE_SKINNING\n\tvec4 mvPosition = modelViewMatrix * skinned;\n#else\n\tvec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n#endif\ngl_Position = projectionMatrix * mvPosition;\n";

    var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.r;\n#endif\n";

    var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";

    var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\treturn (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn 1.0;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\tfloat dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n";

    var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n";

    var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n";

    var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n";

    var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";

    var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureWidth;\n\t\tuniform int boneTextureHeight;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureWidth ) );\n\t\t\tfloat y = floor( j / float( boneTextureWidth ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureWidth );\n\t\t\tfloat dy = 1.0 / float( boneTextureHeight );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n";

    var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\tskinned  = bindMatrixInverse * skinned;\n#endif\n";

    var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n";

    var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";

    var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";

    var tonemapping_fragment = "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n";

    var tonemapping_pars_fragment = "#define saturate(a) clamp( a, 0.0, 1.0 )\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n  return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  return saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  color = max( vec3( 0.0 ), color - 0.004 );\n  return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n";

    var uv_pars_fragment = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif";

    var uv_pars_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform vec4 offsetRepeat;\n#endif\n";

    var uv_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n#endif";

    var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";

    var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif";

    var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif";

    var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\t#ifdef USE_SKINNING\n\t\tvec4 worldPosition = modelMatrix * skinned;\n\t#else\n\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\t#endif\n#endif\n";

    var cube_frag = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\tgl_FragColor.a *= opacity;\n}\n";

    var cube_vert = "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n";

    var depth_frag = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n";

    var depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n";

    var distanceRGBA_frag = "uniform vec3 lightPos;\nvarying vec4 vWorldPosition;\n#include <common>\n#include <packing>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tgl_FragColor = packDepthToRGBA( length( vWorldPosition.xyz - lightPos.xyz ) / 1000.0 );\n}\n";

    var distanceRGBA_vert = "varying vec4 vWorldPosition;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <skinbase_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition;\n}\n";

    var equirect_frag = "uniform sampler2D tEquirect;\nuniform float tFlip;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}\n";

    var equirect_vert = "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n";

    var linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";

    var linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n";

    var meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight;\n\treflectedLight.directDiffuse = vec3( 0.0 );\n\treflectedLight.directSpecular = vec3( 0.0 );\n\treflectedLight.indirectDiffuse = diffuseColor.rgb;\n\treflectedLight.indirectSpecular = vec3( 0.0 );\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <normal_flip>\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";

    var meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n}\n";

    var meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <normal_flip>\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";

    var meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n}\n";

    var meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";

    var meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n}\n";

    var meshphysical_frag = "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nuniform float envMapIntensity;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";

    var meshphysical_vert = "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n";

    var normal_frag = "uniform float opacity;\nvarying vec3 vNormal;\n#include <common>\n#include <packing>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tgl_FragColor = vec4( packNormalToRGB( vNormal ), opacity );\n\t#include <logdepthbuf_fragment>\n}\n";

    var normal_vert = "varying vec3 vNormal;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvNormal = normalize( normalMatrix * normal );\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n";

    var points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";

    var points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n";

    var shadow_frag = "uniform float opacity;\n#include <common>\n#include <packing>\n#include <bsdfs>\n#include <lights_pars>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( 0.0, 0.0, 0.0, opacity * ( 1.0  - getShadowMask() ) );\n}\n";

    var shadow_vert = "#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n";

    var ShaderChunk = {
    	alphamap_fragment: alphamap_fragment,
    	alphamap_pars_fragment: alphamap_pars_fragment,
    	alphatest_fragment: alphatest_fragment,
    	aomap_fragment: aomap_fragment,
    	aomap_pars_fragment: aomap_pars_fragment,
    	begin_vertex: begin_vertex,
    	beginnormal_vertex: beginnormal_vertex,
    	bsdfs: bsdfs,
    	bumpmap_pars_fragment: bumpmap_pars_fragment,
    	clipping_planes_fragment: clipping_planes_fragment,
    	clipping_planes_pars_fragment: clipping_planes_pars_fragment,
    	clipping_planes_pars_vertex: clipping_planes_pars_vertex,
    	clipping_planes_vertex: clipping_planes_vertex,
    	color_fragment: color_fragment,
    	color_pars_fragment: color_pars_fragment,
    	color_pars_vertex: color_pars_vertex,
    	color_vertex: color_vertex,
    	common: common,
    	cube_uv_reflection_fragment: cube_uv_reflection_fragment,
    	defaultnormal_vertex: defaultnormal_vertex,
    	displacementmap_pars_vertex: displacementmap_pars_vertex,
    	displacementmap_vertex: displacementmap_vertex,
    	emissivemap_fragment: emissivemap_fragment,
    	emissivemap_pars_fragment: emissivemap_pars_fragment,
    	encodings_fragment: encodings_fragment,
    	encodings_pars_fragment: encodings_pars_fragment,
    	envmap_fragment: envmap_fragment,
    	envmap_pars_fragment: envmap_pars_fragment,
    	envmap_pars_vertex: envmap_pars_vertex,
    	envmap_vertex: envmap_vertex,
    	fog_fragment: fog_fragment,
    	fog_pars_fragment: fog_pars_fragment,
    	lightmap_fragment: lightmap_fragment,
    	lightmap_pars_fragment: lightmap_pars_fragment,
    	lights_lambert_vertex: lights_lambert_vertex,
    	lights_pars: lights_pars,
    	lights_phong_fragment: lights_phong_fragment,
    	lights_phong_pars_fragment: lights_phong_pars_fragment,
    	lights_physical_fragment: lights_physical_fragment,
    	lights_physical_pars_fragment: lights_physical_pars_fragment,
    	lights_template: lights_template,
    	logdepthbuf_fragment: logdepthbuf_fragment,
    	logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
    	logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
    	logdepthbuf_vertex: logdepthbuf_vertex,
    	map_fragment: map_fragment,
    	map_pars_fragment: map_pars_fragment,
    	map_particle_fragment: map_particle_fragment,
    	map_particle_pars_fragment: map_particle_pars_fragment,
    	metalnessmap_fragment: metalnessmap_fragment,
    	metalnessmap_pars_fragment: metalnessmap_pars_fragment,
    	morphnormal_vertex: morphnormal_vertex,
    	morphtarget_pars_vertex: morphtarget_pars_vertex,
    	morphtarget_vertex: morphtarget_vertex,
    	normal_flip: normal_flip,
    	normal_fragment: normal_fragment,
    	normalmap_pars_fragment: normalmap_pars_fragment,
    	packing: packing,
    	premultiplied_alpha_fragment: premultiplied_alpha_fragment,
    	project_vertex: project_vertex,
    	roughnessmap_fragment: roughnessmap_fragment,
    	roughnessmap_pars_fragment: roughnessmap_pars_fragment,
    	shadowmap_pars_fragment: shadowmap_pars_fragment,
    	shadowmap_pars_vertex: shadowmap_pars_vertex,
    	shadowmap_vertex: shadowmap_vertex,
    	shadowmask_pars_fragment: shadowmask_pars_fragment,
    	skinbase_vertex: skinbase_vertex,
    	skinning_pars_vertex: skinning_pars_vertex,
    	skinning_vertex: skinning_vertex,
    	skinnormal_vertex: skinnormal_vertex,
    	specularmap_fragment: specularmap_fragment,
    	specularmap_pars_fragment: specularmap_pars_fragment,
    	tonemapping_fragment: tonemapping_fragment,
    	tonemapping_pars_fragment: tonemapping_pars_fragment,
    	uv_pars_fragment: uv_pars_fragment,
    	uv_pars_vertex: uv_pars_vertex,
    	uv_vertex: uv_vertex,
    	uv2_pars_fragment: uv2_pars_fragment,
    	uv2_pars_vertex: uv2_pars_vertex,
    	uv2_vertex: uv2_vertex,
    	worldpos_vertex: worldpos_vertex,

    	cube_frag: cube_frag,
    	cube_vert: cube_vert,
    	depth_frag: depth_frag,
    	depth_vert: depth_vert,
    	distanceRGBA_frag: distanceRGBA_frag,
    	distanceRGBA_vert: distanceRGBA_vert,
    	equirect_frag: equirect_frag,
    	equirect_vert: equirect_vert,
    	linedashed_frag: linedashed_frag,
    	linedashed_vert: linedashed_vert,
    	meshbasic_frag: meshbasic_frag,
    	meshbasic_vert: meshbasic_vert,
    	meshlambert_frag: meshlambert_frag,
    	meshlambert_vert: meshlambert_vert,
    	meshphong_frag: meshphong_frag,
    	meshphong_vert: meshphong_vert,
    	meshphysical_frag: meshphysical_frag,
    	meshphysical_vert: meshphysical_vert,
    	normal_frag: normal_frag,
    	normal_vert: normal_vert,
    	points_frag: points_frag,
    	points_vert: points_vert,
    	shadow_frag: shadow_frag,
    	shadow_vert: shadow_vert
    };

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function Color( r, g, b ) {

    	if ( g === undefined && b === undefined ) {

    		// r is THREE.Color, hex or string
    		return this.set( r );

    	}

    	return this.setRGB( r, g, b );

    }

    Color.prototype = {

    	constructor: Color,

    	isColor: true,

    	r: 1, g: 1, b: 1,

    	set: function ( value ) {

    		if ( (value && value.isColor) ) {

    			this.copy( value );

    		} else if ( typeof value === 'number' ) {

    			this.setHex( value );

    		} else if ( typeof value === 'string' ) {

    			this.setStyle( value );

    		}

    		return this;

    	},

    	setScalar: function ( scalar ) {

    		this.r = scalar;
    		this.g = scalar;
    		this.b = scalar;

    	},

    	setHex: function ( hex ) {

    		hex = Math.floor( hex );

    		this.r = ( hex >> 16 & 255 ) / 255;
    		this.g = ( hex >> 8 & 255 ) / 255;
    		this.b = ( hex & 255 ) / 255;

    		return this;

    	},

    	setRGB: function ( r, g, b ) {

    		this.r = r;
    		this.g = g;
    		this.b = b;

    		return this;

    	},

    	setHSL: function () {

    		function hue2rgb( p, q, t ) {

    			if ( t < 0 ) t += 1;
    			if ( t > 1 ) t -= 1;
    			if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
    			if ( t < 1 / 2 ) return q;
    			if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
    			return p;

    		}

    		return function setHSL( h, s, l ) {

    			// h,s,l ranges are in 0.0 - 1.0
    			h = exports.Math.euclideanModulo( h, 1 );
    			s = exports.Math.clamp( s, 0, 1 );
    			l = exports.Math.clamp( l, 0, 1 );

    			if ( s === 0 ) {

    				this.r = this.g = this.b = l;

    			} else {

    				var p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
    				var q = ( 2 * l ) - p;

    				this.r = hue2rgb( q, p, h + 1 / 3 );
    				this.g = hue2rgb( q, p, h );
    				this.b = hue2rgb( q, p, h - 1 / 3 );

    			}

    			return this;

    		};

    	}(),

    	setStyle: function ( style ) {

    		function handleAlpha( string ) {

    			if ( string === undefined ) return;

    			if ( parseFloat( string ) < 1 ) {

    				console.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );

    			}

    		}


    		var m;

    		if ( m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec( style ) ) {

    			// rgb / hsl

    			var color;
    			var name = m[ 1 ];
    			var components = m[ 2 ];

    			switch ( name ) {

    				case 'rgb':
    				case 'rgba':

    					if ( color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

    						// rgb(255,0,0) rgba(255,0,0,0.5)
    						this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
    						this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
    						this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;

    						handleAlpha( color[ 5 ] );

    						return this;

    					}

    					if ( color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

    						// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
    						this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
    						this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
    						this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;

    						handleAlpha( color[ 5 ] );

    						return this;

    					}

    					break;

    				case 'hsl':
    				case 'hsla':

    					if ( color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

    						// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
    						var h = parseFloat( color[ 1 ] ) / 360;
    						var s = parseInt( color[ 2 ], 10 ) / 100;
    						var l = parseInt( color[ 3 ], 10 ) / 100;

    						handleAlpha( color[ 5 ] );

    						return this.setHSL( h, s, l );

    					}

    					break;

    			}

    		} else if ( m = /^\#([A-Fa-f0-9]+)$/.exec( style ) ) {

    			// hex color

    			var hex = m[ 1 ];
    			var size = hex.length;

    			if ( size === 3 ) {

    				// #ff0
    				this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;
    				this.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;
    				this.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;

    				return this;

    			} else if ( size === 6 ) {

    				// #ff0000
    				this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;
    				this.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;
    				this.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;

    				return this;

    			}

    		}

    		if ( style && style.length > 0 ) {

    			// color keywords
    			var hex = exports.ColorKeywords[ style ];

    			if ( hex !== undefined ) {

    				// red
    				this.setHex( hex );

    			} else {

    				// unknown color
    				console.warn( 'THREE.Color: Unknown color ' + style );

    			}

    		}

    		return this;

    	},

    	clone: function () {

    		return new this.constructor( this.r, this.g, this.b );

    	},

    	copy: function ( color ) {

    		this.r = color.r;
    		this.g = color.g;
    		this.b = color.b;

    		return this;

    	},

    	copyGammaToLinear: function ( color, gammaFactor ) {

    		if ( gammaFactor === undefined ) gammaFactor = 2.0;

    		this.r = Math.pow( color.r, gammaFactor );
    		this.g = Math.pow( color.g, gammaFactor );
    		this.b = Math.pow( color.b, gammaFactor );

    		return this;

    	},

    	copyLinearToGamma: function ( color, gammaFactor ) {

    		if ( gammaFactor === undefined ) gammaFactor = 2.0;

    		var safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;

    		this.r = Math.pow( color.r, safeInverse );
    		this.g = Math.pow( color.g, safeInverse );
    		this.b = Math.pow( color.b, safeInverse );

    		return this;

    	},

    	convertGammaToLinear: function () {

    		var r = this.r, g = this.g, b = this.b;

    		this.r = r * r;
    		this.g = g * g;
    		this.b = b * b;

    		return this;

    	},

    	convertLinearToGamma: function () {

    		this.r = Math.sqrt( this.r );
    		this.g = Math.sqrt( this.g );
    		this.b = Math.sqrt( this.b );

    		return this;

    	},

    	getHex: function () {

    		return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;

    	},

    	getHexString: function () {

    		return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );

    	},

    	getHSL: function ( optionalTarget ) {

    		// h,s,l ranges are in 0.0 - 1.0

    		var hsl = optionalTarget || { h: 0, s: 0, l: 0 };

    		var r = this.r, g = this.g, b = this.b;

    		var max = Math.max( r, g, b );
    		var min = Math.min( r, g, b );

    		var hue, saturation;
    		var lightness = ( min + max ) / 2.0;

    		if ( min === max ) {

    			hue = 0;
    			saturation = 0;

    		} else {

    			var delta = max - min;

    			saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

    			switch ( max ) {

    				case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
    				case g: hue = ( b - r ) / delta + 2; break;
    				case b: hue = ( r - g ) / delta + 4; break;

    			}

    			hue /= 6;

    		}

    		hsl.h = hue;
    		hsl.s = saturation;
    		hsl.l = lightness;

    		return hsl;

    	},

    	getStyle: function () {

    		return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';

    	},

    	offsetHSL: function ( h, s, l ) {

    		var hsl = this.getHSL();

    		hsl.h += h; hsl.s += s; hsl.l += l;

    		this.setHSL( hsl.h, hsl.s, hsl.l );

    		return this;

    	},

    	add: function ( color ) {

    		this.r += color.r;
    		this.g += color.g;
    		this.b += color.b;

    		return this;

    	},

    	addColors: function ( color1, color2 ) {

    		this.r = color1.r + color2.r;
    		this.g = color1.g + color2.g;
    		this.b = color1.b + color2.b;

    		return this;

    	},

    	addScalar: function ( s ) {

    		this.r += s;
    		this.g += s;
    		this.b += s;

    		return this;

    	},

    	sub: function( color ) {

    		this.r = Math.max( 0, this.r - color.r );
    		this.g = Math.max( 0, this.g - color.g );
    		this.b = Math.max( 0, this.b - color.b );

    		return this;

    	},

    	multiply: function ( color ) {

    		this.r *= color.r;
    		this.g *= color.g;
    		this.b *= color.b;

    		return this;

    	},

    	multiplyScalar: function ( s ) {

    		this.r *= s;
    		this.g *= s;
    		this.b *= s;

    		return this;

    	},

    	lerp: function ( color, alpha ) {

    		this.r += ( color.r - this.r ) * alpha;
    		this.g += ( color.g - this.g ) * alpha;
    		this.b += ( color.b - this.b ) * alpha;

    		return this;

    	},

    	equals: function ( c ) {

    		return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

    	},

    	fromArray: function ( array, offset ) {

    		if ( offset === undefined ) offset = 0;

    		this.r = array[ offset ];
    		this.g = array[ offset + 1 ];
    		this.b = array[ offset + 2 ];

    		return this;

    	},

    	toArray: function ( array, offset ) {

    		if ( array === undefined ) array = [];
    		if ( offset === undefined ) offset = 0;

    		array[ offset ] = this.r;
    		array[ offset + 1 ] = this.g;
    		array[ offset + 2 ] = this.b;

    		return array;

    	},

    	toJSON: function () {

    		return this.getHex();

    	}

    };

    exports.ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
    'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
    'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
    'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
    'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
    'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
    'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
    'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
    'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
    'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
    'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
    'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
    'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
    'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
    'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
    'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
    'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
    'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
    'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
    'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
    'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
    'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
    'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
    'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

    /**
     * Uniforms library for shared webgl shaders
     */

    var UniformsLib = {

    	common: {

    		diffuse: { value: new Color( 0xeeeeee ) },
    		opacity: { value: 1.0 },

    		map: { value: null },
    		offsetRepeat: { value: new Vector4( 0, 0, 1, 1 ) },

    		specularMap: { value: null },
    		alphaMap: { value: null },

    		envMap: { value: null },
    		flipEnvMap: { value: - 1 },
    		reflectivity: { value: 1.0 },
    		refractionRatio: { value: 0.98 }

    	},

    	aomap: {

    		aoMap: { value: null },
    		aoMapIntensity: { value: 1 }

    	},

    	lightmap: {

    		lightMap: { value: null },
    		lightMapIntensity: { value: 1 }

    	},

    	emissivemap: {

    		emissiveMap: { value: null }

    	},

    	bumpmap: {

    		bumpMap: { value: null },
    		bumpScale: { value: 1 }

    	},

    	normalmap: {

    		normalMap: { value: null },
    		normalScale: { value: new Vector2( 1, 1 ) }

    	},

    	displacementmap: {

    		displacementMap: { value: null },
    		displacementScale: { value: 1 },
    		displacementBias: { value: 0 }

    	},

    	roughnessmap: {

    		roughnessMap: { value: null }

    	},

    	metalnessmap: {

    		metalnessMap: { value: null }

    	},

    	fog: {

    		fogDensity: { value: 0.00025 },
    		fogNear: { value: 1 },
    		fogFar: { value: 2000 },
    		fogColor: { value: new Color( 0xffffff ) }

    	},

    	lights: {

    		ambientLightColor: { value: [] },

    		directionalLights: { value: [], properties: {
    			direction: {},
    			color: {},

    			shadow: {},
    			shadowBias: {},
    			shadowRadius: {},
    			shadowMapSize: {}
    		} },

    		directionalShadowMap: { value: [] },
    		directionalShadowMatrix: { value: [] },

    		spotLights: { value: [], properties: {
    			color: {},
    			position: {},
    			direction: {},
    			distance: {},
    			coneCos: {},
    			penumbraCos: {},
    			decay: {},

    			shadow: {},
    			shadowBias: {},
    			shadowRadius: {},
    			shadowMapSize: {}
    		} },

    		spotShadowMap: { value: [] },
    		spotShadowMatrix: { value: [] },

    		pointLights: { value: [], properties: {
    			color: {},
    			position: {},
    			decay: {},
    			distance: {},

    			shadow: {},
    			shadowBias: {},
    			shadowRadius: {},
    			shadowMapSize: {}
    		} },

    		pointShadowMap: { value: [] },
    		pointShadowMatrix: { value: [] },

    		hemisphereLights: { value: [], properties: {
    			direction: {},
    			skyColor: {},
    			groundColor: {}
    		} }

    	},

    	points: {

    		diffuse: { value: new Color( 0xeeeeee ) },
    		opacity: { value: 1.0 },
    		size: { value: 1.0 },
    		scale: { value: 1.0 },
    		map: { value: null },
    		offsetRepeat: { value: new Vector4( 0, 0, 1, 1 ) }

    	}

    };

    /**
     * @author alteredq / http://alteredqualia.com/
     * @author mrdoob / http://mrdoob.com/
     * @author mikael emtinger / http://gomo.se/
     */

    var ShaderLib = {

    	basic: {

    		uniforms: exports.UniformsUtils.merge( [

    			UniformsLib.common,
    			UniformsLib.aomap,
    			UniformsLib.fog

    		] ),

    		vertexShader: ShaderChunk.meshbasic_vert,
    		fragmentShader: ShaderChunk.meshbasic_frag

    	},

    	lambert: {

    		uniforms: exports.UniformsUtils.merge( [

    			UniformsLib.common,
    			UniformsLib.aomap,
    			UniformsLib.lightmap,
    			UniformsLib.emissivemap,
    			UniformsLib.fog,
    			UniformsLib.lights,

    			{
    				emissive : { value: new Color( 0x000000 ) }
    			}

    		] ),

    		vertexShader: ShaderChunk.meshlambert_vert,
    		fragmentShader: ShaderChunk.meshlambert_frag

    	},

    	phong: {

    		uniforms: exports.UniformsUtils.merge( [

    			UniformsLib.common,
    			UniformsLib.aomap,
    			UniformsLib.lightmap,
    			UniformsLib.emissivemap,
    			UniformsLib.bumpmap,
    			UniformsLib.normalmap,
    			UniformsLib.displacementmap,
    			UniformsLib.fog,
    			UniformsLib.lights,

    			{
    				emissive : { value: new Color( 0x000000 ) },
    				specular : { value: new Color( 0x111111 ) },
    				shininess: { value: 30 }
    			}

    		] ),

    		vertexShader: ShaderChunk.meshphong_vert,
    		fragmentShader: ShaderChunk.meshphong_frag

    	},

    	standard: {

    		uniforms: exports.UniformsUtils.merge( [

    			UniformsLib.common,
    			UniformsLib.aomap,
    			UniformsLib.lightmap,
    			UniformsLib.emissivemap,
    			UniformsLib.bumpmap,
    			UniformsLib.normalmap,
    			UniformsLib.displacementmap,
    			UniformsLib.roughnessmap,
    			UniformsLib.metalnessmap,
    			UniformsLib.fog,
    			UniformsLib.lights,

    			{
    				emissive : { value: new Color( 0x000000 ) },
    				roughness: { value: 0.5 },
    				metalness: { value: 0 },
    				envMapIntensity : { value: 1 }, // temporary
    			}

    		] ),

    		vertexShader: ShaderChunk.meshphysical_vert,
    		fragmentShader: ShaderChunk.meshphysical_frag

    	},

    	points: {

    		uniforms: exports.UniformsUtils.merge( [

    			UniformsLib.points,
    			UniformsLib.fog

    		] ),

    		vertexShader: ShaderChunk.points_vert,
    		fragmentShader: ShaderChunk.points_frag

    	},

    	dashed: {

    		uniforms: exports.UniformsUtils.merge( [

    			UniformsLib.common,
    			UniformsLib.fog,

    			{
    				scale    : { value: 1 },
    				dashSize : { value: 1 },
    				totalSize: { value: 2 }
    			}

    		] ),

    		vertexShader: ShaderChunk.linedashed_vert,
    		fragmentShader: ShaderChunk.linedashed_frag

    	},

    	depth: {

    		uniforms: exports.UniformsUtils.merge( [

    			UniformsLib.common,
    			UniformsLib.displacementmap

    		] ),

    		vertexShader: ShaderChunk.depth_vert,
    		fragmentShader: ShaderChunk.depth_frag

    	},

    	normal: {

    		uniforms: {

    			opacity : { value: 1.0 }

    		},

    		vertexShader: ShaderChunk.normal_vert,
    		fragmentShader: ShaderChunk.normal_frag

    	},

    	/* -------------------------------------------------------------------------
    	//	Cube map shader
    	 ------------------------------------------------------------------------- */

    	cube: {

    		uniforms: {
    			tCube: { value: null },
    			tFlip: { value: - 1 },
    			opacity: { value: 1.0 }
    		},

    		vertexShader: ShaderChunk.cube_vert,
    		fragmentShader: ShaderChunk.cube_frag

    	},

    	/* -------------------------------------------------------------------------
    	//	Cube map shader
    	 ------------------------------------------------------------------------- */

    	equirect: {

    		uniforms: {
    			tEquirect: { value: null },
    			tFlip: { value: - 1 }
    		},

    		vertexShader: ShaderChunk.equirect_vert,
    		fragmentShader: ShaderChunk.equirect_frag

    	},

    	distanceRGBA: {

    		uniforms: {

    			lightPos: { value: new Vector3() }

    		},

    		vertexShader: ShaderChunk.distanceRGBA_vert,
    		fragmentShader: ShaderChunk.distanceRGBA_frag

    	}

    };

    ShaderLib.physical = {

    	uniforms: exports.UniformsUtils.merge( [

    		ShaderLib.standard.uniforms,

    		{
    			clearCoat: { value: 0 },
    			clearCoatRoughness: { value: 0 }
    		}

    	] ),

    	vertexShader: ShaderChunk.meshphysical_vert,
    	fragmentShader: ShaderChunk.meshphysical_frag

    };

    /**
     * @author bhouston / http://clara.io
     */

    function Box2( min, max ) {

    	this.min = ( min !== undefined ) ? min : new Vector2( + Infinity, + Infinity );
    	this.max = ( max !== undefined ) ? max : new Vector2( - Infinity, - Infinity );

    }

    Box2.prototype = {

    	constructor: Box2,

    	set: function ( min, max ) {

    		this.min.copy( min );
    		this.max.copy( max );

    		return this;

    	},

    	setFromPoints: function ( points ) {

    		this.makeEmpty();

    		for ( var i = 0, il = points.length; i < il; i ++ ) {

    			this.expandByPoint( points[ i ] );

    		}

    		return this;

    	},

    	setFromCenterAndSize: function () {

    		var v1 = new Vector2();

    		return function setFromCenterAndSize( center, size ) {

    			var halfSize = v1.copy( size ).multiplyScalar( 0.5 );
    			this.min.copy( center ).sub( halfSize );
    			this.max.copy( center ).add( halfSize );

    			return this;

    		};

    	}(),

    	clone: function () {

    		return new this.constructor().copy( this );

    	},

    	copy: function ( box ) {

    		this.min.copy( box.min );
    		this.max.copy( box.max );

    		return this;

    	},

    	makeEmpty: function () {

    		this.min.x = this.min.y = + Infinity;
    		this.max.x = this.max.y = - Infinity;

    		return this;

    	},

    	isEmpty: function () {

    		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

    		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );

    	},

    	getCenter: function ( optionalTarget ) {

    		var result = optionalTarget || new Vector2();
    		return this.isEmpty() ? result.set( 0, 0 ) : result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

    	},

    	getSize: function ( optionalTarget ) {

    		var result = optionalTarget || new Vector2();
    		return this.isEmpty() ? result.set( 0, 0 ) : result.subVectors( this.max, this.min );

    	},

    	expandByPoint: function ( point ) {

    		this.min.min( point );
    		this.max.max( point );

    		return this;

    	},

    	expandByVector: function ( vector ) {

    		this.min.sub( vector );
    		this.max.add( vector );

    		return this;

    	},

    	expandByScalar: function ( scalar ) {

    		this.min.addScalar( - scalar );
    		this.max.addScalar( scalar );

    		return this;

    	},

    	containsPoint: function ( point ) {

    		if ( point.x < this.min.x || point.x > this.max.x ||
    		     point.y < this.min.y || point.y > this.max.y ) {

    			return false;

    		}

    		return true;

    	},

    	containsBox: function ( box ) {

    		if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
    		     ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) ) {

    			return true;

    		}

    		return false;

    	},

    	getParameter: function ( point, optionalTarget ) {

    		// This can potentially have a divide by zero if the box
    		// has a size dimension of 0.

    		var result = optionalTarget || new Vector2();

    		return result.set(
    			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
    			( point.y - this.min.y ) / ( this.max.y - this.min.y )
    		);

    	},

    	intersectsBox: function ( box ) {

    		// using 6 splitting planes to rule out intersections.

    		if ( box.max.x < this.min.x || box.min.x > this.max.x ||
    		     box.max.y < this.min.y || box.min.y > this.max.y ) {

    			return false;

    		}

    		return true;

    	},

    	clampPoint: function ( point, optionalTarget ) {

    		var result = optionalTarget || new Vector2();
    		return result.copy( point ).clamp( this.min, this.max );

    	},

    	distanceToPoint: function () {

    		var v1 = new Vector2();

    		return function distanceToPoint( point ) {

    			var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
    			return clampedPoint.sub( point ).length();

    		};

    	}(),

    	intersect: function ( box ) {

    		this.min.max( box.min );
    		this.max.min( box.max );

    		return this;

    	},

    	union: function ( box ) {

    		this.min.min( box.min );
    		this.max.max( box.max );

    		return this;

    	},

    	translate: function ( offset ) {

    		this.min.add( offset );
    		this.max.add( offset );

    		return this;

    	},

    	equals: function ( box ) {

    		return box.min.equals( this.min ) && box.max.equals( this.max );

    	}

    };

    /**
     * @author mikael emtinger / http://gomo.se/
     * @author alteredq / http://alteredqualia.com/
     */

    function LensFlarePlugin( renderer, flares ) {

    	var gl = renderer.context;
    	var state = renderer.state;

    	var vertexBuffer, elementBuffer;
    	var shader, program, attributes, uniforms;

    	var tempTexture, occlusionTexture;

    	function init() {

    		var vertices = new Float32Array( [
    			- 1, - 1,  0, 0,
    			 1, - 1,  1, 0,
    			 1,  1,  1, 1,
    			- 1,  1,  0, 1
    		] );

    		var faces = new Uint16Array( [
    			0, 1, 2,
    			0, 2, 3
    		] );

    		// buffers

    		vertexBuffer     = gl.createBuffer();
    		elementBuffer    = gl.createBuffer();

    		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
    		gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );

    		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
    		gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );

    		// textures

    		tempTexture      = gl.createTexture();
    		occlusionTexture = gl.createTexture();

    		state.bindTexture( gl.TEXTURE_2D, tempTexture );
    		gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );
    		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
    		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
    		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
    		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

    		state.bindTexture( gl.TEXTURE_2D, occlusionTexture );
    		gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );
    		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
    		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
    		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
    		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

    		shader = {

    			vertexShader: [

    				"uniform lowp int renderType;",

    				"uniform vec3 screenPosition;",
    				"uniform vec2 scale;",
    				"uniform float rotation;",

    				"uniform sampler2D occlusionMap;",

    				"attribute vec2 position;",
    				"attribute vec2 uv;",

    				"varying vec2 vUV;",
    				"varying float vVisibility;",

    				"void main() {",

    					"vUV = uv;",

    					"vec2 pos = position;",

    					"if ( renderType == 2 ) {",

    						"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );",
    						"visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );",
    						"visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );",
    						"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );",
    						"visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );",
    						"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );",
    						"visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );",
    						"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );",
    						"visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );",

    						"vVisibility =        visibility.r / 9.0;",
    						"vVisibility *= 1.0 - visibility.g / 9.0;",
    						"vVisibility *=       visibility.b / 9.0;",
    						"vVisibility *= 1.0 - visibility.a / 9.0;",

    						"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
    						"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",

    					"}",

    					"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",

    				"}"

    			].join( "\n" ),

    			fragmentShader: [

    				"uniform lowp int renderType;",

    				"uniform sampler2D map;",
    				"uniform float opacity;",
    				"uniform vec3 color;",

    				"varying vec2 vUV;",
    				"varying float vVisibility;",

    				"void main() {",

    					// pink square

    					"if ( renderType == 0 ) {",

    						"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );",

    					// restore

    					"} else if ( renderType == 1 ) {",

    						"gl_FragColor = texture2D( map, vUV );",

    					// flare

    					"} else {",

    						"vec4 texture = texture2D( map, vUV );",
    						"texture.a *= opacity * vVisibility;",
    						"gl_FragColor = texture;",
    						"gl_FragColor.rgb *= color;",

    					"}",

    				"}"

    			].join( "\n" )

    		};

    		program = createProgram( shader );

    		attributes = {
    			vertex: gl.getAttribLocation ( program, "position" ),
    			uv:     gl.getAttribLocation ( program, "uv" )
    		};

    		uniforms = {
    			renderType:     gl.getUniformLocation( program, "renderType" ),
    			map:            gl.getUniformLocation( program, "map" ),
    			occlusionMap:   gl.getUniformLocation( program, "occlusionMap" ),
    			opacity:        gl.getUniformLocation( program, "opacity" ),
    			color:          gl.getUniformLocation( program, "color" ),
    			scale:          gl.getUniformLocation( program, "scale" ),
    			rotation:       gl.getUniformLocation( program, "rotation" ),
    			screenPosition: gl.getUniformLocation( program, "screenPosition" )
    		};

    	}

    	/*
    	 * Render lens flares
    	 * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,
    	 *         reads these back and calculates occlusion.
    	 */

    	this.render = function ( scene, camera, viewport ) {

    		if ( flares.length === 0 ) return;

    		var tempPosition = new Vector3();

    		var invAspect = viewport.w / viewport.z,
    			halfViewportWidth = viewport.z * 0.5,
    			halfViewportHeight = viewport.w * 0.5;

    		var size = 16 / viewport.w,
    			scale = new Vector2( size * invAspect, size );

    		var screenPosition = new Vector3( 1, 1, 0 ),
    			screenPositionPixels = new Vector2( 1, 1 );

    		var validArea = new Box2();

    		validArea.min.set( 0, 0 );
    		validArea.max.set( viewport.z - 16, viewport.w - 16 );

    		if ( program === undefined ) {

    			init();

    		}

    		gl.useProgram( program );

    		state.initAttributes();
    		state.enableAttribute( attributes.vertex );
    		state.enableAttribute( attributes.uv );
    		state.disableUnusedAttributes();

    		// loop through all lens flares to update their occlusion and positions
    		// setup gl and common used attribs/uniforms

    		gl.uniform1i( uniforms.occlusionMap, 0 );
    		gl.uniform1i( uniforms.map, 1 );

    		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
    		gl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );
    		gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );

    		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

    		state.disable( gl.CULL_FACE );
    		state.setDepthWrite( false );

    		for ( var i = 0, l = flares.length; i < l; i ++ ) {

    			size = 16 / viewport.w;
    			scale.set( size * invAspect, size );

    			// calc object screen position

    			var flare = flares[ i ];

    			tempPosition.set( flare.matrixWorld.elements[ 12 ], flare.matrixWorld.elements[ 13 ], flare.matrixWorld.elements[ 14 ] );

    			tempPosition.applyMatrix4( camera.matrixWorldInverse );
    			tempPosition.applyProjection( camera.projectionMatrix );

    			// setup arrays for gl programs

    			screenPosition.copy( tempPosition );

    			// horizontal and vertical coordinate of the lower left corner of the pixels to copy

    			screenPositionPixels.x = viewport.x + ( screenPosition.x * halfViewportWidth ) + halfViewportWidth - 8;
    			screenPositionPixels.y = viewport.y + ( screenPosition.y * halfViewportHeight ) + halfViewportHeight - 8;

    			// screen cull

    			if ( validArea.containsPoint( screenPositionPixels ) === true ) {

    				// save current RGB to temp texture

    				state.activeTexture( gl.TEXTURE0 );
    				state.bindTexture( gl.TEXTURE_2D, null );
    				state.activeTexture( gl.TEXTURE1 );
    				state.bindTexture( gl.TEXTURE_2D, tempTexture );
    				gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );


    				// render pink quad

    				gl.uniform1i( uniforms.renderType, 0 );
    				gl.uniform2f( uniforms.scale, scale.x, scale.y );
    				gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );

    				state.disable( gl.BLEND );
    				state.enable( gl.DEPTH_TEST );

    				gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );


    				// copy result to occlusionMap

    				state.activeTexture( gl.TEXTURE0 );
    				state.bindTexture( gl.TEXTURE_2D, occlusionTexture );
    				gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );


    				// restore graphics

    				gl.uniform1i( uniforms.renderType, 1 );
    				state.disable( gl.DEPTH_TEST );

    				state.activeTexture( gl.TEXTURE1 );
    				state.bindTexture( gl.TEXTURE_2D, tempTexture );
    				gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );


    				// update object positions

    				flare.positionScreen.copy( screenPosition );

    				if ( flare.customUpdateCallback ) {

    					flare.customUpdateCallback( flare );

    				} else {

    					flare.updateLensFlares();

    				}

    				// render flares

    				gl.uniform1i( uniforms.renderType, 2 );
    				state.enable( gl.BLEND );

    				for ( var j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {

    					var sprite = flare.lensFlares[ j ];

    					if ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {

    						screenPosition.x = sprite.x;
    						screenPosition.y = sprite.y;
    						screenPosition.z = sprite.z;

    						size = sprite.size * sprite.scale / viewport.w;

    						scale.x = size * invAspect;
    						scale.y = size;

    						gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );
    						gl.uniform2f( uniforms.scale, scale.x, scale.y );
    						gl.uniform1f( uniforms.rotation, sprite.rotation );

    						gl.uniform1f( uniforms.opacity, sprite.opacity );
    						gl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );

    						state.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );
    						renderer.setTexture2D( sprite.texture, 1 );

    						gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

    					}

    				}

    			}

    		}

    		// restore gl

    		state.enable( gl.CULL_FACE );
    		state.enable( gl.DEPTH_TEST );
    		state.setDepthWrite( true );

    		renderer.resetGLState();

    	};

    	function createProgram( shader ) {

    		var program = gl.createProgram();

    		var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );
    		var vertexShader = gl.createShader( gl.VERTEX_SHADER );

    		var prefix = "precision " + renderer.getPrecision() + " float;\n";

    		gl.shaderSource( fragmentShader, prefix + shader.fragmentShader );
    		gl.shaderSource( vertexShader, prefix + shader.vertexShader );

    		gl.compileShader( fragmentShader );
    		gl.compileShader( vertexShader );

    		gl.attachShader( program, fragmentShader );
    		gl.attachShader( program, vertexShader );

    		gl.linkProgram( program );

    		return program;

    	}

    }

    /**
     * @author mikael emtinger / http://gomo.se/
     * @author alteredq / http://alteredqualia.com/
     */

    function SpritePlugin( renderer, sprites ) {

    	var gl = renderer.context;
    	var state = renderer.state;

    	var vertexBuffer, elementBuffer;
    	var program, attributes, uniforms;

    	var texture;

    	// decompose matrixWorld

    	var spritePosition = new Vector3();
    	var spriteRotation = new Quaternion();
    	var spriteScale = new Vector3();

    	function init() {

    		var vertices = new Float32Array( [
    			- 0.5, - 0.5,  0, 0,
    			  0.5, - 0.5,  1, 0,
    			  0.5,   0.5,  1, 1,
    			- 0.5,   0.5,  0, 1
    		] );

    		var faces = new Uint16Array( [
    			0, 1, 2,
    			0, 2, 3
    		] );

    		vertexBuffer  = gl.createBuffer();
    		elementBuffer = gl.createBuffer();

    		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
    		gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );

    		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
    		gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );

    		program = createProgram();

    		attributes = {
    			position:			gl.getAttribLocation ( program, 'position' ),
    			uv:					gl.getAttribLocation ( program, 'uv' )
    		};

    		uniforms = {
    			uvOffset:			gl.getUniformLocation( program, 'uvOffset' ),
    			uvScale:			gl.getUniformLocation( program, 'uvScale' ),

    			rotation:			gl.getUniformLocation( program, 'rotation' ),
    			scale:				gl.getUniformLocation( program, 'scale' ),

    			color:				gl.getUniformLocation( program, 'color' ),
    			map:				gl.getUniformLocation( program, 'map' ),
    			opacity:			gl.getUniformLocation( program, 'opacity' ),

    			modelViewMatrix: 	gl.getUniformLocation( program, 'modelViewMatrix' ),
    			projectionMatrix:	gl.getUniformLocation( program, 'projectionMatrix' ),

    			fogType:			gl.getUniformLocation( program, 'fogType' ),
    			fogDensity:			gl.getUniformLocation( program, 'fogDensity' ),
    			fogNear:			gl.getUniformLocation( program, 'fogNear' ),
    			fogFar:				gl.getUniformLocation( program, 'fogFar' ),
    			fogColor:			gl.getUniformLocation( program, 'fogColor' ),

    			alphaTest:			gl.getUniformLocation( program, 'alphaTest' )
    		};

    		var canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
    		canvas.width = 8;
    		canvas.height = 8;

    		var context = canvas.getContext( '2d' );
    		context.fillStyle = 'white';
    		context.fillRect( 0, 0, 8, 8 );

    		texture = new Texture( canvas );
    		texture.needsUpdate = true;

    	}

    	this.render = function ( scene, camera ) {

    		if ( sprites.length === 0 ) return;

    		// setup gl

    		if ( program === undefined ) {

    			init();

    		}

    		gl.useProgram( program );

    		state.initAttributes();
    		state.enableAttribute( attributes.position );
    		state.enableAttribute( attributes.uv );
    		state.disableUnusedAttributes();

    		state.disable( gl.CULL_FACE );
    		state.enable( gl.BLEND );

    		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
    		gl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );
    		gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );

    		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

    		gl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );

    		state.activeTexture( gl.TEXTURE0 );
    		gl.uniform1i( uniforms.map, 0 );

    		var oldFogType = 0;
    		var sceneFogType = 0;
    		var fog = scene.fog;

    		if ( fog ) {

    			gl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );

    			if ( (fog && fog.isFog) ) {

    				gl.uniform1f( uniforms.fogNear, fog.near );
    				gl.uniform1f( uniforms.fogFar, fog.far );

    				gl.uniform1i( uniforms.fogType, 1 );
    				oldFogType = 1;
    				sceneFogType = 1;

    			} else if ( (fog && fog.isFogExp2) ) {

    				gl.uniform1f( uniforms.fogDensity, fog.density );

    				gl.uniform1i( uniforms.fogType, 2 );
    				oldFogType = 2;
    				sceneFogType = 2;

    			}

    		} else {

    			gl.uniform1i( uniforms.fogType, 0 );
    			oldFogType = 0;
    			sceneFogType = 0;

    		}


    		// update positions and sort

    		for ( var i = 0, l = sprites.length; i < l; i ++ ) {

    			var sprite = sprites[ i ];

    			sprite.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );
    			sprite.z = - sprite.modelViewMatrix.elements[ 14 ];

    		}

    		sprites.sort( painterSortStable );

    		// render all sprites

    		var scale = [];

    		for ( var i = 0, l = sprites.length; i < l; i ++ ) {

    			var sprite = sprites[ i ];
    			var material = sprite.material;

    			if ( material.visible === false ) continue;

    			gl.uniform1f( uniforms.alphaTest, material.alphaTest );
    			gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements );

    			sprite.matrixWorld.decompose( spritePosition, spriteRotation, spriteScale );

    			scale[ 0 ] = spriteScale.x;
    			scale[ 1 ] = spriteScale.y;

    			var fogType = 0;

    			if ( scene.fog && material.fog ) {

    				fogType = sceneFogType;

    			}

    			if ( oldFogType !== fogType ) {

    				gl.uniform1i( uniforms.fogType, fogType );
    				oldFogType = fogType;

    			}

    			if ( material.map !== null ) {

    				gl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );
    				gl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );

    			} else {

    				gl.uniform2f( uniforms.uvOffset, 0, 0 );
    				gl.uniform2f( uniforms.uvScale, 1, 1 );

    			}

    			gl.uniform1f( uniforms.opacity, material.opacity );
    			gl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );

    			gl.uniform1f( uniforms.rotation, material.rotation );
    			gl.uniform2fv( uniforms.scale, scale );

    			state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );
    			state.setDepthTest( material.depthTest );
    			state.setDepthWrite( material.depthWrite );

    			if ( material.map ) {

    				renderer.setTexture2D( material.map, 0 );

    			} else {

    				renderer.setTexture2D( texture, 0 );

    			}

    			gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

    		}

    		// restore gl

    		state.enable( gl.CULL_FACE );

    		renderer.resetGLState();

    	};

    	function createProgram() {

    		var program = gl.createProgram();

    		var vertexShader = gl.createShader( gl.VERTEX_SHADER );
    		var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );

    		gl.shaderSource( vertexShader, [

    			'precision ' + renderer.getPrecision() + ' float;',

    			'uniform mat4 modelViewMatrix;',
    			'uniform mat4 projectionMatrix;',
    			'uniform float rotation;',
    			'uniform vec2 scale;',
    			'uniform vec2 uvOffset;',
    			'uniform vec2 uvScale;',

    			'attribute vec2 position;',
    			'attribute vec2 uv;',

    			'varying vec2 vUV;',

    			'void main() {',

    				'vUV = uvOffset + uv * uvScale;',

    				'vec2 alignedPosition = position * scale;',

    				'vec2 rotatedPosition;',
    				'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',
    				'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',

    				'vec4 finalPosition;',

    				'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',
    				'finalPosition.xy += rotatedPosition;',
    				'finalPosition = projectionMatrix * finalPosition;',

    				'gl_Position = finalPosition;',

    			'}'

    		].join( '\n' ) );

    		gl.shaderSource( fragmentShader, [

    			'precision ' + renderer.getPrecision() + ' float;',

    			'uniform vec3 color;',
    			'uniform sampler2D map;',
    			'uniform float opacity;',

    			'uniform int fogType;',
    			'uniform vec3 fogColor;',
    			'uniform float fogDensity;',
    			'uniform float fogNear;',
    			'uniform float fogFar;',
    			'uniform float alphaTest;',

    			'varying vec2 vUV;',

    			'void main() {',

    				'vec4 texture = texture2D( map, vUV );',

    				'if ( texture.a < alphaTest ) discard;',

    				'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',

    				'if ( fogType > 0 ) {',

    					'float depth = gl_FragCoord.z / gl_FragCoord.w;',
    					'float fogFactor = 0.0;',

    					'if ( fogType == 1 ) {',

    						'fogFactor = smoothstep( fogNear, fogFar, depth );',

    					'} else {',

    						'const float LOG2 = 1.442695;',
    						'fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',
    						'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',

    					'}',

    					'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',

    				'}',

    			'}'

    		].join( '\n' ) );

    		gl.compileShader( vertexShader );
    		gl.compileShader( fragmentShader );

    		gl.attachShader( program, vertexShader );
    		gl.attachShader( program, fragmentShader );

    		gl.linkProgram( program );

    		return program;

    	}

    	function painterSortStable( a, b ) {

    		if ( a.renderOrder !== b.renderOrder ) {

    			return a.renderOrder - b.renderOrder;

    		} else if ( a.z !== b.z ) {

    			return b.z - a.z;

    		} else {

    			return b.id - a.id;

    		}

    	}

    }

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     */

    function Material() {

    	Object.defineProperty( this, 'id', { value: MaterialIdCount() } );

    	this.uuid = exports.Math.generateUUID();

    	this.name = '';
    	this.type = 'Material';

    	this.fog = true;
    	this.lights = true;

    	this.blending = NormalBlending;
    	this.side = FrontSide;
    	this.shading = SmoothShading; // THREE.FlatShading, THREE.SmoothShading
    	this.vertexColors = NoColors; // THREE.NoColors, THREE.VertexColors, THREE.FaceColors

    	this.opacity = 1;
    	this.transparent = false;

    	this.blendSrc = SrcAlphaFactor;
    	this.blendDst = OneMinusSrcAlphaFactor;
    	this.blendEquation = AddEquation;
    	this.blendSrcAlpha = null;
    	this.blendDstAlpha = null;
    	this.blendEquationAlpha = null;

    	this.depthFunc = LessEqualDepth;
    	this.depthTest = true;
    	this.depthWrite = true;

    	this.clippingPlanes = null;
    	this.clipShadows = false;

    	this.colorWrite = true;

    	this.precision = null; // override the renderer's default precision for this material

    	this.polygonOffset = false;
    	this.polygonOffsetFactor = 0;
    	this.polygonOffsetUnits = 0;

    	this.alphaTest = 0;
    	this.premultipliedAlpha = false;

    	this.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer

    	this.visible = true;

    	this._needsUpdate = true;

    }

    Material.prototype = {

    	constructor: Material,

    	isMaterial: true,

    	get needsUpdate() {

    		return this._needsUpdate;

    	},

    	set needsUpdate( value ) {

    		if ( value === true ) this.update();
    		this._needsUpdate = value;

    	},

    	setValues: function ( values ) {

    		if ( values === undefined ) return;

    		for ( var key in values ) {

    			var newValue = values[ key ];

    			if ( newValue === undefined ) {

    				console.warn( "THREE.Material: '" + key + "' parameter is undefined." );
    				continue;

    			}

    			var currentValue = this[ key ];

    			if ( currentValue === undefined ) {

    				console.warn( "THREE." + this.type + ": '" + key + "' is not a property of this material." );
    				continue;

    			}

    			if ( (currentValue && currentValue.isColor) ) {

    				currentValue.set( newValue );

    			} else if ( (currentValue && currentValue.isVector3) && (newValue && newValue.isVector3) ) {

    				currentValue.copy( newValue );

    			} else if ( key === 'overdraw' ) {

    				// ensure overdraw is backwards-compatible with legacy boolean type
    				this[ key ] = Number( newValue );

    			} else {

    				this[ key ] = newValue;

    			}

    		}

    	},

    	toJSON: function ( meta ) {

    		var isRoot = meta === undefined;

    		if ( isRoot ) {

    			meta = {
    				textures: {},
    				images: {}
    			};

    		}

    		var data = {
    			metadata: {
    				version: 4.4,
    				type: 'Material',
    				generator: 'Material.toJSON'
    			}
    		};

    		// standard Material serialization
    		data.uuid = this.uuid;
    		data.type = this.type;

    		if ( this.name !== '' ) data.name = this.name;

    		if ( (this.color && this.color.isColor) ) data.color = this.color.getHex();

    		if ( this.roughness !== undefined ) data.roughness = this.roughness;
    		if ( this.metalness !== undefined ) data.metalness = this.metalness;

    		if ( (this.emissive && this.emissive.isColor) ) data.emissive = this.emissive.getHex();
    		if ( (this.specular && this.specular.isColor) ) data.specular = this.specular.getHex();
    		if ( this.shininess !== undefined ) data.shininess = this.shininess;

    		if ( (this.map && this.map.isTexture) ) data.map = this.map.toJSON( meta ).uuid;
    		if ( (this.alphaMap && this.alphaMap.isTexture) ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;
    		if ( (this.lightMap && this.lightMap.isTexture) ) data.lightMap = this.lightMap.toJSON( meta ).uuid;
    		if ( (this.bumpMap && this.bumpMap.isTexture) ) {

    			data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
    			data.bumpScale = this.bumpScale;

    		}
    		if ( (this.normalMap && this.normalMap.isTexture) ) {

    			data.normalMap = this.normalMap.toJSON( meta ).uuid;
    			data.normalScale = this.normalScale.toArray();

    		}
    		if ( (this.displacementMap && this.displacementMap.isTexture) ) {

    			data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
    			data.displacementScale = this.displacementScale;
    			data.displacementBias = this.displacementBias;

    		}
    		if ( (this.roughnessMap && this.roughnessMap.isTexture) ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;
    		if ( (this.metalnessMap && this.metalnessMap.isTexture) ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;

    		if ( (this.emissiveMap && this.emissiveMap.isTexture) ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;
    		if ( (this.specularMap && this.specularMap.isTexture) ) data.specularMap = this.specularMap.toJSON( meta ).uuid;

    		if ( (this.envMap && this.envMap.isTexture) ) {

    			data.envMap = this.envMap.toJSON( meta ).uuid;
    			data.reflectivity = this.reflectivity; // Scale behind envMap

    		}

    		if ( this.size !== undefined ) data.size = this.size;
    		if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;

    		if ( this.blending !== NormalBlending ) data.blending = this.blending;
    		if ( this.shading !== SmoothShading ) data.shading = this.shading;
    		if ( this.side !== FrontSide ) data.side = this.side;
    		if ( this.vertexColors !== NoColors ) data.vertexColors = this.vertexColors;

    		if ( this.opacity < 1 ) data.opacity = this.opacity;
    		if ( this.transparent === true ) data.transparent = this.transparent;

    		data.depthFunc = this.depthFunc;
    		data.depthTest = this.depthTest;
    		data.depthWrite = this.depthWrite;

    		if ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;
    		if ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;
    		if ( this.wireframe === true ) data.wireframe = this.wireframe;
    		if ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;
    		if ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;
    		if ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;

    		data.skinning = this.skinning;
    		data.morphTargets = this.morphTargets;

    		// TODO: Copied from Object3D.toJSON

    		function extractFromCache( cache ) {

    			var values = [];

    			for ( var key in cache ) {

    				var data = cache[ key ];
    				delete data.metadata;
    				values.push( data );

    			}

    			return values;

    		}

    		if ( isRoot ) {

    			var textures = extractFromCache( meta.textures );
    			var images = extractFromCache( meta.images );

    			if ( textures.length > 0 ) data.textures = textures;
    			if ( images.length > 0 ) data.images = images;

    		}

    		return data;

    	},

    	clone: function () {

    		return new this.constructor().copy( this );

    	},

    	copy: function ( source ) {

    		this.name = source.name;

    		this.fog = source.fog;
    		this.lights = source.lights;

    		this.blending = source.blending;
    		this.side = source.side;
    		this.shading = source.shading;
    		this.vertexColors = source.vertexColors;

    		this.opacity = source.opacity;
    		this.transparent = source.transparent;

    		this.blendSrc = source.blendSrc;
    		this.blendDst = source.blendDst;
    		this.blendEquation = source.blendEquation;
    		this.blendSrcAlpha = source.blendSrcAlpha;
    		this.blendDstAlpha = source.blendDstAlpha;
    		this.blendEquationAlpha = source.blendEquationAlpha;

    		this.depthFunc = source.depthFunc;
    		this.depthTest = source.depthTest;
    		this.depthWrite = source.depthWrite;

    		this.colorWrite = source.colorWrite;

    		this.precision = source.precision;

    		this.polygonOffset = source.polygonOffset;
    		this.polygonOffsetFactor = source.polygonOffsetFactor;
    		this.polygonOffsetUnits = source.polygonOffsetUnits;

    		this.alphaTest = source.alphaTest;

    		this.premultipliedAlpha = source.premultipliedAlpha;

    		this.overdraw = source.overdraw;

    		this.visible = source.visible;
    		this.clipShadows = source.clipShadows;

    		var srcPlanes = source.clippingPlanes,
    			dstPlanes = null;

    		if ( srcPlanes !== null ) {

    			var n = srcPlanes.length;
    			dstPlanes = new Array( n );

    			for ( var i = 0; i !== n; ++ i )
    				dstPlanes[ i ] = srcPlanes[ i ].clone();

    		}

    		this.clippingPlanes = dstPlanes;

    		return this;

    	},

    	update: function () {

    		this.dispatchEvent( { type: 'update' } );

    	},

    	dispose: function () {

    		this.dispatchEvent( { type: 'dispose' } );

    	}

    };

    Object.assign( Material.prototype, EventDispatcher.prototype );

    var count$1 = 0;
    function MaterialIdCount() { return count$1++; };

    /**
     * @author alteredq / http://alteredqualia.com/
     *
     * parameters = {
     *  defines: { "label" : "value" },
     *  uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
     *
     *  fragmentShader: <string>,
     *  vertexShader: <string>,
     *
     *  wireframe: <boolean>,
     *  wireframeLinewidth: <float>,
     *
     *  lights: <bool>,
     *
     *  skinning: <bool>,
     *  morphTargets: <bool>,
     *  morphNormals: <bool>
     * }
     */

    function ShaderMaterial( parameters ) {

    	Material.call( this );

    	this.type = 'ShaderMaterial';

    	this.defines = {};
    	this.uniforms = {};

    	this.vertexShader = 'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}';
    	this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}';

    	this.linewidth = 1;

    	this.wireframe = false;
    	this.wireframeLinewidth = 1;

    	this.fog = false; // set to use scene fog
    	this.lights = false; // set to use scene lights
    	this.clipping = false; // set to use user-defined clipping planes

    	this.skinning = false; // set to use skinning attribute streams
    	this.morphTargets = false; // set to use morph targets
    	this.morphNormals = false; // set to use morph normals

    	this.extensions = {
    		derivatives: false, // set to use derivatives
    		fragDepth: false, // set to use fragment depth values
    		drawBuffers: false, // set to use draw buffers
    		shaderTextureLOD: false // set to use shader texture LOD
    	};

    	// When rendered geometry doesn't include these attributes but the material does,
    	// use these default values in WebGL. This avoids errors when buffer data is missing.
    	this.defaultAttributeValues = {
    		'color': [ 1, 1, 1 ],
    		'uv': [ 0, 0 ],
    		'uv2': [ 0, 0 ]
    	};

    	this.index0AttributeName = undefined;

    	if ( parameters !== undefined ) {

    		if ( parameters.attributes !== undefined ) {

    			console.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );

    		}

    		this.setValues( parameters );

    	}

    }

    ShaderMaterial.prototype = Object.create( Material.prototype );
    ShaderMaterial.prototype.constructor = ShaderMaterial;

    ShaderMaterial.prototype.isShaderMaterial = true;

    ShaderMaterial.prototype.copy = function ( source ) {

    	Material.prototype.copy.call( this, source );

    	this.fragmentShader = source.fragmentShader;
    	this.vertexShader = source.vertexShader;

    	this.uniforms = exports.UniformsUtils.clone( source.uniforms );

    	this.defines = source.defines;

    	this.wireframe = source.wireframe;
    	this.wireframeLinewidth = source.wireframeLinewidth;

    	this.lights = source.lights;
    	this.clipping = source.clipping;

    	this.skinning = source.skinning;

    	this.morphTargets = source.morphTargets;
    	this.morphNormals = source.morphNormals;

    	this.extensions = source.extensions;

    	return this;

    };

    ShaderMaterial.prototype.toJSON = function ( meta ) {

    	var data = Material.prototype.toJSON.call( this, meta );

    	data.uniforms = this.uniforms;
    	data.vertexShader = this.vertexShader;
    	data.fragmentShader = this.fragmentShader;

    	return data;

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     * @author bhouston / https://clara.io
     * @author WestLangley / http://github.com/WestLangley
     *
     * parameters = {
     *
     *  opacity: <float>,
     *
     *  map: new THREE.Texture( <Image> ),
     *
     *  alphaMap: new THREE.Texture( <Image> ),
     *
     *  displacementMap: new THREE.Texture( <Image> ),
     *  displacementScale: <float>,
     *  displacementBias: <float>,
     *
     *  wireframe: <boolean>,
     *  wireframeLinewidth: <float>
     * }
     */

    function MeshDepthMaterial( parameters ) {

    	Material.call( this );

    	this.type = 'MeshDepthMaterial';

    	this.depthPacking = BasicDepthPacking;

    	this.skinning = false;
    	this.morphTargets = false;

    	this.map = null;

    	this.alphaMap = null;

    	this.displacementMap = null;
    	this.displacementScale = 1;
    	this.displacementBias = 0;

    	this.wireframe = false;
    	this.wireframeLinewidth = 1;

    	this.fog = false;
    	this.lights = false;

    	this.setValues( parameters );

    }

    MeshDepthMaterial.prototype = Object.create( Material.prototype );
    MeshDepthMaterial.prototype.constructor = MeshDepthMaterial;

    MeshDepthMaterial.prototype.isMeshDepthMaterial = true;

    MeshDepthMaterial.prototype.copy = function ( source ) {

    	Material.prototype.copy.call( this, source );

    	this.depthPacking = source.depthPacking;

    	this.skinning = source.skinning;
    	this.morphTargets = source.morphTargets;

    	this.map = source.map;

    	this.alphaMap = source.alphaMap;

    	this.displacementMap = source.displacementMap;
    	this.displacementScale = source.displacementScale;
    	this.displacementBias = source.displacementBias;

    	this.wireframe = source.wireframe;
    	this.wireframeLinewidth = source.wireframeLinewidth;

    	return this;

    };

    /**
     * @author bhouston / http://clara.io
     * @author WestLangley / http://github.com/WestLangley
     */

    function Box3( min, max ) {

    	this.min = ( min !== undefined ) ? min : new Vector3( + Infinity, + Infinity, + Infinity );
    	this.max = ( max !== undefined ) ? max : new Vector3( - Infinity, - Infinity, - Infinity );

    }

    Box3.prototype = {

    	constructor: Box3,

    	isBox3: true,

    	set: function ( min, max ) {

    		this.min.copy( min );
    		this.max.copy( max );

    		return this;

    	},

    	setFromArray: function ( array ) {

    		var minX = + Infinity;
    		var minY = + Infinity;
    		var minZ = + Infinity;

    		var maxX = - Infinity;
    		var maxY = - Infinity;
    		var maxZ = - Infinity;

    		for ( var i = 0, l = array.length; i < l; i += 3 ) {

    			var x = array[ i ];
    			var y = array[ i + 1 ];
    			var z = array[ i + 2 ];

    			if ( x < minX ) minX = x;
    			if ( y < minY ) minY = y;
    			if ( z < minZ ) minZ = z;

    			if ( x > maxX ) maxX = x;
    			if ( y > maxY ) maxY = y;
    			if ( z > maxZ ) maxZ = z;

    		}

    		this.min.set( minX, minY, minZ );
    		this.max.set( maxX, maxY, maxZ );

    	},

    	setFromPoints: function ( points ) {

    		this.makeEmpty();

    		for ( var i = 0, il = points.length; i < il; i ++ ) {

    			this.expandByPoint( points[ i ] );

    		}

    		return this;

    	},

    	setFromCenterAndSize: function () {

    		var v1 = new Vector3();

    		return function setFromCenterAndSize( center, size ) {

    			var halfSize = v1.copy( size ).multiplyScalar( 0.5 );

    			this.min.copy( center ).sub( halfSize );
    			this.max.copy( center ).add( halfSize );

    			return this;

    		};

    	}(),

    	setFromObject: function () {

    		// Computes the world-axis-aligned bounding box of an object (including its children),
    		// accounting for both the object's, and children's, world transforms

    		var v1 = new Vector3();

    		return function setFromObject( object ) {

    			var scope = this;

    			object.updateMatrixWorld( true );

    			this.makeEmpty();

    			object.traverse( function ( node ) {

    				var geometry = node.geometry;

    				if ( geometry !== undefined ) {

    					if ( (geometry && geometry.isGeometry) ) {

    						var vertices = geometry.vertices;

    						for ( var i = 0, il = vertices.length; i < il; i ++ ) {

    							v1.copy( vertices[ i ] );
    							v1.applyMatrix4( node.matrixWorld );

    							scope.expandByPoint( v1 );

    						}

    					} else if ( (geometry && geometry.isBufferGeometry) ) {

    						var attribute = geometry.attributes.position;

    						if ( attribute !== undefined ) {

    							var array, offset, stride;

    							if ( (attribute && attribute.isInterleavedBufferAttribute) ) {

    								array = attribute.data.array;
    								offset = attribute.offset;
    								stride = attribute.data.stride;

    							} else {

    								array = attribute.array;
    								offset = 0;
    								stride = 3;

    							}

    							for ( var i = offset, il = array.length; i < il; i += stride ) {

    								v1.fromArray( array, i );
    								v1.applyMatrix4( node.matrixWorld );

    								scope.expandByPoint( v1 );

    							}

    						}

    					}

    				}

    			} );

    			return this;

    		};

    	}(),

    	clone: function () {

    		return new this.constructor().copy( this );

    	},

    	copy: function ( box ) {

    		this.min.copy( box.min );
    		this.max.copy( box.max );

    		return this;

    	},

    	makeEmpty: function () {

    		this.min.x = this.min.y = this.min.z = + Infinity;
    		this.max.x = this.max.y = this.max.z = - Infinity;

    		return this;

    	},

    	isEmpty: function () {

    		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

    		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

    	},

    	getCenter: function ( optionalTarget ) {

    		var result = optionalTarget || new Vector3();
    		return this.isEmpty() ? result.set( 0, 0, 0 ) : result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

    	},

    	getSize: function ( optionalTarget ) {

    		var result = optionalTarget || new Vector3();
    		return this.isEmpty() ? result.set( 0, 0, 0 ) : result.subVectors( this.max, this.min );

    	},

    	expandByPoint: function ( point ) {

    		this.min.min( point );
    		this.max.max( point );

    		return this;

    	},

    	expandByVector: function ( vector ) {

    		this.min.sub( vector );
    		this.max.add( vector );

    		return this;

    	},

    	expandByScalar: function ( scalar ) {

    		this.min.addScalar( - scalar );
    		this.max.addScalar( scalar );

    		return this;

    	},

    	containsPoint: function ( point ) {

    		if ( point.x < this.min.x || point.x > this.max.x ||
    				 point.y < this.min.y || point.y > this.max.y ||
    				 point.z < this.min.z || point.z > this.max.z ) {

    			return false;

    		}

    		return true;

    	},

    	containsBox: function ( box ) {

    		if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
    			 ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) &&
    			 ( this.min.z <= box.min.z ) && ( box.max.z <= this.max.z ) ) {

    			return true;

    		}

    		return false;

    	},

    	getParameter: function ( point, optionalTarget ) {

    		// This can potentially have a divide by zero if the box
    		// has a size dimension of 0.

    		var result = optionalTarget || new Vector3();

    		return result.set(
    			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
    			( point.y - this.min.y ) / ( this.max.y - this.min.y ),
    			( point.z - this.min.z ) / ( this.max.z - this.min.z )
    		);

    	},

    	intersectsBox: function ( box ) {

    		// using 6 splitting planes to rule out intersections.

    		if ( box.max.x < this.min.x || box.min.x > this.max.x ||
    				 box.max.y < this.min.y || box.min.y > this.max.y ||
    				 box.max.z < this.min.z || box.min.z > this.max.z ) {

    			return false;

    		}

    		return true;

    	},

    	intersectsSphere: ( function () {

    		var closestPoint;

    		return function intersectsSphere( sphere ) {

    			if ( closestPoint === undefined ) closestPoint = new Vector3();

    			// Find the point on the AABB closest to the sphere center.
    			this.clampPoint( sphere.center, closestPoint );

    			// If that point is inside the sphere, the AABB and sphere intersect.
    			return closestPoint.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );

    		};

    	} )(),

    	intersectsPlane: function ( plane ) {

    		// We compute the minimum and maximum dot product values. If those values
    		// are on the same side (back or front) of the plane, then there is no intersection.

    		var min, max;

    		if ( plane.normal.x > 0 ) {

    			min = plane.normal.x * this.min.x;
    			max = plane.normal.x * this.max.x;

    		} else {

    			min = plane.normal.x * this.max.x;
    			max = plane.normal.x * this.min.x;

    		}

    		if ( plane.normal.y > 0 ) {

    			min += plane.normal.y * this.min.y;
    			max += plane.normal.y * this.max.y;

    		} else {

    			min += plane.normal.y * this.max.y;
    			max += plane.normal.y * this.min.y;

    		}

    		if ( plane.normal.z > 0 ) {

    			min += plane.normal.z * this.min.z;
    			max += plane.normal.z * this.max.z;

    		} else {

    			min += plane.normal.z * this.max.z;
    			max += plane.normal.z * this.min.z;

    		}

    		return ( min <= plane.constant && max >= plane.constant );

    	},

    	clampPoint: function ( point, optionalTarget ) {

    		var result = optionalTarget || new Vector3();
    		return result.copy( point ).clamp( this.min, this.max );

    	},

    	distanceToPoint: function () {

    		var v1 = new Vector3();

    		return function distanceToPoint( point ) {

    			var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
    			return clampedPoint.sub( point ).length();

    		};

    	}(),

    	getBoundingSphere: function () {

    		var v1 = new Vector3();

    		return function getBoundingSphere( optionalTarget ) {

    			var result = optionalTarget || new Sphere();

    			this.getCenter( result.center );

    			result.radius = this.size( v1 ).length() * 0.5;

    			return result;

    		};

    	}(),

    	intersect: function ( box ) {

    		this.min.max( box.min );
    		this.max.min( box.max );

    		// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
    		if( this.isEmpty() ) this.makeEmpty();

    		return this;

    	},

    	union: function ( box ) {

    		this.min.min( box.min );
    		this.max.max( box.max );

    		return this;

    	},

    	applyMatrix4: function () {

    		var points = [
    			new Vector3(),
    			new Vector3(),
    			new Vector3(),
    			new Vector3(),
    			new Vector3(),
    			new Vector3(),
    			new Vector3(),
    			new Vector3()
    		];

    		return function applyMatrix4( matrix ) {

    			// transform of empty box is an empty box.
    			if( this.isEmpty() ) return this;

    			// NOTE: I am using a binary pattern to specify all 2^3 combinations below
    			points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
    			points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
    			points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
    			points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
    			points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
    			points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
    			points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
    			points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );	// 111

    			this.setFromPoints( points );

    			return this;

    		};

    	}(),

    	translate: function ( offset ) {

    		this.min.add( offset );
    		this.max.add( offset );

    		return this;

    	},

    	equals: function ( box ) {

    		return box.min.equals( this.min ) && box.max.equals( this.max );

    	}

    };

    /**
     * @author bhouston / http://clara.io
     * @author mrdoob / http://mrdoob.com/
     */

    function Sphere( center, radius ) {

    	this.center = ( center !== undefined ) ? center : new Vector3();
    	this.radius = ( radius !== undefined ) ? radius : 0;

    }

    Sphere.prototype = {

    	constructor: Sphere,

    	set: function ( center, radius ) {

    		this.center.copy( center );
    		this.radius = radius;

    		return this;

    	},

    	setFromPoints: function () {

    		var box = new Box3();

    		return function setFromPoints( points, optionalCenter ) {

    			var center = this.center;

    			if ( optionalCenter !== undefined ) {

    				center.copy( optionalCenter );

    			} else {

    				box.setFromPoints( points ).getCenter( center );

    			}

    			var maxRadiusSq = 0;

    			for ( var i = 0, il = points.length; i < il; i ++ ) {

    				maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

    			}

    			this.radius = Math.sqrt( maxRadiusSq );

    			return this;

    		};

    	}(),

    	clone: function () {

    		return new this.constructor().copy( this );

    	},

    	copy: function ( sphere ) {

    		this.center.copy( sphere.center );
    		this.radius = sphere.radius;

    		return this;

    	},

    	empty: function () {

    		return ( this.radius <= 0 );

    	},

    	containsPoint: function ( point ) {

    		return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

    	},

    	distanceToPoint: function ( point ) {

    		return ( point.distanceTo( this.center ) - this.radius );

    	},

    	intersectsSphere: function ( sphere ) {

    		var radiusSum = this.radius + sphere.radius;

    		return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

    	},

    	intersectsBox: function ( box ) {

    		return box.intersectsSphere( this );

    	},

    	intersectsPlane: function ( plane ) {

    		// We use the following equation to compute the signed distance from
    		// the center of the sphere to the plane.
    		//
    		// distance = q * n - d
    		//
    		// If this distance is greater than the radius of the sphere,
    		// then there is no intersection.

    		return Math.abs( this.center.dot( plane.normal ) - plane.constant ) <= this.radius;

    	},

    	clampPoint: function ( point, optionalTarget ) {

    		var deltaLengthSq = this.center.distanceToSquared( point );

    		var result = optionalTarget || new Vector3();

    		result.copy( point );

    		if ( deltaLengthSq > ( this.radius * this.radius ) ) {

    			result.sub( this.center ).normalize();
    			result.multiplyScalar( this.radius ).add( this.center );

    		}

    		return result;

    	},

    	getBoundingBox: function ( optionalTarget ) {

    		var box = optionalTarget || new Box3();

    		box.set( this.center, this.center );
    		box.expandByScalar( this.radius );

    		return box;

    	},

    	applyMatrix4: function ( matrix ) {

    		this.center.applyMatrix4( matrix );
    		this.radius = this.radius * matrix.getMaxScaleOnAxis();

    		return this;

    	},

    	translate: function ( offset ) {

    		this.center.add( offset );

    		return this;

    	},

    	equals: function ( sphere ) {

    		return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

    	}

    };

    /**
     * @author alteredq / http://alteredqualia.com/
     * @author WestLangley / http://github.com/WestLangley
     * @author bhouston / http://clara.io
     * @author tschw
     */

    function Matrix3() {

    	this.elements = new Float32Array( [

    		1, 0, 0,
    		0, 1, 0,
    		0, 0, 1

    	] );

    	if ( arguments.length > 0 ) {

    		console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );

    	}

    }

    Matrix3.prototype = {

    	constructor: Matrix3,

    	isMatrix3: true,

    	set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

    		var te = this.elements;

    		te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;
    		te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;
    		te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;

    		return this;

    	},

    	identity: function () {

    		this.set(

    			1, 0, 0,
    			0, 1, 0,
    			0, 0, 1

    		);

    		return this;

    	},

    	clone: function () {

    		return new this.constructor().fromArray( this.elements );

    	},

    	copy: function ( m ) {

    		var me = m.elements;

    		this.set(

    			me[ 0 ], me[ 3 ], me[ 6 ],
    			me[ 1 ], me[ 4 ], me[ 7 ],
    			me[ 2 ], me[ 5 ], me[ 8 ]

    		);

    		return this;

    	},

    	setFromMatrix4: function( m ) {

    		var me = m.elements;

    		this.set(

    			me[ 0 ], me[ 4 ], me[  8 ],
    			me[ 1 ], me[ 5 ], me[  9 ],
    			me[ 2 ], me[ 6 ], me[ 10 ]

    		);

    		return this;

    	},

    	applyToVector3Array: function () {

    		var v1;

    		return function applyToVector3Array( array, offset, length ) {

    			if ( v1 === undefined ) v1 = new Vector3();
    			if ( offset === undefined ) offset = 0;
    			if ( length === undefined ) length = array.length;

    			for ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {

    				v1.fromArray( array, j );
    				v1.applyMatrix3( this );
    				v1.toArray( array, j );

    			}

    			return array;

    		};

    	}(),

    	applyToBuffer: function () {

    		var v1;

    		return function applyToBuffer( buffer, offset, length ) {

    			if ( v1 === undefined ) v1 = new Vector3();
    			if ( offset === undefined ) offset = 0;
    			if ( length === undefined ) length = buffer.length / buffer.itemSize;

    			for ( var i = 0, j = offset; i < length; i ++, j ++ ) {

    				v1.x = buffer.getX( j );
    				v1.y = buffer.getY( j );
    				v1.z = buffer.getZ( j );

    				v1.applyMatrix3( this );

    				buffer.setXYZ( v1.x, v1.y, v1.z );

    			}

    			return buffer;

    		};

    	}(),

    	multiplyScalar: function ( s ) {

    		var te = this.elements;

    		te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
    		te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
    		te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

    		return this;

    	},

    	determinant: function () {

    		var te = this.elements;

    		var a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
    			d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
    			g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

    		return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

    	},

    	getInverse: function ( matrix, throwOnDegenerate ) {

    		if ( (matrix && matrix.isMatrix4) ) {

    			console.error( "THREE.Matrix3.getInverse no longer takes a Matrix4 argument." );

    		}

    		var me = matrix.elements,
    			te = this.elements,

    			n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],
    			n12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],
    			n13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],

    			t11 = n33 * n22 - n32 * n23,
    			t12 = n32 * n13 - n33 * n12,
    			t13 = n23 * n12 - n22 * n13,

    			det = n11 * t11 + n21 * t12 + n31 * t13;

    		if ( det === 0 ) {

    			var msg = "THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0";

    			if ( throwOnDegenerate === true ) {

    				throw new Error( msg );

    			} else {

    				console.warn( msg );

    			}

    			return this.identity();
    		}

    		var detInv = 1 / det;

    		te[ 0 ] = t11 * detInv;
    		te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;
    		te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;

    		te[ 3 ] = t12 * detInv;
    		te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;
    		te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;

    		te[ 6 ] = t13 * detInv;
    		te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;
    		te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;

    		return this;

    	},

    	transpose: function () {

    		var tmp, m = this.elements;

    		tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
    		tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
    		tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

    		return this;

    	},

    	flattenToArrayOffset: function ( array, offset ) {

    		console.warn( "THREE.Matrix3: .flattenToArrayOffset is deprecated " +
    				"- just use .toArray instead." );

    		return this.toArray( array, offset );

    	},

    	getNormalMatrix: function ( matrix4 ) {

    		return this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();

    	},

    	transposeIntoArray: function ( r ) {

    		var m = this.elements;

    		r[ 0 ] = m[ 0 ];
    		r[ 1 ] = m[ 3 ];
    		r[ 2 ] = m[ 6 ];
    		r[ 3 ] = m[ 1 ];
    		r[ 4 ] = m[ 4 ];
    		r[ 5 ] = m[ 7 ];
    		r[ 6 ] = m[ 2 ];
    		r[ 7 ] = m[ 5 ];
    		r[ 8 ] = m[ 8 ];

    		return this;

    	},

    	fromArray: function ( array, offset ) {

    		if ( offset === undefined ) offset = 0;

    		for( var i = 0; i < 9; i ++ ) {

    			this.elements[ i ] = array[ i + offset ];

    		}

    		return this;

    	},

    	toArray: function ( array, offset ) {

    		if ( array === undefined ) array = [];
    		if ( offset === undefined ) offset = 0;

    		var te = this.elements;

    		array[ offset ] = te[ 0 ];
    		array[ offset + 1 ] = te[ 1 ];
    		array[ offset + 2 ] = te[ 2 ];

    		array[ offset + 3 ] = te[ 3 ];
    		array[ offset + 4 ] = te[ 4 ];
    		array[ offset + 5 ] = te[ 5 ];

    		array[ offset + 6 ] = te[ 6 ];
    		array[ offset + 7 ] = te[ 7 ];
    		array[ offset + 8 ]  = te[ 8 ];

    		return array;

    	}

    };

    /**
     * @author bhouston / http://clara.io
     */

    function Plane( normal, constant ) {

    	this.normal = ( normal !== undefined ) ? normal : new Vector3( 1, 0, 0 );
    	this.constant = ( constant !== undefined ) ? constant : 0;

    }

    Plane.prototype = {

    	constructor: Plane,

    	set: function ( normal, constant ) {

    		this.normal.copy( normal );
    		this.constant = constant;

    		return this;

    	},

    	setComponents: function ( x, y, z, w ) {

    		this.normal.set( x, y, z );
    		this.constant = w;

    		return this;

    	},

    	setFromNormalAndCoplanarPoint: function ( normal, point ) {

    		this.normal.copy( normal );
    		this.constant = - point.dot( this.normal );	// must be this.normal, not normal, as this.normal is normalized

    		return this;

    	},

    	setFromCoplanarPoints: function () {

    		var v1 = new Vector3();
    		var v2 = new Vector3();

    		return function setFromCoplanarPoints( a, b, c ) {

    			var normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();

    			// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

    			this.setFromNormalAndCoplanarPoint( normal, a );

    			return this;

    		};

    	}(),

    	clone: function () {

    		return new this.constructor().copy( this );

    	},

    	copy: function ( plane ) {

    		this.normal.copy( plane.normal );
    		this.constant = plane.constant;

    		return this;

    	},

    	normalize: function () {

    		// Note: will lead to a divide by zero if the plane is invalid.

    		var inverseNormalLength = 1.0 / this.normal.length();
    		this.normal.multiplyScalar( inverseNormalLength );
    		this.constant *= inverseNormalLength;

    		return this;

    	},

    	negate: function () {

    		this.constant *= - 1;
    		this.normal.negate();

    		return this;

    	},

    	distanceToPoint: function ( point ) {

    		return this.normal.dot( point ) + this.constant;

    	},

    	distanceToSphere: function ( sphere ) {

    		return this.distanceToPoint( sphere.center ) - sphere.radius;

    	},

    	projectPoint: function ( point, optionalTarget ) {

    		return this.orthoPoint( point, optionalTarget ).sub( point ).negate();

    	},

    	orthoPoint: function ( point, optionalTarget ) {

    		var perpendicularMagnitude = this.distanceToPoint( point );

    		var result = optionalTarget || new Vector3();
    		return result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );

    	},

    	intersectLine: function () {

    		var v1 = new Vector3();

    		return function intersectLine( line, optionalTarget ) {

    			var result = optionalTarget || new Vector3();

    			var direction = line.delta( v1 );

    			var denominator = this.normal.dot( direction );

    			if ( denominator === 0 ) {

    				// line is coplanar, return origin
    				if ( this.distanceToPoint( line.start ) === 0 ) {

    					return result.copy( line.start );

    				}

    				// Unsure if this is the correct method to handle this case.
    				return undefined;

    			}

    			var t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

    			if ( t < 0 || t > 1 ) {

    				return undefined;

    			}

    			return result.copy( direction ).multiplyScalar( t ).add( line.start );

    		};

    	}(),

    	intersectsLine: function ( line ) {

    		// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

    		var startSign = this.distanceToPoint( line.start );
    		var endSign = this.distanceToPoint( line.end );

    		return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

    	},

    	intersectsBox: function ( box ) {

    		return box.intersectsPlane( this );

    	},

    	intersectsSphere: function ( sphere ) {

    		return sphere.intersectsPlane( this );

    	},

    	coplanarPoint: function ( optionalTarget ) {

    		var result = optionalTarget || new Vector3();
    		return result.copy( this.normal ).multiplyScalar( - this.constant );

    	},

    	applyMatrix4: function () {

    		var v1 = new Vector3();
    		var m1 = new Matrix3();

    		return function applyMatrix4( matrix, optionalNormalMatrix ) {

    			var referencePoint = this.coplanarPoint( v1 ).applyMatrix4( matrix );

    			// transform normal based on theory here:
    			// http://www.songho.ca/opengl/gl_normaltransform.html
    			var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );
    			var normal = this.normal.applyMatrix3( normalMatrix ).normalize();

    			// recalculate constant (like in setFromNormalAndCoplanarPoint)
    			this.constant = - referencePoint.dot( normal );

    			return this;

    		};

    	}(),

    	translate: function ( offset ) {

    		this.constant = this.constant - offset.dot( this.normal );

    		return this;

    	},

    	equals: function ( plane ) {

    		return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );

    	}

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     * @author bhouston / http://clara.io
     */

    function Frustum( p0, p1, p2, p3, p4, p5 ) {

    	this.planes = [

    		( p0 !== undefined ) ? p0 : new Plane(),
    		( p1 !== undefined ) ? p1 : new Plane(),
    		( p2 !== undefined ) ? p2 : new Plane(),
    		( p3 !== undefined ) ? p3 : new Plane(),
    		( p4 !== undefined ) ? p4 : new Plane(),
    		( p5 !== undefined ) ? p5 : new Plane()

    	];

    }

    Frustum.prototype = {

    	constructor: Frustum,

    	set: function ( p0, p1, p2, p3, p4, p5 ) {

    		var planes = this.planes;

    		planes[ 0 ].copy( p0 );
    		planes[ 1 ].copy( p1 );
    		planes[ 2 ].copy( p2 );
    		planes[ 3 ].copy( p3 );
    		planes[ 4 ].copy( p4 );
    		planes[ 5 ].copy( p5 );

    		return this;

    	},

    	clone: function () {

    		return new this.constructor().copy( this );

    	},

    	copy: function ( frustum ) {

    		var planes = this.planes;

    		for ( var i = 0; i < 6; i ++ ) {

    			planes[ i ].copy( frustum.planes[ i ] );

    		}

    		return this;

    	},

    	setFromMatrix: function ( m ) {

    		var planes = this.planes;
    		var me = m.elements;
    		var me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
    		var me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
    		var me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
    		var me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];

    		planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
    		planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
    		planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
    		planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
    		planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
    		planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

    		return this;

    	},

    	intersectsObject: function () {

    		var sphere = new Sphere();

    		return function intersectsObject( object ) {

    			var geometry = object.geometry;

    			if ( geometry.boundingSphere === null )
    				geometry.computeBoundingSphere();

    			sphere.copy( geometry.boundingSphere )
    				.applyMatrix4( object.matrixWorld );

    			return this.intersectsSphere( sphere );

    		};

    	}(),

    	intersectsSprite: function () {

    		var sphere = new Sphere();

    		return function intersectsSprite( sprite ) {

    			sphere.center.set( 0, 0, 0 );
    			sphere.radius = 0.7071067811865476;
    			sphere.applyMatrix4( sprite.matrixWorld );

    			return this.intersectsSphere( sphere );

    		};

    	}(),

    	intersectsSphere: function ( sphere ) {

    		var planes = this.planes;
    		var center = sphere.center;
    		var negRadius = - sphere.radius;

    		for ( var i = 0; i < 6; i ++ ) {

    			var distance = planes[ i ].distanceToPoint( center );

    			if ( distance < negRadius ) {

    				return false;

    			}

    		}

    		return true;

    	},

    	intersectsBox: function () {

    		var p1 = new Vector3(),
    			p2 = new Vector3();

    		return function intersectsBox( box ) {

    			var planes = this.planes;

    			for ( var i = 0; i < 6 ; i ++ ) {

    				var plane = planes[ i ];

    				p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
    				p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
    				p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
    				p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
    				p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
    				p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;

    				var d1 = plane.distanceToPoint( p1 );
    				var d2 = plane.distanceToPoint( p2 );

    				// if both outside plane, no intersection

    				if ( d1 < 0 && d2 < 0 ) {

    					return false;

    				}

    			}

    			return true;

    		};

    	}(),


    	containsPoint: function ( point ) {

    		var planes = this.planes;

    		for ( var i = 0; i < 6; i ++ ) {

    			if ( planes[ i ].distanceToPoint( point ) < 0 ) {

    				return false;

    			}

    		}

    		return true;

    	}

    };

    function WebGLShadowMap( _renderer, _lights, _objects, capabilities ) {

    	var _gl = _renderer.context,
    	_state = _renderer.state,
    	_frustum = new Frustum(),
    	_projScreenMatrix = new Matrix4(),

    	_lightShadows = _lights.shadows,

    	_shadowMapSize = new Vector2(),
    	_maxShadowMapSize = new Vector2( capabilities.maxTextureSize, capabilities.maxTextureSize ),

    	_lookTarget = new Vector3(),
    	_lightPositionWorld = new Vector3(),

    	_renderList = [],

    	_MorphingFlag = 1,
    	_SkinningFlag = 2,

    	_NumberOfMaterialVariants = ( _MorphingFlag | _SkinningFlag ) + 1,

    	_depthMaterials = new Array( _NumberOfMaterialVariants ),
    	_distanceMaterials = new Array( _NumberOfMaterialVariants ),

    	_materialCache = {};

    	var cubeDirections = [
    		new Vector3( 1, 0, 0 ), new Vector3( - 1, 0, 0 ), new Vector3( 0, 0, 1 ),
    		new Vector3( 0, 0, - 1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, - 1, 0 )
    	];

    	var cubeUps = [
    		new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),
    		new Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ),	new Vector3( 0, 0, - 1 )
    	];

    	var cube2DViewPorts = [
    		new Vector4(), new Vector4(), new Vector4(),
    		new Vector4(), new Vector4(), new Vector4()
    	];

    	// init

    	var depthMaterialTemplate = new MeshDepthMaterial();
    	depthMaterialTemplate.depthPacking = RGBADepthPacking;
    	depthMaterialTemplate.clipping = true;

    	var distanceShader = ShaderLib[ "distanceRGBA" ];
    	var distanceUniforms = exports.UniformsUtils.clone( distanceShader.uniforms );

    	for ( var i = 0; i !== _NumberOfMaterialVariants; ++ i ) {

    		var useMorphing = ( i & _MorphingFlag ) !== 0;
    		var useSkinning = ( i & _SkinningFlag ) !== 0;

    		var depthMaterial = depthMaterialTemplate.clone();
    		depthMaterial.morphTargets = useMorphing;
    		depthMaterial.skinning = useSkinning;

    		_depthMaterials[ i ] = depthMaterial;

    		var distanceMaterial = new ShaderMaterial( {
    			defines: {
    				'USE_SHADOWMAP': ''
    			},
    			uniforms: distanceUniforms,
    			vertexShader: distanceShader.vertexShader,
    			fragmentShader: distanceShader.fragmentShader,
    			morphTargets: useMorphing,
    			skinning: useSkinning,
    			clipping: true
    		} );

    		_distanceMaterials[ i ] = distanceMaterial;

    	}

    	//

    	var scope = this;

    	this.enabled = false;

    	this.autoUpdate = true;
    	this.needsUpdate = false;

    	this.type = PCFShadowMap;

    	this.renderReverseSided = true;
    	this.renderSingleSided = true;

    	this.render = function ( scene, camera ) {

    		if ( scope.enabled === false ) return;
    		if ( scope.autoUpdate === false && scope.needsUpdate === false ) return;

    		if ( _lightShadows.length === 0 ) return;

    		// Set GL state for depth map.
    		_state.clearColor( 1, 1, 1, 1 );
    		_state.disable( _gl.BLEND );
    		_state.setDepthTest( true );
    		_state.setScissorTest( false );

    		// render depth map

    		var faceCount, isPointLight;

    		for ( var i = 0, il = _lightShadows.length; i < il; i ++ ) {

    			var light = _lightShadows[ i ];
    			var shadow = light.shadow;

    			if ( shadow === undefined ) {

    				console.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );
    				continue;

    			}

    			var shadowCamera = shadow.camera;

    			_shadowMapSize.copy( shadow.mapSize );
    			_shadowMapSize.min( _maxShadowMapSize );

    			if ( (light && light.isPointLight) ) {

    				faceCount = 6;
    				isPointLight = true;

    				var vpWidth = _shadowMapSize.x;
    				var vpHeight = _shadowMapSize.y;

    				// These viewports map a cube-map onto a 2D texture with the
    				// following orientation:
    				//
    				//  xzXZ
    				//   y Y
    				//
    				// X - Positive x direction
    				// x - Negative x direction
    				// Y - Positive y direction
    				// y - Negative y direction
    				// Z - Positive z direction
    				// z - Negative z direction

    				// positive X
    				cube2DViewPorts[ 0 ].set( vpWidth * 2, vpHeight, vpWidth, vpHeight );
    				// negative X
    				cube2DViewPorts[ 1 ].set( 0, vpHeight, vpWidth, vpHeight );
    				// positive Z
    				cube2DViewPorts[ 2 ].set( vpWidth * 3, vpHeight, vpWidth, vpHeight );
    				// negative Z
    				cube2DViewPorts[ 3 ].set( vpWidth, vpHeight, vpWidth, vpHeight );
    				// positive Y
    				cube2DViewPorts[ 4 ].set( vpWidth * 3, 0, vpWidth, vpHeight );
    				// negative Y
    				cube2DViewPorts[ 5 ].set( vpWidth, 0, vpWidth, vpHeight );

    				_shadowMapSize.x *= 4.0;
    				_shadowMapSize.y *= 2.0;

    			} else {

    				faceCount = 1;
    				isPointLight = false;

    			}

    			if ( shadow.map === null ) {

    				var pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };

    				shadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );

    				shadowCamera.updateProjectionMatrix();

    			}

    			if ( (shadow && shadow.isSpotLightShadow) ) {

    				shadow.update( light );

    			}

    			var shadowMap = shadow.map;
    			var shadowMatrix = shadow.matrix;

    			_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );
    			shadowCamera.position.copy( _lightPositionWorld );

    			_renderer.setRenderTarget( shadowMap );
    			_renderer.clear();

    			// render shadow map for each cube face (if omni-directional) or
    			// run a single pass if not

    			for ( var face = 0; face < faceCount; face ++ ) {

    				if ( isPointLight ) {

    					_lookTarget.copy( shadowCamera.position );
    					_lookTarget.add( cubeDirections[ face ] );
    					shadowCamera.up.copy( cubeUps[ face ] );
    					shadowCamera.lookAt( _lookTarget );

    					var vpDimensions = cube2DViewPorts[ face ];
    					_state.viewport( vpDimensions );

    				} else {

    					_lookTarget.setFromMatrixPosition( light.target.matrixWorld );
    					shadowCamera.lookAt( _lookTarget );

    				}

    				shadowCamera.updateMatrixWorld();
    				shadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );

    				// compute shadow matrix

    				shadowMatrix.set(
    					0.5, 0.0, 0.0, 0.5,
    					0.0, 0.5, 0.0, 0.5,
    					0.0, 0.0, 0.5, 0.5,
    					0.0, 0.0, 0.0, 1.0
    				);

    				shadowMatrix.multiply( shadowCamera.projectionMatrix );
    				shadowMatrix.multiply( shadowCamera.matrixWorldInverse );

    				// update camera matrices and frustum

    				_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
    				_frustum.setFromMatrix( _projScreenMatrix );

    				// set object matrices & frustum culling

    				_renderList.length = 0;

    				projectObject( scene, camera, shadowCamera );

    				// render shadow map
    				// render regular objects

    				for ( var j = 0, jl = _renderList.length; j < jl; j ++ ) {

    					var object = _renderList[ j ];
    					var geometry = _objects.update( object );
    					var material = object.material;

    					if ( (material && material.isMultiMaterial) ) {

    						var groups = geometry.groups;
    						var materials = material.materials;

    						for ( var k = 0, kl = groups.length; k < kl; k ++ ) {

    							var group = groups[ k ];
    							var groupMaterial = materials[ group.materialIndex ];

    							if ( groupMaterial.visible === true ) {

    								var depthMaterial = getDepthMaterial( object, groupMaterial, isPointLight, _lightPositionWorld );
    								_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );

    							}

    						}

    					} else {

    						var depthMaterial = getDepthMaterial( object, material, isPointLight, _lightPositionWorld );
    						_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );

    					}

    				}

    			}

    		}

    		// Restore GL state.
    		var clearColor = _renderer.getClearColor(),
    		clearAlpha = _renderer.getClearAlpha();
    		_renderer.setClearColor( clearColor, clearAlpha );

    		scope.needsUpdate = false;

    	};

    	function getDepthMaterial( object, material, isPointLight, lightPositionWorld ) {

    		var geometry = object.geometry;

    		var result = null;

    		var materialVariants = _depthMaterials;
    		var customMaterial = object.customDepthMaterial;

    		if ( isPointLight ) {

    			materialVariants = _distanceMaterials;
    			customMaterial = object.customDistanceMaterial;

    		}

    		if ( ! customMaterial ) {

    			var useMorphing = false;

    			if ( material.morphTargets ) {

    				if ( (geometry && geometry.isBufferGeometry) ) {

    					useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;

    				} else if ( (geometry && geometry.isGeometry) ) {

    					useMorphing = geometry.morphTargets && geometry.morphTargets.length > 0;

    				}

    			}

    			var useSkinning = object.isSkinnedMesh && material.skinning;

    			var variantIndex = 0;

    			if ( useMorphing ) variantIndex |= _MorphingFlag;
    			if ( useSkinning ) variantIndex |= _SkinningFlag;

    			result = materialVariants[ variantIndex ];

    		} else {

    			result = customMaterial;

    		}

    		if ( _renderer.localClippingEnabled &&
    			 material.clipShadows === true &&
    				material.clippingPlanes.length !== 0 ) {

    			// in this case we need a unique material instance reflecting the
    			// appropriate state

    			var keyA = result.uuid, keyB = material.uuid;

    			var materialsForVariant = _materialCache[ keyA ];

    			if ( materialsForVariant === undefined ) {

    				materialsForVariant = {};
    				_materialCache[ keyA ] = materialsForVariant;

    			}

    			var cachedMaterial = materialsForVariant[ keyB ];

    			if ( cachedMaterial === undefined ) {

    				cachedMaterial = result.clone();
    				materialsForVariant[ keyB ] = cachedMaterial;

    			}

    			result = cachedMaterial;

    		}

    		result.visible = material.visible;
    		result.wireframe = material.wireframe;

    		var side = material.side;

    		if ( scope.renderSingleSided && side == DoubleSide ) {

    			side = FrontSide;

    		}

    		if ( scope.renderReverseSided ) {

    			if ( side === FrontSide ) side = BackSide;
    			else if ( side === BackSide ) side = FrontSide;

    		}

    		result.side = side;

    		result.clipShadows = material.clipShadows;
    		result.clippingPlanes = material.clippingPlanes;

    		result.wireframeLinewidth = material.wireframeLinewidth;
    		result.linewidth = material.linewidth;

    		if ( isPointLight && result.uniforms.lightPos !== undefined ) {

    			result.uniforms.lightPos.value.copy( lightPositionWorld );

    		}

    		return result;

    	}

    	function projectObject( object, camera, shadowCamera ) {

    		if ( object.visible === false ) return;

    		var visible = ( object.layers.mask & camera.layers.mask ) !== 0;

    		if ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {

    			if ( object.castShadow && ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) ) {

    				var material = object.material;

    				if ( material.visible === true ) {

    					object.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );
    					_renderList.push( object );

    				}

    			}

    		}

    		var children = object.children;

    		for ( var i = 0, l = children.length; i < l; i ++ ) {

    			projectObject( children[ i ], camera, shadowCamera );

    		}

    	}

    }

    /**
     * @author bhouston / http://clara.io
     */

    function Ray( origin, direction ) {

    	this.origin = ( origin !== undefined ) ? origin : new Vector3();
    	this.direction = ( direction !== undefined ) ? direction : new Vector3();

    }

    Ray.prototype = {

    	constructor: Ray,

    	set: function ( origin, direction ) {

    		this.origin.copy( origin );
    		this.direction.copy( direction );

    		return this;

    	},

    	clone: function () {

    		return new this.constructor().copy( this );

    	},

    	copy: function ( ray ) {

    		this.origin.copy( ray.origin );
    		this.direction.copy( ray.direction );

    		return this;

    	},

    	at: function ( t, optionalTarget ) {

    		var result = optionalTarget || new Vector3();

    		return result.copy( this.direction ).multiplyScalar( t ).add( this.origin );

    	},

    	lookAt: function ( v ) {

    		this.direction.copy( v ).sub( this.origin ).normalize();

    		return this;

    	},

    	recast: function () {

    		var v1 = new Vector3();

    		return function recast( t ) {

    			this.origin.copy( this.at( t, v1 ) );

    			return this;

    		};

    	}(),

    	closestPointToPoint: function ( point, optionalTarget ) {

    		var result = optionalTarget || new Vector3();
    		result.subVectors( point, this.origin );
    		var directionDistance = result.dot( this.direction );

    		if ( directionDistance < 0 ) {

    			return result.copy( this.origin );

    		}

    		return result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

    	},

    	distanceToPoint: function ( point ) {

    		return Math.sqrt( this.distanceSqToPoint( point ) );

    	},

    	distanceSqToPoint: function () {

    		var v1 = new Vector3();

    		return function distanceSqToPoint( point ) {

    			var directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );

    			// point behind the ray

    			if ( directionDistance < 0 ) {

    				return this.origin.distanceToSquared( point );

    			}

    			v1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

    			return v1.distanceToSquared( point );

    		};

    	}(),

    	distanceSqToSegment: function () {

    		var segCenter = new Vector3();
    		var segDir = new Vector3();
    		var diff = new Vector3();

    		return function distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

    			// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
    			// It returns the min distance between the ray and the segment
    			// defined by v0 and v1
    			// It can also set two optional targets :
    			// - The closest point on the ray
    			// - The closest point on the segment

    			segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
    			segDir.copy( v1 ).sub( v0 ).normalize();
    			diff.copy( this.origin ).sub( segCenter );

    			var segExtent = v0.distanceTo( v1 ) * 0.5;
    			var a01 = - this.direction.dot( segDir );
    			var b0 = diff.dot( this.direction );
    			var b1 = - diff.dot( segDir );
    			var c = diff.lengthSq();
    			var det = Math.abs( 1 - a01 * a01 );
    			var s0, s1, sqrDist, extDet;

    			if ( det > 0 ) {

    				// The ray and segment are not parallel.

    				s0 = a01 * b1 - b0;
    				s1 = a01 * b0 - b1;
    				extDet = segExtent * det;

    				if ( s0 >= 0 ) {

    					if ( s1 >= - extDet ) {

    						if ( s1 <= extDet ) {

    							// region 0
    							// Minimum at interior points of ray and segment.

    							var invDet = 1 / det;
    							s0 *= invDet;
    							s1 *= invDet;
    							sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

    						} else {

    							// region 1

    							s1 = segExtent;
    							s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
    							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

    						}

    					} else {

    						// region 5

    						s1 = - segExtent;
    						s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
    						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

    					}

    				} else {

    					if ( s1 <= - extDet ) {

    						// region 4

    						s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
    						s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
    						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

    					} else if ( s1 <= extDet ) {

    						// region 3

    						s0 = 0;
    						s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
    						sqrDist = s1 * ( s1 + 2 * b1 ) + c;

    					} else {

    						// region 2

    						s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
    						s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
    						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

    					}

    				}

    			} else {

    				// Ray and segment are parallel.

    				s1 = ( a01 > 0 ) ? - segExtent : segExtent;
    				s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
    				sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

    			}

    			if ( optionalPointOnRay ) {

    				optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );

    			}

    			if ( optionalPointOnSegment ) {

    				optionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );

    			}

    			return sqrDist;

    		};

    	}(),

    	intersectSphere: function () {

    		var v1 = new Vector3();

    		return function intersectSphere( sphere, optionalTarget ) {

    			v1.subVectors( sphere.center, this.origin );
    			var tca = v1.dot( this.direction );
    			var d2 = v1.dot( v1 ) - tca * tca;
    			var radius2 = sphere.radius * sphere.radius;

    			if ( d2 > radius2 ) return null;

    			var thc = Math.sqrt( radius2 - d2 );

    			// t0 = first intersect point - entrance on front of sphere
    			var t0 = tca - thc;

    			// t1 = second intersect point - exit point on back of sphere
    			var t1 = tca + thc;

    			// test to see if both t0 and t1 are behind the ray - if so, return null
    			if ( t0 < 0 && t1 < 0 ) return null;

    			// test to see if t0 is behind the ray:
    			// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
    			// in order to always return an intersect point that is in front of the ray.
    			if ( t0 < 0 ) return this.at( t1, optionalTarget );

    			// else t0 is in front of the ray, so return the first collision point scaled by t0
    			return this.at( t0, optionalTarget );

    		};

    	}(),

    	intersectsSphere: function ( sphere ) {

    		return this.distanceToPoint( sphere.center ) <= sphere.radius;

    	},

    	distanceToPlane: function ( plane ) {

    		var denominator = plane.normal.dot( this.direction );

    		if ( denominator === 0 ) {

    			// line is coplanar, return origin
    			if ( plane.distanceToPoint( this.origin ) === 0 ) {

    				return 0;

    			}

    			// Null is preferable to undefined since undefined means.... it is undefined

    			return null;

    		}

    		var t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

    		// Return if the ray never intersects the plane

    		return t >= 0 ? t :  null;

    	},

    	intersectPlane: function ( plane, optionalTarget ) {

    		var t = this.distanceToPlane( plane );

    		if ( t === null ) {

    			return null;

    		}

    		return this.at( t, optionalTarget );

    	},



    	intersectsPlane: function ( plane ) {

    		// check if the ray lies on the plane first

    		var distToPoint = plane.distanceToPoint( this.origin );

    		if ( distToPoint === 0 ) {

    			return true;

    		}

    		var denominator = plane.normal.dot( this.direction );

    		if ( denominator * distToPoint < 0 ) {

    			return true;

    		}

    		// ray origin is behind the plane (and is pointing behind it)

    		return false;

    	},

    	intersectBox: function ( box, optionalTarget ) {

    		var tmin, tmax, tymin, tymax, tzmin, tzmax;

    		var invdirx = 1 / this.direction.x,
    			invdiry = 1 / this.direction.y,
    			invdirz = 1 / this.direction.z;

    		var origin = this.origin;

    		if ( invdirx >= 0 ) {

    			tmin = ( box.min.x - origin.x ) * invdirx;
    			tmax = ( box.max.x - origin.x ) * invdirx;

    		} else {

    			tmin = ( box.max.x - origin.x ) * invdirx;
    			tmax = ( box.min.x - origin.x ) * invdirx;

    		}

    		if ( invdiry >= 0 ) {

    			tymin = ( box.min.y - origin.y ) * invdiry;
    			tymax = ( box.max.y - origin.y ) * invdiry;

    		} else {

    			tymin = ( box.max.y - origin.y ) * invdiry;
    			tymax = ( box.min.y - origin.y ) * invdiry;

    		}

    		if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;

    		// These lines also handle the case where tmin or tmax is NaN
    		// (result of 0 * Infinity). x !== x returns true if x is NaN

    		if ( tymin > tmin || tmin !== tmin ) tmin = tymin;

    		if ( tymax < tmax || tmax !== tmax ) tmax = tymax;

    		if ( invdirz >= 0 ) {

    			tzmin = ( box.min.z - origin.z ) * invdirz;
    			tzmax = ( box.max.z - origin.z ) * invdirz;

    		} else {

    			tzmin = ( box.max.z - origin.z ) * invdirz;
    			tzmax = ( box.min.z - origin.z ) * invdirz;

    		}

    		if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;

    		if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;

    		if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;

    		//return point closest to the ray (positive side)

    		if ( tmax < 0 ) return null;

    		return this.at( tmin >= 0 ? tmin : tmax, optionalTarget );

    	},

    	intersectsBox: ( function () {

    		var v = new Vector3();

    		return function intersectsBox( box ) {

    			return this.intersectBox( box, v ) !== null;

    		};

    	} )(),

    	intersectTriangle: function () {

    		// Compute the offset origin, edges, and normal.
    		var diff = new Vector3();
    		var edge1 = new Vector3();
    		var edge2 = new Vector3();
    		var normal = new Vector3();

    		return function intersectTriangle( a, b, c, backfaceCulling, optionalTarget ) {

    			// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h

    			edge1.subVectors( b, a );
    			edge2.subVectors( c, a );
    			normal.crossVectors( edge1, edge2 );

    			// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
    			// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
    			//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
    			//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
    			//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
    			var DdN = this.direction.dot( normal );
    			var sign;

    			if ( DdN > 0 ) {

    				if ( backfaceCulling ) return null;
    				sign = 1;

    			} else if ( DdN < 0 ) {

    				sign = - 1;
    				DdN = - DdN;

    			} else {

    				return null;

    			}

    			diff.subVectors( this.origin, a );
    			var DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );

    			// b1 < 0, no intersection
    			if ( DdQxE2 < 0 ) {

    				return null;

    			}

    			var DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );

    			// b2 < 0, no intersection
    			if ( DdE1xQ < 0 ) {

    				return null;

    			}

    			// b1+b2 > 1, no intersection
    			if ( DdQxE2 + DdE1xQ > DdN ) {

    				return null;

    			}

    			// Line intersects triangle, check if ray does.
    			var QdN = - sign * diff.dot( normal );

    			// t < 0, no intersection
    			if ( QdN < 0 ) {

    				return null;

    			}

    			// Ray intersects triangle.
    			return this.at( QdN / DdN, optionalTarget );

    		};

    	}(),

    	applyMatrix4: function ( matrix4 ) {

    		this.direction.add( this.origin ).applyMatrix4( matrix4 );
    		this.origin.applyMatrix4( matrix4 );
    		this.direction.sub( this.origin );
    		this.direction.normalize();

    		return this;

    	},

    	equals: function ( ray ) {

    		return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

    	}

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author WestLangley / http://github.com/WestLangley
     * @author bhouston / http://clara.io
     */

    function Euler( x, y, z, order ) {

    	this._x = x || 0;
    	this._y = y || 0;
    	this._z = z || 0;
    	this._order = order || Euler.DefaultOrder;

    }

    Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];

    Euler.DefaultOrder = 'XYZ';

    Euler.prototype = {

    	constructor: Euler,

    	isEuler: true,

    	get x () {

    		return this._x;

    	},

    	set x ( value ) {

    		this._x = value;
    		this.onChangeCallback();

    	},

    	get y () {

    		return this._y;

    	},

    	set y ( value ) {

    		this._y = value;
    		this.onChangeCallback();

    	},

    	get z () {

    		return this._z;

    	},

    	set z ( value ) {

    		this._z = value;
    		this.onChangeCallback();

    	},

    	get order () {

    		return this._order;

    	},

    	set order ( value ) {

    		this._order = value;
    		this.onChangeCallback();

    	},

    	set: function ( x, y, z, order ) {

    		this._x = x;
    		this._y = y;
    		this._z = z;
    		this._order = order || this._order;

    		this.onChangeCallback();

    		return this;

    	},

    	clone: function () {

    		return new this.constructor( this._x, this._y, this._z, this._order );

    	},

    	copy: function ( euler ) {

    		this._x = euler._x;
    		this._y = euler._y;
    		this._z = euler._z;
    		this._order = euler._order;

    		this.onChangeCallback();

    		return this;

    	},

    	setFromRotationMatrix: function ( m, order, update ) {

    		var clamp = exports.Math.clamp;

    		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

    		var te = m.elements;
    		var m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
    		var m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
    		var m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

    		order = order || this._order;

    		if ( order === 'XYZ' ) {

    			this._y = Math.asin( clamp( m13, - 1, 1 ) );

    			if ( Math.abs( m13 ) < 0.99999 ) {

    				this._x = Math.atan2( - m23, m33 );
    				this._z = Math.atan2( - m12, m11 );

    			} else {

    				this._x = Math.atan2( m32, m22 );
    				this._z = 0;

    			}

    		} else if ( order === 'YXZ' ) {

    			this._x = Math.asin( - clamp( m23, - 1, 1 ) );

    			if ( Math.abs( m23 ) < 0.99999 ) {

    				this._y = Math.atan2( m13, m33 );
    				this._z = Math.atan2( m21, m22 );

    			} else {

    				this._y = Math.atan2( - m31, m11 );
    				this._z = 0;

    			}

    		} else if ( order === 'ZXY' ) {

    			this._x = Math.asin( clamp( m32, - 1, 1 ) );

    			if ( Math.abs( m32 ) < 0.99999 ) {

    				this._y = Math.atan2( - m31, m33 );
    				this._z = Math.atan2( - m12, m22 );

    			} else {

    				this._y = 0;
    				this._z = Math.atan2( m21, m11 );

    			}

    		} else if ( order === 'ZYX' ) {

    			this._y = Math.asin( - clamp( m31, - 1, 1 ) );

    			if ( Math.abs( m31 ) < 0.99999 ) {

    				this._x = Math.atan2( m32, m33 );
    				this._z = Math.atan2( m21, m11 );

    			} else {

    				this._x = 0;
    				this._z = Math.atan2( - m12, m22 );

    			}

    		} else if ( order === 'YZX' ) {

    			this._z = Math.asin( clamp( m21, - 1, 1 ) );

    			if ( Math.abs( m21 ) < 0.99999 ) {

    				this._x = Math.atan2( - m23, m22 );
    				this._y = Math.atan2( - m31, m11 );

    			} else {

    				this._x = 0;
    				this._y = Math.atan2( m13, m33 );

    			}

    		} else if ( order === 'XZY' ) {

    			this._z = Math.asin( - clamp( m12, - 1, 1 ) );

    			if ( Math.abs( m12 ) < 0.99999 ) {

    				this._x = Math.atan2( m32, m22 );
    				this._y = Math.atan2( m13, m11 );

    			} else {

    				this._x = Math.atan2( - m23, m33 );
    				this._y = 0;

    			}

    		} else {

    			console.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order );

    		}

    		this._order = order;

    		if ( update !== false ) this.onChangeCallback();

    		return this;

    	},

    	setFromQuaternion: function () {

    		var matrix;

    		return function setFromQuaternion( q, order, update ) {

    			if ( matrix === undefined ) matrix = new Matrix4();

    			matrix.makeRotationFromQuaternion( q );

    			return this.setFromRotationMatrix( matrix, order, update );

    		};

    	}(),

    	setFromVector3: function ( v, order ) {

    		return this.set( v.x, v.y, v.z, order || this._order );

    	},

    	reorder: function () {

    		// WARNING: this discards revolution information -bhouston

    		var q = new Quaternion();

    		return function reorder( newOrder ) {

    			q.setFromEuler( this );

    			return this.setFromQuaternion( q, newOrder );

    		};

    	}(),

    	equals: function ( euler ) {

    		return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

    	},

    	fromArray: function ( array ) {

    		this._x = array[ 0 ];
    		this._y = array[ 1 ];
    		this._z = array[ 2 ];
    		if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

    		this.onChangeCallback();

    		return this;

    	},

    	toArray: function ( array, offset ) {

    		if ( array === undefined ) array = [];
    		if ( offset === undefined ) offset = 0;

    		array[ offset ] = this._x;
    		array[ offset + 1 ] = this._y;
    		array[ offset + 2 ] = this._z;
    		array[ offset + 3 ] = this._order;

    		return array;

    	},

    	toVector3: function ( optionalResult ) {

    		if ( optionalResult ) {

    			return optionalResult.set( this._x, this._y, this._z );

    		} else {

    			return new Vector3( this._x, this._y, this._z );

    		}

    	},

    	onChange: function ( callback ) {

    		this.onChangeCallback = callback;

    		return this;

    	},

    	onChangeCallback: function () {}

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function Layers() {

    	this.mask = 1;

    }

    Layers.prototype = {

    	constructor: Layers,

    	set: function ( channel ) {

    		this.mask = 1 << channel;

    	},

    	enable: function ( channel ) {

    		this.mask |= 1 << channel;

    	},

    	toggle: function ( channel ) {

    		this.mask ^= 1 << channel;

    	},

    	disable: function ( channel ) {

    		this.mask &= ~ ( 1 << channel );

    	},

    	test: function ( layers ) {

    		return ( this.mask & layers.mask ) !== 0;

    	}

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author mikael emtinger / http://gomo.se/
     * @author alteredq / http://alteredqualia.com/
     * @author WestLangley / http://github.com/WestLangley
     * @author elephantatwork / www.elephantatwork.ch
     */

    function Object3D() {

    	Object.defineProperty( this, 'id', { value: Object3DIdCount() } );

    	this.uuid = exports.Math.generateUUID();

    	this.name = '';
    	this.type = 'Object3D';

    	this.parent = null;
    	this.children = [];

    	this.up = Object3D.DefaultUp.clone();

    	var position = new Vector3();
    	var rotation = new Euler();
    	var quaternion = new Quaternion();
    	var scale = new Vector3( 1, 1, 1 );

    	function onRotationChange() {

    		quaternion.setFromEuler( rotation, false );

    	}

    	function onQuaternionChange() {

    		rotation.setFromQuaternion( quaternion, undefined, false );

    	}

    	rotation.onChange( onRotationChange );
    	quaternion.onChange( onQuaternionChange );

    	Object.defineProperties( this, {
    		position: {
    			enumerable: true,
    			value: position
    		},
    		rotation: {
    			enumerable: true,
    			value: rotation
    		},
    		quaternion: {
    			enumerable: true,
    			value: quaternion
    		},
    		scale: {
    			enumerable: true,
    			value: scale
    		},
    		modelViewMatrix: {
    			value: new Matrix4()
    		},
    		normalMatrix: {
    			value: new Matrix3()
    		}
    	} );

    	this.matrix = new Matrix4();
    	this.matrixWorld = new Matrix4();

    	this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
    	this.matrixWorldNeedsUpdate = false;

    	this.layers = new Layers();
    	this.visible = true;

    	this.castShadow = false;
    	this.receiveShadow = false;

    	this.frustumCulled = true;
    	this.renderOrder = 0;

    	this.userData = {};

    	this.onBeforeRender = null;

    }

    Object3D.DefaultUp = new Vector3( 0, 1, 0 );
    Object3D.DefaultMatrixAutoUpdate = true;

    Object.assign( Object3D.prototype, EventDispatcher.prototype, {

    	isObject3D: true,

    	applyMatrix: function ( matrix ) {

    		this.matrix.multiplyMatrices( matrix, this.matrix );

    		this.matrix.decompose( this.position, this.quaternion, this.scale );

    	},

    	setRotationFromAxisAngle: function ( axis, angle ) {

    		// assumes axis is normalized

    		this.quaternion.setFromAxisAngle( axis, angle );

    	},

    	setRotationFromEuler: function ( euler ) {

    		this.quaternion.setFromEuler( euler, true );

    	},

    	setRotationFromMatrix: function ( m ) {

    		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

    		this.quaternion.setFromRotationMatrix( m );

    	},

    	setRotationFromQuaternion: function ( q ) {

    		// assumes q is normalized

    		this.quaternion.copy( q );

    	},

    	rotateOnAxis: function () {

    		// rotate object on axis in object space
    		// axis is assumed to be normalized

    		var q1 = new Quaternion();

    		return function rotateOnAxis( axis, angle ) {

    			q1.setFromAxisAngle( axis, angle );

    			this.quaternion.multiply( q1 );

    			return this;

    		};

    	}(),

    	rotateX: function () {

    		var v1 = new Vector3( 1, 0, 0 );

    		return function rotateX( angle ) {

    			return this.rotateOnAxis( v1, angle );

    		};

    	}(),

    	rotateY: function () {

    		var v1 = new Vector3( 0, 1, 0 );

    		return function rotateY( angle ) {

    			return this.rotateOnAxis( v1, angle );

    		};

    	}(),

    	rotateZ: function () {

    		var v1 = new Vector3( 0, 0, 1 );

    		return function rotateZ( angle ) {

    			return this.rotateOnAxis( v1, angle );

    		};

    	}(),

    	translateOnAxis: function () {

    		// translate object by distance along axis in object space
    		// axis is assumed to be normalized

    		var v1 = new Vector3();

    		return function translateOnAxis( axis, distance ) {

    			v1.copy( axis ).applyQuaternion( this.quaternion );

    			this.position.add( v1.multiplyScalar( distance ) );

    			return this;

    		};

    	}(),

    	translateX: function () {

    		var v1 = new Vector3( 1, 0, 0 );

    		return function translateX( distance ) {

    			return this.translateOnAxis( v1, distance );

    		};

    	}(),

    	translateY: function () {

    		var v1 = new Vector3( 0, 1, 0 );

    		return function translateY( distance ) {

    			return this.translateOnAxis( v1, distance );

    		};

    	}(),

    	translateZ: function () {

    		var v1 = new Vector3( 0, 0, 1 );

    		return function translateZ( distance ) {

    			return this.translateOnAxis( v1, distance );

    		};

    	}(),

    	localToWorld: function ( vector ) {

    		return vector.applyMatrix4( this.matrixWorld );

    	},

    	worldToLocal: function () {

    		var m1 = new Matrix4();

    		return function worldToLocal( vector ) {

    			return vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );

    		};

    	}(),

    	lookAt: function () {

    		// This routine does not support objects with rotated and/or translated parent(s)

    		var m1 = new Matrix4();

    		return function lookAt( vector ) {

    			m1.lookAt( vector, this.position, this.up );

    			this.quaternion.setFromRotationMatrix( m1 );

    		};

    	}(),

    	add: function ( object ) {

    		if ( arguments.length > 1 ) {

    			for ( var i = 0; i < arguments.length; i ++ ) {

    				this.add( arguments[ i ] );

    			}

    			return this;

    		}

    		if ( object === this ) {

    			console.error( "THREE.Object3D.add: object can't be added as a child of itself.", object );
    			return this;

    		}

    		if ( (object && object.isObject3D) ) {

    			if ( object.parent !== null ) {

    				object.parent.remove( object );

    			}

    			object.parent = this;
    			object.dispatchEvent( { type: 'added' } );

    			this.children.push( object );

    		} else {

    			console.error( "THREE.Object3D.add: object not an instance of THREE.Object3D.", object );

    		}

    		return this;

    	},

    	remove: function ( object ) {

    		if ( arguments.length > 1 ) {

    			for ( var i = 0; i < arguments.length; i ++ ) {

    				this.remove( arguments[ i ] );

    			}

    		}

    		var index = this.children.indexOf( object );

    		if ( index !== - 1 ) {

    			object.parent = null;

    			object.dispatchEvent( { type: 'removed' } );

    			this.children.splice( index, 1 );

    		}

    	},

    	getObjectById: function ( id ) {

    		return this.getObjectByProperty( 'id', id );

    	},

    	getObjectByName: function ( name ) {

    		return this.getObjectByProperty( 'name', name );

    	},

    	getObjectByProperty: function ( name, value ) {

    		if ( this[ name ] === value ) return this;

    		for ( var i = 0, l = this.children.length; i < l; i ++ ) {

    			var child = this.children[ i ];
    			var object = child.getObjectByProperty( name, value );

    			if ( object !== undefined ) {

    				return object;

    			}

    		}

    		return undefined;

    	},

    	getWorldPosition: function ( optionalTarget ) {

    		var result = optionalTarget || new Vector3();

    		this.updateMatrixWorld( true );

    		return result.setFromMatrixPosition( this.matrixWorld );

    	},

    	getWorldQuaternion: function () {

    		var position = new Vector3();
    		var scale = new Vector3();

    		return function getWorldQuaternion( optionalTarget ) {

    			var result = optionalTarget || new Quaternion();

    			this.updateMatrixWorld( true );

    			this.matrixWorld.decompose( position, result, scale );

    			return result;

    		};

    	}(),

    	getWorldRotation: function () {

    		var quaternion = new Quaternion();

    		return function getWorldRotation( optionalTarget ) {

    			var result = optionalTarget || new Euler();

    			this.getWorldQuaternion( quaternion );

    			return result.setFromQuaternion( quaternion, this.rotation.order, false );

    		};

    	}(),

    	getWorldScale: function () {

    		var position = new Vector3();
    		var quaternion = new Quaternion();

    		return function getWorldScale( optionalTarget ) {

    			var result = optionalTarget || new Vector3();

    			this.updateMatrixWorld( true );

    			this.matrixWorld.decompose( position, quaternion, result );

    			return result;

    		};

    	}(),

    	getWorldDirection: function () {

    		var quaternion = new Quaternion();

    		return function getWorldDirection( optionalTarget ) {

    			var result = optionalTarget || new Vector3();

    			this.getWorldQuaternion( quaternion );

    			return result.set( 0, 0, 1 ).applyQuaternion( quaternion );

    		};

    	}(),

    	raycast: function () {},

    	traverse: function ( callback ) {

    		callback( this );

    		var children = this.children;

    		for ( var i = 0, l = children.length; i < l; i ++ ) {

    			children[ i ].traverse( callback );

    		}

    	},

    	traverseVisible: function ( callback ) {

    		if ( this.visible === false ) return;

    		callback( this );

    		var children = this.children;

    		for ( var i = 0, l = children.length; i < l; i ++ ) {

    			children[ i ].traverseVisible( callback );

    		}

    	},

    	traverseAncestors: function ( callback ) {

    		var parent = this.parent;

    		if ( parent !== null ) {

    			callback( parent );

    			parent.traverseAncestors( callback );

    		}

    	},

    	updateMatrix: function () {

    		this.matrix.compose( this.position, this.quaternion, this.scale );

    		this.matrixWorldNeedsUpdate = true;

    	},

    	updateMatrixWorld: function ( force ) {

    		if ( this.matrixAutoUpdate === true ) this.updateMatrix();

    		if ( this.matrixWorldNeedsUpdate === true || force === true ) {

    			if ( this.parent === null ) {

    				this.matrixWorld.copy( this.matrix );

    			} else {

    				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

    			}

    			this.matrixWorldNeedsUpdate = false;

    			force = true;

    		}

    		// update children

    		var children = this.children;

    		for ( var i = 0, l = children.length; i < l; i ++ ) {

    			children[ i ].updateMatrixWorld( force );

    		}

    	},

    	toJSON: function ( meta ) {

    		// meta is '' when called from JSON.stringify
    		var isRootObject = ( meta === undefined || meta === '' );

    		var output = {};

    		// meta is a hash used to collect geometries, materials.
    		// not providing it implies that this is the root object
    		// being serialized.
    		if ( isRootObject ) {

    			// initialize meta obj
    			meta = {
    				geometries: {},
    				materials: {},
    				textures: {},
    				images: {}
    			};

    			output.metadata = {
    				version: 4.4,
    				type: 'Object',
    				generator: 'Object3D.toJSON'
    			};

    		}

    		// standard Object3D serialization

    		var object = {};

    		object.uuid = this.uuid;
    		object.type = this.type;

    		if ( this.name !== '' ) object.name = this.name;
    		if ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;
    		if ( this.castShadow === true ) object.castShadow = true;
    		if ( this.receiveShadow === true ) object.receiveShadow = true;
    		if ( this.visible === false ) object.visible = false;

    		object.matrix = this.matrix.toArray();

    		//

    		if ( this.geometry !== undefined ) {

    			if ( meta.geometries[ this.geometry.uuid ] === undefined ) {

    				meta.geometries[ this.geometry.uuid ] = this.geometry.toJSON( meta );

    			}

    			object.geometry = this.geometry.uuid;

    		}

    		if ( this.material !== undefined ) {

    			if ( meta.materials[ this.material.uuid ] === undefined ) {

    				meta.materials[ this.material.uuid ] = this.material.toJSON( meta );

    			}

    			object.material = this.material.uuid;

    		}

    		//

    		if ( this.children.length > 0 ) {

    			object.children = [];

    			for ( var i = 0; i < this.children.length; i ++ ) {

    				object.children.push( this.children[ i ].toJSON( meta ).object );

    			}

    		}

    		if ( isRootObject ) {

    			var geometries = extractFromCache( meta.geometries );
    			var materials = extractFromCache( meta.materials );
    			var textures = extractFromCache( meta.textures );
    			var images = extractFromCache( meta.images );

    			if ( geometries.length > 0 ) output.geometries = geometries;
    			if ( materials.length > 0 ) output.materials = materials;
    			if ( textures.length > 0 ) output.textures = textures;
    			if ( images.length > 0 ) output.images = images;

    		}

    		output.object = object;

    		return output;

    		// extract data from the cache hash
    		// remove metadata on each item
    		// and return as array
    		function extractFromCache( cache ) {

    			var values = [];
    			for ( var key in cache ) {

    				var data = cache[ key ];
    				delete data.metadata;
    				values.push( data );

    			}
    			return values;

    		}

    	},

    	clone: function ( recursive ) {

    		return new this.constructor().copy( this, recursive );

    	},

    	copy: function ( source, recursive ) {

    		if ( recursive === undefined ) recursive = true;

    		this.name = source.name;

    		this.up.copy( source.up );

    		this.position.copy( source.position );
    		this.quaternion.copy( source.quaternion );
    		this.scale.copy( source.scale );

    		this.matrix.copy( source.matrix );
    		this.matrixWorld.copy( source.matrixWorld );

    		this.matrixAutoUpdate = source.matrixAutoUpdate;
    		this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

    		this.visible = source.visible;

    		this.castShadow = source.castShadow;
    		this.receiveShadow = source.receiveShadow;

    		this.frustumCulled = source.frustumCulled;
    		this.renderOrder = source.renderOrder;

    		this.userData = JSON.parse( JSON.stringify( source.userData ) );

    		if ( recursive === true ) {

    			for ( var i = 0; i < source.children.length; i ++ ) {

    				var child = source.children[ i ];
    				this.add( child.clone() );

    			}

    		}

    		return this;

    	}

    } );

    var count$2 = 0;
    function Object3DIdCount() { return count$2++; };

    /**
     * @author bhouston / http://clara.io
     */

    function Line3( start, end ) {

    	this.start = ( start !== undefined ) ? start : new Vector3();
    	this.end = ( end !== undefined ) ? end : new Vector3();

    }

    Line3.prototype = {

    	constructor: Line3,

    	set: function ( start, end ) {

    		this.start.copy( start );
    		this.end.copy( end );

    		return this;

    	},

    	clone: function () {

    		return new this.constructor().copy( this );

    	},

    	copy: function ( line ) {

    		this.start.copy( line.start );
    		this.end.copy( line.end );

    		return this;

    	},

    	getCenter: function ( optionalTarget ) {

    		var result = optionalTarget || new Vector3();
    		return result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );

    	},

    	delta: function ( optionalTarget ) {

    		var result = optionalTarget || new Vector3();
    		return result.subVectors( this.end, this.start );

    	},

    	distanceSq: function () {

    		return this.start.distanceToSquared( this.end );

    	},

    	distance: function () {

    		return this.start.distanceTo( this.end );

    	},

    	at: function ( t, optionalTarget ) {

    		var result = optionalTarget || new Vector3();

    		return this.delta( result ).multiplyScalar( t ).add( this.start );

    	},

    	closestPointToPointParameter: function () {

    		var startP = new Vector3();
    		var startEnd = new Vector3();

    		return function closestPointToPointParameter( point, clampToLine ) {

    			startP.subVectors( point, this.start );
    			startEnd.subVectors( this.end, this.start );

    			var startEnd2 = startEnd.dot( startEnd );
    			var startEnd_startP = startEnd.dot( startP );

    			var t = startEnd_startP / startEnd2;

    			if ( clampToLine ) {

    				t = exports.Math.clamp( t, 0, 1 );

    			}

    			return t;

    		};

    	}(),

    	closestPointToPoint: function ( point, clampToLine, optionalTarget ) {

    		var t = this.closestPointToPointParameter( point, clampToLine );

    		var result = optionalTarget || new Vector3();

    		return this.delta( result ).multiplyScalar( t ).add( this.start );

    	},

    	applyMatrix4: function ( matrix ) {

    		this.start.applyMatrix4( matrix );
    		this.end.applyMatrix4( matrix );

    		return this;

    	},

    	equals: function ( line ) {

    		return line.start.equals( this.start ) && line.end.equals( this.end );

    	}

    };

    /**
     * @author bhouston / http://clara.io
     * @author mrdoob / http://mrdoob.com/
     */

    function Triangle( a, b, c ) {

    	this.a = ( a !== undefined ) ? a : new Vector3();
    	this.b = ( b !== undefined ) ? b : new Vector3();
    	this.c = ( c !== undefined ) ? c : new Vector3();

    }

    Triangle.normal = function () {

    	var v0 = new Vector3();

    	return function normal( a, b, c, optionalTarget ) {

    		var result = optionalTarget || new Vector3();

    		result.subVectors( c, b );
    		v0.subVectors( a, b );
    		result.cross( v0 );

    		var resultLengthSq = result.lengthSq();
    		if ( resultLengthSq > 0 ) {

    			return result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );

    		}

    		return result.set( 0, 0, 0 );

    	};

    }();

    // static/instance method to calculate barycentric coordinates
    // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
    Triangle.barycoordFromPoint = function () {

    	var v0 = new Vector3();
    	var v1 = new Vector3();
    	var v2 = new Vector3();

    	return function barycoordFromPoint( point, a, b, c, optionalTarget ) {

    		v0.subVectors( c, a );
    		v1.subVectors( b, a );
    		v2.subVectors( point, a );

    		var dot00 = v0.dot( v0 );
    		var dot01 = v0.dot( v1 );
    		var dot02 = v0.dot( v2 );
    		var dot11 = v1.dot( v1 );
    		var dot12 = v1.dot( v2 );

    		var denom = ( dot00 * dot11 - dot01 * dot01 );

    		var result = optionalTarget || new Vector3();

    		// collinear or singular triangle
    		if ( denom === 0 ) {

    			// arbitrary location outside of triangle?
    			// not sure if this is the best idea, maybe should be returning undefined
    			return result.set( - 2, - 1, - 1 );

    		}

    		var invDenom = 1 / denom;
    		var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
    		var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

    		// barycentric coordinates must always sum to 1
    		return result.set( 1 - u - v, v, u );

    	};

    }();

    Triangle.containsPoint = function () {

    	var v1 = new Vector3();

    	return function containsPoint( point, a, b, c ) {

    		var result = Triangle.barycoordFromPoint( point, a, b, c, v1 );

    		return ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );

    	};

    }();

    Triangle.prototype = {

    	constructor: Triangle,

    	set: function ( a, b, c ) {

    		this.a.copy( a );
    		this.b.copy( b );
    		this.c.copy( c );

    		return this;

    	},

    	setFromPointsAndIndices: function ( points, i0, i1, i2 ) {

    		this.a.copy( points[ i0 ] );
    		this.b.copy( points[ i1 ] );
    		this.c.copy( points[ i2 ] );

    		return this;

    	},

    	clone: function () {

    		return new this.constructor().copy( this );

    	},

    	copy: function ( triangle ) {

    		this.a.copy( triangle.a );
    		this.b.copy( triangle.b );
    		this.c.copy( triangle.c );

    		return this;

    	},

    	area: function () {

    		var v0 = new Vector3();
    		var v1 = new Vector3();

    		return function area() {

    			v0.subVectors( this.c, this.b );
    			v1.subVectors( this.a, this.b );

    			return v0.cross( v1 ).length() * 0.5;

    		};

    	}(),

    	midpoint: function ( optionalTarget ) {

    		var result = optionalTarget || new Vector3();
    		return result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

    	},

    	normal: function ( optionalTarget ) {

    		return Triangle.normal( this.a, this.b, this.c, optionalTarget );

    	},

    	plane: function ( optionalTarget ) {

    		var result = optionalTarget || new Plane();

    		return result.setFromCoplanarPoints( this.a, this.b, this.c );

    	},

    	barycoordFromPoint: function ( point, optionalTarget ) {

    		return Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );

    	},

    	containsPoint: function ( point ) {

    		return Triangle.containsPoint( point, this.a, this.b, this.c );

    	},

    	closestPointToPoint: function () {

    		var plane, edgeList, projectedPoint, closestPoint;

    		return function closestPointToPoint( point, optionalTarget ) {

    			if ( plane === undefined ) {

    				plane = new Plane();
    				edgeList = [ new Line3(), new Line3(), new Line3() ];
    				projectedPoint = new Vector3();
    				closestPoint = new Vector3();

    			}

    			var result = optionalTarget || new Vector3();
    			var minDistance = Infinity;

    			// project the point onto the plane of the triangle

    			plane.setFromCoplanarPoints( this.a, this.b, this.c );
    			plane.projectPoint( point, projectedPoint );

    			// check if the projection lies within the triangle

    			if( this.containsPoint( projectedPoint ) === true ) {

    				// if so, this is the closest point

    				result.copy( projectedPoint );

    			} else {

    				// if not, the point falls outside the triangle. the result is the closest point to the triangle's edges or vertices

    				edgeList[ 0 ].set( this.a, this.b );
    				edgeList[ 1 ].set( this.b, this.c );
    				edgeList[ 2 ].set( this.c, this.a );

    				for( var i = 0; i < edgeList.length; i ++ ) {

    					edgeList[ i ].closestPointToPoint( projectedPoint, true, closestPoint );

    					var distance = projectedPoint.distanceToSquared( closestPoint );

    					if( distance < minDistance ) {

    						minDistance = distance;

    						result.copy( closestPoint );

    					}

    				}

    			}

    			return result;

    		};

    	}(),

    	equals: function ( triangle ) {

    		return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

    	}

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     */

    function Face3( a, b, c, normal, color, materialIndex ) {

    	this.a = a;
    	this.b = b;
    	this.c = c;

    	this.normal = (normal && normal.isVector3) ? normal : new Vector3();
    	this.vertexNormals = Array.isArray( normal ) ? normal : [];

    	this.color = (color && color.isColor) ? color : new Color();
    	this.vertexColors = Array.isArray( color ) ? color : [];

    	this.materialIndex = materialIndex !== undefined ? materialIndex : 0;

    }

    Face3.prototype = {

    	constructor: Face3,

    	clone: function () {

    		return new this.constructor().copy( this );

    	},

    	copy: function ( source ) {

    		this.a = source.a;
    		this.b = source.b;
    		this.c = source.c;

    		this.normal.copy( source.normal );
    		this.color.copy( source.color );

    		this.materialIndex = source.materialIndex;

    		for ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {

    			this.vertexNormals[ i ] = source.vertexNormals[ i ].clone();

    		}

    		for ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {

    			this.vertexColors[ i ] = source.vertexColors[ i ].clone();

    		}

    		return this;

    	}

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     *
     * parameters = {
     *  color: <hex>,
     *  opacity: <float>,
     *  map: new THREE.Texture( <Image> ),
     *
     *  aoMap: new THREE.Texture( <Image> ),
     *  aoMapIntensity: <float>
     *
     *  specularMap: new THREE.Texture( <Image> ),
     *
     *  alphaMap: new THREE.Texture( <Image> ),
     *
     *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
     *  combine: THREE.Multiply,
     *  reflectivity: <float>,
     *  refractionRatio: <float>,
     *
     *  shading: THREE.SmoothShading,
     *  depthTest: <bool>,
     *  depthWrite: <bool>,
     *
     *  wireframe: <boolean>,
     *  wireframeLinewidth: <float>,
     *
     *  skinning: <bool>,
     *  morphTargets: <bool>
     * }
     */

    function MeshBasicMaterial( parameters ) {

    	Material.call( this );

    	this.type = 'MeshBasicMaterial';

    	this.color = new Color( 0xffffff ); // emissive

    	this.map = null;

    	this.aoMap = null;
    	this.aoMapIntensity = 1.0;

    	this.specularMap = null;

    	this.alphaMap = null;

    	this.envMap = null;
    	this.combine = MultiplyOperation;
    	this.reflectivity = 1;
    	this.refractionRatio = 0.98;

    	this.wireframe = false;
    	this.wireframeLinewidth = 1;
    	this.wireframeLinecap = 'round';
    	this.wireframeLinejoin = 'round';

    	this.skinning = false;
    	this.morphTargets = false;

    	this.lights = false;

    	this.setValues( parameters );

    }

    MeshBasicMaterial.prototype = Object.create( Material.prototype );
    MeshBasicMaterial.prototype.constructor = MeshBasicMaterial;

    MeshBasicMaterial.prototype.isMeshBasicMaterial = true;

    MeshBasicMaterial.prototype.copy = function ( source ) {

    	Material.prototype.copy.call( this, source );

    	this.color.copy( source.color );

    	this.map = source.map;

    	this.aoMap = source.aoMap;
    	this.aoMapIntensity = source.aoMapIntensity;

    	this.specularMap = source.specularMap;

    	this.alphaMap = source.alphaMap;

    	this.envMap = source.envMap;
    	this.combine = source.combine;
    	this.reflectivity = source.reflectivity;
    	this.refractionRatio = source.refractionRatio;

    	this.wireframe = source.wireframe;
    	this.wireframeLinewidth = source.wireframeLinewidth;
    	this.wireframeLinecap = source.wireframeLinecap;
    	this.wireframeLinejoin = source.wireframeLinejoin;

    	this.skinning = source.skinning;
    	this.morphTargets = source.morphTargets;

    	return this;

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function BufferAttribute( array, itemSize, normalized ) {

    	if ( Array.isArray( array ) ) {

    		throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

    	}

    	this.uuid = exports.Math.generateUUID();

    	this.array = array;
    	this.itemSize = itemSize;
    	this.count = array !== undefined ? array.length / itemSize : 0;
    	this.normalized = normalized === true;

    	this.dynamic = false;
    	this.updateRange = { offset: 0, count: - 1 };

    	this.version = 0;

    }

    BufferAttribute.prototype = {

    	constructor: BufferAttribute,

    	isBufferAttribute: true,

    	set needsUpdate( value ) {

    		if ( value === true ) this.version ++;

    	},

    	setDynamic: function ( value ) {

    		this.dynamic = value;

    		return this;

    	},

    	copy: function ( source ) {

    		this.array = new source.array.constructor( source.array );
    		this.itemSize = source.itemSize;
    		this.count = source.count;
    		this.normalized = source.normalized;

    		this.dynamic = source.dynamic;

    		return this;

    	},

    	copyAt: function ( index1, attribute, index2 ) {

    		index1 *= this.itemSize;
    		index2 *= attribute.itemSize;

    		for ( var i = 0, l = this.itemSize; i < l; i ++ ) {

    			this.array[ index1 + i ] = attribute.array[ index2 + i ];

    		}

    		return this;

    	},

    	copyArray: function ( array ) {

    		this.array.set( array );

    		return this;

    	},

    	copyColorsArray: function ( colors ) {

    		var array = this.array, offset = 0;

    		for ( var i = 0, l = colors.length; i < l; i ++ ) {

    			var color = colors[ i ];

    			if ( color === undefined ) {

    				console.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );
    				color = new Color();

    			}

    			array[ offset ++ ] = color.r;
    			array[ offset ++ ] = color.g;
    			array[ offset ++ ] = color.b;

    		}

    		return this;

    	},

    	copyIndicesArray: function ( indices ) {

    		var array = this.array, offset = 0;

    		for ( var i = 0, l = indices.length; i < l; i ++ ) {

    			var index = indices[ i ];

    			array[ offset ++ ] = index.a;
    			array[ offset ++ ] = index.b;
    			array[ offset ++ ] = index.c;

    		}

    		return this;

    	},

    	copyVector2sArray: function ( vectors ) {

    		var array = this.array, offset = 0;

    		for ( var i = 0, l = vectors.length; i < l; i ++ ) {

    			var vector = vectors[ i ];

    			if ( vector === undefined ) {

    				console.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );
    				vector = new Vector2();

    			}

    			array[ offset ++ ] = vector.x;
    			array[ offset ++ ] = vector.y;

    		}

    		return this;

    	},

    	copyVector3sArray: function ( vectors ) {

    		var array = this.array, offset = 0;

    		for ( var i = 0, l = vectors.length; i < l; i ++ ) {

    			var vector = vectors[ i ];

    			if ( vector === undefined ) {

    				console.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );
    				vector = new Vector3();

    			}

    			array[ offset ++ ] = vector.x;
    			array[ offset ++ ] = vector.y;
    			array[ offset ++ ] = vector.z;

    		}

    		return this;

    	},

    	copyVector4sArray: function ( vectors ) {

    		var array = this.array, offset = 0;

    		for ( var i = 0, l = vectors.length; i < l; i ++ ) {

    			var vector = vectors[ i ];

    			if ( vector === undefined ) {

    				console.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );
    				vector = new Vector4();

    			}

    			array[ offset ++ ] = vector.x;
    			array[ offset ++ ] = vector.y;
    			array[ offset ++ ] = vector.z;
    			array[ offset ++ ] = vector.w;

    		}

    		return this;

    	},

    	set: function ( value, offset ) {

    		if ( offset === undefined ) offset = 0;

    		this.array.set( value, offset );

    		return this;

    	},

    	getX: function ( index ) {

    		return this.array[ index * this.itemSize ];

    	},

    	setX: function ( index, x ) {

    		this.array[ index * this.itemSize ] = x;

    		return this;

    	},

    	getY: function ( index ) {

    		return this.array[ index * this.itemSize + 1 ];

    	},

    	setY: function ( index, y ) {

    		this.array[ index * this.itemSize + 1 ] = y;

    		return this;

    	},

    	getZ: function ( index ) {

    		return this.array[ index * this.itemSize + 2 ];

    	},

    	setZ: function ( index, z ) {

    		this.array[ index * this.itemSize + 2 ] = z;

    		return this;

    	},

    	getW: function ( index ) {

    		return this.array[ index * this.itemSize + 3 ];

    	},

    	setW: function ( index, w ) {

    		this.array[ index * this.itemSize + 3 ] = w;

    		return this;

    	},

    	setXY: function ( index, x, y ) {

    		index *= this.itemSize;

    		this.array[ index + 0 ] = x;
    		this.array[ index + 1 ] = y;

    		return this;

    	},

    	setXYZ: function ( index, x, y, z ) {

    		index *= this.itemSize;

    		this.array[ index + 0 ] = x;
    		this.array[ index + 1 ] = y;
    		this.array[ index + 2 ] = z;

    		return this;

    	},

    	setXYZW: function ( index, x, y, z, w ) {

    		index *= this.itemSize;

    		this.array[ index + 0 ] = x;
    		this.array[ index + 1 ] = y;
    		this.array[ index + 2 ] = z;
    		this.array[ index + 3 ] = w;

    		return this;

    	},

    	clone: function () {

    		return new this.constructor().copy( this );

    	}

    };

    //

    function Int8Attribute( array, itemSize ) {

    	return new BufferAttribute( new Int8Array( array ), itemSize );

    }

    function Uint8Attribute( array, itemSize ) {

    	return new BufferAttribute( new Uint8Array( array ), itemSize );

    }

    function Uint8ClampedAttribute( array, itemSize ) {

    	return new BufferAttribute( new Uint8ClampedArray( array ), itemSize );

    }

    function Int16Attribute( array, itemSize ) {

    	return new BufferAttribute( new Int16Array( array ), itemSize );

    }

    function Uint16Attribute( array, itemSize ) {

    	return new BufferAttribute( new Uint16Array( array ), itemSize );

    }

    function Int32Attribute( array, itemSize ) {

    	return new BufferAttribute( new Int32Array( array ), itemSize );

    }

    function Uint32Attribute( array, itemSize ) {

    	return new BufferAttribute( new Uint32Array( array ), itemSize );

    }

    function Float32Attribute( array, itemSize ) {

    	return new BufferAttribute( new Float32Array( array ), itemSize );

    }

    function Float64Attribute( array, itemSize ) {

    	return new BufferAttribute( new Float64Array( array ), itemSize );

    }

    // Deprecated

    function DynamicBufferAttribute( array, itemSize ) {

    	console.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.' );
    	return new BufferAttribute( array, itemSize ).setDynamic( true );

    }

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author kile / http://kile.stravaganza.org/
     * @author alteredq / http://alteredqualia.com/
     * @author mikael emtinger / http://gomo.se/
     * @author zz85 / http://www.lab4games.net/zz85/blog
     * @author bhouston / http://clara.io
     */

    function Geometry() {

    	Object.defineProperty( this, 'id', { value: GeometryIdCount() } );

    	this.uuid = exports.Math.generateUUID();

    	this.name = '';
    	this.type = 'Geometry';

    	this.vertices = [];
    	this.colors = [];
    	this.faces = [];
    	this.faceVertexUvs = [ [] ];

    	this.morphTargets = [];
    	this.morphNormals = [];

    	this.skinWeights = [];
    	this.skinIndices = [];

    	this.lineDistances = [];

    	this.boundingBox = null;
    	this.boundingSphere = null;

    	// update flags

    	this.elementsNeedUpdate = false;
    	this.verticesNeedUpdate = false;
    	this.uvsNeedUpdate = false;
    	this.normalsNeedUpdate = false;
    	this.colorsNeedUpdate = false;
    	this.lineDistancesNeedUpdate = false;
    	this.groupsNeedUpdate = false;

    }

    Object.assign( Geometry.prototype, EventDispatcher.prototype, {

    	isGeometry: true,

    	applyMatrix: function ( matrix ) {

    		var normalMatrix = new Matrix3().getNormalMatrix( matrix );

    		for ( var i = 0, il = this.vertices.length; i < il; i ++ ) {

    			var vertex = this.vertices[ i ];
    			vertex.applyMatrix4( matrix );

    		}

    		for ( var i = 0, il = this.faces.length; i < il; i ++ ) {

    			var face = this.faces[ i ];
    			face.normal.applyMatrix3( normalMatrix ).normalize();

    			for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

    				face.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();

    			}

    		}

    		if ( this.boundingBox !== null ) {

    			this.computeBoundingBox();

    		}

    		if ( this.boundingSphere !== null ) {

    			this.computeBoundingSphere();

    		}

    		this.verticesNeedUpdate = true;
    		this.normalsNeedUpdate = true;

    		return this;

    	},

    	rotateX: function () {

    		// rotate geometry around world x-axis

    		var m1;

    		return function rotateX( angle ) {

    			if ( m1 === undefined ) m1 = new Matrix4();

    			m1.makeRotationX( angle );

    			this.applyMatrix( m1 );

    			return this;

    		};

    	}(),

    	rotateY: function () {

    		// rotate geometry around world y-axis

    		var m1;

    		return function rotateY( angle ) {

    			if ( m1 === undefined ) m1 = new Matrix4();

    			m1.makeRotationY( angle );

    			this.applyMatrix( m1 );

    			return this;

    		};

    	}(),

    	rotateZ: function () {

    		// rotate geometry around world z-axis

    		var m1;

    		return function rotateZ( angle ) {

    			if ( m1 === undefined ) m1 = new Matrix4();

    			m1.makeRotationZ( angle );

    			this.applyMatrix( m1 );

    			return this;

    		};

    	}(),

    	translate: function () {

    		// translate geometry

    		var m1;

    		return function translate( x, y, z ) {

    			if ( m1 === undefined ) m1 = new Matrix4();

    			m1.makeTranslation( x, y, z );

    			this.applyMatrix( m1 );

    			return this;

    		};

    	}(),

    	scale: function () {

    		// scale geometry

    		var m1;

    		return function scale( x, y, z ) {

    			if ( m1 === undefined ) m1 = new Matrix4();

    			m1.makeScale( x, y, z );

    			this.applyMatrix( m1 );

    			return this;

    		};

    	}(),

    	lookAt: function () {

    		var obj;

    		return function lookAt( vector ) {

    			if ( obj === undefined ) obj = new Object3D();

    			obj.lookAt( vector );

    			obj.updateMatrix();

    			this.applyMatrix( obj.matrix );

    		};

    	}(),

    	fromBufferGeometry: function ( geometry ) {

    		var scope = this;

    		var indices = geometry.index !== null ? geometry.index.array : undefined;
    		var attributes = geometry.attributes;

    		var positions = attributes.position.array;
    		var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
    		var colors = attributes.color !== undefined ? attributes.color.array : undefined;
    		var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
    		var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;

    		if ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];

    		var tempNormals = [];
    		var tempUVs = [];
    		var tempUVs2 = [];

    		for ( var i = 0, j = 0; i < positions.length; i += 3, j += 2 ) {

    			scope.vertices.push( new Vector3( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] ) );

    			if ( normals !== undefined ) {

    				tempNormals.push( new Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );

    			}

    			if ( colors !== undefined ) {

    				scope.colors.push( new Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );

    			}

    			if ( uvs !== undefined ) {

    				tempUVs.push( new Vector2( uvs[ j ], uvs[ j + 1 ] ) );

    			}

    			if ( uvs2 !== undefined ) {

    				tempUVs2.push( new Vector2( uvs2[ j ], uvs2[ j + 1 ] ) );

    			}

    		}

    		function addFace( a, b, c, materialIndex ) {

    			var vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];
    			var vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];

    			var face = new Face3( a, b, c, vertexNormals, vertexColors, materialIndex );

    			scope.faces.push( face );

    			if ( uvs !== undefined ) {

    				scope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );

    			}

    			if ( uvs2 !== undefined ) {

    				scope.faceVertexUvs[ 1 ].push( [ tempUVs2[ a ].clone(), tempUVs2[ b ].clone(), tempUVs2[ c ].clone() ] );

    			}

    		}

    		if ( indices !== undefined ) {

    			var groups = geometry.groups;

    			if ( groups.length > 0 ) {

    				for ( var i = 0; i < groups.length; i ++ ) {

    					var group = groups[ i ];

    					var start = group.start;
    					var count = group.count;

    					for ( var j = start, jl = start + count; j < jl; j += 3 ) {

    						addFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ], group.materialIndex  );

    					}

    				}

    			} else {

    				for ( var i = 0; i < indices.length; i += 3 ) {

    					addFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );

    				}

    			}

    		} else {

    			for ( var i = 0; i < positions.length / 3; i += 3 ) {

    				addFace( i, i + 1, i + 2 );

    			}

    		}

    		this.computeFaceNormals();

    		if ( geometry.boundingBox !== null ) {

    			this.boundingBox = geometry.boundingBox.clone();

    		}

    		if ( geometry.boundingSphere !== null ) {

    			this.boundingSphere = geometry.boundingSphere.clone();

    		}

    		return this;

    	},

    	center: function () {

    		this.computeBoundingBox();

    		var offset = this.boundingBox.getCenter().negate();

    		this.translate( offset.x, offset.y, offset.z );

    		return offset;

    	},

    	normalize: function () {

    		this.computeBoundingSphere();

    		var center = this.boundingSphere.center;
    		var radius = this.boundingSphere.radius;

    		var s = radius === 0 ? 1 : 1.0 / radius;

    		var matrix = new Matrix4();
    		matrix.set(
    			s, 0, 0, - s * center.x,
    			0, s, 0, - s * center.y,
    			0, 0, s, - s * center.z,
    			0, 0, 0, 1
    		);

    		this.applyMatrix( matrix );

    		return this;

    	},

    	computeFaceNormals: function () {

    		var cb = new Vector3(), ab = new Vector3();

    		for ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {

    			var face = this.faces[ f ];

    			var vA = this.vertices[ face.a ];
    			var vB = this.vertices[ face.b ];
    			var vC = this.vertices[ face.c ];

    			cb.subVectors( vC, vB );
    			ab.subVectors( vA, vB );
    			cb.cross( ab );

    			cb.normalize();

    			face.normal.copy( cb );

    		}

    	},

    	computeVertexNormals: function ( areaWeighted ) {

    		if ( areaWeighted === undefined ) areaWeighted = true;

    		var v, vl, f, fl, face, vertices;

    		vertices = new Array( this.vertices.length );

    		for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

    			vertices[ v ] = new Vector3();

    		}

    		if ( areaWeighted ) {

    			// vertex normals weighted by triangle areas
    			// http://www.iquilezles.org/www/articles/normals/normals.htm

    			var vA, vB, vC;
    			var cb = new Vector3(), ab = new Vector3();

    			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

    				face = this.faces[ f ];

    				vA = this.vertices[ face.a ];
    				vB = this.vertices[ face.b ];
    				vC = this.vertices[ face.c ];

    				cb.subVectors( vC, vB );
    				ab.subVectors( vA, vB );
    				cb.cross( ab );

    				vertices[ face.a ].add( cb );
    				vertices[ face.b ].add( cb );
    				vertices[ face.c ].add( cb );

    			}

    		} else {

    			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

    				face = this.faces[ f ];

    				vertices[ face.a ].add( face.normal );
    				vertices[ face.b ].add( face.normal );
    				vertices[ face.c ].add( face.normal );

    			}

    		}

    		for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

    			vertices[ v ].normalize();

    		}

    		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

    			face = this.faces[ f ];

    			var vertexNormals = face.vertexNormals;

    			if ( vertexNormals.length === 3 ) {

    				vertexNormals[ 0 ].copy( vertices[ face.a ] );
    				vertexNormals[ 1 ].copy( vertices[ face.b ] );
    				vertexNormals[ 2 ].copy( vertices[ face.c ] );

    			} else {

    				vertexNormals[ 0 ] = vertices[ face.a ].clone();
    				vertexNormals[ 1 ] = vertices[ face.b ].clone();
    				vertexNormals[ 2 ] = vertices[ face.c ].clone();

    			}

    		}

    		if ( this.faces.length > 0 ) {

    			this.normalsNeedUpdate = true;

    		}

    	},

    	computeMorphNormals: function () {

    		var i, il, f, fl, face;

    		// save original normals
    		// - create temp variables on first access
    		//   otherwise just copy (for faster repeated calls)

    		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

    			face = this.faces[ f ];

    			if ( ! face.__originalFaceNormal ) {

    				face.__originalFaceNormal = face.normal.clone();

    			} else {

    				face.__originalFaceNormal.copy( face.normal );

    			}

    			if ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];

    			for ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {

    				if ( ! face.__originalVertexNormals[ i ] ) {

    					face.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();

    				} else {

    					face.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );

    				}

    			}

    		}

    		// use temp geometry to compute face and vertex normals for each morph

    		var tmpGeo = new Geometry();
    		tmpGeo.faces = this.faces;

    		for ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {

    			// create on first access

    			if ( ! this.morphNormals[ i ] ) {

    				this.morphNormals[ i ] = {};
    				this.morphNormals[ i ].faceNormals = [];
    				this.morphNormals[ i ].vertexNormals = [];

    				var dstNormalsFace = this.morphNormals[ i ].faceNormals;
    				var dstNormalsVertex = this.morphNormals[ i ].vertexNormals;

    				var faceNormal, vertexNormals;

    				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

    					faceNormal = new Vector3();
    					vertexNormals = { a: new Vector3(), b: new Vector3(), c: new Vector3() };

    					dstNormalsFace.push( faceNormal );
    					dstNormalsVertex.push( vertexNormals );

    				}

    			}

    			var morphNormals = this.morphNormals[ i ];

    			// set vertices to morph target

    			tmpGeo.vertices = this.morphTargets[ i ].vertices;

    			// compute morph normals

    			tmpGeo.computeFaceNormals();
    			tmpGeo.computeVertexNormals();

    			// store morph normals

    			var faceNormal, vertexNormals;

    			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

    				face = this.faces[ f ];

    				faceNormal = morphNormals.faceNormals[ f ];
    				vertexNormals = morphNormals.vertexNormals[ f ];

    				faceNormal.copy( face.normal );

    				vertexNormals.a.copy( face.vertexNormals[ 0 ] );
    				vertexNormals.b.copy( face.vertexNormals[ 1 ] );
    				vertexNormals.c.copy( face.vertexNormals[ 2 ] );

    			}

    		}

    		// restore original normals

    		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

    			face = this.faces[ f ];

    			face.normal = face.__originalFaceNormal;
    			face.vertexNormals = face.__originalVertexNormals;

    		}

    	},

    	computeTangents: function () {

    		console.warn( 'THREE.Geometry: .computeTangents() has been removed.' );

    	},

    	computeLineDistances: function () {

    		var d = 0;
    		var vertices = this.vertices;

    		for ( var i = 0, il = vertices.length; i < il; i ++ ) {

    			if ( i > 0 ) {

    				d += vertices[ i ].distanceTo( vertices[ i - 1 ] );

    			}

    			this.lineDistances[ i ] = d;

    		}

    	},

    	computeBoundingBox: function () {

    		if ( this.boundingBox === null ) {

    			this.boundingBox = new Box3();

    		}

    		this.boundingBox.setFromPoints( this.vertices );

    	},

    	computeBoundingSphere: function () {

    		if ( this.boundingSphere === null ) {

    			this.boundingSphere = new Sphere();

    		}

    		this.boundingSphere.setFromPoints( this.vertices );

    	},

    	merge: function ( geometry, matrix, materialIndexOffset ) {

    		if ( (geometry && geometry.isGeometry) === false ) {

    			console.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );
    			return;

    		}

    		var normalMatrix,
    		vertexOffset = this.vertices.length,
    		vertices1 = this.vertices,
    		vertices2 = geometry.vertices,
    		faces1 = this.faces,
    		faces2 = geometry.faces,
    		uvs1 = this.faceVertexUvs[ 0 ],
    		uvs2 = geometry.faceVertexUvs[ 0 ],
    		colors1 = this.colors,
    		colors2 = geometry.colors;

    		if ( materialIndexOffset === undefined ) materialIndexOffset = 0;

    		if ( matrix !== undefined ) {

    			normalMatrix = new Matrix3().getNormalMatrix( matrix );

    		}

    		// vertices

    		for ( var i = 0, il = vertices2.length; i < il; i ++ ) {

    			var vertex = vertices2[ i ];

    			var vertexCopy = vertex.clone();

    			if ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );

    			vertices1.push( vertexCopy );

    		}

    		// colors

    		for ( var i = 0, il = colors2.length; i < il; i ++ ) {

    			colors1.push( colors2[ i ].clone() );

    		}

    		// faces

    		for ( i = 0, il = faces2.length; i < il; i ++ ) {

    			var face = faces2[ i ], faceCopy, normal, color,
    			faceVertexNormals = face.vertexNormals,
    			faceVertexColors = face.vertexColors;

    			faceCopy = new Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );
    			faceCopy.normal.copy( face.normal );

    			if ( normalMatrix !== undefined ) {

    				faceCopy.normal.applyMatrix3( normalMatrix ).normalize();

    			}

    			for ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {

    				normal = faceVertexNormals[ j ].clone();

    				if ( normalMatrix !== undefined ) {

    					normal.applyMatrix3( normalMatrix ).normalize();

    				}

    				faceCopy.vertexNormals.push( normal );

    			}

    			faceCopy.color.copy( face.color );

    			for ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {

    				color = faceVertexColors[ j ];
    				faceCopy.vertexColors.push( color.clone() );

    			}

    			faceCopy.materialIndex = face.materialIndex + materialIndexOffset;

    			faces1.push( faceCopy );

    		}

    		// uvs

    		for ( i = 0, il = uvs2.length; i < il; i ++ ) {

    			var uv = uvs2[ i ], uvCopy = [];

    			if ( uv === undefined ) {

    				continue;

    			}

    			for ( var j = 0, jl = uv.length; j < jl; j ++ ) {

    				uvCopy.push( uv[ j ].clone() );

    			}

    			uvs1.push( uvCopy );

    		}

    	},

    	mergeMesh: function ( mesh ) {

    		if ( (mesh && mesh.isMesh) === false ) {

    			console.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );
    			return;

    		}

    		mesh.matrixAutoUpdate && mesh.updateMatrix();

    		this.merge( mesh.geometry, mesh.matrix );

    	},

    	/*
    	 * Checks for duplicate vertices with hashmap.
    	 * Duplicated vertices are removed
    	 * and faces' vertices are updated.
    	 */

    	mergeVertices: function () {

    		var verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)
    		var unique = [], changes = [];

    		var v, key;
    		var precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001
    		var precision = Math.pow( 10, precisionPoints );
    		var i, il, face;
    		var indices, j, jl;

    		for ( i = 0, il = this.vertices.length; i < il; i ++ ) {

    			v = this.vertices[ i ];
    			key = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );

    			if ( verticesMap[ key ] === undefined ) {

    				verticesMap[ key ] = i;
    				unique.push( this.vertices[ i ] );
    				changes[ i ] = unique.length - 1;

    			} else {

    				//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
    				changes[ i ] = changes[ verticesMap[ key ] ];

    			}

    		}


    		// if faces are completely degenerate after merging vertices, we
    		// have to remove them from the geometry.
    		var faceIndicesToRemove = [];

    		for ( i = 0, il = this.faces.length; i < il; i ++ ) {

    			face = this.faces[ i ];

    			face.a = changes[ face.a ];
    			face.b = changes[ face.b ];
    			face.c = changes[ face.c ];

    			indices = [ face.a, face.b, face.c ];

    			var dupIndex = - 1;

    			// if any duplicate vertices are found in a Face3
    			// we have to remove the face as nothing can be saved
    			for ( var n = 0; n < 3; n ++ ) {

    				if ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {

    					dupIndex = n;
    					faceIndicesToRemove.push( i );
    					break;

    				}

    			}

    		}

    		for ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {

    			var idx = faceIndicesToRemove[ i ];

    			this.faces.splice( idx, 1 );

    			for ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {

    				this.faceVertexUvs[ j ].splice( idx, 1 );

    			}

    		}

    		// Use unique set of vertices

    		var diff = this.vertices.length - unique.length;
    		this.vertices = unique;
    		return diff;

    	},

    	sortFacesByMaterialIndex: function () {

    		var faces = this.faces;
    		var length = faces.length;

    		// tag faces

    		for ( var i = 0; i < length; i ++ ) {

    			faces[ i ]._id = i;

    		}

    		// sort faces

    		function materialIndexSort( a, b ) {

    			return a.materialIndex - b.materialIndex;

    		}

    		faces.sort( materialIndexSort );

    		// sort uvs

    		var uvs1 = this.faceVertexUvs[ 0 ];
    		var uvs2 = this.faceVertexUvs[ 1 ];

    		var newUvs1, newUvs2;

    		if ( uvs1 && uvs1.length === length ) newUvs1 = [];
    		if ( uvs2 && uvs2.length === length ) newUvs2 = [];

    		for ( var i = 0; i < length; i ++ ) {

    			var id = faces[ i ]._id;

    			if ( newUvs1 ) newUvs1.push( uvs1[ id ] );
    			if ( newUvs2 ) newUvs2.push( uvs2[ id ] );

    		}

    		if ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;
    		if ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;

    	},

    	toJSON: function () {

    		var data = {
    			metadata: {
    				version: 4.4,
    				type: 'Geometry',
    				generator: 'Geometry.toJSON'
    			}
    		};

    		// standard Geometry serialization

    		data.uuid = this.uuid;
    		data.type = this.type;
    		if ( this.name !== '' ) data.name = this.name;

    		if ( this.parameters !== undefined ) {

    			var parameters = this.parameters;

    			for ( var key in parameters ) {

    				if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

    			}

    			return data;

    		}

    		var vertices = [];

    		for ( var i = 0; i < this.vertices.length; i ++ ) {

    			var vertex = this.vertices[ i ];
    			vertices.push( vertex.x, vertex.y, vertex.z );

    		}

    		var faces = [];
    		var normals = [];
    		var normalsHash = {};
    		var colors = [];
    		var colorsHash = {};
    		var uvs = [];
    		var uvsHash = {};

    		for ( var i = 0; i < this.faces.length; i ++ ) {

    			var face = this.faces[ i ];

    			var hasMaterial = true;
    			var hasFaceUv = false; // deprecated
    			var hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;
    			var hasFaceNormal = face.normal.length() > 0;
    			var hasFaceVertexNormal = face.vertexNormals.length > 0;
    			var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
    			var hasFaceVertexColor = face.vertexColors.length > 0;

    			var faceType = 0;

    			faceType = setBit( faceType, 0, 0 ); // isQuad
    			faceType = setBit( faceType, 1, hasMaterial );
    			faceType = setBit( faceType, 2, hasFaceUv );
    			faceType = setBit( faceType, 3, hasFaceVertexUv );
    			faceType = setBit( faceType, 4, hasFaceNormal );
    			faceType = setBit( faceType, 5, hasFaceVertexNormal );
    			faceType = setBit( faceType, 6, hasFaceColor );
    			faceType = setBit( faceType, 7, hasFaceVertexColor );

    			faces.push( faceType );
    			faces.push( face.a, face.b, face.c );
    			faces.push( face.materialIndex );

    			if ( hasFaceVertexUv ) {

    				var faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];

    				faces.push(
    					getUvIndex( faceVertexUvs[ 0 ] ),
    					getUvIndex( faceVertexUvs[ 1 ] ),
    					getUvIndex( faceVertexUvs[ 2 ] )
    				);

    			}

    			if ( hasFaceNormal ) {

    				faces.push( getNormalIndex( face.normal ) );

    			}

    			if ( hasFaceVertexNormal ) {

    				var vertexNormals = face.vertexNormals;

    				faces.push(
    					getNormalIndex( vertexNormals[ 0 ] ),
    					getNormalIndex( vertexNormals[ 1 ] ),
    					getNormalIndex( vertexNormals[ 2 ] )
    				);

    			}

    			if ( hasFaceColor ) {

    				faces.push( getColorIndex( face.color ) );

    			}

    			if ( hasFaceVertexColor ) {

    				var vertexColors = face.vertexColors;

    				faces.push(
    					getColorIndex( vertexColors[ 0 ] ),
    					getColorIndex( vertexColors[ 1 ] ),
    					getColorIndex( vertexColors[ 2 ] )
    				);

    			}

    		}

    		function setBit( value, position, enabled ) {

    			return enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );

    		}

    		function getNormalIndex( normal ) {

    			var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();

    			if ( normalsHash[ hash ] !== undefined ) {

    				return normalsHash[ hash ];

    			}

    			normalsHash[ hash ] = normals.length / 3;
    			normals.push( normal.x, normal.y, normal.z );

    			return normalsHash[ hash ];

    		}

    		function getColorIndex( color ) {

    			var hash = color.r.toString() + color.g.toString() + color.b.toString();

    			if ( colorsHash[ hash ] !== undefined ) {

    				return colorsHash[ hash ];

    			}

    			colorsHash[ hash ] = colors.length;
    			colors.push( color.getHex() );

    			return colorsHash[ hash ];

    		}

    		function getUvIndex( uv ) {

    			var hash = uv.x.toString() + uv.y.toString();

    			if ( uvsHash[ hash ] !== undefined ) {

    				return uvsHash[ hash ];

    			}

    			uvsHash[ hash ] = uvs.length / 2;
    			uvs.push( uv.x, uv.y );

    			return uvsHash[ hash ];

    		}

    		data.data = {};

    		data.data.vertices = vertices;
    		data.data.normals = normals;
    		if ( colors.length > 0 ) data.data.colors = colors;
    		if ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility
    		data.data.faces = faces;

    		return data;

    	},

    	clone: function () {

    		/*
    		// Handle primitives

    		var parameters = this.parameters;

    		if ( parameters !== undefined ) {

    			var values = [];

    			for ( var key in parameters ) {

    				values.push( parameters[ key ] );

    			}

    			var geometry = Object.create( this.constructor.prototype );
    			this.constructor.apply( geometry, values );
    			return geometry;

    		}

    		return new this.constructor().copy( this );
    		*/

    		return new Geometry().copy( this );

    	},

    	copy: function ( source ) {

    		this.vertices = [];
    		this.faces = [];
    		this.faceVertexUvs = [ [] ];
    		this.colors = [];

    		var vertices = source.vertices;

    		for ( var i = 0, il = vertices.length; i < il; i ++ ) {

    			this.vertices.push( vertices[ i ].clone() );

    		}

    		var colors = source.colors;

    		for ( var i = 0, il = colors.length; i < il; i ++ ) {

    			this.colors.push( colors[ i ].clone() );

    		}

    		var faces = source.faces;

    		for ( var i = 0, il = faces.length; i < il; i ++ ) {

    			this.faces.push( faces[ i ].clone() );

    		}

    		for ( var i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {

    			var faceVertexUvs = source.faceVertexUvs[ i ];

    			if ( this.faceVertexUvs[ i ] === undefined ) {

    				this.faceVertexUvs[ i ] = [];

    			}

    			for ( var j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {

    				var uvs = faceVertexUvs[ j ], uvsCopy = [];

    				for ( var k = 0, kl = uvs.length; k < kl; k ++ ) {

    					var uv = uvs[ k ];

    					uvsCopy.push( uv.clone() );

    				}

    				this.faceVertexUvs[ i ].push( uvsCopy );

    			}

    		}

    		return this;

    	},

    	dispose: function () {

    		this.dispatchEvent( { type: 'dispose' } );

    	}

    } );

    var count$3 = 0;
    function GeometryIdCount() { return count$3++; };

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function DirectGeometry() {

    	Object.defineProperty( this, 'id', { value: GeometryIdCount() } );

    	this.uuid = exports.Math.generateUUID();

    	this.name = '';
    	this.type = 'DirectGeometry';

    	this.indices = [];
    	this.vertices = [];
    	this.normals = [];
    	this.colors = [];
    	this.uvs = [];
    	this.uvs2 = [];

    	this.groups = [];

    	this.morphTargets = {};

    	this.skinWeights = [];
    	this.skinIndices = [];

    	// this.lineDistances = [];

    	this.boundingBox = null;
    	this.boundingSphere = null;

    	// update flags

    	this.verticesNeedUpdate = false;
    	this.normalsNeedUpdate = false;
    	this.colorsNeedUpdate = false;
    	this.uvsNeedUpdate = false;
    	this.groupsNeedUpdate = false;

    }

    Object.assign( DirectGeometry.prototype, EventDispatcher.prototype, {

    	computeBoundingBox: Geometry.prototype.computeBoundingBox,
    	computeBoundingSphere: Geometry.prototype.computeBoundingSphere,

    	computeFaceNormals: function () {

    		console.warn( 'THREE.DirectGeometry: computeFaceNormals() is not a method of this type of geometry.' );

    	},

    	computeVertexNormals: function () {

    		console.warn( 'THREE.DirectGeometry: computeVertexNormals() is not a method of this type of geometry.' );

    	},

    	computeGroups: function ( geometry ) {

    		var group;
    		var groups = [];
    		var materialIndex;

    		var faces = geometry.faces;

    		for ( var i = 0; i < faces.length; i ++ ) {

    			var face = faces[ i ];

    			// materials

    			if ( face.materialIndex !== materialIndex ) {

    				materialIndex = face.materialIndex;

    				if ( group !== undefined ) {

    					group.count = ( i * 3 ) - group.start;
    					groups.push( group );

    				}

    				group = {
    					start: i * 3,
    					materialIndex: materialIndex
    				};

    			}

    		}

    		if ( group !== undefined ) {

    			group.count = ( i * 3 ) - group.start;
    			groups.push( group );

    		}

    		this.groups = groups;

    	},

    	fromGeometry: function ( geometry ) {

    		var faces = geometry.faces;
    		var vertices = geometry.vertices;
    		var faceVertexUvs = geometry.faceVertexUvs;

    		var hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;
    		var hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;

    		// morphs

    		var morphTargets = geometry.morphTargets;
    		var morphTargetsLength = morphTargets.length;

    		var morphTargetsPosition;

    		if ( morphTargetsLength > 0 ) {

    			morphTargetsPosition = [];

    			for ( var i = 0; i < morphTargetsLength; i ++ ) {

    				morphTargetsPosition[ i ] = [];

    			}

    			this.morphTargets.position = morphTargetsPosition;

    		}

    		var morphNormals = geometry.morphNormals;
    		var morphNormalsLength = morphNormals.length;

    		var morphTargetsNormal;

    		if ( morphNormalsLength > 0 ) {

    			morphTargetsNormal = [];

    			for ( var i = 0; i < morphNormalsLength; i ++ ) {

    				morphTargetsNormal[ i ] = [];

    			}

    			this.morphTargets.normal = morphTargetsNormal;

    		}

    		// skins

    		var skinIndices = geometry.skinIndices;
    		var skinWeights = geometry.skinWeights;

    		var hasSkinIndices = skinIndices.length === vertices.length;
    		var hasSkinWeights = skinWeights.length === vertices.length;

    		//

    		for ( var i = 0; i < faces.length; i ++ ) {

    			var face = faces[ i ];

    			this.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );

    			var vertexNormals = face.vertexNormals;

    			if ( vertexNormals.length === 3 ) {

    				this.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );

    			} else {

    				var normal = face.normal;

    				this.normals.push( normal, normal, normal );

    			}

    			var vertexColors = face.vertexColors;

    			if ( vertexColors.length === 3 ) {

    				this.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );

    			} else {

    				var color = face.color;

    				this.colors.push( color, color, color );

    			}

    			if ( hasFaceVertexUv === true ) {

    				var vertexUvs = faceVertexUvs[ 0 ][ i ];

    				if ( vertexUvs !== undefined ) {

    					this.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

    				} else {

    					console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );

    					this.uvs.push( new Vector2(), new Vector2(), new Vector2() );

    				}

    			}

    			if ( hasFaceVertexUv2 === true ) {

    				var vertexUvs = faceVertexUvs[ 1 ][ i ];

    				if ( vertexUvs !== undefined ) {

    					this.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

    				} else {

    					console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );

    					this.uvs2.push( new Vector2(), new Vector2(), new Vector2() );

    				}

    			}

    			// morphs

    			for ( var j = 0; j < morphTargetsLength; j ++ ) {

    				var morphTarget = morphTargets[ j ].vertices;

    				morphTargetsPosition[ j ].push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );

    			}

    			for ( var j = 0; j < morphNormalsLength; j ++ ) {

    				var morphNormal = morphNormals[ j ].vertexNormals[ i ];

    				morphTargetsNormal[ j ].push( morphNormal.a, morphNormal.b, morphNormal.c );

    			}

    			// skins

    			if ( hasSkinIndices ) {

    				this.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );

    			}

    			if ( hasSkinWeights ) {

    				this.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );

    			}

    		}

    		this.computeGroups( geometry );

    		this.verticesNeedUpdate = geometry.verticesNeedUpdate;
    		this.normalsNeedUpdate = geometry.normalsNeedUpdate;
    		this.colorsNeedUpdate = geometry.colorsNeedUpdate;
    		this.uvsNeedUpdate = geometry.uvsNeedUpdate;
    		this.groupsNeedUpdate = geometry.groupsNeedUpdate;

    		return this;

    	},

    	dispose: function () {

    		this.dispatchEvent( { type: 'dispose' } );

    	}

    } );

    /**
     * @author alteredq / http://alteredqualia.com/
     * @author mrdoob / http://mrdoob.com/
     */

    function BufferGeometry() {

    	Object.defineProperty( this, 'id', { value: GeometryIdCount() } );

    	this.uuid = exports.Math.generateUUID();

    	this.name = '';
    	this.type = 'BufferGeometry';

    	this.index = null;
    	this.attributes = {};

    	this.morphAttributes = {};

    	this.groups = [];

    	this.boundingBox = null;
    	this.boundingSphere = null;

    	this.drawRange = { start: 0, count: Infinity };

    }

    Object.assign( BufferGeometry.prototype, EventDispatcher.prototype, {

    	isBufferGeometry: true,

    	getIndex: function () {

    		return this.index;

    	},

    	setIndex: function ( index ) {

    		this.index = index;

    	},

    	addAttribute: function ( name, attribute ) {

    		if ( (attribute && attribute.isBufferAttribute) === false && (attribute && attribute.isInterleavedBufferAttribute) === false ) {

    			console.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );

    			this.addAttribute( name, new BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );

    			return;

    		}

    		if ( name === 'index' ) {

    			console.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );
    			this.setIndex( attribute );

    			return;

    		}

    		this.attributes[ name ] = attribute;

    		return this;

    	},

    	getAttribute: function ( name ) {

    		return this.attributes[ name ];

    	},

    	removeAttribute: function ( name ) {

    		delete this.attributes[ name ];

    		return this;

    	},

    	addGroup: function ( start, count, materialIndex ) {

    		this.groups.push( {

    			start: start,
    			count: count,
    			materialIndex: materialIndex !== undefined ? materialIndex : 0

    		} );

    	},

    	clearGroups: function () {

    		this.groups = [];

    	},

    	setDrawRange: function ( start, count ) {

    		this.drawRange.start = start;
    		this.drawRange.count = count;

    	},

    	applyMatrix: function ( matrix ) {

    		var position = this.attributes.position;

    		if ( position !== undefined ) {

    			matrix.applyToVector3Array( position.array );
    			position.needsUpdate = true;

    		}

    		var normal = this.attributes.normal;

    		if ( normal !== undefined ) {

    			var normalMatrix = new Matrix3().getNormalMatrix( matrix );

    			normalMatrix.applyToVector3Array( normal.array );
    			normal.needsUpdate = true;

    		}

    		if ( this.boundingBox !== null ) {

    			this.computeBoundingBox();

    		}

    		if ( this.boundingSphere !== null ) {

    			this.computeBoundingSphere();

    		}

    		return this;

    	},

    	rotateX: function () {

    		// rotate geometry around world x-axis

    		var m1;

    		return function rotateX( angle ) {

    			if ( m1 === undefined ) m1 = new Matrix4();

    			m1.makeRotationX( angle );

    			this.applyMatrix( m1 );

    			return this;

    		};

    	}(),

    	rotateY: function () {

    		// rotate geometry around world y-axis

    		var m1;

    		return function rotateY( angle ) {

    			if ( m1 === undefined ) m1 = new Matrix4();

    			m1.makeRotationY( angle );

    			this.applyMatrix( m1 );

    			return this;

    		};

    	}(),

    	rotateZ: function () {

    		// rotate geometry around world z-axis

    		var m1;

    		return function rotateZ( angle ) {

    			if ( m1 === undefined ) m1 = new Matrix4();

    			m1.makeRotationZ( angle );

    			this.applyMatrix( m1 );

    			return this;

    		};

    	}(),

    	translate: function () {

    		// translate geometry

    		var m1;

    		return function translate( x, y, z ) {

    			if ( m1 === undefined ) m1 = new Matrix4();

    			m1.makeTranslation( x, y, z );

    			this.applyMatrix( m1 );

    			return this;

    		};

    	}(),

    	scale: function () {

    		// scale geometry

    		var m1;

    		return function scale( x, y, z ) {

    			if ( m1 === undefined ) m1 = new Matrix4();

    			m1.makeScale( x, y, z );

    			this.applyMatrix( m1 );

    			return this;

    		};

    	}(),

    	lookAt: function () {

    		var obj;

    		return function lookAt( vector ) {

    			if ( obj === undefined ) obj = new Object3D();

    			obj.lookAt( vector );

    			obj.updateMatrix();

    			this.applyMatrix( obj.matrix );

    		};

    	}(),

    	center: function () {

    		this.computeBoundingBox();

    		var offset = this.boundingBox.getCenter().negate();

    		this.translate( offset.x, offset.y, offset.z );

    		return offset;

    	},

    	setFromObject: function ( object ) {

    		// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );

    		var geometry = object.geometry;

    		if ( (object && object.isPoints) || (object && object.isLine) ) {

    			var positions = new Float32Attribute( geometry.vertices.length * 3, 3 );
    			var colors = new Float32Attribute( geometry.colors.length * 3, 3 );

    			this.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );
    			this.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );

    			if ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {

    				var lineDistances = new Float32Attribute( geometry.lineDistances.length, 1 );

    				this.addAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );

    			}

    			if ( geometry.boundingSphere !== null ) {

    				this.boundingSphere = geometry.boundingSphere.clone();

    			}

    			if ( geometry.boundingBox !== null ) {

    				this.boundingBox = geometry.boundingBox.clone();

    			}

    		} else if ( (object && object.isMesh) ) {

    			if ( (geometry && geometry.isGeometry) ) {

    				this.fromGeometry( geometry );

    			}

    		}

    		return this;

    	},

    	updateFromObject: function ( object ) {

    		var geometry = object.geometry;

    		if ( (object && object.isMesh) ) {

    			var direct = geometry.__directGeometry;

    			if ( geometry.elementsNeedUpdate === true ) {

    				direct = undefined;
    				geometry.elementsNeedUpdate = false;

    			}

    			if ( direct === undefined ) {

    				return this.fromGeometry( geometry );

    			}

    			direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
    			direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
    			direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
    			direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
    			direct.groupsNeedUpdate = geometry.groupsNeedUpdate;

    			geometry.verticesNeedUpdate = false;
    			geometry.normalsNeedUpdate = false;
    			geometry.colorsNeedUpdate = false;
    			geometry.uvsNeedUpdate = false;
    			geometry.groupsNeedUpdate = false;

    			geometry = direct;

    		}

    		var attribute;

    		if ( geometry.verticesNeedUpdate === true ) {

    			attribute = this.attributes.position;

    			if ( attribute !== undefined ) {

    				attribute.copyVector3sArray( geometry.vertices );
    				attribute.needsUpdate = true;

    			}

    			geometry.verticesNeedUpdate = false;

    		}

    		if ( geometry.normalsNeedUpdate === true ) {

    			attribute = this.attributes.normal;

    			if ( attribute !== undefined ) {

    				attribute.copyVector3sArray( geometry.normals );
    				attribute.needsUpdate = true;

    			}

    			geometry.normalsNeedUpdate = false;

    		}

    		if ( geometry.colorsNeedUpdate === true ) {

    			attribute = this.attributes.color;

    			if ( attribute !== undefined ) {

    				attribute.copyColorsArray( geometry.colors );
    				attribute.needsUpdate = true;

    			}

    			geometry.colorsNeedUpdate = false;

    		}

    		if ( geometry.uvsNeedUpdate ) {

    			attribute = this.attributes.uv;

    			if ( attribute !== undefined ) {

    				attribute.copyVector2sArray( geometry.uvs );
    				attribute.needsUpdate = true;

    			}

    			geometry.uvsNeedUpdate = false;

    		}

    		if ( geometry.lineDistancesNeedUpdate ) {

    			attribute = this.attributes.lineDistance;

    			if ( attribute !== undefined ) {

    				attribute.copyArray( geometry.lineDistances );
    				attribute.needsUpdate = true;

    			}

    			geometry.lineDistancesNeedUpdate = false;

    		}

    		if ( geometry.groupsNeedUpdate ) {

    			geometry.computeGroups( object.geometry );
    			this.groups = geometry.groups;

    			geometry.groupsNeedUpdate = false;

    		}

    		return this;

    	},

    	fromGeometry: function ( geometry ) {

    		geometry.__directGeometry = new DirectGeometry().fromGeometry( geometry );

    		return this.fromDirectGeometry( geometry.__directGeometry );

    	},

    	fromDirectGeometry: function ( geometry ) {

    		var positions = new Float32Array( geometry.vertices.length * 3 );
    		this.addAttribute( 'position', new BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );

    		if ( geometry.normals.length > 0 ) {

    			var normals = new Float32Array( geometry.normals.length * 3 );
    			this.addAttribute( 'normal', new BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );

    		}

    		if ( geometry.colors.length > 0 ) {

    			var colors = new Float32Array( geometry.colors.length * 3 );
    			this.addAttribute( 'color', new BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );

    		}

    		if ( geometry.uvs.length > 0 ) {

    			var uvs = new Float32Array( geometry.uvs.length * 2 );
    			this.addAttribute( 'uv', new BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );

    		}

    		if ( geometry.uvs2.length > 0 ) {

    			var uvs2 = new Float32Array( geometry.uvs2.length * 2 );
    			this.addAttribute( 'uv2', new BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );

    		}

    		if ( geometry.indices.length > 0 ) {

    			var TypeArray = geometry.vertices.length > 65535 ? Uint32Array : Uint16Array;
    			var indices = new TypeArray( geometry.indices.length * 3 );
    			this.setIndex( new BufferAttribute( indices, 1 ).copyIndicesArray( geometry.indices ) );

    		}

    		// groups

    		this.groups = geometry.groups;

    		// morphs

    		for ( var name in geometry.morphTargets ) {

    			var array = [];
    			var morphTargets = geometry.morphTargets[ name ];

    			for ( var i = 0, l = morphTargets.length; i < l; i ++ ) {

    				var morphTarget = morphTargets[ i ];

    				var attribute = new Float32Attribute( morphTarget.length * 3, 3 );

    				array.push( attribute.copyVector3sArray( morphTarget ) );

    			}

    			this.morphAttributes[ name ] = array;

    		}

    		// skinning

    		if ( geometry.skinIndices.length > 0 ) {

    			var skinIndices = new Float32Attribute( geometry.skinIndices.length * 4, 4 );
    			this.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );

    		}

    		if ( geometry.skinWeights.length > 0 ) {

    			var skinWeights = new Float32Attribute( geometry.skinWeights.length * 4, 4 );
    			this.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );

    		}

    		//

    		if ( geometry.boundingSphere !== null ) {

    			this.boundingSphere = geometry.boundingSphere.clone();

    		}

    		if ( geometry.boundingBox !== null ) {

    			this.boundingBox = geometry.boundingBox.clone();

    		}

    		return this;

    	},

    	computeBoundingBox: function () {

    		if ( this.boundingBox === null ) {

    			this.boundingBox = new Box3();

    		}

    		var positions = this.attributes.position.array;

    		if ( positions !== undefined ) {

    			this.boundingBox.setFromArray( positions );

    		} else {

    			this.boundingBox.makeEmpty();

    		}

    		if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {

    			console.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );

    		}

    	},

    	computeBoundingSphere: function () {

    		var box = new Box3();
    		var vector = new Vector3();

    		return function computeBoundingSphere() {

    			if ( this.boundingSphere === null ) {

    				this.boundingSphere = new Sphere();

    			}

    			var positions = this.attributes.position;

    			if ( positions ) {

    				var array = positions.array;
    				var center = this.boundingSphere.center;

    				box.setFromArray( array );
    				box.getCenter( center );

    				// hoping to find a boundingSphere with a radius smaller than the
    				// boundingSphere of the boundingBox: sqrt(3) smaller in the best case

    				var maxRadiusSq = 0;

    				for ( var i = 0, il = array.length; i < il; i += 3 ) {

    					vector.fromArray( array, i );
    					maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );

    				}

    				this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

    				if ( isNaN( this.boundingSphere.radius ) ) {

    					console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );

    				}

    			}

    		};

    	}(),

    	computeFaceNormals: function () {

    		// backwards compatibility

    	},

    	computeVertexNormals: function () {

    		var index = this.index;
    		var attributes = this.attributes;
    		var groups = this.groups;

    		if ( attributes.position ) {

    			var positions = attributes.position.array;

    			if ( attributes.normal === undefined ) {

    				this.addAttribute( 'normal', new BufferAttribute( new Float32Array( positions.length ), 3 ) );

    			} else {

    				// reset existing normals to zero

    				var array = attributes.normal.array;

    				for ( var i = 0, il = array.length; i < il; i ++ ) {

    					array[ i ] = 0;

    				}

    			}

    			var normals = attributes.normal.array;

    			var vA, vB, vC,

    			pA = new Vector3(),
    			pB = new Vector3(),
    			pC = new Vector3(),

    			cb = new Vector3(),
    			ab = new Vector3();

    			// indexed elements

    			if ( index ) {

    				var indices = index.array;

    				if ( groups.length === 0 ) {

    					this.addGroup( 0, indices.length );

    				}

    				for ( var j = 0, jl = groups.length; j < jl; ++ j ) {

    					var group = groups[ j ];

    					var start = group.start;
    					var count = group.count;

    					for ( var i = start, il = start + count; i < il; i += 3 ) {

    						vA = indices[ i + 0 ] * 3;
    						vB = indices[ i + 1 ] * 3;
    						vC = indices[ i + 2 ] * 3;

    						pA.fromArray( positions, vA );
    						pB.fromArray( positions, vB );
    						pC.fromArray( positions, vC );

    						cb.subVectors( pC, pB );
    						ab.subVectors( pA, pB );
    						cb.cross( ab );

    						normals[ vA ] += cb.x;
    						normals[ vA + 1 ] += cb.y;
    						normals[ vA + 2 ] += cb.z;

    						normals[ vB ] += cb.x;
    						normals[ vB + 1 ] += cb.y;
    						normals[ vB + 2 ] += cb.z;

    						normals[ vC ] += cb.x;
    						normals[ vC + 1 ] += cb.y;
    						normals[ vC + 2 ] += cb.z;

    					}

    				}

    			} else {

    				// non-indexed elements (unconnected triangle soup)

    				for ( var i = 0, il = positions.length; i < il; i += 9 ) {

    					pA.fromArray( positions, i );
    					pB.fromArray( positions, i + 3 );
    					pC.fromArray( positions, i + 6 );

    					cb.subVectors( pC, pB );
    					ab.subVectors( pA, pB );
    					cb.cross( ab );

    					normals[ i ] = cb.x;
    					normals[ i + 1 ] = cb.y;
    					normals[ i + 2 ] = cb.z;

    					normals[ i + 3 ] = cb.x;
    					normals[ i + 4 ] = cb.y;
    					normals[ i + 5 ] = cb.z;

    					normals[ i + 6 ] = cb.x;
    					normals[ i + 7 ] = cb.y;
    					normals[ i + 8 ] = cb.z;

    				}

    			}

    			this.normalizeNormals();

    			attributes.normal.needsUpdate = true;

    		}

    	},

    	merge: function ( geometry, offset ) {

    		if ( (geometry && geometry.isBufferGeometry) === false ) {

    			console.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );
    			return;

    		}

    		if ( offset === undefined ) offset = 0;

    		var attributes = this.attributes;

    		for ( var key in attributes ) {

    			if ( geometry.attributes[ key ] === undefined ) continue;

    			var attribute1 = attributes[ key ];
    			var attributeArray1 = attribute1.array;

    			var attribute2 = geometry.attributes[ key ];
    			var attributeArray2 = attribute2.array;

    			var attributeSize = attribute2.itemSize;

    			for ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {

    				attributeArray1[ j ] = attributeArray2[ i ];

    			}

    		}

    		return this;

    	},

    	normalizeNormals: function () {

    		var normals = this.attributes.normal.array;

    		var x, y, z, n;

    		for ( var i = 0, il = normals.length; i < il; i += 3 ) {

    			x = normals[ i ];
    			y = normals[ i + 1 ];
    			z = normals[ i + 2 ];

    			n = 1.0 / Math.sqrt( x * x + y * y + z * z );

    			normals[ i ] *= n;
    			normals[ i + 1 ] *= n;
    			normals[ i + 2 ] *= n;

    		}

    	},

    	toNonIndexed: function () {

    		if ( this.index === null ) {

    			console.warn( 'THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' );
    			return this;

    		}

    		var geometry2 = new BufferGeometry();

    		var indices = this.index.array;
    		var attributes = this.attributes;

    		for ( var name in attributes ) {

    			var attribute = attributes[ name ];

    			var array = attribute.array;
    			var itemSize = attribute.itemSize;

    			var array2 = new array.constructor( indices.length * itemSize );

    			var index = 0, index2 = 0;

    			for ( var i = 0, l = indices.length; i < l; i ++ ) {

    				index = indices[ i ] * itemSize;

    				for ( var j = 0; j < itemSize; j ++ ) {

    					array2[ index2 ++ ] = array[ index ++ ];

    				}

    			}

    			geometry2.addAttribute( name, new BufferAttribute( array2, itemSize ) );

    		}

    		return geometry2;

    	},

    	toJSON: function () {

    		var data = {
    			metadata: {
    				version: 4.4,
    				type: 'BufferGeometry',
    				generator: 'BufferGeometry.toJSON'
    			}
    		};

    		// standard BufferGeometry serialization

    		data.uuid = this.uuid;
    		data.type = this.type;
    		if ( this.name !== '' ) data.name = this.name;

    		if ( this.parameters !== undefined ) {

    			var parameters = this.parameters;

    			for ( var key in parameters ) {

    				if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

    			}

    			return data;

    		}

    		data.data = { attributes: {} };

    		var index = this.index;

    		if ( index !== null ) {

    			var array = Array.prototype.slice.call( index.array );

    			data.data.index = {
    				type: index.array.constructor.name,
    				array: array
    			};

    		}

    		var attributes = this.attributes;

    		for ( var key in attributes ) {

    			var attribute = attributes[ key ];

    			var array = Array.prototype.slice.call( attribute.array );

    			data.data.attributes[ key ] = {
    				itemSize: attribute.itemSize,
    				type: attribute.array.constructor.name,
    				array: array,
    				normalized: attribute.normalized
    			};

    		}

    		var groups = this.groups;

    		if ( groups.length > 0 ) {

    			data.data.groups = JSON.parse( JSON.stringify( groups ) );

    		}

    		var boundingSphere = this.boundingSphere;

    		if ( boundingSphere !== null ) {

    			data.data.boundingSphere = {
    				center: boundingSphere.center.toArray(),
    				radius: boundingSphere.radius
    			};

    		}

    		return data;

    	},

    	clone: function () {

    		/*
    		// Handle primitives

    		var parameters = this.parameters;

    		if ( parameters !== undefined ) {

    			var values = [];

    			for ( var key in parameters ) {

    				values.push( parameters[ key ] );

    			}

    			var geometry = Object.create( this.constructor.prototype );
    			this.constructor.apply( geometry, values );
    			return geometry;

    		}

    		return new this.constructor().copy( this );
    		*/

    		return new BufferGeometry().copy( this );

    	},

    	copy: function ( source ) {

    		var index = source.index;

    		if ( index !== null ) {

    			this.setIndex( index.clone() );

    		}

    		var attributes = source.attributes;

    		for ( var name in attributes ) {

    			var attribute = attributes[ name ];
    			this.addAttribute( name, attribute.clone() );

    		}

    		var groups = source.groups;

    		for ( var i = 0, l = groups.length; i < l; i ++ ) {

    			var group = groups[ i ];
    			this.addGroup( group.start, group.count, group.materialIndex );

    		}

    		return this;

    	},

    	dispose: function () {

    		this.dispatchEvent( { type: 'dispose' } );

    	}

    } );

    BufferGeometry.MaxIndex = 65535;

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     * @author mikael emtinger / http://gomo.se/
     * @author jonobr1 / http://jonobr1.com/
     */

    function Mesh( geometry, material ) {

    	Object3D.call( this );

    	this.type = 'Mesh';

    	this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
    	this.material = material !== undefined ? material : new MeshBasicMaterial( { color: Math.random() * 0xffffff } );

    	this.drawMode = TrianglesDrawMode;

    	this.updateMorphTargets();

    }

    Mesh.prototype = Object.assign( Object.create( Object3D.prototype ), {

    	constructor: Mesh,

    	isMesh: true,

    	setDrawMode: function ( value ) {

    		this.drawMode = value;

    	},

    	copy: function ( source ) {

    		Object3D.prototype.copy.call( this, source );

    		this.drawMode = source.drawMode;

    		return this;

    	},

    	updateMorphTargets: function () {

    		var morphTargets = this.geometry.morphTargets;

    		if ( morphTargets !== undefined && morphTargets.length > 0 ) {

    			this.morphTargetInfluences = [];
    			this.morphTargetDictionary = {};

    			for ( var m = 0, ml = morphTargets.length; m < ml; m ++ ) {

    				this.morphTargetInfluences.push( 0 );
    				this.morphTargetDictionary[ morphTargets[ m ].name ] = m;

    			}

    		}

    	},

    	raycast: ( function () {

    		var inverseMatrix = new Matrix4();
    		var ray = new Ray();
    		var sphere = new Sphere();

    		var vA = new Vector3();
    		var vB = new Vector3();
    		var vC = new Vector3();

    		var tempA = new Vector3();
    		var tempB = new Vector3();
    		var tempC = new Vector3();

    		var uvA = new Vector2();
    		var uvB = new Vector2();
    		var uvC = new Vector2();

    		var barycoord = new Vector3();

    		var intersectionPoint = new Vector3();
    		var intersectionPointWorld = new Vector3();

    		function uvIntersection( point, p1, p2, p3, uv1, uv2, uv3 ) {

    			Triangle.barycoordFromPoint( point, p1, p2, p3, barycoord );

    			uv1.multiplyScalar( barycoord.x );
    			uv2.multiplyScalar( barycoord.y );
    			uv3.multiplyScalar( barycoord.z );

    			uv1.add( uv2 ).add( uv3 );

    			return uv1.clone();

    		}

    		function checkIntersection( object, raycaster, ray, pA, pB, pC, point ) {

    			var intersect;
    			var material = object.material;

    			if ( material.side === BackSide ) {

    				intersect = ray.intersectTriangle( pC, pB, pA, true, point );

    			} else {

    				intersect = ray.intersectTriangle( pA, pB, pC, material.side !== DoubleSide, point );

    			}

    			if ( intersect === null ) return null;

    			intersectionPointWorld.copy( point );
    			intersectionPointWorld.applyMatrix4( object.matrixWorld );

    			var distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );

    			if ( distance < raycaster.near || distance > raycaster.far ) return null;

    			return {
    				distance: distance,
    				point: intersectionPointWorld.clone(),
    				object: object
    			};

    		}

    		function checkBufferGeometryIntersection( object, raycaster, ray, positions, uvs, a, b, c ) {

    			vA.fromArray( positions, a * 3 );
    			vB.fromArray( positions, b * 3 );
    			vC.fromArray( positions, c * 3 );

    			var intersection = checkIntersection( object, raycaster, ray, vA, vB, vC, intersectionPoint );

    			if ( intersection ) {

    				if ( uvs ) {

    					uvA.fromArray( uvs, a * 2 );
    					uvB.fromArray( uvs, b * 2 );
    					uvC.fromArray( uvs, c * 2 );

    					intersection.uv = uvIntersection( intersectionPoint,  vA, vB, vC,  uvA, uvB, uvC );

    				}

    				intersection.face = new Face3( a, b, c, Triangle.normal( vA, vB, vC ) );
    				intersection.faceIndex = a;

    			}

    			return intersection;

    		}

    		return function raycast( raycaster, intersects ) {

    			var geometry = this.geometry;
    			var material = this.material;
    			var matrixWorld = this.matrixWorld;

    			if ( material === undefined ) return;

    			// Checking boundingSphere distance to ray

    			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

    			sphere.copy( geometry.boundingSphere );
    			sphere.applyMatrix4( matrixWorld );

    			if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;

    			//

    			inverseMatrix.getInverse( matrixWorld );
    			ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

    			// Check boundingBox before continuing

    			if ( geometry.boundingBox !== null ) {

    				if ( ray.intersectsBox( geometry.boundingBox ) === false ) return;

    			}

    			var uvs, intersection;

    			if ( (geometry && geometry.isBufferGeometry) ) {

    				var a, b, c;
    				var index = geometry.index;
    				var attributes = geometry.attributes;
    				var positions = attributes.position.array;

    				if ( attributes.uv !== undefined ) {

    					uvs = attributes.uv.array;

    				}

    				if ( index !== null ) {

    					var indices = index.array;

    					for ( var i = 0, l = indices.length; i < l; i += 3 ) {

    						a = indices[ i ];
    						b = indices[ i + 1 ];
    						c = indices[ i + 2 ];

    						intersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );

    						if ( intersection ) {

    							intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indices buffer semantics
    							intersects.push( intersection );

    						}

    					}

    				} else {


    					for ( var i = 0, l = positions.length; i < l; i += 9 ) {

    						a = i / 3;
    						b = a + 1;
    						c = a + 2;

    						intersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );

    						if ( intersection ) {

    							intersection.index = a; // triangle number in positions buffer semantics
    							intersects.push( intersection );

    						}

    					}

    				}

    			} else if ( (geometry && geometry.isGeometry) ) {

    				var fvA, fvB, fvC;
    				var isFaceMaterial = (material && material.isMultiMaterial);
    				var materials = isFaceMaterial === true ? material.materials : null;

    				var vertices = geometry.vertices;
    				var faces = geometry.faces;
    				var faceVertexUvs = geometry.faceVertexUvs[ 0 ];
    				if ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;

    				for ( var f = 0, fl = faces.length; f < fl; f ++ ) {

    					var face = faces[ f ];
    					var faceMaterial = isFaceMaterial === true ? materials[ face.materialIndex ] : material;

    					if ( faceMaterial === undefined ) continue;

    					fvA = vertices[ face.a ];
    					fvB = vertices[ face.b ];
    					fvC = vertices[ face.c ];

    					if ( faceMaterial.morphTargets === true ) {

    						var morphTargets = geometry.morphTargets;
    						var morphInfluences = this.morphTargetInfluences;

    						vA.set( 0, 0, 0 );
    						vB.set( 0, 0, 0 );
    						vC.set( 0, 0, 0 );

    						for ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {

    							var influence = morphInfluences[ t ];

    							if ( influence === 0 ) continue;

    							var targets = morphTargets[ t ].vertices;

    							vA.addScaledVector( tempA.subVectors( targets[ face.a ], fvA ), influence );
    							vB.addScaledVector( tempB.subVectors( targets[ face.b ], fvB ), influence );
    							vC.addScaledVector( tempC.subVectors( targets[ face.c ], fvC ), influence );

    						}

    						vA.add( fvA );
    						vB.add( fvB );
    						vC.add( fvC );

    						fvA = vA;
    						fvB = vB;
    						fvC = vC;

    					}

    					intersection = checkIntersection( this, raycaster, ray, fvA, fvB, fvC, intersectionPoint );

    					if ( intersection ) {

    						if ( uvs ) {

    							var uvs_f = uvs[ f ];
    							uvA.copy( uvs_f[ 0 ] );
    							uvB.copy( uvs_f[ 1 ] );
    							uvC.copy( uvs_f[ 2 ] );

    							intersection.uv = uvIntersection( intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC );

    						}

    						intersection.face = face;
    						intersection.faceIndex = f;
    						intersects.push( intersection );

    					}

    				}

    			}

    		};

    	}() ),

    	clone: function () {

    		return new this.constructor( this.geometry, this.material ).copy( this );

    	}

    } );

    /**
     * @author Mugen87 / https://github.com/Mugen87
     */

    function BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {

    	BufferGeometry.call( this );

    	this.type = 'BoxBufferGeometry';

    	this.parameters = {
    		width: width,
    		height: height,
    		depth: depth,
    		widthSegments: widthSegments,
    		heightSegments: heightSegments,
    		depthSegments: depthSegments
    	};

    	var scope = this;

    	// segments
    	widthSegments = Math.floor( widthSegments ) || 1;
    	heightSegments = Math.floor( heightSegments ) || 1;
    	depthSegments = Math.floor( depthSegments ) || 1;

    	// these are used to calculate buffer length
    	var vertexCount = calculateVertexCount( widthSegments, heightSegments, depthSegments );
    	var indexCount = calculateIndexCount( widthSegments, heightSegments, depthSegments );

    	// buffers
    	var indices = new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount );
    	var vertices = new Float32Array( vertexCount * 3 );
    	var normals = new Float32Array( vertexCount * 3 );
    	var uvs = new Float32Array( vertexCount * 2 );

    	// offset variables
    	var vertexBufferOffset = 0;
    	var uvBufferOffset = 0;
    	var indexBufferOffset = 0;
    	var numberOfVertices = 0;

    	// group variables
    	var groupStart = 0;

    	// build each side of the box geometry
    	buildPlane( 'z', 'y', 'x', - 1, - 1, depth, height,   width,  depthSegments, heightSegments, 0 ); // px
    	buildPlane( 'z', 'y', 'x',   1, - 1, depth, height, - width,  depthSegments, heightSegments, 1 ); // nx
    	buildPlane( 'x', 'z', 'y',   1,   1, width, depth,    height, widthSegments, depthSegments,  2 ); // py
    	buildPlane( 'x', 'z', 'y',   1, - 1, width, depth,  - height, widthSegments, depthSegments,  3 ); // ny
    	buildPlane( 'x', 'y', 'z',   1, - 1, width, height,   depth,  widthSegments, heightSegments, 4 ); // pz
    	buildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth,  widthSegments, heightSegments, 5 ); // nz

    	// build geometry
    	this.setIndex( new BufferAttribute( indices, 1 ) );
    	this.addAttribute( 'position', new BufferAttribute( vertices, 3 ) );
    	this.addAttribute( 'normal', new BufferAttribute( normals, 3 ) );
    	this.addAttribute( 'uv', new BufferAttribute( uvs, 2 ) );

    	// helper functions

    	function calculateVertexCount( w, h, d ) {

    		var vertices = 0;

    		// calculate the amount of vertices for each side (plane)
    		vertices += (w + 1) * (h + 1) * 2; // xy
    		vertices += (w + 1) * (d + 1) * 2; // xz
    		vertices += (d + 1) * (h + 1) * 2; // zy

    		return vertices;

    	}

    	function calculateIndexCount( w, h, d ) {

    		var index = 0;

    		// calculate the amount of squares for each side
    		index += w * h * 2; // xy
    		index += w * d * 2; // xz
    		index += d * h * 2; // zy

    		return index * 6; // two triangles per square => six vertices per square

    	}

    	function buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {

    		var segmentWidth	= width / gridX;
    		var segmentHeight = height / gridY;

    		var widthHalf = width / 2;
    		var heightHalf = height / 2;
    		var depthHalf = depth / 2;

    		var gridX1 = gridX + 1;
    		var gridY1 = gridY + 1;

    		var vertexCounter = 0;
    		var groupCount = 0;

    		var vector = new Vector3();

    		// generate vertices, normals and uvs

    		for ( var iy = 0; iy < gridY1; iy ++ ) {

    			var y = iy * segmentHeight - heightHalf;

    			for ( var ix = 0; ix < gridX1; ix ++ ) {

    				var x = ix * segmentWidth - widthHalf;

    				// set values to correct vector component
    				vector[ u ] = x * udir;
    				vector[ v ] = y * vdir;
    				vector[ w ] = depthHalf;

    				// now apply vector to vertex buffer
    				vertices[ vertexBufferOffset ] = vector.x;
    				vertices[ vertexBufferOffset + 1 ] = vector.y;
    				vertices[ vertexBufferOffset + 2 ] = vector.z;

    				// set values to correct vector component
    				vector[ u ] = 0;
    				vector[ v ] = 0;
    				vector[ w ] = depth > 0 ? 1 : - 1;

    				// now apply vector to normal buffer
    				normals[ vertexBufferOffset ] = vector.x;
    				normals[ vertexBufferOffset + 1 ] = vector.y;
    				normals[ vertexBufferOffset + 2 ] = vector.z;

    				// uvs
    				uvs[ uvBufferOffset ] = ix / gridX;
    				uvs[ uvBufferOffset + 1 ] = 1 - ( iy / gridY );

    				// update offsets and counters
    				vertexBufferOffset += 3;
    				uvBufferOffset += 2;
    				vertexCounter += 1;

    			}

    		}

    		// 1. you need three indices to draw a single face
    		// 2. a single segment consists of two faces
    		// 3. so we need to generate six (2*3) indices per segment

    		for ( iy = 0; iy < gridY; iy ++ ) {

    			for ( ix = 0; ix < gridX; ix ++ ) {

    				// indices
    				var a = numberOfVertices + ix + gridX1 * iy;
    				var b = numberOfVertices + ix + gridX1 * ( iy + 1 );
    				var c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );
    				var d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;

    				// face one
    				indices[ indexBufferOffset ] = a;
    				indices[ indexBufferOffset + 1 ] = b;
    				indices[ indexBufferOffset + 2 ] = d;

    				// face two
    				indices[ indexBufferOffset + 3 ] = b;
    				indices[ indexBufferOffset + 4 ] = c;
    				indices[ indexBufferOffset + 5 ] = d;

    				// update offsets and counters
    				indexBufferOffset += 6;
    				groupCount += 6;

    			}

    		}

    		// add a group to the geometry. this will ensure multi material support
    		scope.addGroup( groupStart, groupCount, materialIndex );

    		// calculate new start value for groups
    		groupStart += groupCount;

    		// update total number of vertices
    		numberOfVertices += vertexCounter;

    	}

    }

    BoxBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
    BoxBufferGeometry.prototype.constructor = BoxBufferGeometry;

    /**
     * @author mrdoob / http://mrdoob.com/
     * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
     */

    function PlaneBufferGeometry( width, height, widthSegments, heightSegments ) {

    	BufferGeometry.call( this );

    	this.type = 'PlaneBufferGeometry';

    	this.parameters = {
    		width: width,
    		height: height,
    		widthSegments: widthSegments,
    		heightSegments: heightSegments
    	};

    	var width_half = width / 2;
    	var height_half = height / 2;

    	var gridX = Math.floor( widthSegments ) || 1;
    	var gridY = Math.floor( heightSegments ) || 1;

    	var gridX1 = gridX + 1;
    	var gridY1 = gridY + 1;

    	var segment_width = width / gridX;
    	var segment_height = height / gridY;

    	var vertices = new Float32Array( gridX1 * gridY1 * 3 );
    	var normals = new Float32Array( gridX1 * gridY1 * 3 );
    	var uvs = new Float32Array( gridX1 * gridY1 * 2 );

    	var offset = 0;
    	var offset2 = 0;

    	for ( var iy = 0; iy < gridY1; iy ++ ) {

    		var y = iy * segment_height - height_half;

    		for ( var ix = 0; ix < gridX1; ix ++ ) {

    			var x = ix * segment_width - width_half;

    			vertices[ offset ] = x;
    			vertices[ offset + 1 ] = - y;

    			normals[ offset + 2 ] = 1;

    			uvs[ offset2 ] = ix / gridX;
    			uvs[ offset2 + 1 ] = 1 - ( iy / gridY );

    			offset += 3;
    			offset2 += 2;

    		}

    	}

    	offset = 0;

    	var indices = new ( ( vertices.length / 3 ) > 65535 ? Uint32Array : Uint16Array )( gridX * gridY * 6 );

    	for ( var iy = 0; iy < gridY; iy ++ ) {

    		for ( var ix = 0; ix < gridX; ix ++ ) {

    			var a = ix + gridX1 * iy;
    			var b = ix + gridX1 * ( iy + 1 );
    			var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
    			var d = ( ix + 1 ) + gridX1 * iy;

    			indices[ offset ] = a;
    			indices[ offset + 1 ] = b;
    			indices[ offset + 2 ] = d;

    			indices[ offset + 3 ] = b;
    			indices[ offset + 4 ] = c;
    			indices[ offset + 5 ] = d;

    			offset += 6;

    		}

    	}

    	this.setIndex( new BufferAttribute( indices, 1 ) );
    	this.addAttribute( 'position', new BufferAttribute( vertices, 3 ) );
    	this.addAttribute( 'normal', new BufferAttribute( normals, 3 ) );
    	this.addAttribute( 'uv', new BufferAttribute( uvs, 2 ) );

    }

    PlaneBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
    PlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author mikael emtinger / http://gomo.se/
     * @author WestLangley / http://github.com/WestLangley
    */

    function Camera() {

    	Object3D.call( this );

    	this.type = 'Camera';

    	this.matrixWorldInverse = new Matrix4();
    	this.projectionMatrix = new Matrix4();

    }

    Camera.prototype = Object.create( Object3D.prototype );
    Camera.prototype.constructor = Camera;

    Camera.prototype.isCamera = true;

    Camera.prototype.getWorldDirection = function () {

    	var quaternion = new Quaternion();

    	return function getWorldDirection( optionalTarget ) {

    		var result = optionalTarget || new Vector3();

    		this.getWorldQuaternion( quaternion );

    		return result.set( 0, 0, - 1 ).applyQuaternion( quaternion );

    	};

    }();

    Camera.prototype.lookAt = function () {

    	// This routine does not support cameras with rotated and/or translated parent(s)

    	var m1 = new Matrix4();

    	return function lookAt( vector ) {

    		m1.lookAt( this.position, vector, this.up );

    		this.quaternion.setFromRotationMatrix( m1 );

    	};

    }();

    Camera.prototype.clone = function () {

    	return new this.constructor().copy( this );

    };

    Camera.prototype.copy = function ( source ) {

    	Object3D.prototype.copy.call( this, source );

    	this.matrixWorldInverse.copy( source.matrixWorldInverse );
    	this.projectionMatrix.copy( source.projectionMatrix );

    	return this;

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author greggman / http://games.greggman.com/
     * @author zz85 / http://www.lab4games.net/zz85/blog
     * @author tschw
     */

    function PerspectiveCamera( fov, aspect, near, far ) {

    	Camera.call( this );

    	this.type = 'PerspectiveCamera';

    	this.fov = fov !== undefined ? fov : 50;
    	this.zoom = 1;

    	this.near = near !== undefined ? near : 0.1;
    	this.far = far !== undefined ? far : 2000;
    	this.focus = 10;

    	this.aspect = aspect !== undefined ? aspect : 1;
    	this.view = null;

    	this.filmGauge = 35;	// width of the film (default in millimeters)
    	this.filmOffset = 0;	// horizontal film offset (same unit as gauge)

    	this.updateProjectionMatrix();

    }

    PerspectiveCamera.prototype = Object.assign( Object.create( Camera.prototype ), {

    	constructor: PerspectiveCamera,

    	isPerspectiveCamera: true,

    	copy: function ( source ) {

    		Camera.prototype.copy.call( this, source );

    		this.fov = source.fov;
    		this.zoom = source.zoom;

    		this.near = source.near;
    		this.far = source.far;
    		this.focus = source.focus;

    		this.aspect = source.aspect;
    		this.view = source.view === null ? null : Object.assign( {}, source.view );

    		this.filmGauge = source.filmGauge;
    		this.filmOffset = source.filmOffset;

    		return this;

    	},

    	/**
    	 * Sets the FOV by focal length in respect to the current .filmGauge.
    	 *
    	 * The default film gauge is 35, so that the focal length can be specified for
    	 * a 35mm (full frame) camera.
    	 *
    	 * Values for focal length and film gauge must have the same unit.
    	 */
    	setFocalLength: function ( focalLength ) {

    		// see http://www.bobatkins.com/photography/technical/field_of_view.html
    		var vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;

    		this.fov = exports.Math.RAD2DEG * 2 * Math.atan( vExtentSlope );
    		this.updateProjectionMatrix();

    	},

    	/**
    	 * Calculates the focal length from the current .fov and .filmGauge.
    	 */
    	getFocalLength: function () {

    		var vExtentSlope = Math.tan( exports.Math.DEG2RAD * 0.5 * this.fov );

    		return 0.5 * this.getFilmHeight() / vExtentSlope;

    	},

    	getEffectiveFOV: function () {

    		return exports.Math.RAD2DEG * 2 * Math.atan(
    				Math.tan( exports.Math.DEG2RAD * 0.5 * this.fov ) / this.zoom );

    	},

    	getFilmWidth: function () {

    		// film not completely covered in portrait format (aspect < 1)
    		return this.filmGauge * Math.min( this.aspect, 1 );

    	},

    	getFilmHeight: function () {

    		// film not completely covered in landscape format (aspect > 1)
    		return this.filmGauge / Math.max( this.aspect, 1 );

    	},

    	/**
    	 * Sets an offset in a larger frustum. This is useful for multi-window or
    	 * multi-monitor/multi-machine setups.
    	 *
    	 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
    	 * the monitors are in grid like this
    	 *
    	 *   +---+---+---+
    	 *   | A | B | C |
    	 *   +---+---+---+
    	 *   | D | E | F |
    	 *   +---+---+---+
    	 *
    	 * then for each monitor you would call it like this
    	 *
    	 *   var w = 1920;
    	 *   var h = 1080;
    	 *   var fullWidth = w * 3;
    	 *   var fullHeight = h * 2;
    	 *
    	 *   --A--
    	 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
    	 *   --B--
    	 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
    	 *   --C--
    	 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
    	 *   --D--
    	 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
    	 *   --E--
    	 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
    	 *   --F--
    	 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
    	 *
    	 *   Note there is no reason monitors have to be the same size or in a grid.
    	 */
    	setViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {

    		this.aspect = fullWidth / fullHeight;

    		this.view = {
    			fullWidth: fullWidth,
    			fullHeight: fullHeight,
    			offsetX: x,
    			offsetY: y,
    			width: width,
    			height: height
    		};

    		this.updateProjectionMatrix();

    	},

    	clearViewOffset: function() {

    		this.view = null;
    		this.updateProjectionMatrix();

    	},

    	updateProjectionMatrix: function () {

    		var near = this.near,
    			top = near * Math.tan(
    					exports.Math.DEG2RAD * 0.5 * this.fov ) / this.zoom,
    			height = 2 * top,
    			width = this.aspect * height,
    			left = - 0.5 * width,
    			view = this.view;

    		if ( view !== null ) {

    			var fullWidth = view.fullWidth,
    				fullHeight = view.fullHeight;

    			left += view.offsetX * width / fullWidth;
    			top -= view.offsetY * height / fullHeight;
    			width *= view.width / fullWidth;
    			height *= view.height / fullHeight;

    		}

    		var skew = this.filmOffset;
    		if ( skew !== 0 ) left += near * skew / this.getFilmWidth();

    		this.projectionMatrix.makeFrustum(
    				left, left + width, top - height, top, near, this.far );

    	},

    	toJSON: function ( meta ) {

    		var data = Object3D.prototype.toJSON.call( this, meta );

    		data.object.fov = this.fov;
    		data.object.zoom = this.zoom;

    		data.object.near = this.near;
    		data.object.far = this.far;
    		data.object.focus = this.focus;

    		data.object.aspect = this.aspect;

    		if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

    		data.object.filmGauge = this.filmGauge;
    		data.object.filmOffset = this.filmOffset;

    		return data;

    	}

    } );

    /**
     * @author alteredq / http://alteredqualia.com/
     * @author arose / http://github.com/arose
     */

    function OrthographicCamera( left, right, top, bottom, near, far ) {

    	Camera.call( this );

    	this.type = 'OrthographicCamera';

    	this.zoom = 1;
    	this.view = null;

    	this.left = left;
    	this.right = right;
    	this.top = top;
    	this.bottom = bottom;

    	this.near = ( near !== undefined ) ? near : 0.1;
    	this.far = ( far !== undefined ) ? far : 2000;

    	this.updateProjectionMatrix();

    }

    OrthographicCamera.prototype = Object.assign( Object.create( Camera.prototype ), {

    	constructor: OrthographicCamera,

    	isOrthographicCamera: true,

    	copy: function ( source ) {

    		Camera.prototype.copy.call( this, source );

    		this.left = source.left;
    		this.right = source.right;
    		this.top = source.top;
    		this.bottom = source.bottom;
    		this.near = source.near;
    		this.far = source.far;

    		this.zoom = source.zoom;
    		this.view = source.view === null ? null : Object.assign( {}, source.view );

    		return this;

    	},

    	setViewOffset: function( fullWidth, fullHeight, x, y, width, height ) {

    		this.view = {
    			fullWidth: fullWidth,
    			fullHeight: fullHeight,
    			offsetX: x,
    			offsetY: y,
    			width: width,
    			height: height
    		};

    		this.updateProjectionMatrix();

    	},

    	clearViewOffset: function() {

    		this.view = null;
    		this.updateProjectionMatrix();

    	},

    	updateProjectionMatrix: function () {

    		var dx = ( this.right - this.left ) / ( 2 * this.zoom );
    		var dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
    		var cx = ( this.right + this.left ) / 2;
    		var cy = ( this.top + this.bottom ) / 2;

    		var left = cx - dx;
    		var right = cx + dx;
    		var top = cy + dy;
    		var bottom = cy - dy;

    		if ( this.view !== null ) {

    			var zoomW = this.zoom / ( this.view.width / this.view.fullWidth );
    			var zoomH = this.zoom / ( this.view.height / this.view.fullHeight );
    			var scaleW = ( this.right - this.left ) / this.view.width;
    			var scaleH = ( this.top - this.bottom ) / this.view.height;

    			left += scaleW * ( this.view.offsetX / zoomW );
    			right = left + scaleW * ( this.view.width / zoomW );
    			top -= scaleH * ( this.view.offsetY / zoomH );
    			bottom = top - scaleH * ( this.view.height / zoomH );

    		}

    		this.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );

    	},

    	toJSON: function ( meta ) {

    		var data = Object3D.prototype.toJSON.call( this, meta );

    		data.object.zoom = this.zoom;
    		data.object.left = this.left;
    		data.object.right = this.right;
    		data.object.top = this.top;
    		data.object.bottom = this.bottom;
    		data.object.near = this.near;
    		data.object.far = this.far;

    		if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

    		return data;

    	}

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function WebGLIndexedBufferRenderer( gl, extensions, infoRender ) {

    	var mode;

    	function setMode( value ) {

    		mode = value;

    	}

    	var type, size;

    	function setIndex( index ) {

    		if ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {

    			type = gl.UNSIGNED_INT;
    			size = 4;

    		} else {

    			type = gl.UNSIGNED_SHORT;
    			size = 2;

    		}

    	}

    	function render( start, count ) {

    		gl.drawElements( mode, count, type, start * size );

    		infoRender.calls ++;
    		infoRender.vertices += count;

    		if ( mode === gl.TRIANGLES ) infoRender.faces += count / 3;

    	}

    	function renderInstances( geometry, start, count ) {

    		var extension = extensions.get( 'ANGLE_instanced_arrays' );

    		if ( extension === null ) {

    			console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
    			return;

    		}

    		extension.drawElementsInstancedANGLE( mode, count, type, start * size, geometry.maxInstancedCount );

    		infoRender.calls ++;
    		infoRender.vertices += count * geometry.maxInstancedCount;

    		if ( mode === gl.TRIANGLES ) infoRender.faces += geometry.maxInstancedCount * count / 3;

    	}

    	return {

    		setMode: setMode,
    		setIndex: setIndex,
    		render: render,
    		renderInstances: renderInstances

    	};

    }

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function WebGLBufferRenderer( gl, extensions, infoRender ) {

    	var mode;

    	function setMode( value ) {

    		mode = value;

    	}

    	function render( start, count ) {

    		gl.drawArrays( mode, start, count );

    		infoRender.calls ++;
    		infoRender.vertices += count;

    		if ( mode === gl.TRIANGLES ) infoRender.faces += count / 3;

    	}

    	function renderInstances( geometry ) {

    		var extension = extensions.get( 'ANGLE_instanced_arrays' );

    		if ( extension === null ) {

    			console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
    			return;

    		}

    		var position = geometry.attributes.position;

    		var count = 0;

    		if ( (position && position.isInterleavedBufferAttribute) ) {

    			count = position.data.count;

    			extension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );

    		} else {

    			count = position.count;

    			extension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );

    		}

    		infoRender.calls ++;
    		infoRender.vertices += count * geometry.maxInstancedCount;

    		if ( mode === gl.TRIANGLES ) infoRender.faces += geometry.maxInstancedCount * count / 3;

    	}

    	return {
    		setMode: setMode,
    		render: render,
    		renderInstances: renderInstances
    	};

    }

    function WebGLLights() {

    	var lights = {};

    	return {

    		get: function ( light ) {

    			if ( lights[ light.id ] !== undefined ) {

    				return lights[ light.id ];

    			}

    			var uniforms;

    			switch ( light.type ) {

    				case 'DirectionalLight':
    					uniforms = {
    						direction: new Vector3(),
    						color: new Color(),

    						shadow: false,
    						shadowBias: 0,
    						shadowRadius: 1,
    						shadowMapSize: new Vector2()
    					};
    					break;

    				case 'SpotLight':
    					uniforms = {
    						position: new Vector3(),
    						direction: new Vector3(),
    						color: new Color(),
    						distance: 0,
    						coneCos: 0,
    						penumbraCos: 0,
    						decay: 0,

    						shadow: false,
    						shadowBias: 0,
    						shadowRadius: 1,
    						shadowMapSize: new Vector2()
    					};
    					break;

    				case 'PointLight':
    					uniforms = {
    						position: new Vector3(),
    						color: new Color(),
    						distance: 0,
    						decay: 0,

    						shadow: false,
    						shadowBias: 0,
    						shadowRadius: 1,
    						shadowMapSize: new Vector2()
    					};
    					break;

    				case 'HemisphereLight':
    					uniforms = {
    						direction: new Vector3(),
    						skyColor: new Color(),
    						groundColor: new Color()
    					};
    					break;

    			}

    			lights[ light.id ] = uniforms;

    			return uniforms;

    		}

    	};

    }

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function addLineNumbers( string ) {

    	var lines = string.split( '\n' );

    	for ( var i = 0; i < lines.length; i ++ ) {

    		lines[ i ] = ( i + 1 ) + ': ' + lines[ i ];

    	}

    	return lines.join( '\n' );

    }

    function WebGLShader( gl, type, string ) {

    	var shader = gl.createShader( type );

    	gl.shaderSource( shader, string );
    	gl.compileShader( shader );

    	if ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {

    		console.error( 'THREE.WebGLShader: Shader couldn\'t compile.' );

    	}

    	if ( gl.getShaderInfoLog( shader ) !== '' ) {

    		console.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );

    	}

    	// --enable-privileged-webgl-extension
    	// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

    	return shader;

    }

    var programIdCount = 0;

    function getEncodingComponents( encoding ) {

    	switch ( encoding ) {

    		case LinearEncoding:
    			return [ 'Linear','( value )' ];
    		case sRGBEncoding:
    			return [ 'sRGB','( value )' ];
    		case RGBEEncoding:
    			return [ 'RGBE','( value )' ];
    		case RGBM7Encoding:
    			return [ 'RGBM','( value, 7.0 )' ];
    		case RGBM16Encoding:
    			return [ 'RGBM','( value, 16.0 )' ];
    		case RGBDEncoding:
    			return [ 'RGBD','( value, 256.0 )' ];
    		case GammaEncoding:
    			return [ 'Gamma','( value, float( GAMMA_FACTOR ) )' ];
    		default:
    			throw new Error( 'unsupported encoding: ' + encoding );

    	}

    }

    function getTexelDecodingFunction( functionName, encoding ) {

    	var components = getEncodingComponents( encoding );
    	return "vec4 " + functionName + "( vec4 value ) { return " + components[ 0 ] + "ToLinear" + components[ 1 ] + "; }";

    }

    function getTexelEncodingFunction( functionName, encoding ) {

    	var components = getEncodingComponents( encoding );
    	return "vec4 " + functionName + "( vec4 value ) { return LinearTo" + components[ 0 ] + components[ 1 ] + "; }";

    }

    function getToneMappingFunction( functionName, toneMapping ) {

    	var toneMappingName;

    	switch ( toneMapping ) {

    		case LinearToneMapping:
    			toneMappingName = "Linear";
    			break;

    		case ReinhardToneMapping:
    			toneMappingName = "Reinhard";
    			break;

    		case Uncharted2ToneMapping:
    			toneMappingName = "Uncharted2";
    			break;

    		case CineonToneMapping:
    			toneMappingName = "OptimizedCineon";
    			break;

    		default:
    			throw new Error( 'unsupported toneMapping: ' + toneMapping );

    	}

    	return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";

    }

    function generateExtensions( extensions, parameters, rendererExtensions ) {

    	extensions = extensions || {};

    	var chunks = [
    		( extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.normalMap || parameters.flatShading ) ? '#extension GL_OES_standard_derivatives : enable' : '',
    		( extensions.fragDepth || parameters.logarithmicDepthBuffer ) && rendererExtensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',
    		( extensions.drawBuffers ) && rendererExtensions.get( 'WEBGL_draw_buffers' ) ? '#extension GL_EXT_draw_buffers : require' : '',
    		( extensions.shaderTextureLOD || parameters.envMap ) && rendererExtensions.get( 'EXT_shader_texture_lod' ) ? '#extension GL_EXT_shader_texture_lod : enable' : '',
    	];

    	return chunks.filter( filterEmptyLine ).join( '\n' );

    }

    function generateDefines( defines ) {

    	var chunks = [];

    	for ( var name in defines ) {

    		var value = defines[ name ];

    		if ( value === false ) continue;

    		chunks.push( '#define ' + name + ' ' + value );

    	}

    	return chunks.join( '\n' );

    }

    function fetchAttributeLocations( gl, program, identifiers ) {

    	var attributes = {};

    	var n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );

    	for ( var i = 0; i < n; i ++ ) {

    		var info = gl.getActiveAttrib( program, i );
    		var name = info.name;

    		// console.log("THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:", name, i );

    		attributes[ name ] = gl.getAttribLocation( program, name );

    	}

    	return attributes;

    }

    function filterEmptyLine( string ) {

    	return string !== '';

    }

    function replaceLightNums( string, parameters ) {

    	return string
    		.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )
    		.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )
    		.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )
    		.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights );

    }

    function parseIncludes( string ) {

    	var pattern = /#include +<([\w\d.]+)>/g;

    	function replace( match, include ) {

    		var replace = ShaderChunk[ include ];

    		if ( replace === undefined ) {

    			throw new Error( 'Can not resolve #include <' + include + '>' );

    		}

    		return parseIncludes( replace );

    	}

    	return string.replace( pattern, replace );

    }

    function unrollLoops( string ) {

    	var pattern = /for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;

    	function replace( match, start, end, snippet ) {

    		var unroll = '';

    		for ( var i = parseInt( start ); i < parseInt( end ); i ++ ) {

    			unroll += snippet.replace( /\[ i \]/g, '[ ' + i + ' ]' );

    		}

    		return unroll;

    	}

    	return string.replace( pattern, replace );

    }

    function WebGLProgram( renderer, code, material, parameters ) {

    	var gl = renderer.context;

    	var extensions = material.extensions;
    	var defines = material.defines;

    	var vertexShader = material.__webglShader.vertexShader;
    	var fragmentShader = material.__webglShader.fragmentShader;

    	var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

    	if ( parameters.shadowMapType === PCFShadowMap ) {

    		shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';

    	} else if ( parameters.shadowMapType === PCFSoftShadowMap ) {

    		shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';

    	}

    	var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
    	var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
    	var envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';

    	if ( parameters.envMap ) {

    		switch ( material.envMap.mapping ) {

    			case CubeReflectionMapping:
    			case CubeRefractionMapping:
    				envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
    				break;

    			case CubeUVReflectionMapping:
    			case CubeUVRefractionMapping:
    				envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
    				break;

    			case EquirectangularReflectionMapping:
    			case EquirectangularRefractionMapping:
    				envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
    				break;

    			case SphericalReflectionMapping:
    				envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
    				break;

    		}

    		switch ( material.envMap.mapping ) {

    			case CubeRefractionMapping:
    			case EquirectangularRefractionMapping:
    				envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
    				break;

    		}

    		switch ( material.combine ) {

    			case MultiplyOperation:
    				envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
    				break;

    			case MixOperation:
    				envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
    				break;

    			case AddOperation:
    				envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
    				break;

    		}

    	}

    	var gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;

    	// console.log( 'building new program ' );

    	//

    	var customExtensions = generateExtensions( extensions, parameters, renderer.extensions );

    	var customDefines = generateDefines( defines );

    	//

    	var program = gl.createProgram();

    	var prefixVertex, prefixFragment;

    	if ( material.isRawShaderMaterial ) {

    		prefixVertex = [

    			customDefines,

    			'\n'

    		].filter( filterEmptyLine ).join( '\n' );

    		prefixFragment = [

    			customExtensions,
    			customDefines,

    			'\n'

    		].filter( filterEmptyLine ).join( '\n' );

    	} else {

    		prefixVertex = [

    			'precision ' + parameters.precision + ' float;',
    			'precision ' + parameters.precision + ' int;',

    			'#define SHADER_NAME ' + material.__webglShader.name,

    			customDefines,

    			parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',

    			'#define GAMMA_FACTOR ' + gammaFactorDefine,

    			'#define MAX_BONES ' + parameters.maxBones,

    			parameters.map ? '#define USE_MAP' : '',
    			parameters.envMap ? '#define USE_ENVMAP' : '',
    			parameters.envMap ? '#define ' + envMapModeDefine : '',
    			parameters.lightMap ? '#define USE_LIGHTMAP' : '',
    			parameters.aoMap ? '#define USE_AOMAP' : '',
    			parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
    			parameters.bumpMap ? '#define USE_BUMPMAP' : '',
    			parameters.normalMap ? '#define USE_NORMALMAP' : '',
    			parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
    			parameters.specularMap ? '#define USE_SPECULARMAP' : '',
    			parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
    			parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
    			parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
    			parameters.vertexColors ? '#define USE_COLOR' : '',

    			parameters.flatShading ? '#define FLAT_SHADED' : '',

    			parameters.skinning ? '#define USE_SKINNING' : '',
    			parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',

    			parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
    			parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
    			parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
    			parameters.flipSided ? '#define FLIP_SIDED' : '',

    			'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,

    			parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
    			parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

    			parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',

    			parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
    			parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

    			'uniform mat4 modelMatrix;',
    			'uniform mat4 modelViewMatrix;',
    			'uniform mat4 projectionMatrix;',
    			'uniform mat4 viewMatrix;',
    			'uniform mat3 normalMatrix;',
    			'uniform vec3 cameraPosition;',

    			'attribute vec3 position;',
    			'attribute vec3 normal;',
    			'attribute vec2 uv;',

    			'#ifdef USE_COLOR',

    			'	attribute vec3 color;',

    			'#endif',

    			'#ifdef USE_MORPHTARGETS',

    			'	attribute vec3 morphTarget0;',
    			'	attribute vec3 morphTarget1;',
    			'	attribute vec3 morphTarget2;',
    			'	attribute vec3 morphTarget3;',

    			'	#ifdef USE_MORPHNORMALS',

    			'		attribute vec3 morphNormal0;',
    			'		attribute vec3 morphNormal1;',
    			'		attribute vec3 morphNormal2;',
    			'		attribute vec3 morphNormal3;',

    			'	#else',

    			'		attribute vec3 morphTarget4;',
    			'		attribute vec3 morphTarget5;',
    			'		attribute vec3 morphTarget6;',
    			'		attribute vec3 morphTarget7;',

    			'	#endif',

    			'#endif',

    			'#ifdef USE_SKINNING',

    			'	attribute vec4 skinIndex;',
    			'	attribute vec4 skinWeight;',

    			'#endif',

    			'\n'

    		].filter( filterEmptyLine ).join( '\n' );

    		prefixFragment = [

    			customExtensions,

    			'precision ' + parameters.precision + ' float;',
    			'precision ' + parameters.precision + ' int;',

    			'#define SHADER_NAME ' + material.__webglShader.name,

    			customDefines,

    			parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',

    			'#define GAMMA_FACTOR ' + gammaFactorDefine,

    			( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
    			( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',

    			parameters.map ? '#define USE_MAP' : '',
    			parameters.envMap ? '#define USE_ENVMAP' : '',
    			parameters.envMap ? '#define ' + envMapTypeDefine : '',
    			parameters.envMap ? '#define ' + envMapModeDefine : '',
    			parameters.envMap ? '#define ' + envMapBlendingDefine : '',
    			parameters.lightMap ? '#define USE_LIGHTMAP' : '',
    			parameters.aoMap ? '#define USE_AOMAP' : '',
    			parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
    			parameters.bumpMap ? '#define USE_BUMPMAP' : '',
    			parameters.normalMap ? '#define USE_NORMALMAP' : '',
    			parameters.specularMap ? '#define USE_SPECULARMAP' : '',
    			parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
    			parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
    			parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
    			parameters.vertexColors ? '#define USE_COLOR' : '',

    			parameters.flatShading ? '#define FLAT_SHADED' : '',

    			parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
    			parameters.flipSided ? '#define FLIP_SIDED' : '',

    			'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,

    			parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
    			parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

    			parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : '',

    			parameters.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : '',

    			parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
    			parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

    			parameters.envMap && renderer.extensions.get( 'EXT_shader_texture_lod' ) ? '#define TEXTURE_LOD_EXT' : '',

    			'uniform mat4 viewMatrix;',
    			'uniform vec3 cameraPosition;',

    			( parameters.toneMapping !== NoToneMapping ) ? "#define TONE_MAPPING" : '',
    			( parameters.toneMapping !== NoToneMapping ) ? ShaderChunk[ 'tonemapping_pars_fragment' ] : '',  // this code is required here because it is used by the toneMapping() function defined below
    			( parameters.toneMapping !== NoToneMapping ) ? getToneMappingFunction( "toneMapping", parameters.toneMapping ) : '',

    			( parameters.outputEncoding || parameters.mapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ) ? ShaderChunk[ 'encodings_pars_fragment' ] : '', // this code is required here because it is used by the various encoding/decoding function defined below
    			parameters.mapEncoding ? getTexelDecodingFunction( 'mapTexelToLinear', parameters.mapEncoding ) : '',
    			parameters.envMapEncoding ? getTexelDecodingFunction( 'envMapTexelToLinear', parameters.envMapEncoding ) : '',
    			parameters.emissiveMapEncoding ? getTexelDecodingFunction( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : '',
    			parameters.outputEncoding ? getTexelEncodingFunction( "linearToOutputTexel", parameters.outputEncoding ) : '',

    			parameters.depthPacking ? "#define DEPTH_PACKING " + material.depthPacking : '',

    			'\n'

    		].filter( filterEmptyLine ).join( '\n' );

    	}

    	vertexShader = parseIncludes( vertexShader, parameters );
    	vertexShader = replaceLightNums( vertexShader, parameters );

    	fragmentShader = parseIncludes( fragmentShader, parameters );
    	fragmentShader = replaceLightNums( fragmentShader, parameters );

    	if ( ! material.isShaderMaterial ) {

    		vertexShader = unrollLoops( vertexShader );
    		fragmentShader = unrollLoops( fragmentShader );

    	}

    	var vertexGlsl = prefixVertex + vertexShader;
    	var fragmentGlsl = prefixFragment + fragmentShader;

    	// console.log( '*VERTEX*', vertexGlsl );
    	// console.log( '*FRAGMENT*', fragmentGlsl );

    	var glVertexShader = WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );
    	var glFragmentShader = WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );

    	gl.attachShader( program, glVertexShader );
    	gl.attachShader( program, glFragmentShader );

    	// Force a particular attribute to index 0.

    	if ( material.index0AttributeName !== undefined ) {

    		gl.bindAttribLocation( program, 0, material.index0AttributeName );

    	} else if ( parameters.morphTargets === true ) {

    		// programs with morphTargets displace position out of attribute 0
    		gl.bindAttribLocation( program, 0, 'position' );

    	}

    	gl.linkProgram( program );

    	var programLog = gl.getProgramInfoLog( program );
    	var vertexLog = gl.getShaderInfoLog( glVertexShader );
    	var fragmentLog = gl.getShaderInfoLog( glFragmentShader );

    	var runnable = true;
    	var haveDiagnostics = true;

    	// console.log( '**VERTEX**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );
    	// console.log( '**FRAGMENT**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );

    	if ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {

    		runnable = false;

    		console.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog );

    	} else if ( programLog !== '' ) {

    		console.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );

    	} else if ( vertexLog === '' || fragmentLog === '' ) {

    		haveDiagnostics = false;

    	}

    	if ( haveDiagnostics ) {

    		this.diagnostics = {

    			runnable: runnable,
    			material: material,

    			programLog: programLog,

    			vertexShader: {

    				log: vertexLog,
    				prefix: prefixVertex

    			},

    			fragmentShader: {

    				log: fragmentLog,
    				prefix: prefixFragment

    			}

    		};

    	}

    	// clean up

    	gl.deleteShader( glVertexShader );
    	gl.deleteShader( glFragmentShader );

    	// set up caching for uniform locations

    	var cachedUniforms;

    	this.getUniforms = function() {

    		if ( cachedUniforms === undefined ) {

    			cachedUniforms =
    					new WebGLUniforms( gl, program, renderer );

    		}

    		return cachedUniforms;

    	};

    	// set up caching for attribute locations

    	var cachedAttributes;

    	this.getAttributes = function() {

    		if ( cachedAttributes === undefined ) {

    			cachedAttributes = fetchAttributeLocations( gl, program );

    		}

    		return cachedAttributes;

    	};

    	// free resource

    	this.destroy = function() {

    		gl.deleteProgram( program );
    		this.program = undefined;

    	};

    	// DEPRECATED

    	Object.defineProperties( this, {

    		uniforms: {
    			get: function() {

    				console.warn( 'THREE.WebGLProgram: .uniforms is now .getUniforms().' );
    				return this.getUniforms();

    			}
    		},

    		attributes: {
    			get: function() {

    				console.warn( 'THREE.WebGLProgram: .attributes is now .getAttributes().' );
    				return this.getAttributes();

    			}
    		}

    	} );


    	//

    	this.id = programIdCount ++;
    	this.code = code;
    	this.usedTimes = 1;
    	this.program = program;
    	this.vertexShader = glVertexShader;
    	this.fragmentShader = glFragmentShader;

    	return this;

    }

    function WebGLPrograms( renderer, capabilities ) {

    	var programs = [];

    	var shaderIDs = {
    		MeshDepthMaterial: 'depth',
    		MeshNormalMaterial: 'normal',
    		MeshBasicMaterial: 'basic',
    		MeshLambertMaterial: 'lambert',
    		MeshPhongMaterial: 'phong',
    		MeshStandardMaterial: 'physical',
    		MeshPhysicalMaterial: 'physical',
    		LineBasicMaterial: 'basic',
    		LineDashedMaterial: 'dashed',
    		PointsMaterial: 'points'
    	};

    	var parameterNames = [
    		"precision", "supportsVertexTextures", "map", "mapEncoding", "envMap", "envMapMode", "envMapEncoding",
    		"lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "displacementMap", "specularMap",
    		"roughnessMap", "metalnessMap",
    		"alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp",
    		"flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning",
    		"maxBones", "useVertexTexture", "morphTargets", "morphNormals",
    		"maxMorphTargets", "maxMorphNormals", "premultipliedAlpha",
    		"numDirLights", "numPointLights", "numSpotLights", "numHemiLights",
    		"shadowMapEnabled", "shadowMapType", "toneMapping", 'physicallyCorrectLights',
    		"alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "depthPacking"
    	];


    	function allocateBones( object ) {

    		if ( capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture ) {

    			return 1024;

    		} else {

    			// default for when object is not specified
    			// ( for example when prebuilding shader to be used with multiple objects )
    			//
    			//  - leave some extra space for other uniforms
    			//  - limit here is ANGLE's 254 max uniform vectors
    			//    (up to 54 should be safe)

    			var nVertexUniforms = capabilities.maxVertexUniforms;
    			var nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );

    			var maxBones = nVertexMatrices;

    			if ( object !== undefined && (object && object.isSkinnedMesh) ) {

    				maxBones = Math.min( object.skeleton.bones.length, maxBones );

    				if ( maxBones < object.skeleton.bones.length ) {

    					console.warn( 'WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)' );

    				}

    			}

    			return maxBones;

    		}

    	}

    	function getTextureEncodingFromMap( map, gammaOverrideLinear ) {

    		var encoding;

    		if ( ! map ) {

    			encoding = LinearEncoding;

    		} else if ( (map && map.isTexture) ) {

    			encoding = map.encoding;

    		} else if ( (map && map.isWebGLRenderTarget) ) {

    			console.warn( "THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead." );
    			encoding = map.texture.encoding;

    		}

    		// add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.
    		if ( encoding === LinearEncoding && gammaOverrideLinear ) {

    			encoding = GammaEncoding;

    		}

    		return encoding;

    	}

    	this.getParameters = function ( material, lights, fog, nClipPlanes, object ) {

    		var shaderID = shaderIDs[ material.type ];

    		// heuristics to create shader parameters according to lights in the scene
    		// (not to blow over maxLights budget)

    		var maxBones = allocateBones( object );
    		var precision = renderer.getPrecision();

    		if ( material.precision !== null ) {

    			precision = capabilities.getMaxPrecision( material.precision );

    			if ( precision !== material.precision ) {

    				console.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );

    			}

    		}

    		var currentRenderTarget = renderer.getCurrentRenderTarget();

    		var parameters = {

    			shaderID: shaderID,

    			precision: precision,
    			supportsVertexTextures: capabilities.vertexTextures,
    			outputEncoding: getTextureEncodingFromMap( ( ! currentRenderTarget ) ? null : currentRenderTarget.texture, renderer.gammaOutput ),
    			map: !! material.map,
    			mapEncoding: getTextureEncodingFromMap( material.map, renderer.gammaInput ),
    			envMap: !! material.envMap,
    			envMapMode: material.envMap && material.envMap.mapping,
    			envMapEncoding: getTextureEncodingFromMap( material.envMap, renderer.gammaInput ),
    			envMapCubeUV: ( !! material.envMap ) && ( ( material.envMap.mapping === CubeUVReflectionMapping ) || ( material.envMap.mapping === CubeUVRefractionMapping ) ),
    			lightMap: !! material.lightMap,
    			aoMap: !! material.aoMap,
    			emissiveMap: !! material.emissiveMap,
    			emissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap, renderer.gammaInput ),
    			bumpMap: !! material.bumpMap,
    			normalMap: !! material.normalMap,
    			displacementMap: !! material.displacementMap,
    			roughnessMap: !! material.roughnessMap,
    			metalnessMap: !! material.metalnessMap,
    			specularMap: !! material.specularMap,
    			alphaMap: !! material.alphaMap,

    			combine: material.combine,

    			vertexColors: material.vertexColors,

    			fog: !! fog,
    			useFog: material.fog,
    			fogExp: (fog && fog.isFogExp2),

    			flatShading: material.shading === FlatShading,

    			sizeAttenuation: material.sizeAttenuation,
    			logarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,

    			skinning: material.skinning,
    			maxBones: maxBones,
    			useVertexTexture: capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture,

    			morphTargets: material.morphTargets,
    			morphNormals: material.morphNormals,
    			maxMorphTargets: renderer.maxMorphTargets,
    			maxMorphNormals: renderer.maxMorphNormals,

    			numDirLights: lights.directional.length,
    			numPointLights: lights.point.length,
    			numSpotLights: lights.spot.length,
    			numHemiLights: lights.hemi.length,

    			numClippingPlanes: nClipPlanes,

    			shadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && lights.shadows.length > 0,
    			shadowMapType: renderer.shadowMap.type,

    			toneMapping: renderer.toneMapping,
    			physicallyCorrectLights: renderer.physicallyCorrectLights,

    			premultipliedAlpha: material.premultipliedAlpha,

    			alphaTest: material.alphaTest,
    			doubleSided: material.side === DoubleSide,
    			flipSided: material.side === BackSide,

    			depthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false

    		};

    		return parameters;

    	};

    	this.getProgramCode = function ( material, parameters ) {

    		var array = [];

    		if ( parameters.shaderID ) {

    			array.push( parameters.shaderID );

    		} else {

    			array.push( material.fragmentShader );
    			array.push( material.vertexShader );

    		}

    		if ( material.defines !== undefined ) {

    			for ( var name in material.defines ) {

    				array.push( name );
    				array.push( material.defines[ name ] );

    			}

    		}

    		for ( var i = 0; i < parameterNames.length; i ++ ) {

    			array.push( parameters[ parameterNames[ i ] ] );

    		}

    		return array.join();

    	};

    	this.acquireProgram = function ( material, parameters, code ) {

    		var program;

    		// Check if code has been already compiled
    		for ( var p = 0, pl = programs.length; p < pl; p ++ ) {

    			var programInfo = programs[ p ];

    			if ( programInfo.code === code ) {

    				program = programInfo;
    				++ program.usedTimes;

    				break;

    			}

    		}

    		if ( program === undefined ) {

    			program = new WebGLProgram( renderer, code, material, parameters );
    			programs.push( program );

    		}

    		return program;

    	};

    	this.releaseProgram = function( program ) {

    		if ( -- program.usedTimes === 0 ) {

    			// Remove from unordered set
    			var i = programs.indexOf( program );
    			programs[ i ] = programs[ programs.length - 1 ];
    			programs.pop();

    			// Free WebGL resources
    			program.destroy();

    		}

    	};

    	// Exposed for resource monitoring & error feedback via renderer.info:
    	this.programs = programs;

    }

    function WebGLGeometries( gl, properties, info ) {

    	var geometries = {};

    	function onGeometryDispose( event ) {

    		var geometry = event.target;
    		var buffergeometry = geometries[ geometry.id ];

    		if ( buffergeometry.index !== null ) {

    			deleteAttribute( buffergeometry.index );

    		}

    		deleteAttributes( buffergeometry.attributes );

    		geometry.removeEventListener( 'dispose', onGeometryDispose );

    		delete geometries[ geometry.id ];

    		// TODO

    		var property = properties.get( geometry );

    		if ( property.wireframe ) {

    			deleteAttribute( property.wireframe );

    		}

    		properties.delete( geometry );

    		var bufferproperty = properties.get( buffergeometry );

    		if ( bufferproperty.wireframe ) {

    			deleteAttribute( bufferproperty.wireframe );

    		}

    		properties.delete( buffergeometry );

    		//

    		info.memory.geometries --;

    	}

    	function getAttributeBuffer( attribute ) {

    		if ( attribute.isInterleavedBufferAttribute ) {

    			return properties.get( attribute.data ).__webglBuffer;

    		}

    		return properties.get( attribute ).__webglBuffer;

    	}

    	function deleteAttribute( attribute ) {

    		var buffer = getAttributeBuffer( attribute );

    		if ( buffer !== undefined ) {

    			gl.deleteBuffer( buffer );
    			removeAttributeBuffer( attribute );

    		}

    	}

    	function deleteAttributes( attributes ) {

    		for ( var name in attributes ) {

    			deleteAttribute( attributes[ name ] );

    		}

    	}

    	function removeAttributeBuffer( attribute ) {

    		if ( attribute.isInterleavedBufferAttribute ) {

    			properties.delete( attribute.data );

    		} else {

    			properties.delete( attribute );

    		}

    	}

    	return {

    		get: function ( object ) {

    			var geometry = object.geometry;

    			if ( geometries[ geometry.id ] !== undefined ) {

    				return geometries[ geometry.id ];

    			}

    			geometry.addEventListener( 'dispose', onGeometryDispose );

    			var buffergeometry;

    			if ( geometry.isBufferGeometry ) {

    				buffergeometry = geometry;

    			} else if ( geometry.isGeometry ) {

    				if ( geometry._bufferGeometry === undefined ) {

    					geometry._bufferGeometry = new BufferGeometry().setFromObject( object );

    				}

    				buffergeometry = geometry._bufferGeometry;

    			}

    			geometries[ geometry.id ] = buffergeometry;

    			info.memory.geometries ++;

    			return buffergeometry;

    		}

    	};

    }

    function WebGLObjects( gl, properties, info ) {

    	var geometries = new WebGLGeometries( gl, properties, info );

    	//

    	function update( object ) {

    		// TODO: Avoid updating twice (when using shadowMap). Maybe add frame counter.

    		var geometry = geometries.get( object );

    		if ( object.geometry.isGeometry ) {

    			geometry.updateFromObject( object );

    		}

    		var index = geometry.index;
    		var attributes = geometry.attributes;

    		if ( index !== null ) {

    			updateAttribute( index, gl.ELEMENT_ARRAY_BUFFER );

    		}

    		for ( var name in attributes ) {

    			updateAttribute( attributes[ name ], gl.ARRAY_BUFFER );

    		}

    		// morph targets

    		var morphAttributes = geometry.morphAttributes;

    		for ( var name in morphAttributes ) {

    			var array = morphAttributes[ name ];

    			for ( var i = 0, l = array.length; i < l; i ++ ) {

    				updateAttribute( array[ i ], gl.ARRAY_BUFFER );

    			}

    		}

    		return geometry;

    	}

    	function updateAttribute( attribute, bufferType ) {

    		var data = ( attribute.isInterleavedBufferAttribute ) ? attribute.data : attribute;

    		var attributeProperties = properties.get( data );

    		if ( attributeProperties.__webglBuffer === undefined ) {

    			createBuffer( attributeProperties, data, bufferType );

    		} else if ( attributeProperties.version !== data.version ) {

    			updateBuffer( attributeProperties, data, bufferType );

    		}

    	}

    	function createBuffer( attributeProperties, data, bufferType ) {

    		attributeProperties.__webglBuffer = gl.createBuffer();
    		gl.bindBuffer( bufferType, attributeProperties.__webglBuffer );

    		var usage = data.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;

    		gl.bufferData( bufferType, data.array, usage );

    		attributeProperties.version = data.version;

    	}

    	function updateBuffer( attributeProperties, data, bufferType ) {

    		gl.bindBuffer( bufferType, attributeProperties.__webglBuffer );

    		if ( data.dynamic === false || data.updateRange.count === - 1 ) {

    			// Not using update ranges

    			gl.bufferSubData( bufferType, 0, data.array );

    		} else if ( data.updateRange.count === 0 ) {

    			console.error( 'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );

    		} else {

    			gl.bufferSubData( bufferType, data.updateRange.offset * data.array.BYTES_PER_ELEMENT,
    							  data.array.subarray( data.updateRange.offset, data.updateRange.offset + data.updateRange.count ) );

    			data.updateRange.count = 0; // reset range

    		}

    		attributeProperties.version = data.version;

    	}

    	function getAttributeBuffer( attribute ) {

    		if ( attribute.isInterleavedBufferAttribute ) {

    			return properties.get( attribute.data ).__webglBuffer;

    		}

    		return properties.get( attribute ).__webglBuffer;

    	}

    	function getWireframeAttribute( geometry ) {

    		var property = properties.get( geometry );

    		if ( property.wireframe !== undefined ) {

    			return property.wireframe;

    		}

    		var indices = [];

    		var index = geometry.index;
    		var attributes = geometry.attributes;
    		var position = attributes.position;

    		// console.time( 'wireframe' );

    		if ( index !== null ) {

    			var edges = {};
    			var array = index.array;

    			for ( var i = 0, l = array.length; i < l; i += 3 ) {

    				var a = array[ i + 0 ];
    				var b = array[ i + 1 ];
    				var c = array[ i + 2 ];

    				indices.push( a, b, b, c, c, a );

    			}

    		} else {

    			var array = attributes.position.array;

    			for ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {

    				var a = i + 0;
    				var b = i + 1;
    				var c = i + 2;

    				indices.push( a, b, b, c, c, a );

    			}

    		}

    		// console.timeEnd( 'wireframe' );

    		var TypeArray = position.count > 65535 ? Uint32Array : Uint16Array;
    		var attribute = new BufferAttribute( new TypeArray( indices ), 1 );

    		updateAttribute( attribute, gl.ELEMENT_ARRAY_BUFFER );

    		property.wireframe = attribute;

    		return attribute;

    	}

    	return {

    		getAttributeBuffer: getAttributeBuffer,
    		getWireframeAttribute: getWireframeAttribute,

    		update: update

    	};

    }

    function WebGLTextures( _gl, extensions, state, properties, capabilities, paramThreeToGL, info ) {

    	var _infoMemory = info.memory;
    	var _isWebGL2 = ( typeof WebGL2RenderingContext !== 'undefined' && _gl instanceof WebGL2RenderingContext );

    	//

    	function clampToMaxSize( image, maxSize ) {

    		if ( image.width > maxSize || image.height > maxSize ) {

    			// Warning: Scaling through the canvas will only work with images that use
    			// premultiplied alpha.

    			var scale = maxSize / Math.max( image.width, image.height );

    			var canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
    			canvas.width = Math.floor( image.width * scale );
    			canvas.height = Math.floor( image.height * scale );

    			var context = canvas.getContext( '2d' );
    			context.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );

    			console.warn( 'THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );

    			return canvas;

    		}

    		return image;

    	}

    	function isPowerOfTwo( image ) {

    		return exports.Math.isPowerOfTwo( image.width ) && exports.Math.isPowerOfTwo( image.height );

    	}

    	function makePowerOfTwo( image ) {

    		if ( image instanceof HTMLImageElement || image instanceof HTMLCanvasElement ) {

    			var canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
    			canvas.width = exports.Math.nearestPowerOfTwo( image.width );
    			canvas.height = exports.Math.nearestPowerOfTwo( image.height );

    			var context = canvas.getContext( '2d' );
    			context.drawImage( image, 0, 0, canvas.width, canvas.height );

    			console.warn( 'THREE.WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );

    			return canvas;

    		}

    		return image;

    	}

    	function textureNeedsPowerOfTwo( texture ) {

    		if ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) return true;
    		if ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) return true;

    		return false;

    	}

    	// Fallback filters for non-power-of-2 textures

    	function filterFallback( f ) {

    		if ( f === NearestFilter || f === NearestMipMapNearestFilter || f === NearestMipMapLinearFilter ) {

    			return _gl.NEAREST;

    		}

    		return _gl.LINEAR;

    	}

    	//

    	function onTextureDispose( event ) {

    		var texture = event.target;

    		texture.removeEventListener( 'dispose', onTextureDispose );

    		deallocateTexture( texture );

    		_infoMemory.textures --;


    	}

    	function onRenderTargetDispose( event ) {

    		var renderTarget = event.target;

    		renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

    		deallocateRenderTarget( renderTarget );

    		_infoMemory.textures --;

    	}

    	//

    	function deallocateTexture( texture ) {

    		var textureProperties = properties.get( texture );

    		if ( texture.image && textureProperties.__image__webglTextureCube ) {

    			// cube texture

    			_gl.deleteTexture( textureProperties.__image__webglTextureCube );

    		} else {

    			// 2D texture

    			if ( textureProperties.__webglInit === undefined ) return;

    			_gl.deleteTexture( textureProperties.__webglTexture );

    		}

    		// remove all webgl properties
    		properties.delete( texture );

    	}

    	function deallocateRenderTarget( renderTarget ) {

    		var renderTargetProperties = properties.get( renderTarget );
    		var textureProperties = properties.get( renderTarget.texture );

    		if ( ! renderTarget ) return;

    		if ( textureProperties.__webglTexture !== undefined ) {

    			_gl.deleteTexture( textureProperties.__webglTexture );

    		}

    		if ( renderTarget.depthTexture ) {

    			renderTarget.depthTexture.dispose();

    		}

    		if ( (renderTarget && renderTarget.isWebGLRenderTargetCube) ) {

    			for ( var i = 0; i < 6; i ++ ) {

    				_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );
    				if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );

    			}

    		} else {

    			_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );
    			if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );

    		}

    		properties.delete( renderTarget.texture );
    		properties.delete( renderTarget );

    	}

    	//



    	function setTexture2D( texture, slot ) {

    		var textureProperties = properties.get( texture );

    		if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

    			var image = texture.image;

    			if ( image === undefined ) {

    				console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined', texture );

    			} else if ( image.complete === false ) {

    				console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture );

    			} else {

    				uploadTexture( textureProperties, texture, slot );
    				return;

    			}

    		}

    		state.activeTexture( _gl.TEXTURE0 + slot );
    		state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );

    	}

    	function setTextureCube( texture, slot ) {

    		var textureProperties = properties.get( texture );

    		if ( texture.image.length === 6 ) {

    			if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

    				if ( ! textureProperties.__image__webglTextureCube ) {

    					texture.addEventListener( 'dispose', onTextureDispose );

    					textureProperties.__image__webglTextureCube = _gl.createTexture();

    					_infoMemory.textures ++;

    				}

    				state.activeTexture( _gl.TEXTURE0 + slot );
    				state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );

    				_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );

    				var isCompressed = (texture && texture.isCompressedTexture);
    				var isDataTexture = (texture.image[ 0 ] && texture.image[ 0 ].isDataTexture);

    				var cubeImage = [];

    				for ( var i = 0; i < 6; i ++ ) {

    					if ( ! isCompressed && ! isDataTexture ) {

    						cubeImage[ i ] = clampToMaxSize( texture.image[ i ], capabilities.maxCubemapSize );

    					} else {

    						cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];

    					}

    				}

    				var image = cubeImage[ 0 ],
    				isPowerOfTwoImage = isPowerOfTwo( image ),
    				glFormat = paramThreeToGL( texture.format ),
    				glType = paramThreeToGL( texture.type );

    				setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isPowerOfTwoImage );

    				for ( var i = 0; i < 6; i ++ ) {

    					if ( ! isCompressed ) {

    						if ( isDataTexture ) {

    							state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );

    						} else {

    							state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );

    						}

    					} else {

    						var mipmap, mipmaps = cubeImage[ i ].mipmaps;

    						for ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {

    							mipmap = mipmaps[ j ];

    							if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {

    								if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {

    									state.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

    								} else {

    									console.warn( "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()" );

    								}

    							} else {

    								state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

    							}

    						}

    					}

    				}

    				if ( texture.generateMipmaps && isPowerOfTwoImage ) {

    					_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );

    				}

    				textureProperties.__version = texture.version;

    				if ( texture.onUpdate ) texture.onUpdate( texture );

    			} else {

    				state.activeTexture( _gl.TEXTURE0 + slot );
    				state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );

    			}

    		}

    	}

    	function setTextureCubeDynamic( texture, slot ) {

    		state.activeTexture( _gl.TEXTURE0 + slot );
    		state.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( texture ).__webglTexture );

    	}

    	function setTextureParameters( textureType, texture, isPowerOfTwoImage ) {

    		var extension;

    		if ( isPowerOfTwoImage ) {

    			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );
    			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );

    			_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );
    			_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );

    		} else {

    			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
    			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );

    			if ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) {

    				console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.', texture );

    			}

    			_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );
    			_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );

    			if ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) {

    				console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.', texture );

    			}

    		}

    		extension = extensions.get( 'EXT_texture_filter_anisotropic' );

    		if ( extension ) {

    			if ( texture.type === FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;
    			if ( texture.type === HalfFloatType && extensions.get( 'OES_texture_half_float_linear' ) === null ) return;

    			if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {

    				_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );
    				properties.get( texture ).__currentAnisotropy = texture.anisotropy;

    			}

    		}

    	}

    	function uploadTexture( textureProperties, texture, slot ) {

    		if ( textureProperties.__webglInit === undefined ) {

    			textureProperties.__webglInit = true;

    			texture.addEventListener( 'dispose', onTextureDispose );

    			textureProperties.__webglTexture = _gl.createTexture();

    			_infoMemory.textures ++;

    		}

    		state.activeTexture( _gl.TEXTURE0 + slot );
    		state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );

    		_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
    		_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
    		_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );

    		var image = clampToMaxSize( texture.image, capabilities.maxTextureSize );

    		if ( textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( image ) === false ) {

    			image = makePowerOfTwo( image );

    		}

    		var isPowerOfTwoImage = isPowerOfTwo( image ),
    		glFormat = paramThreeToGL( texture.format ),
    		glType = paramThreeToGL( texture.type );

    		setTextureParameters( _gl.TEXTURE_2D, texture, isPowerOfTwoImage );

    		var mipmap, mipmaps = texture.mipmaps;

    		if ( (texture && texture.isDepthTexture) ) {

    			// populate depth texture with dummy data

    			var internalFormat = _gl.DEPTH_COMPONENT;

    			if ( texture.type === FloatType ) {

    				if ( !_isWebGL2 ) throw new Error('Float Depth Texture only supported in WebGL2.0');
    				internalFormat = _gl.DEPTH_COMPONENT32F;

    			} else if ( _isWebGL2 ) {

    				// WebGL 2.0 requires signed internalformat for glTexImage2D
    				internalFormat = _gl.DEPTH_COMPONENT16;

    			}

    			// Depth stencil textures need the DEPTH_STENCIL internal format
    			// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
    			if ( texture.format === DepthStencilFormat ) {

    				internalFormat = _gl.DEPTH_STENCIL;

    			}

    			state.texImage2D( _gl.TEXTURE_2D, 0, internalFormat, image.width, image.height, 0, glFormat, glType, null );

    		} else if ( (texture && texture.isDataTexture) ) {

    			// use manually created mipmaps if available
    			// if there are no manual mipmaps
    			// set 0 level mipmap and then use GL to generate other mipmap levels

    			if ( mipmaps.length > 0 && isPowerOfTwoImage ) {

    				for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

    					mipmap = mipmaps[ i ];
    					state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

    				}

    				texture.generateMipmaps = false;

    			} else {

    				state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );

    			}

    		} else if ( (texture && texture.isCompressedTexture) ) {

    			for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

    				mipmap = mipmaps[ i ];

    				if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {

    					if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {

    						state.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

    					} else {

    						console.warn( "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()" );

    					}

    				} else {

    					state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

    				}

    			}

    		} else {

    			// regular Texture (image, video, canvas)

    			// use manually created mipmaps if available
    			// if there are no manual mipmaps
    			// set 0 level mipmap and then use GL to generate other mipmap levels

    			if ( mipmaps.length > 0 && isPowerOfTwoImage ) {

    				for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

    					mipmap = mipmaps[ i ];
    					state.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );

    				}

    				texture.generateMipmaps = false;

    			} else {

    				state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, image );

    			}

    		}

    		if ( texture.generateMipmaps && isPowerOfTwoImage ) _gl.generateMipmap( _gl.TEXTURE_2D );

    		textureProperties.__version = texture.version;

    		if ( texture.onUpdate ) texture.onUpdate( texture );

    	}

    	// Render targets

    	// Setup storage for target texture and bind it to correct framebuffer
    	function setupFrameBufferTexture( framebuffer, renderTarget, attachment, textureTarget ) {

    		var glFormat = paramThreeToGL( renderTarget.texture.format );
    		var glType = paramThreeToGL( renderTarget.texture.type );
    		state.texImage2D( textureTarget, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );
    		_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
    		_gl.framebufferTexture2D( _gl.FRAMEBUFFER, attachment, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );
    		_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );

    	}

    	// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
    	function setupRenderBufferStorage( renderbuffer, renderTarget ) {

    		_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );

    		if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

    			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );
    			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

    		} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

    			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );
    			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

    		} else {

    			// FIXME: We don't support !depth !stencil
    			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );

    		}

    		_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );

    	}

    	// Setup resources for a Depth Texture for a FBO (needs an extension)
    	function setupDepthTexture( framebuffer, renderTarget ) {

    		var isCube = ( (renderTarget && renderTarget.isWebGLRenderTargetCube) );
    		if ( isCube ) throw new Error('Depth Texture with cube render targets is not supported!');

    		_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

    		if ( !( (renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture) ) ) {

    			throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');

    		}

    		// upload an empty depth texture with framebuffer size
    		if ( !properties.get( renderTarget.depthTexture ).__webglTexture ||
    				renderTarget.depthTexture.image.width !== renderTarget.width ||
    				renderTarget.depthTexture.image.height !== renderTarget.height ) {
    			renderTarget.depthTexture.image.width = renderTarget.width;
    			renderTarget.depthTexture.image.height = renderTarget.height;
    			renderTarget.depthTexture.needsUpdate = true;
    		}

    		setTexture2D( renderTarget.depthTexture, 0 );

    		var webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;

    		if ( renderTarget.depthTexture.format === DepthFormat ) {

    			_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );

    		} else if ( renderTarget.depthTexture.format === DepthStencilFormat ) {

    			_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );

    		} else {

    			throw new Error('Unknown depthTexture format')

    		}

    	}

    	// Setup GL resources for a non-texture depth buffer
    	function setupDepthRenderbuffer( renderTarget ) {

    		var renderTargetProperties = properties.get( renderTarget );

    		var isCube = ( (renderTarget && renderTarget.isWebGLRenderTargetCube) );

    		if ( renderTarget.depthTexture ) {

    			if ( isCube ) throw new Error('target.depthTexture not supported in Cube render targets');

    			setupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );

    		} else {

    			if ( isCube ) {

    				renderTargetProperties.__webglDepthbuffer = [];

    				for ( var i = 0; i < 6; i ++ ) {

    					_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ i ] );
    					renderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();
    					setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget );

    				}

    			} else {

    				_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );
    				renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
    				setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget );

    			}

    		}

    		_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );

    	}

    	// Set up GL resources for the render target
    	function setupRenderTarget( renderTarget ) {

    		var renderTargetProperties = properties.get( renderTarget );
    		var textureProperties = properties.get( renderTarget.texture );

    		renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

    		textureProperties.__webglTexture = _gl.createTexture();

    		_infoMemory.textures ++;

    		var isCube = ( (renderTarget && renderTarget.isWebGLRenderTargetCube) );
    		var isTargetPowerOfTwo = isPowerOfTwo( renderTarget );

    		// Setup framebuffer

    		if ( isCube ) {

    			renderTargetProperties.__webglFramebuffer = [];

    			for ( var i = 0; i < 6; i ++ ) {

    				renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();

    			}

    		} else {

    			renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

    		}

    		// Setup color buffer

    		if ( isCube ) {

    			state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );
    			setTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo );

    			for ( var i = 0; i < 6; i ++ ) {

    				setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );

    			}

    			if ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );
    			state.bindTexture( _gl.TEXTURE_CUBE_MAP, null );

    		} else {

    			state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );
    			setTextureParameters( _gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo );
    			setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D );

    			if ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );
    			state.bindTexture( _gl.TEXTURE_2D, null );

    		}

    		// Setup depth and stencil buffers

    		if ( renderTarget.depthBuffer ) {

    			setupDepthRenderbuffer( renderTarget );

    		}

    	}

    	function updateRenderTargetMipmap( renderTarget ) {

    		var texture = renderTarget.texture;

    		if ( texture.generateMipmaps && isPowerOfTwo( renderTarget ) &&
    				texture.minFilter !== NearestFilter &&
    				texture.minFilter !== LinearFilter ) {

    			var target = (renderTarget && renderTarget.isWebGLRenderTargetCube) ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
    			var webglTexture = properties.get( texture ).__webglTexture;

    			state.bindTexture( target, webglTexture );
    			_gl.generateMipmap( target );
    			state.bindTexture( target, null );

    		}

    	}

    	this.setTexture2D = setTexture2D;
    	this.setTextureCube = setTextureCube;
    	this.setTextureCubeDynamic = setTextureCubeDynamic;
    	this.setupRenderTarget = setupRenderTarget;
    	this.updateRenderTargetMipmap = updateRenderTargetMipmap;

    }

    /**
     * @author fordacious / fordacious.github.io
     */

    function WebGLProperties() {

    	var properties = {};

    	return {

    		get: function ( object ) {

    			var uuid = object.uuid;
    			var map = properties[ uuid ];

    			if ( map === undefined ) {

    				map = {};
    				properties[ uuid ] = map;

    			}

    			return map;

    		},

    		delete: function ( object ) {

    			delete properties[ object.uuid ];

    		},

    		clear: function () {

    			properties = {};

    		}

    	};

    }

    function WebGLState( gl, extensions, paramThreeToGL ) {

    	function ColorBuffer() {

    		var locked = false;

    		var color = new Vector4();
    		var currentColorMask = null;
    		var currentColorClear = new Vector4();

    		return {

    			setMask: function ( colorMask ) {

    				if ( currentColorMask !== colorMask && ! locked ) {

    					gl.colorMask( colorMask, colorMask, colorMask, colorMask );
    					currentColorMask = colorMask;

    				}

    			},

    			setLocked: function ( lock ) {

    				locked = lock;

    			},

    			setClear: function ( r, g, b, a ) {

    				color.set( r, g, b, a );

    				if ( currentColorClear.equals( color ) === false ) {

    					gl.clearColor( r, g, b, a );
    					currentColorClear.copy( color );

    				}

    			},

    			reset: function () {

    				locked = false;

    				currentColorMask = null;
    				currentColorClear.set( 0, 0, 0, 1 );

    			}

    		};

    	}

    	function DepthBuffer() {

    		var locked = false;

    		var currentDepthMask = null;
    		var currentDepthFunc = null;
    		var currentDepthClear = null;

    		return {

    			setTest: function ( depthTest ) {

    				if ( depthTest ) {

    					enable( gl.DEPTH_TEST );

    				} else {

    					disable( gl.DEPTH_TEST );

    				}

    			},

    			setMask: function ( depthMask ) {

    				if ( currentDepthMask !== depthMask && ! locked ) {

    					gl.depthMask( depthMask );
    					currentDepthMask = depthMask;

    				}

    			},

    			setFunc: function ( depthFunc ) {

    				if ( currentDepthFunc !== depthFunc ) {

    					if ( depthFunc ) {

    						switch ( depthFunc ) {

    							case NeverDepth:

    								gl.depthFunc( gl.NEVER );
    								break;

    							case AlwaysDepth:

    								gl.depthFunc( gl.ALWAYS );
    								break;

    							case LessDepth:

    								gl.depthFunc( gl.LESS );
    								break;

    							case LessEqualDepth:

    								gl.depthFunc( gl.LEQUAL );
    								break;

    							case EqualDepth:

    								gl.depthFunc( gl.EQUAL );
    								break;

    							case GreaterEqualDepth:

    								gl.depthFunc( gl.GEQUAL );
    								break;

    							case GreaterDepth:

    								gl.depthFunc( gl.GREATER );
    								break;

    							case NotEqualDepth:

    								gl.depthFunc( gl.NOTEQUAL );
    								break;

    							default:

    								gl.depthFunc( gl.LEQUAL );

    						}

    					} else {

    						gl.depthFunc( gl.LEQUAL );

    					}

    					currentDepthFunc = depthFunc;

    				}

    			},

    			setLocked: function ( lock ) {

    				locked = lock;

    			},

    			setClear: function ( depth ) {

    				if ( currentDepthClear !== depth ) {

    					gl.clearDepth( depth );
    					currentDepthClear = depth;

    				}

    			},

    			reset: function () {

    				locked = false;

    				currentDepthMask = null;
    				currentDepthFunc = null;
    				currentDepthClear = null;

    			}

    		};

    	}

    	function StencilBuffer() {

    		var locked = false;

    		var currentStencilMask = null;
    		var currentStencilFunc = null;
    		var currentStencilRef = null;
    		var currentStencilFuncMask = null;
    		var currentStencilFail  = null;
    		var currentStencilZFail = null;
    		var currentStencilZPass = null;
    		var currentStencilClear = null;

    		return {

    			setTest: function ( stencilTest ) {

    				if ( stencilTest ) {

    					enable( gl.STENCIL_TEST );

    				} else {

    					disable( gl.STENCIL_TEST );

    				}

    			},

    			setMask: function ( stencilMask ) {

    				if ( currentStencilMask !== stencilMask && ! locked ) {

    					gl.stencilMask( stencilMask );
    					currentStencilMask = stencilMask;

    				}

    			},

    			setFunc: function ( stencilFunc, stencilRef, stencilMask ) {

    				if ( currentStencilFunc !== stencilFunc ||
    				     currentStencilRef 	!== stencilRef 	||
    				     currentStencilFuncMask !== stencilMask ) {

    					gl.stencilFunc( stencilFunc,  stencilRef, stencilMask );

    					currentStencilFunc = stencilFunc;
    					currentStencilRef  = stencilRef;
    					currentStencilFuncMask = stencilMask;

    				}

    			},

    			setOp: function ( stencilFail, stencilZFail, stencilZPass ) {

    				if ( currentStencilFail	 !== stencilFail 	||
    				     currentStencilZFail !== stencilZFail ||
    				     currentStencilZPass !== stencilZPass ) {

    					gl.stencilOp( stencilFail,  stencilZFail, stencilZPass );

    					currentStencilFail  = stencilFail;
    					currentStencilZFail = stencilZFail;
    					currentStencilZPass = stencilZPass;

    				}

    			},

    			setLocked: function ( lock ) {

    				locked = lock;

    			},

    			setClear: function ( stencil ) {

    				if ( currentStencilClear !== stencil ) {

    					gl.clearStencil( stencil );
    					currentStencilClear = stencil;

    				}

    			},

    			reset: function () {

    				locked = false;

    				currentStencilMask = null;
    				currentStencilFunc = null;
    				currentStencilRef = null;
    				currentStencilFuncMask = null;
    				currentStencilFail = null;
    				currentStencilZFail = null;
    				currentStencilZPass = null;
    				currentStencilClear = null;

    			}

    		};

    	}

    	//

    	var colorBuffer = new ColorBuffer();
    	var depthBuffer = new DepthBuffer();
    	var stencilBuffer = new StencilBuffer();

    	var maxVertexAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
    	var newAttributes = new Uint8Array( maxVertexAttributes );
    	var enabledAttributes = new Uint8Array( maxVertexAttributes );
    	var attributeDivisors = new Uint8Array( maxVertexAttributes );

    	var capabilities = {};

    	var compressedTextureFormats = null;

    	var currentBlending = null;
    	var currentBlendEquation = null;
    	var currentBlendSrc = null;
    	var currentBlendDst = null;
    	var currentBlendEquationAlpha = null;
    	var currentBlendSrcAlpha = null;
    	var currentBlendDstAlpha = null;
    	var currentPremultipledAlpha = false;

    	var currentFlipSided = null;
    	var currentCullFace = null;

    	var currentLineWidth = null;

    	var currentPolygonOffsetFactor = null;
    	var currentPolygonOffsetUnits = null;

    	var currentScissorTest = null;

    	var maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );

    	var currentTextureSlot = null;
    	var currentBoundTextures = {};

    	var currentScissor = new Vector4();
    	var currentViewport = new Vector4();

    	function createTexture( type, target, count ) {

    		var data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.
    		var texture = gl.createTexture();

    		gl.bindTexture( type, texture );
    		gl.texParameteri( type, gl.TEXTURE_MIN_FILTER, gl.NEAREST );
    		gl.texParameteri( type, gl.TEXTURE_MAG_FILTER, gl.NEAREST );

    		for ( var i = 0; i < count; i ++ ) {

    			gl.texImage2D( target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );

    		}

    		return texture;

    	}

    	var emptyTextures = {};
    	emptyTextures[ gl.TEXTURE_2D ] = createTexture( gl.TEXTURE_2D, gl.TEXTURE_2D, 1 );
    	emptyTextures[ gl.TEXTURE_CUBE_MAP ] = createTexture( gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6 );

    	//

    	function init() {

    		clearColor( 0, 0, 0, 1 );
    		clearDepth( 1 );
    		clearStencil( 0 );

    		enable( gl.DEPTH_TEST );
    		setDepthFunc( LessEqualDepth );

    		setFlipSided( false );
    		setCullFace( CullFaceBack );
    		enable( gl.CULL_FACE );

    		enable( gl.BLEND );
    		setBlending( NormalBlending );

    	}

    	function initAttributes() {

    		for ( var i = 0, l = newAttributes.length; i < l; i ++ ) {

    			newAttributes[ i ] = 0;

    		}

    	}

    	function enableAttribute( attribute ) {

    		newAttributes[ attribute ] = 1;

    		if ( enabledAttributes[ attribute ] === 0 ) {

    			gl.enableVertexAttribArray( attribute );
    			enabledAttributes[ attribute ] = 1;

    		}

    		if ( attributeDivisors[ attribute ] !== 0 ) {

    			var extension = extensions.get( 'ANGLE_instanced_arrays' );

    			extension.vertexAttribDivisorANGLE( attribute, 0 );
    			attributeDivisors[ attribute ] = 0;

    		}

    	}

    	function enableAttributeAndDivisor( attribute, meshPerAttribute, extension ) {

    		newAttributes[ attribute ] = 1;

    		if ( enabledAttributes[ attribute ] === 0 ) {

    			gl.enableVertexAttribArray( attribute );
    			enabledAttributes[ attribute ] = 1;

    		}

    		if ( attributeDivisors[ attribute ] !== meshPerAttribute ) {

    			extension.vertexAttribDivisorANGLE( attribute, meshPerAttribute );
    			attributeDivisors[ attribute ] = meshPerAttribute;

    		}

    	}

    	function disableUnusedAttributes() {

    		for ( var i = 0, l = enabledAttributes.length; i !== l; ++ i ) {

    			if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {

    				gl.disableVertexAttribArray( i );
    				enabledAttributes[ i ] = 0;

    			}

    		}

    	}

    	function enable( id ) {

    		if ( capabilities[ id ] !== true ) {

    			gl.enable( id );
    			capabilities[ id ] = true;

    		}

    	}

    	function disable( id ) {

    		if ( capabilities[ id ] !== false ) {

    			gl.disable( id );
    			capabilities[ id ] = false;

    		}

    	}

    	function getCompressedTextureFormats() {

    		if ( compressedTextureFormats === null ) {

    			compressedTextureFormats = [];

    			if ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||
    			     extensions.get( 'WEBGL_compressed_texture_s3tc' ) ||
    			     extensions.get( 'WEBGL_compressed_texture_etc1' ) ) {

    				var formats = gl.getParameter( gl.COMPRESSED_TEXTURE_FORMATS );

    				for ( var i = 0; i < formats.length; i ++ ) {

    					compressedTextureFormats.push( formats[ i ] );

    				}

    			}

    		}

    		return compressedTextureFormats;

    	}

    	function setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {

    		if ( blending !== NoBlending ) {

    			enable( gl.BLEND );

    		} else {

    			disable( gl.BLEND );
    			currentBlending = blending; // no blending, that is
    			return;

    		}

    		if ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {

    			if ( blending === AdditiveBlending ) {

    				if ( premultipliedAlpha ) {

    					gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
    					gl.blendFuncSeparate( gl.ONE, gl.ONE, gl.ONE, gl.ONE );

    				} else {

    					gl.blendEquation( gl.FUNC_ADD );
    					gl.blendFunc( gl.SRC_ALPHA, gl.ONE );

    				}

    			} else if ( blending === SubtractiveBlending ) {

    				if ( premultipliedAlpha ) {

    					gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
    					gl.blendFuncSeparate( gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA );

    				} else {

    					gl.blendEquation( gl.FUNC_ADD );
    					gl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );

    				}

    			} else if ( blending === MultiplyBlending ) {

    				if ( premultipliedAlpha ) {

    					gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
    					gl.blendFuncSeparate( gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA );

    				} else {

    					gl.blendEquation( gl.FUNC_ADD );
    					gl.blendFunc( gl.ZERO, gl.SRC_COLOR );

    				}

    			} else {

    				if ( premultipliedAlpha ) {

    					gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
    					gl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );

    				} else {

    					gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
    					gl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );

    				}

    			}

    			currentBlending = blending;
    			currentPremultipledAlpha = premultipliedAlpha;

    		}

    		if ( blending === CustomBlending ) {

    			blendEquationAlpha = blendEquationAlpha || blendEquation;
    			blendSrcAlpha = blendSrcAlpha || blendSrc;
    			blendDstAlpha = blendDstAlpha || blendDst;

    			if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {

    				gl.blendEquationSeparate( paramThreeToGL( blendEquation ), paramThreeToGL( blendEquationAlpha ) );

    				currentBlendEquation = blendEquation;
    				currentBlendEquationAlpha = blendEquationAlpha;

    			}

    			if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {

    				gl.blendFuncSeparate( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ), paramThreeToGL( blendSrcAlpha ), paramThreeToGL( blendDstAlpha ) );

    				currentBlendSrc = blendSrc;
    				currentBlendDst = blendDst;
    				currentBlendSrcAlpha = blendSrcAlpha;
    				currentBlendDstAlpha = blendDstAlpha;

    			}

    		} else {

    			currentBlendEquation = null;
    			currentBlendSrc = null;
    			currentBlendDst = null;
    			currentBlendEquationAlpha = null;
    			currentBlendSrcAlpha = null;
    			currentBlendDstAlpha = null;

    		}

    	}

    	// TODO Deprecate

    	function setColorWrite( colorWrite ) {

    		colorBuffer.setMask( colorWrite );

    	}

    	function setDepthTest( depthTest ) {

    		depthBuffer.setTest( depthTest );

    	}

    	function setDepthWrite( depthWrite ) {

    		depthBuffer.setMask( depthWrite );

    	}

    	function setDepthFunc( depthFunc ) {

    		depthBuffer.setFunc( depthFunc );

    	}

    	function setStencilTest( stencilTest ) {

    		stencilBuffer.setTest( stencilTest );

    	}

    	function setStencilWrite( stencilWrite ) {

    		stencilBuffer.setMask( stencilWrite );

    	}

    	function setStencilFunc( stencilFunc, stencilRef, stencilMask ) {

    		stencilBuffer.setFunc( stencilFunc, stencilRef, stencilMask );

    	}

    	function setStencilOp( stencilFail, stencilZFail, stencilZPass ) {

    		stencilBuffer.setOp( stencilFail, stencilZFail, stencilZPass );

    	}

    	//

    	function setFlipSided( flipSided ) {

    		if ( currentFlipSided !== flipSided ) {

    			if ( flipSided ) {

    				gl.frontFace( gl.CW );

    			} else {

    				gl.frontFace( gl.CCW );

    			}

    			currentFlipSided = flipSided;

    		}

    	}

    	function setCullFace( cullFace ) {

    		if ( cullFace !== CullFaceNone ) {

    			enable( gl.CULL_FACE );

    			if ( cullFace !== currentCullFace ) {

    				if ( cullFace === CullFaceBack ) {

    					gl.cullFace( gl.BACK );

    				} else if ( cullFace === CullFaceFront ) {

    					gl.cullFace( gl.FRONT );

    				} else {

    					gl.cullFace( gl.FRONT_AND_BACK );

    				}

    			}

    		} else {

    			disable( gl.CULL_FACE );

    		}

    		currentCullFace = cullFace;

    	}

    	function setLineWidth( width ) {

    		if ( width !== currentLineWidth ) {

    			gl.lineWidth( width );

    			currentLineWidth = width;

    		}

    	}

    	function setPolygonOffset( polygonOffset, factor, units ) {

    		if ( polygonOffset ) {

    			enable( gl.POLYGON_OFFSET_FILL );

    			if ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {

    				gl.polygonOffset( factor, units );

    				currentPolygonOffsetFactor = factor;
    				currentPolygonOffsetUnits = units;

    			}

    		} else {

    			disable( gl.POLYGON_OFFSET_FILL );

    		}

    	}

    	function getScissorTest() {

    		return currentScissorTest;

    	}

    	function setScissorTest( scissorTest ) {

    		currentScissorTest = scissorTest;

    		if ( scissorTest ) {

    			enable( gl.SCISSOR_TEST );

    		} else {

    			disable( gl.SCISSOR_TEST );

    		}

    	}

    	// texture

    	function activeTexture( webglSlot ) {

    		if ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;

    		if ( currentTextureSlot !== webglSlot ) {

    			gl.activeTexture( webglSlot );
    			currentTextureSlot = webglSlot;

    		}

    	}

    	function bindTexture( webglType, webglTexture ) {

    		if ( currentTextureSlot === null ) {

    			activeTexture();

    		}

    		var boundTexture = currentBoundTextures[ currentTextureSlot ];

    		if ( boundTexture === undefined ) {

    			boundTexture = { type: undefined, texture: undefined };
    			currentBoundTextures[ currentTextureSlot ] = boundTexture;

    		}

    		if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {

    			gl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );

    			boundTexture.type = webglType;
    			boundTexture.texture = webglTexture;

    		}

    	}

    	function compressedTexImage2D() {

    		try {

    			gl.compressedTexImage2D.apply( gl, arguments );

    		} catch ( error ) {

    			console.error( error );

    		}

    	}

    	function texImage2D() {

    		try {

    			gl.texImage2D.apply( gl, arguments );

    		} catch ( error ) {

    			console.error( error );

    		}

    	}

    	// TODO Deprecate

    	function clearColor( r, g, b, a ) {

    		colorBuffer.setClear( r, g, b, a );

    	}

    	function clearDepth( depth ) {

    		depthBuffer.setClear( depth );

    	}

    	function clearStencil( stencil ) {

    		stencilBuffer.setClear( stencil );

    	}

    	//

    	function scissor( scissor ) {

    		if ( currentScissor.equals( scissor ) === false ) {

    			gl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );
    			currentScissor.copy( scissor );

    		}

    	}

    	function viewport( viewport ) {

    		if ( currentViewport.equals( viewport ) === false ) {

    			gl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );
    			currentViewport.copy( viewport );

    		}

    	}

    	//

    	function reset() {

    		for ( var i = 0; i < enabledAttributes.length; i ++ ) {

    			if ( enabledAttributes[ i ] === 1 ) {

    				gl.disableVertexAttribArray( i );
    				enabledAttributes[ i ] = 0;

    			}

    		}

    		capabilities = {};

    		compressedTextureFormats = null;

    		currentTextureSlot = null;
    		currentBoundTextures = {};

    		currentBlending = null;

    		currentFlipSided = null;
    		currentCullFace = null;

    		colorBuffer.reset();
    		depthBuffer.reset();
    		stencilBuffer.reset();

    	}

    	return {

    		buffers: {
    			color: colorBuffer,
    			depth: depthBuffer,
    			stencil: stencilBuffer
    		},

    		init: init,
    		initAttributes: initAttributes,
    		enableAttribute: enableAttribute,
    		enableAttributeAndDivisor: enableAttributeAndDivisor,
    		disableUnusedAttributes: disableUnusedAttributes,
    		enable: enable,
    		disable: disable,
    		getCompressedTextureFormats: getCompressedTextureFormats,

    		setBlending: setBlending,

    		setColorWrite: setColorWrite,
    		setDepthTest: setDepthTest,
    		setDepthWrite: setDepthWrite,
    		setDepthFunc: setDepthFunc,
    		setStencilTest: setStencilTest,
    		setStencilWrite: setStencilWrite,
    		setStencilFunc: setStencilFunc,
    		setStencilOp: setStencilOp,

    		setFlipSided: setFlipSided,
    		setCullFace: setCullFace,

    		setLineWidth: setLineWidth,
    		setPolygonOffset: setPolygonOffset,

    		getScissorTest: getScissorTest,
    		setScissorTest: setScissorTest,

    		activeTexture: activeTexture,
    		bindTexture: bindTexture,
    		compressedTexImage2D: compressedTexImage2D,
    		texImage2D: texImage2D,

    		clearColor: clearColor,
    		clearDepth: clearDepth,
    		clearStencil: clearStencil,

    		scissor: scissor,
    		viewport: viewport,

    		reset: reset

    	};

    }

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function WebGLCapabilities( gl, extensions, parameters ) {

    	var maxAnisotropy;

    	function getMaxAnisotropy() {

    		if ( maxAnisotropy !== undefined ) return maxAnisotropy;

    		var extension = extensions.get( 'EXT_texture_filter_anisotropic' );

    		if ( extension !== null ) {

    			maxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );

    		} else {

    			maxAnisotropy = 0;

    		}

    		return maxAnisotropy;

    	}

    	function getMaxPrecision( precision ) {

    		if ( precision === 'highp' ) {

    			if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&
    			     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {

    				return 'highp';

    			}

    			precision = 'mediump';

    		}

    		if ( precision === 'mediump' ) {

    			if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&
    			     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {

    				return 'mediump';

    			}

    		}

    		return 'lowp';

    	}

    	var precision = parameters.precision !== undefined ? parameters.precision : 'highp';
    	var maxPrecision = getMaxPrecision( precision );

    	if ( maxPrecision !== precision ) {

    		console.warn( 'THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );
    		precision = maxPrecision;

    	}

    	var logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true && !! extensions.get( 'EXT_frag_depth' );

    	var maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );
    	var maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );
    	var maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );
    	var maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );

    	var maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
    	var maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );
    	var maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );
    	var maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );

    	var vertexTextures = maxVertexTextures > 0;
    	var floatFragmentTextures = !! extensions.get( 'OES_texture_float' );
    	var floatVertexTextures = vertexTextures && floatFragmentTextures;

    	return {

    		getMaxAnisotropy: getMaxAnisotropy,
    		getMaxPrecision: getMaxPrecision,

    		precision: precision,
    		logarithmicDepthBuffer: logarithmicDepthBuffer,

    		maxTextures: maxTextures,
    		maxVertexTextures: maxVertexTextures,
    		maxTextureSize: maxTextureSize,
    		maxCubemapSize: maxCubemapSize,

    		maxAttributes: maxAttributes,
    		maxVertexUniforms: maxVertexUniforms,
    		maxVaryings: maxVaryings,
    		maxFragmentUniforms: maxFragmentUniforms,

    		vertexTextures: vertexTextures,
    		floatFragmentTextures: floatFragmentTextures,
    		floatVertexTextures: floatVertexTextures

    	};

    }

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function WebGLExtensions( gl ) {

    	var extensions = {};

    	return {

    		get: function ( name ) {

    			if ( extensions[ name ] !== undefined ) {

    				return extensions[ name ];

    			}

    			var extension;

    			switch ( name ) {

    				case 'WEBGL_depth_texture':
    					extension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );
    					break;

    				case 'EXT_texture_filter_anisotropic':
    					extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
    					break;

    				case 'WEBGL_compressed_texture_s3tc':
    					extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
    					break;

    				case 'WEBGL_compressed_texture_pvrtc':
    					extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
    					break;

    				case 'WEBGL_compressed_texture_etc1':
    					extension = gl.getExtension( 'WEBGL_compressed_texture_etc1' );
    					break;

    				default:
    					extension = gl.getExtension( name );

    			}

    			if ( extension === null ) {

    				console.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );

    			}

    			extensions[ name ] = extension;

    			return extension;

    		}

    	};

    }

    function WebGLClipping() {

    	var scope = this,

    		globalState = null,
    		numGlobalPlanes = 0,
    		localClippingEnabled = false,
    		renderingShadows = false,

    		plane = new Plane(),
    		viewNormalMatrix = new Matrix3(),

    		uniform = { value: null, needsUpdate: false };

    	this.uniform = uniform;
    	this.numPlanes = 0;

    	this.init = function( planes, enableLocalClipping, camera ) {

    		var enabled =
    			planes.length !== 0 ||
    			enableLocalClipping ||
    			// enable state of previous frame - the clipping code has to
    			// run another frame in order to reset the state:
    			numGlobalPlanes !== 0 ||
    			localClippingEnabled;

    		localClippingEnabled = enableLocalClipping;

    		globalState = projectPlanes( planes, camera, 0 );
    		numGlobalPlanes = planes.length;

    		return enabled;

    	};

    	this.beginShadows = function() {

    		renderingShadows = true;
    		projectPlanes( null );

    	};

    	this.endShadows = function() {

    		renderingShadows = false;
    		resetGlobalState();

    	};

    	this.setState = function( planes, clipShadows, camera, cache, fromCache ) {

    		if ( ! localClippingEnabled ||
    				planes === null || planes.length === 0 ||
    				renderingShadows && ! clipShadows ) {
    			// there's no local clipping

    			if ( renderingShadows ) {
    				// there's no global clipping

    				projectPlanes( null );

    			} else {

    				resetGlobalState();
    			}

    		} else {

    			var nGlobal = renderingShadows ? 0 : numGlobalPlanes,
    				lGlobal = nGlobal * 4,

    				dstArray = cache.clippingState || null;

    			uniform.value = dstArray; // ensure unique state

    			dstArray = projectPlanes( planes, camera, lGlobal, fromCache );

    			for ( var i = 0; i !== lGlobal; ++ i ) {

    				dstArray[ i ] = globalState[ i ];

    			}

    			cache.clippingState = dstArray;
    			this.numPlanes += nGlobal;

    		}


    	};

    	function resetGlobalState() {

    		if ( uniform.value !== globalState ) {

    			uniform.value = globalState;
    			uniform.needsUpdate = numGlobalPlanes > 0;

    		}

    		scope.numPlanes = numGlobalPlanes;

    	}

    	function projectPlanes( planes, camera, dstOffset, skipTransform ) {

    		var nPlanes = planes !== null ? planes.length : 0,
    			dstArray = null;

    		if ( nPlanes !== 0 ) {

    			dstArray = uniform.value;

    			if ( skipTransform !== true || dstArray === null ) {

    				var flatSize = dstOffset + nPlanes * 4,
    					viewMatrix = camera.matrixWorldInverse;

    				viewNormalMatrix.getNormalMatrix( viewMatrix );

    				if ( dstArray === null || dstArray.length < flatSize ) {

    					dstArray = new Float32Array( flatSize );

    				}

    				for ( var i = 0, i4 = dstOffset;
    									i !== nPlanes; ++ i, i4 += 4 ) {

    					plane.copy( planes[ i ] ).
    							applyMatrix4( viewMatrix, viewNormalMatrix );

    					plane.normal.toArray( dstArray, i4 );
    					dstArray[ i4 + 3 ] = plane.constant;

    				}

    			}

    			uniform.value = dstArray;
    			uniform.needsUpdate = true;

    		}

    		scope.numPlanes = nPlanes;
    		return dstArray;

    	}

    }

    /**
     * @author supereggbert / http://www.paulbrunt.co.uk/
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     * @author szimek / https://github.com/szimek/
     * @author tschw
     */

    function WebGLRenderer( parameters ) {

    	console.log( 'THREE.WebGLRenderer', REVISION );

    	parameters = parameters || {};

    	var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ),
    	_context = parameters.context !== undefined ? parameters.context : null,

    	_alpha = parameters.alpha !== undefined ? parameters.alpha : false,
    	_depth = parameters.depth !== undefined ? parameters.depth : true,
    	_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
    	_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
    	_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
    	_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false;

    	var lights = [];

    	var opaqueObjects = [];
    	var opaqueObjectsLastIndex = - 1;
    	var transparentObjects = [];
    	var transparentObjectsLastIndex = - 1;

    	var morphInfluences = new Float32Array( 8 );

    	var sprites = [];
    	var lensFlares = [];

    	// public properties

    	this.domElement = _canvas;
    	this.context = null;

    	// clearing

    	this.autoClear = true;
    	this.autoClearColor = true;
    	this.autoClearDepth = true;
    	this.autoClearStencil = true;

    	// scene graph

    	this.sortObjects = true;

    	// user-defined clipping

    	this.clippingPlanes = [];
    	this.localClippingEnabled = false;

    	// physically based shading

    	this.gammaFactor = 2.0;	// for backwards compatibility
    	this.gammaInput = false;
    	this.gammaOutput = false;

    	// physical lights

    	this.physicallyCorrectLights = false;

    	// tone mapping

    	this.toneMapping = LinearToneMapping;
    	this.toneMappingExposure = 1.0;
    	this.toneMappingWhitePoint = 1.0;

    	// morphs

    	this.maxMorphTargets = 8;
    	this.maxMorphNormals = 4;

    	// internal properties

    	var _this = this,

    	// internal state cache

    	_currentProgram = null,
    	_currentRenderTarget = null,
    	_currentFramebuffer = null,
    	_currentMaterialId = - 1,
    	_currentGeometryProgram = '',
    	_currentCamera = null,

    	_currentScissor = new Vector4(),
    	_currentScissorTest = null,

    	_currentViewport = new Vector4(),

    	//

    	_usedTextureUnits = 0,

    	//

    	_clearColor = new Color( 0x000000 ),
    	_clearAlpha = 0,

    	_width = _canvas.width,
    	_height = _canvas.height,

    	_pixelRatio = 1,

    	_scissor = new Vector4( 0, 0, _width, _height ),
    	_scissorTest = false,

    	_viewport = new Vector4( 0, 0, _width, _height ),

    	// frustum

    	_frustum = new Frustum(),

    	// clipping

    	_clipping = new WebGLClipping(),
    	_clippingEnabled = false,
    	_localClippingEnabled = false,

    	_sphere = new Sphere(),

    	// camera matrices cache

    	_projScreenMatrix = new Matrix4(),

    	_vector3 = new Vector3(),

    	// light arrays cache

    	_lights = {

    		hash: '',

    		ambient: [ 0, 0, 0 ],
    		directional: [],
    		directionalShadowMap: [],
    		directionalShadowMatrix: [],
    		spot: [],
    		spotShadowMap: [],
    		spotShadowMatrix: [],
    		point: [],
    		pointShadowMap: [],
    		pointShadowMatrix: [],
    		hemi: [],

    		shadows: []

    	},

    	// info

    	_infoRender = {

    		calls: 0,
    		vertices: 0,
    		faces: 0,
    		points: 0

    	};

    	this.info = {

    		render: _infoRender,
    		memory: {

    			geometries: 0,
    			textures: 0

    		},
    		programs: null

    	};


    	// initialize

    	var _gl;

    	try {

    		var attributes = {
    			alpha: _alpha,
    			depth: _depth,
    			stencil: _stencil,
    			antialias: _antialias,
    			premultipliedAlpha: _premultipliedAlpha,
    			preserveDrawingBuffer: _preserveDrawingBuffer
    		};

    		_gl = _context || _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );

    		if ( _gl === null ) {

    			if ( _canvas.getContext( 'webgl' ) !== null ) {

    				throw 'Error creating WebGL context with your selected attributes.';

    			} else {

    				throw 'Error creating WebGL context.';

    			}

    		}

    		// Some experimental-webgl implementations do not have getShaderPrecisionFormat

    		if ( _gl.getShaderPrecisionFormat === undefined ) {

    			_gl.getShaderPrecisionFormat = function () {

    				return { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };

    			};

    		}

    		_canvas.addEventListener( 'webglcontextlost', onContextLost, false );

    	} catch ( error ) {

    		console.error( 'THREE.WebGLRenderer: ' + error );

    	}

    	var extensions = new WebGLExtensions( _gl );

    	extensions.get( 'WEBGL_depth_texture' );
    	extensions.get( 'OES_texture_float' );
    	extensions.get( 'OES_texture_float_linear' );
    	extensions.get( 'OES_texture_half_float' );
    	extensions.get( 'OES_texture_half_float_linear' );
    	extensions.get( 'OES_standard_derivatives' );
    	extensions.get( 'ANGLE_instanced_arrays' );

    	if ( extensions.get( 'OES_element_index_uint' ) ) {

    		BufferGeometry.MaxIndex = 4294967296;

    	}

    	var capabilities = new WebGLCapabilities( _gl, extensions, parameters );

    	var state = new WebGLState( _gl, extensions, paramThreeToGL );
    	var properties = new WebGLProperties();
    	var textures = new WebGLTextures( _gl, extensions, state, properties, capabilities, paramThreeToGL, this.info );
    	var objects = new WebGLObjects( _gl, properties, this.info );
    	var programCache = new WebGLPrograms( this, capabilities );
    	var lightCache = new WebGLLights();

    	this.info.programs = programCache.programs;

    	var bufferRenderer = new WebGLBufferRenderer( _gl, extensions, _infoRender );
    	var indexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, _infoRender );

    	//

    	var backgroundCamera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );
    	var backgroundCamera2 = new PerspectiveCamera();
    	var backgroundPlaneMesh = new Mesh(
    		new PlaneBufferGeometry( 2, 2 ),
    		new MeshBasicMaterial( { depthTest: false, depthWrite: false, fog: false } )
    	);
    	var backgroundBoxShader = ShaderLib[ 'cube' ];
    	var backgroundBoxMesh = new Mesh(
    		new BoxBufferGeometry( 5, 5, 5 ),
    		new ShaderMaterial( {
    			uniforms: backgroundBoxShader.uniforms,
    			vertexShader: backgroundBoxShader.vertexShader,
    			fragmentShader: backgroundBoxShader.fragmentShader,
    			side: BackSide,
    			depthTest: false,
    			depthWrite: false,
    			fog: false
    		} )
    	);

    	//

    	function getTargetPixelRatio() {

    		return _currentRenderTarget === null ? _pixelRatio : 1;

    	}

    	function glClearColor( r, g, b, a ) {

    		if ( _premultipliedAlpha === true ) {

    			r *= a; g *= a; b *= a;

    		}

    		state.clearColor( r, g, b, a );

    	}

    	function setDefaultGLState() {

    		state.init();

    		state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );
    		state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );

    		glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

    	}

    	function resetGLState() {

    		_currentProgram = null;
    		_currentCamera = null;

    		_currentGeometryProgram = '';
    		_currentMaterialId = - 1;

    		state.reset();

    	}

    	setDefaultGLState();

    	this.context = _gl;
    	this.capabilities = capabilities;
    	this.extensions = extensions;
    	this.properties = properties;
    	this.state = state;

    	// shadow map

    	var shadowMap = new WebGLShadowMap( this, _lights, objects, capabilities );

    	this.shadowMap = shadowMap;


    	// Plugins

    	var spritePlugin = new SpritePlugin( this, sprites );
    	var lensFlarePlugin = new LensFlarePlugin( this, lensFlares );

    	// API

    	this.getContext = function () {

    		return _gl;

    	};

    	this.getContextAttributes = function () {

    		return _gl.getContextAttributes();

    	};

    	this.forceContextLoss = function () {

    		extensions.get( 'WEBGL_lose_context' ).loseContext();

    	};

    	this.getMaxAnisotropy = function () {

    		return capabilities.getMaxAnisotropy();

    	};

    	this.getPrecision = function () {

    		return capabilities.precision;

    	};

    	this.getPixelRatio = function () {

    		return _pixelRatio;

    	};

    	this.setPixelRatio = function ( value ) {

    		if ( value === undefined ) return;

    		_pixelRatio = value;

    		this.setSize( _viewport.z, _viewport.w, false );

    	};

    	this.getSize = function () {

    		return {
    			width: _width,
    			height: _height
    		};

    	};

    	this.setSize = function ( width, height, updateStyle ) {

    		_width = width;
    		_height = height;

    		_canvas.width = width * _pixelRatio;
    		_canvas.height = height * _pixelRatio;

    		if ( updateStyle !== false ) {

    			_canvas.style.width = width + 'px';
    			_canvas.style.height = height + 'px';

    		}

    		this.setViewport( 0, 0, width, height );

    	};

    	this.setViewport = function ( x, y, width, height ) {

    		state.viewport( _viewport.set( x, y, width, height ) );

    	};

    	this.setScissor = function ( x, y, width, height ) {

    		state.scissor( _scissor.set( x, y, width, height ) );

    	};

    	this.setScissorTest = function ( boolean ) {

    		state.setScissorTest( _scissorTest = boolean );

    	};

    	// Clearing

    	this.getClearColor = function () {

    		return _clearColor;

    	};

    	this.setClearColor = function ( color, alpha ) {

    		_clearColor.set( color );

    		_clearAlpha = alpha !== undefined ? alpha : 1;

    		glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

    	};

    	this.getClearAlpha = function () {

    		return _clearAlpha;

    	};

    	this.setClearAlpha = function ( alpha ) {

    		_clearAlpha = alpha;

    		glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

    	};

    	this.clear = function ( color, depth, stencil ) {

    		var bits = 0;

    		if ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;
    		if ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;
    		if ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;

    		_gl.clear( bits );

    	};

    	this.clearColor = function () {

    		this.clear( true, false, false );

    	};

    	this.clearDepth = function () {

    		this.clear( false, true, false );

    	};

    	this.clearStencil = function () {

    		this.clear( false, false, true );

    	};

    	this.clearTarget = function ( renderTarget, color, depth, stencil ) {

    		this.setRenderTarget( renderTarget );
    		this.clear( color, depth, stencil );

    	};

    	// Reset

    	this.resetGLState = resetGLState;

    	this.dispose = function() {

    		transparentObjects = [];
    		transparentObjectsLastIndex = -1;
    		opaqueObjects = [];
    		opaqueObjectsLastIndex = -1;

    		_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );

    	};

    	// Events

    	function onContextLost( event ) {

    		event.preventDefault();

    		resetGLState();
    		setDefaultGLState();

    		properties.clear();

    	}

    	function onMaterialDispose( event ) {

    		var material = event.target;

    		material.removeEventListener( 'dispose', onMaterialDispose );

    		deallocateMaterial( material );

    	}

    	// Buffer deallocation

    	function deallocateMaterial( material ) {

    		releaseMaterialProgramReference( material );

    		properties.delete( material );

    	}


    	function releaseMaterialProgramReference( material ) {

    		var programInfo = properties.get( material ).program;

    		material.program = undefined;

    		if ( programInfo !== undefined ) {

    			programCache.releaseProgram( programInfo );

    		}

    	}

    	// Buffer rendering

    	this.renderBufferImmediate = function ( object, program, material ) {

    		state.initAttributes();

    		var buffers = properties.get( object );

    		if ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();
    		if ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();
    		if ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();
    		if ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();

    		var attributes = program.getAttributes();

    		if ( object.hasPositions ) {

    			_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.position );
    			_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );

    			state.enableAttribute( attributes.position );
    			_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );

    		}

    		if ( object.hasNormals ) {

    			_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.normal );

    			if ( ! material.isMeshPhongMaterial &&
    			     ! material.isMeshStandardMaterial &&
    			       material.shading === FlatShading ) {

    				for ( var i = 0, l = object.count * 3; i < l; i += 9 ) {

    					var array = object.normalArray;

    					var nx = ( array[ i + 0 ] + array[ i + 3 ] + array[ i + 6 ] ) / 3;
    					var ny = ( array[ i + 1 ] + array[ i + 4 ] + array[ i + 7 ] ) / 3;
    					var nz = ( array[ i + 2 ] + array[ i + 5 ] + array[ i + 8 ] ) / 3;

    					array[ i + 0 ] = nx;
    					array[ i + 1 ] = ny;
    					array[ i + 2 ] = nz;

    					array[ i + 3 ] = nx;
    					array[ i + 4 ] = ny;
    					array[ i + 5 ] = nz;

    					array[ i + 6 ] = nx;
    					array[ i + 7 ] = ny;
    					array[ i + 8 ] = nz;

    				}

    			}

    			_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );

    			state.enableAttribute( attributes.normal );

    			_gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );

    		}

    		if ( object.hasUvs && material.map ) {

    			_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.uv );
    			_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );

    			state.enableAttribute( attributes.uv );

    			_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );

    		}

    		if ( object.hasColors && material.vertexColors !== NoColors ) {

    			_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.color );
    			_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );

    			state.enableAttribute( attributes.color );

    			_gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );

    		}

    		state.disableUnusedAttributes();

    		_gl.drawArrays( _gl.TRIANGLES, 0, object.count );

    		object.count = 0;

    	};

    	this.renderBufferDirect = function ( camera, fog, geometry, material, object, group ) {

    		setMaterial( material );

    		var program = setProgram( camera, fog, material, object );

    		var updateBuffers = false;
    		var geometryProgram = geometry.id + '_' + program.id + '_' + material.wireframe;

    		if ( geometryProgram !== _currentGeometryProgram ) {

    			_currentGeometryProgram = geometryProgram;
    			updateBuffers = true;

    		}

    		// morph targets

    		var morphTargetInfluences = object.morphTargetInfluences;

    		if ( morphTargetInfluences !== undefined ) {

    			var activeInfluences = [];

    			for ( var i = 0, l = morphTargetInfluences.length; i < l; i ++ ) {

    				var influence = morphTargetInfluences[ i ];
    				activeInfluences.push( [ influence, i ] );

    			}

    			activeInfluences.sort( absNumericalSort );

    			if ( activeInfluences.length > 8 ) {

    				activeInfluences.length = 8;

    			}

    			var morphAttributes = geometry.morphAttributes;

    			for ( var i = 0, l = activeInfluences.length; i < l; i ++ ) {

    				var influence = activeInfluences[ i ];
    				morphInfluences[ i ] = influence[ 0 ];

    				if ( influence[ 0 ] !== 0 ) {

    					var index = influence[ 1 ];

    					if ( material.morphTargets === true && morphAttributes.position ) geometry.addAttribute( 'morphTarget' + i, morphAttributes.position[ index ] );
    					if ( material.morphNormals === true && morphAttributes.normal ) geometry.addAttribute( 'morphNormal' + i, morphAttributes.normal[ index ] );

    				} else {

    					if ( material.morphTargets === true ) geometry.removeAttribute( 'morphTarget' + i );
    					if ( material.morphNormals === true ) geometry.removeAttribute( 'morphNormal' + i );

    				}

    			}

    			for ( var i = activeInfluences.length, il = morphInfluences.length; i < il; i ++ ) {

    				morphInfluences[ i ] = 0.0;

    			}

    			program.getUniforms().setValue(
    					_gl, 'morphTargetInfluences', morphInfluences );

    			updateBuffers = true;

    		}

    		//

    		var index = geometry.index;
    		var position = geometry.attributes.position;
    		var rangeFactor = 1;

    		if ( material.wireframe === true ) {

    			index = objects.getWireframeAttribute( geometry );
    			rangeFactor = 2;

    		}

    		var renderer;

    		if ( index !== null ) {

    			renderer = indexedBufferRenderer;
    			renderer.setIndex( index );

    		} else {

    			renderer = bufferRenderer;

    		}

    		if ( updateBuffers ) {

    			setupVertexAttributes( material, program, geometry );

    			if ( index !== null ) {

    				_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, objects.getAttributeBuffer( index ) );

    			}

    		}

    		//

    		var dataCount = 0;

    		if ( index !== null ) {

    			dataCount = index.count;

    		} else if ( position !== undefined ) {

    			dataCount = position.count;

    		}

    		var rangeStart = geometry.drawRange.start * rangeFactor;
    		var rangeCount = geometry.drawRange.count * rangeFactor;

    		var groupStart = group !== null ? group.start * rangeFactor : 0;
    		var groupCount = group !== null ? group.count * rangeFactor : Infinity;

    		var drawStart = Math.max( rangeStart, groupStart );
    		var drawEnd = Math.min( dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;

    		var drawCount = Math.max( 0, drawEnd - drawStart + 1 );

    		if ( drawCount === 0 ) return;

    		//

    		if ( object.isMesh ) {

    			if ( material.wireframe === true ) {

    				state.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );
    				renderer.setMode( _gl.LINES );

    			} else {

    				switch ( object.drawMode ) {

    					case TrianglesDrawMode:
    						renderer.setMode( _gl.TRIANGLES );
    						break;

    					case TriangleStripDrawMode:
    						renderer.setMode( _gl.TRIANGLE_STRIP );
    						break;

    					case TriangleFanDrawMode:
    						renderer.setMode( _gl.TRIANGLE_FAN );
    						break;

    				}

    			}


    		} else if ( object.isLine ) {

    			var lineWidth = material.linewidth;

    			if ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material

    			state.setLineWidth( lineWidth * getTargetPixelRatio() );

    			if ( object.isLineSegments ) {

    				renderer.setMode( _gl.LINES );

    			} else {

    				renderer.setMode( _gl.LINE_STRIP );

    			}

    		} else if ( object.isPoints ) {

    			renderer.setMode( _gl.POINTS );

    		}

    		if ( geometry && geometry.isInstancedBufferGeometry ) {

    			if ( geometry.maxInstancedCount > 0 ) {

    				renderer.renderInstances( geometry, drawStart, drawCount );

    			}

    		} else {

    			renderer.render( drawStart, drawCount );

    		}

    	};

    	function setupVertexAttributes( material, program, geometry, startIndex ) {

    		var extension;

    		if ( geometry && geometry.isInstancedBufferGeometry ) {

    			extension = extensions.get( 'ANGLE_instanced_arrays' );

    			if ( extension === null ) {

    				console.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
    				return;

    			}

    		}

    		if ( startIndex === undefined ) startIndex = 0;

    		state.initAttributes();

    		var geometryAttributes = geometry.attributes;

    		var programAttributes = program.getAttributes();

    		var materialDefaultAttributeValues = material.defaultAttributeValues;

    		for ( var name in programAttributes ) {

    			var programAttribute = programAttributes[ name ];

    			if ( programAttribute >= 0 ) {

    				var geometryAttribute = geometryAttributes[ name ];

    				if ( geometryAttribute !== undefined ) {

    					var type = _gl.FLOAT;
    					var array = geometryAttribute.array;
    					var normalized = geometryAttribute.normalized;

    					if ( array instanceof Float32Array ) {

    						type = _gl.FLOAT;

    					} else if ( array instanceof Float64Array ) {

    						console.warn( "Unsupported data buffer format: Float64Array" );

    					} else if ( array instanceof Uint16Array ) {

    						type = _gl.UNSIGNED_SHORT;

    					} else if ( array instanceof Int16Array ) {

    						type = _gl.SHORT;

    					} else if ( array instanceof Uint32Array ) {

    						type = _gl.UNSIGNED_INT;

    					} else if ( array instanceof Int32Array ) {

    						type = _gl.INT;

    					} else if ( array instanceof Int8Array ) {

    						type = _gl.BYTE;

    					} else if ( array instanceof Uint8Array ) {

    						type = _gl.UNSIGNED_BYTE;

    					}

    					var size = geometryAttribute.itemSize;
    					var buffer = objects.getAttributeBuffer( geometryAttribute );

    					if ( geometryAttribute && geometryAttribute.isInterleavedBufferAttribute ) {

    						var data = geometryAttribute.data;
    						var stride = data.stride;
    						var offset = geometryAttribute.offset;

    						if ( data && data.isInstancedInterleavedBuffer ) {

    							state.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute, extension );

    							if ( geometry.maxInstancedCount === undefined ) {

    								geometry.maxInstancedCount = data.meshPerAttribute * data.count;

    							}

    						} else {

    							state.enableAttribute( programAttribute );

    						}

    						_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
    						_gl.vertexAttribPointer( programAttribute, size, type, normalized, stride * data.array.BYTES_PER_ELEMENT, ( startIndex * stride + offset ) * data.array.BYTES_PER_ELEMENT );

    					} else {

    						if ( geometryAttribute && geometryAttribute.isInstancedBufferAttribute ) {

    							state.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute, extension );

    							if ( geometry.maxInstancedCount === undefined ) {

    								geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;

    							}

    						} else {

    							state.enableAttribute( programAttribute );

    						}

    						_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
    						_gl.vertexAttribPointer( programAttribute, size, type, normalized, 0, startIndex * size * geometryAttribute.array.BYTES_PER_ELEMENT );

    					}

    				} else if ( materialDefaultAttributeValues !== undefined ) {

    					var value = materialDefaultAttributeValues[ name ];

    					if ( value !== undefined ) {

    						switch ( value.length ) {

    							case 2:
    								_gl.vertexAttrib2fv( programAttribute, value );
    								break;

    							case 3:
    								_gl.vertexAttrib3fv( programAttribute, value );
    								break;

    							case 4:
    								_gl.vertexAttrib4fv( programAttribute, value );
    								break;

    							default:
    								_gl.vertexAttrib1fv( programAttribute, value );

    						}

    					}

    				}

    			}

    		}

    		state.disableUnusedAttributes();

    	}

    	// Sorting

    	function absNumericalSort( a, b ) {

    		return Math.abs( b[ 0 ] ) - Math.abs( a[ 0 ] );

    	}

    	function painterSortStable( a, b ) {

    		if ( a.object.renderOrder !== b.object.renderOrder ) {

    			return a.object.renderOrder - b.object.renderOrder;

    		} else if ( a.material.program && b.material.program && a.material.program !== b.material.program ) {

    			return a.material.program.id - b.material.program.id;

    		} else if ( a.material.id !== b.material.id ) {

    			return a.material.id - b.material.id;

    		} else if ( a.z !== b.z ) {

    			return a.z - b.z;

    		} else {

    			return a.id - b.id;

    		}

    	}

    	function reversePainterSortStable( a, b ) {

    		if ( a.object.renderOrder !== b.object.renderOrder ) {

    			return a.object.renderOrder - b.object.renderOrder;

    		} if ( a.z !== b.z ) {

    			return b.z - a.z;

    		} else {

    			return a.id - b.id;

    		}

    	}

    	// Rendering

    	this.render = function ( scene, camera, renderTarget, forceClear ) {

    		if ( camera !== undefined && camera.isCamera !== true ) {

    			console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
    			return;

    		}

    		var fog = scene.fog;

    		// reset caching for this frame

    		_currentGeometryProgram = '';
    		_currentMaterialId = - 1;
    		_currentCamera = null;

    		// update scene graph

    		if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

    		// update camera matrices and frustum

    		if ( camera.parent === null ) camera.updateMatrixWorld();

    		camera.matrixWorldInverse.getInverse( camera.matrixWorld );

    		_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
    		_frustum.setFromMatrix( _projScreenMatrix );

    		lights.length = 0;

    		opaqueObjectsLastIndex = - 1;
    		transparentObjectsLastIndex = - 1;

    		sprites.length = 0;
    		lensFlares.length = 0;

    		_localClippingEnabled = this.localClippingEnabled;
    		_clippingEnabled = _clipping.init( this.clippingPlanes, _localClippingEnabled, camera );

    		projectObject( scene, camera );

    		opaqueObjects.length = opaqueObjectsLastIndex + 1;
    		transparentObjects.length = transparentObjectsLastIndex + 1;

    		if ( _this.sortObjects === true ) {

    			opaqueObjects.sort( painterSortStable );
    			transparentObjects.sort( reversePainterSortStable );

    		}

    		//

    		if ( _clippingEnabled ) _clipping.beginShadows();

    		setupShadows( lights );

    		shadowMap.render( scene, camera );

    		setupLights( lights, camera );

    		if ( _clippingEnabled ) _clipping.endShadows();

    		//

    		_infoRender.calls = 0;
    		_infoRender.vertices = 0;
    		_infoRender.faces = 0;
    		_infoRender.points = 0;

    		if ( renderTarget === undefined ) {

    			renderTarget = null;

    		}

    		this.setRenderTarget( renderTarget );

    		//

    		var background = scene.background;

    		if ( background === null ) {

    			glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

    		} else if ( background && background.isColor ) {

    			glClearColor( background.r, background.g, background.b, 1 );
    			forceClear = true;

    		}

    		if ( this.autoClear || forceClear ) {

    			this.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );

    		}

    		if ( background && background.isCubeTexture ) {

    			backgroundCamera2.projectionMatrix.copy( camera.projectionMatrix );

    			backgroundCamera2.matrixWorld.extractRotation( camera.matrixWorld );
    			backgroundCamera2.matrixWorldInverse.getInverse( backgroundCamera2.matrixWorld );

    			backgroundBoxMesh.material.uniforms[ "tCube" ].value = background;
    			backgroundBoxMesh.modelViewMatrix.multiplyMatrices( backgroundCamera2.matrixWorldInverse, backgroundBoxMesh.matrixWorld );

    			objects.update( backgroundBoxMesh );

    			_this.renderBufferDirect( backgroundCamera2, null, backgroundBoxMesh.geometry, backgroundBoxMesh.material, backgroundBoxMesh, null );

    		} else if ( background && background.isTexture ) {

    			backgroundPlaneMesh.material.map = background;

    			objects.update( backgroundPlaneMesh );

    			_this.renderBufferDirect( backgroundCamera, null, backgroundPlaneMesh.geometry, backgroundPlaneMesh.material, backgroundPlaneMesh, null );

    		}

    		//

    		if ( scene.overrideMaterial ) {

    			var overrideMaterial = scene.overrideMaterial;

    			renderObjects( opaqueObjects, camera, fog, overrideMaterial );
    			renderObjects( transparentObjects, camera, fog, overrideMaterial );

    		} else {

    			// opaque pass (front-to-back order)

    			state.setBlending( NoBlending );
    			renderObjects( opaqueObjects, camera, fog );

    			// transparent pass (back-to-front order)

    			renderObjects( transparentObjects, camera, fog );

    		}

    		// custom render plugins (post pass)

    		spritePlugin.render( scene, camera );
    		lensFlarePlugin.render( scene, camera, _currentViewport );

    		// Generate mipmap if we're using any kind of mipmap filtering

    		if ( renderTarget ) {

    			textures.updateRenderTargetMipmap( renderTarget );

    		}

    		// Ensure depth buffer writing is enabled so it can be cleared on next render

    		state.setDepthTest( true );
    		state.setDepthWrite( true );
    		state.setColorWrite( true );

    		// _gl.finish();

    	};

    	function pushRenderItem( object, geometry, material, z, group ) {

    		var array, index;

    		// allocate the next position in the appropriate array

    		if ( material.transparent ) {

    			array = transparentObjects;
    			index = ++ transparentObjectsLastIndex;

    		} else {

    			array = opaqueObjects;
    			index = ++ opaqueObjectsLastIndex;

    		}

    		// recycle existing render item or grow the array

    		var renderItem = array[ index ];

    		if ( renderItem !== undefined ) {

    			renderItem.id = object.id;
    			renderItem.object = object;
    			renderItem.geometry = geometry;
    			renderItem.material = material;
    			renderItem.z = _vector3.z;
    			renderItem.group = group;

    		} else {

    			renderItem = {
    				id: object.id,
    				object: object,
    				geometry: geometry,
    				material: material,
    				z: _vector3.z,
    				group: group
    			};

    			// assert( index === array.length );
    			array.push( renderItem );

    		}

    	}

    	// TODO Duplicated code (Frustum)

    	function isObjectViewable( object ) {

    		var geometry = object.geometry;

    		if ( geometry.boundingSphere === null )
    			geometry.computeBoundingSphere();

    		_sphere.copy( geometry.boundingSphere ).
    			applyMatrix4( object.matrixWorld );

    		return isSphereViewable( _sphere );

    	}

    	function isSpriteViewable( sprite ) {

    		_sphere.center.set( 0, 0, 0 );
    		_sphere.radius = 0.7071067811865476;
    		_sphere.applyMatrix4( sprite.matrixWorld );

    		return isSphereViewable( _sphere );

    	}

    	function isSphereViewable( sphere ) {

    		if ( ! _frustum.intersectsSphere( sphere ) ) return false;

    		var numPlanes = _clipping.numPlanes;

    		if ( numPlanes === 0 ) return true;

    		var planes = _this.clippingPlanes,

    			center = sphere.center,
    			negRad = - sphere.radius,
    			i = 0;

    		do {

    			// out when deeper than radius in the negative halfspace
    			if ( planes[ i ].distanceToPoint( center ) < negRad ) return false;

    		} while ( ++ i !== numPlanes );

    		return true;

    	}

    	function projectObject( object, camera ) {

    		if ( object.visible === false ) return;

    		var visible = ( object.layers.mask & camera.layers.mask ) !== 0;

    		if ( visible ) {

    			if ( object.isLight ) {

    				lights.push( object );

    			} else if ( object.isSprite ) {

    				if ( object.frustumCulled === false || isSpriteViewable( object ) === true ) {

    					sprites.push( object );

    				}

    			} else if ( object.isLensFlare ) {

    				lensFlares.push( object );

    			} else if ( object.isImmediateRenderObject ) {

    				if ( _this.sortObjects === true ) {

    					_vector3.setFromMatrixPosition( object.matrixWorld );
    					_vector3.applyProjection( _projScreenMatrix );

    				}

    				pushRenderItem( object, null, object.material, _vector3.z, null );

    			} else if ( object.isMesh || object.isLine || object.isPoints ) {

    				if ( object.isSkinnedMesh ) {

    					object.skeleton.update();

    				}

    				if ( object.frustumCulled === false || isObjectViewable( object ) === true ) {

    					var material = object.material;

    					if ( material.visible === true ) {

    						if ( _this.sortObjects === true ) {

    							_vector3.setFromMatrixPosition( object.matrixWorld );
    							_vector3.applyProjection( _projScreenMatrix );

    						}

    						var geometry = objects.update( object );

    						if ( material.isMultiMaterial ) {

    							var groups = geometry.groups;
    							var materials = material.materials;

    							for ( var i = 0, l = groups.length; i < l; i ++ ) {

    								var group = groups[ i ];
    								var groupMaterial = materials[ group.materialIndex ];

    								if ( groupMaterial.visible === true ) {

    									pushRenderItem( object, geometry, groupMaterial, _vector3.z, group );

    								}

    							}

    						} else {

    							pushRenderItem( object, geometry, material, _vector3.z, null );

    						}

    					}

    				}

    			}

    		}

    		var children = object.children;

    		for ( var i = 0, l = children.length; i < l; i ++ ) {

    			projectObject( children[ i ], camera );

    		}

    	}

    	function renderObjects( renderList, camera, fog, overrideMaterial ) {

    		for ( var i = 0, l = renderList.length; i < l; i ++ ) {

    			var renderItem = renderList[ i ];

    			var object = renderItem.object;
    			var geometry = renderItem.geometry;
    			var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;
    			var group = renderItem.group;

    			object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
    			object.normalMatrix.getNormalMatrix( object.modelViewMatrix );

    			if ( object.isImmediateRenderObject ) {

    				setMaterial( material );

    				var program = setProgram( camera, fog, material, object );

    				_currentGeometryProgram = '';

    				object.render( function ( object ) {

    					_this.renderBufferImmediate( object, program, material );

    				} );

    			} else {

    				if ( object.onBeforeRender !== null ) object.onBeforeRender();

    				_this.renderBufferDirect( camera, fog, geometry, material, object, group );

    			}

    		}

    	}

    	function initMaterial( material, fog, object ) {

    		var materialProperties = properties.get( material );

    		var parameters = programCache.getParameters(
    				material, _lights, fog, _clipping.numPlanes, object );

    		var code = programCache.getProgramCode( material, parameters );

    		var program = materialProperties.program;
    		var programChange = true;

    		if ( program === undefined ) {

    			// new material
    			material.addEventListener( 'dispose', onMaterialDispose );

    		} else if ( program.code !== code ) {

    			// changed glsl or parameters
    			releaseMaterialProgramReference( material );

    		} else if ( parameters.shaderID !== undefined ) {

    			// same glsl and uniform list
    			return;

    		} else {

    			// only rebuild uniform list
    			programChange = false;

    		}

    		if ( programChange ) {

    			if ( parameters.shaderID ) {

    				var shader = ShaderLib[ parameters.shaderID ];

    				materialProperties.__webglShader = {
    					name: material.type,
    					uniforms: exports.UniformsUtils.clone( shader.uniforms ),
    					vertexShader: shader.vertexShader,
    					fragmentShader: shader.fragmentShader
    				};

    			} else {

    				materialProperties.__webglShader = {
    					name: material.type,
    					uniforms: material.uniforms,
    					vertexShader: material.vertexShader,
    					fragmentShader: material.fragmentShader
    				};

    			}

    			material.__webglShader = materialProperties.__webglShader;

    			program = programCache.acquireProgram( material, parameters, code );

    			materialProperties.program = program;
    			material.program = program;

    		}

    		var attributes = program.getAttributes();

    		if ( material.morphTargets ) {

    			material.numSupportedMorphTargets = 0;

    			for ( var i = 0; i < _this.maxMorphTargets; i ++ ) {

    				if ( attributes[ 'morphTarget' + i ] >= 0 ) {

    					material.numSupportedMorphTargets ++;

    				}

    			}

    		}

    		if ( material.morphNormals ) {

    			material.numSupportedMorphNormals = 0;

    			for ( var i = 0; i < _this.maxMorphNormals; i ++ ) {

    				if ( attributes[ 'morphNormal' + i ] >= 0 ) {

    					material.numSupportedMorphNormals ++;

    				}

    			}

    		}

    		var uniforms = materialProperties.__webglShader.uniforms;

    		if ( ! material.isShaderMaterial &&
    		     ! material.isRawShaderMaterial ||
    		       material.clipping === true ) {

    			materialProperties.numClippingPlanes = _clipping.numPlanes;
    			uniforms.clippingPlanes = _clipping.uniform;

    		}

    		materialProperties.fog = fog;

    		// store the light setup it was created for

    		materialProperties.lightsHash = _lights.hash;

    		if ( material.lights ) {

    			// wire up the material to this renderer's lighting state

    			uniforms.ambientLightColor.value = _lights.ambient;
    			uniforms.directionalLights.value = _lights.directional;
    			uniforms.spotLights.value = _lights.spot;
    			uniforms.pointLights.value = _lights.point;
    			uniforms.hemisphereLights.value = _lights.hemi;

    			uniforms.directionalShadowMap.value = _lights.directionalShadowMap;
    			uniforms.directionalShadowMatrix.value = _lights.directionalShadowMatrix;
    			uniforms.spotShadowMap.value = _lights.spotShadowMap;
    			uniforms.spotShadowMatrix.value = _lights.spotShadowMatrix;
    			uniforms.pointShadowMap.value = _lights.pointShadowMap;
    			uniforms.pointShadowMatrix.value = _lights.pointShadowMatrix;

    		}

    		var progUniforms = materialProperties.program.getUniforms(),
    			uniformsList =
    					WebGLUniforms.seqWithValue( progUniforms.seq, uniforms );

    		materialProperties.uniformsList = uniformsList;
    		materialProperties.dynamicUniforms =
    				WebGLUniforms.splitDynamic( uniformsList, uniforms );

    	}

    	function setMaterial( material ) {

    		material.side === DoubleSide
    			? state.disable( _gl.CULL_FACE )
    			: state.enable( _gl.CULL_FACE );

    		state.setFlipSided( material.side === BackSide );

    		material.transparent === true
    			? state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha )
    			: state.setBlending( NoBlending );

    		state.setDepthFunc( material.depthFunc );
    		state.setDepthTest( material.depthTest );
    		state.setDepthWrite( material.depthWrite );
    		state.setColorWrite( material.colorWrite );
    		state.setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

    	}

    	function setProgram( camera, fog, material, object ) {

    		_usedTextureUnits = 0;

    		var materialProperties = properties.get( material );

    		if ( _clippingEnabled ) {

    			if ( _localClippingEnabled || camera !== _currentCamera ) {

    				var useCache =
    						camera === _currentCamera &&
    						material.id === _currentMaterialId;

    				// we might want to call this function with some ClippingGroup
    				// object instead of the material, once it becomes feasible
    				// (#8465, #8379)
    				_clipping.setState(
    						material.clippingPlanes, material.clipShadows,
    						camera, materialProperties, useCache );

    			}

    		}

    		if ( material.needsUpdate === false ) {

    			if ( materialProperties.program === undefined ) {

    				material.needsUpdate = true;

    			} else if ( material.fog && materialProperties.fog !== fog ) {

    				material.needsUpdate = true;

    			} else if ( material.lights && materialProperties.lightsHash !== _lights.hash ) {

    				material.needsUpdate = true;

    			} else if ( materialProperties.numClippingPlanes !== undefined &&
    				materialProperties.numClippingPlanes !== _clipping.numPlanes ) {

    				material.needsUpdate = true;

    			}

    		}

    		if ( material.needsUpdate ) {

    			initMaterial( material, fog, object );
    			material.needsUpdate = false;

    		}

    		var refreshProgram = false;
    		var refreshMaterial = false;
    		var refreshLights = false;

    		var program = materialProperties.program,
    			p_uniforms = program.getUniforms(),
    			m_uniforms = materialProperties.__webglShader.uniforms;

    		if ( program.id !== _currentProgram ) {

    			_gl.useProgram( program.program );
    			_currentProgram = program.id;

    			refreshProgram = true;
    			refreshMaterial = true;
    			refreshLights = true;

    		}

    		if ( material.id !== _currentMaterialId ) {

    			_currentMaterialId = material.id;

    			refreshMaterial = true;

    		}

    		if ( refreshProgram || camera !== _currentCamera ) {

    			p_uniforms.set( _gl, camera, 'projectionMatrix' );

    			if ( capabilities.logarithmicDepthBuffer ) {

    				p_uniforms.setValue( _gl, 'logDepthBufFC',
    						2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );

    			}


    			if ( camera !== _currentCamera ) {

    				_currentCamera = camera;

    				// lighting uniforms depend on the camera so enforce an update
    				// now, in case this material supports lights - or later, when
    				// the next material that does gets activated:

    				refreshMaterial = true;		// set to true on material change
    				refreshLights = true;		// remains set until update done

    			}

    			// load material specific uniforms
    			// (shader material also gets them for the sake of genericity)

    			if ( material.isShaderMaterial ||
    			     material.isMeshPhongMaterial ||
    			     material.isMeshStandardMaterial ||
    			     material.envMap ) {

    				var uCamPos = p_uniforms.map.cameraPosition;

    				if ( uCamPos !== undefined ) {

    					uCamPos.setValue( _gl,
    							_vector3.setFromMatrixPosition( camera.matrixWorld ) );

    				}

    			}

    			if ( material.isMeshPhongMaterial ||
    			     material.isMeshLambertMaterial ||
    			     material.isMeshBasicMaterial ||
    			     material.isMeshStandardMaterial ||
    			     material.isShaderMaterial ||
    			     material.skinning ) {

    				p_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );

    			}

    			p_uniforms.set( _gl, _this, 'toneMappingExposure' );
    			p_uniforms.set( _gl, _this, 'toneMappingWhitePoint' );

    		}

    		// skinning uniforms must be set even if material didn't change
    		// auto-setting of texture unit for bone texture must go before other textures
    		// not sure why, but otherwise weird things happen

    		if ( material.skinning ) {

    			p_uniforms.setOptional( _gl, object, 'bindMatrix' );
    			p_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );

    			var skeleton = object.skeleton;

    			if ( skeleton ) {

    				if ( capabilities.floatVertexTextures && skeleton.useVertexTexture ) {

    					p_uniforms.set( _gl, skeleton, 'boneTexture' );
    					p_uniforms.set( _gl, skeleton, 'boneTextureWidth' );
    					p_uniforms.set( _gl, skeleton, 'boneTextureHeight' );

    				} else {

    					p_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );

    				}

    			}

    		}

    		if ( refreshMaterial ) {

    			if ( material.lights ) {

    				// the current material requires lighting info

    				// note: all lighting uniforms are always set correctly
    				// they simply reference the renderer's state for their
    				// values
    				//
    				// use the current material's .needsUpdate flags to set
    				// the GL state when required

    				markUniformsLightsNeedsUpdate( m_uniforms, refreshLights );

    			}

    			// refresh uniforms common to several materials

    			if ( fog && material.fog ) {

    				refreshUniformsFog( m_uniforms, fog );

    			}

    			if ( material.isMeshBasicMaterial ||
    			     material.isMeshLambertMaterial ||
    			     material.isMeshPhongMaterial ||
    			     material.isMeshStandardMaterial ||
    			     material.isMeshDepthMaterial ) {

    				refreshUniformsCommon( m_uniforms, material );

    			}

    			// refresh single material specific uniforms

    			if ( material.isLineBasicMaterial ) {

    				refreshUniformsLine( m_uniforms, material );

    			} else if ( material.isLineDashedMaterial ) {

    				refreshUniformsLine( m_uniforms, material );
    				refreshUniformsDash( m_uniforms, material );

    			} else if ( material.isPointsMaterial ) {

    				refreshUniformsPoints( m_uniforms, material );

    			} else if ( material.isMeshLambertMaterial ) {

    				refreshUniformsLambert( m_uniforms, material );

    			} else if ( material.isMeshPhongMaterial ) {

    				refreshUniformsPhong( m_uniforms, material );

    			} else if ( material.isMeshPhysicalMaterial ) {

    				refreshUniformsPhysical( m_uniforms, material );

    			} else if ( material.isMeshStandardMaterial ) {

    				refreshUniformsStandard( m_uniforms, material );

    			} else if ( material.isMeshDepthMaterial ) {

    				if ( material.displacementMap ) {

    					m_uniforms.displacementMap.value = material.displacementMap;
    					m_uniforms.displacementScale.value = material.displacementScale;
    					m_uniforms.displacementBias.value = material.displacementBias;

    				}

    			} else if ( material.isMeshNormalMaterial ) {

    				m_uniforms.opacity.value = material.opacity;

    			}

    			WebGLUniforms.upload(
    					_gl, materialProperties.uniformsList, m_uniforms, _this );

    		}


    		// common matrices

    		p_uniforms.set( _gl, object, 'modelViewMatrix' );
    		p_uniforms.set( _gl, object, 'normalMatrix' );
    		p_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );


    		// dynamic uniforms

    		var dynUniforms = materialProperties.dynamicUniforms;

    		if ( dynUniforms !== null ) {

    			WebGLUniforms.evalDynamic( dynUniforms, m_uniforms, object, material, camera );
    			WebGLUniforms.upload( _gl, dynUniforms, m_uniforms, _this );

    		}

    		return program;

    	}

    	// Uniforms (refresh uniforms objects)

    	function refreshUniformsCommon( uniforms, material ) {

    		uniforms.opacity.value = material.opacity;

    		uniforms.diffuse.value = material.color;

    		if ( material.emissive ) {

    			uniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );

    		}

    		uniforms.map.value = material.map;
    		uniforms.specularMap.value = material.specularMap;
    		uniforms.alphaMap.value = material.alphaMap;

    		if ( material.aoMap ) {

    			uniforms.aoMap.value = material.aoMap;
    			uniforms.aoMapIntensity.value = material.aoMapIntensity;

    		}

    		// uv repeat and offset setting priorities
    		// 1. color map
    		// 2. specular map
    		// 3. normal map
    		// 4. bump map
    		// 5. alpha map
    		// 6. emissive map

    		var uvScaleMap;

    		if ( material.map ) {

    			uvScaleMap = material.map;

    		} else if ( material.specularMap ) {

    			uvScaleMap = material.specularMap;

    		} else if ( material.displacementMap ) {

    			uvScaleMap = material.displacementMap;

    		} else if ( material.normalMap ) {

    			uvScaleMap = material.normalMap;

    		} else if ( material.bumpMap ) {

    			uvScaleMap = material.bumpMap;

    		} else if ( material.roughnessMap ) {

    			uvScaleMap = material.roughnessMap;

    		} else if ( material.metalnessMap ) {

    			uvScaleMap = material.metalnessMap;

    		} else if ( material.alphaMap ) {

    			uvScaleMap = material.alphaMap;

    		} else if ( material.emissiveMap ) {

    			uvScaleMap = material.emissiveMap;

    		}

    		if ( uvScaleMap !== undefined ) {

    			// backwards compatibility
    			if ( uvScaleMap.isWebGLRenderTarget ) {

    				uvScaleMap = uvScaleMap.texture;

    			}

    			var offset = uvScaleMap.offset;
    			var repeat = uvScaleMap.repeat;

    			uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );

    		}

    		uniforms.envMap.value = material.envMap;

    		// don't flip CubeTexture envMaps, flip everything else:
    		//  WebGLRenderTargetCube will be flipped for backwards compatibility
    		//  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture
    		// this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future
    		uniforms.flipEnvMap.value = ( ! ( material.envMap && material.envMap.isCubeTexture ) ) ? 1 : - 1;

    		uniforms.reflectivity.value = material.reflectivity;
    		uniforms.refractionRatio.value = material.refractionRatio;

    	}

    	function refreshUniformsLine( uniforms, material ) {

    		uniforms.diffuse.value = material.color;
    		uniforms.opacity.value = material.opacity;

    	}

    	function refreshUniformsDash( uniforms, material ) {

    		uniforms.dashSize.value = material.dashSize;
    		uniforms.totalSize.value = material.dashSize + material.gapSize;
    		uniforms.scale.value = material.scale;

    	}

    	function refreshUniformsPoints( uniforms, material ) {

    		uniforms.diffuse.value = material.color;
    		uniforms.opacity.value = material.opacity;
    		uniforms.size.value = material.size * _pixelRatio;
    		uniforms.scale.value = _canvas.clientHeight * 0.5;

    		uniforms.map.value = material.map;

    		if ( material.map !== null ) {

    			var offset = material.map.offset;
    			var repeat = material.map.repeat;

    			uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );

    		}

    	}

    	function refreshUniformsFog( uniforms, fog ) {

    		uniforms.fogColor.value = fog.color;

    		if ( fog.isFog ) {

    			uniforms.fogNear.value = fog.near;
    			uniforms.fogFar.value = fog.far;

    		} else if ( fog.isFogExp2 ) {

    			uniforms.fogDensity.value = fog.density;

    		}

    	}

    	function refreshUniformsLambert( uniforms, material ) {

    		if ( material.lightMap ) {

    			uniforms.lightMap.value = material.lightMap;
    			uniforms.lightMapIntensity.value = material.lightMapIntensity;

    		}

    		if ( material.emissiveMap ) {

    			uniforms.emissiveMap.value = material.emissiveMap;

    		}

    	}

    	function refreshUniformsPhong( uniforms, material ) {

    		uniforms.specular.value = material.specular;
    		uniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )

    		if ( material.lightMap ) {

    			uniforms.lightMap.value = material.lightMap;
    			uniforms.lightMapIntensity.value = material.lightMapIntensity;

    		}

    		if ( material.emissiveMap ) {

    			uniforms.emissiveMap.value = material.emissiveMap;

    		}

    		if ( material.bumpMap ) {

    			uniforms.bumpMap.value = material.bumpMap;
    			uniforms.bumpScale.value = material.bumpScale;

    		}

    		if ( material.normalMap ) {

    			uniforms.normalMap.value = material.normalMap;
    			uniforms.normalScale.value.copy( material.normalScale );

    		}

    		if ( material.displacementMap ) {

    			uniforms.displacementMap.value = material.displacementMap;
    			uniforms.displacementScale.value = material.displacementScale;
    			uniforms.displacementBias.value = material.displacementBias;

    		}

    	}

    	function refreshUniformsStandard( uniforms, material ) {

    		uniforms.roughness.value = material.roughness;
    		uniforms.metalness.value = material.metalness;

    		if ( material.roughnessMap ) {

    			uniforms.roughnessMap.value = material.roughnessMap;

    		}

    		if ( material.metalnessMap ) {

    			uniforms.metalnessMap.value = material.metalnessMap;

    		}

    		if ( material.lightMap ) {

    			uniforms.lightMap.value = material.lightMap;
    			uniforms.lightMapIntensity.value = material.lightMapIntensity;

    		}

    		if ( material.emissiveMap ) {

    			uniforms.emissiveMap.value = material.emissiveMap;

    		}

    		if ( material.bumpMap ) {

    			uniforms.bumpMap.value = material.bumpMap;
    			uniforms.bumpScale.value = material.bumpScale;

    		}

    		if ( material.normalMap ) {

    			uniforms.normalMap.value = material.normalMap;
    			uniforms.normalScale.value.copy( material.normalScale );

    		}

    		if ( material.displacementMap ) {

    			uniforms.displacementMap.value = material.displacementMap;
    			uniforms.displacementScale.value = material.displacementScale;
    			uniforms.displacementBias.value = material.displacementBias;

    		}

    		if ( material.envMap ) {

    			//uniforms.envMap.value = material.envMap; // part of uniforms common
    			uniforms.envMapIntensity.value = material.envMapIntensity;

    		}

    	}

    	function refreshUniformsPhysical( uniforms, material ) {

    		uniforms.clearCoat.value = material.clearCoat;
    		uniforms.clearCoatRoughness.value = material.clearCoatRoughness;

    		refreshUniformsStandard( uniforms, material );

    	}

    	// If uniforms are marked as clean, they don't need to be loaded to the GPU.

    	function markUniformsLightsNeedsUpdate( uniforms, value ) {

    		uniforms.ambientLightColor.needsUpdate = value;

    		uniforms.directionalLights.needsUpdate = value;
    		uniforms.pointLights.needsUpdate = value;
    		uniforms.spotLights.needsUpdate = value;
    		uniforms.hemisphereLights.needsUpdate = value;

    	}

    	// Lighting

    	function setupShadows( lights ) {

    		var lightShadowsLength = 0;

    		for ( var i = 0, l = lights.length; i < l; i ++ ) {

    			var light = lights[ i ];

    			if ( light.castShadow ) {

    				_lights.shadows[ lightShadowsLength ++ ] = light;

    			}

    		}

    		_lights.shadows.length = lightShadowsLength;

    	}

    	function setupLights( lights, camera ) {

    		var l, ll, light,
    		r = 0, g = 0, b = 0,
    		color,
    		intensity,
    		distance,
    		shadowMap,

    		viewMatrix = camera.matrixWorldInverse,

    		directionalLength = 0,
    		pointLength = 0,
    		spotLength = 0,
    		hemiLength = 0;

    		for ( l = 0, ll = lights.length; l < ll; l ++ ) {

    			light = lights[ l ];

    			color = light.color;
    			intensity = light.intensity;
    			distance = light.distance;

    			shadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;

    			if ( light.isAmbientLight ) {

    				r += color.r * intensity;
    				g += color.g * intensity;
    				b += color.b * intensity;

    			} else if ( light.isDirectionalLight ) {

    				var uniforms = lightCache.get( light );

    				uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
    				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
    				_vector3.setFromMatrixPosition( light.target.matrixWorld );
    				uniforms.direction.sub( _vector3 );
    				uniforms.direction.transformDirection( viewMatrix );

    				uniforms.shadow = light.castShadow;

    				if ( light.castShadow ) {

    					uniforms.shadowBias = light.shadow.bias;
    					uniforms.shadowRadius = light.shadow.radius;
    					uniforms.shadowMapSize = light.shadow.mapSize;

    				}

    				_lights.directionalShadowMap[ directionalLength ] = shadowMap;
    				_lights.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;
    				_lights.directional[ directionalLength ++ ] = uniforms;

    			} else if ( light.isSpotLight ) {

    				var uniforms = lightCache.get( light );

    				uniforms.position.setFromMatrixPosition( light.matrixWorld );
    				uniforms.position.applyMatrix4( viewMatrix );

    				uniforms.color.copy( color ).multiplyScalar( intensity );
    				uniforms.distance = distance;

    				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
    				_vector3.setFromMatrixPosition( light.target.matrixWorld );
    				uniforms.direction.sub( _vector3 );
    				uniforms.direction.transformDirection( viewMatrix );

    				uniforms.coneCos = Math.cos( light.angle );
    				uniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );
    				uniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;

    				uniforms.shadow = light.castShadow;

    				if ( light.castShadow ) {

    					uniforms.shadowBias = light.shadow.bias;
    					uniforms.shadowRadius = light.shadow.radius;
    					uniforms.shadowMapSize = light.shadow.mapSize;

    				}

    				_lights.spotShadowMap[ spotLength ] = shadowMap;
    				_lights.spotShadowMatrix[ spotLength ] = light.shadow.matrix;
    				_lights.spot[ spotLength ++ ] = uniforms;

    			} else if ( light.isPointLight ) {

    				var uniforms = lightCache.get( light );

    				uniforms.position.setFromMatrixPosition( light.matrixWorld );
    				uniforms.position.applyMatrix4( viewMatrix );

    				uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
    				uniforms.distance = light.distance;
    				uniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;

    				uniforms.shadow = light.castShadow;

    				if ( light.castShadow ) {

    					uniforms.shadowBias = light.shadow.bias;
    					uniforms.shadowRadius = light.shadow.radius;
    					uniforms.shadowMapSize = light.shadow.mapSize;

    				}

    				_lights.pointShadowMap[ pointLength ] = shadowMap;

    				if ( _lights.pointShadowMatrix[ pointLength ] === undefined ) {

    					_lights.pointShadowMatrix[ pointLength ] = new Matrix4();

    				}

    				// for point lights we set the shadow matrix to be a translation-only matrix
    				// equal to inverse of the light's position
    				_vector3.setFromMatrixPosition( light.matrixWorld ).negate();
    				_lights.pointShadowMatrix[ pointLength ].identity().setPosition( _vector3 );

    				_lights.point[ pointLength ++ ] = uniforms;

    			} else if ( light.isHemisphereLight ) {

    				var uniforms = lightCache.get( light );

    				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
    				uniforms.direction.transformDirection( viewMatrix );
    				uniforms.direction.normalize();

    				uniforms.skyColor.copy( light.color ).multiplyScalar( intensity );
    				uniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );

    				_lights.hemi[ hemiLength ++ ] = uniforms;

    			}

    		}

    		_lights.ambient[ 0 ] = r;
    		_lights.ambient[ 1 ] = g;
    		_lights.ambient[ 2 ] = b;

    		_lights.directional.length = directionalLength;
    		_lights.spot.length = spotLength;
    		_lights.point.length = pointLength;
    		_lights.hemi.length = hemiLength;

    		_lights.hash = directionalLength + ',' + pointLength + ',' + spotLength + ',' + hemiLength + ',' + _lights.shadows.length;

    	}

    	// GL state setting

    	this.setFaceCulling = function ( cullFace, frontFaceDirection ) {

    		state.setCullFace( cullFace );
    		state.setFlipSided( frontFaceDirection === FrontFaceDirectionCW );

    	};

    	// Textures

    	function allocTextureUnit() {

    		var textureUnit = _usedTextureUnits;

    		if ( textureUnit >= capabilities.maxTextures ) {

    			console.warn( 'WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );

    		}

    		_usedTextureUnits += 1;

    		return textureUnit;

    	}

    	this.allocTextureUnit = allocTextureUnit;

    	// this.setTexture2D = setTexture2D;
    	this.setTexture2D = ( function() {

    		var warned = false;

    		// backwards compatibility: peel texture.texture
    		return function setTexture2D( texture, slot ) {

    			if ( texture && texture.isWebGLRenderTarget ) {

    				if ( ! warned ) {

    					console.warn( "THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead." );
    					warned = true;

    				}

    				texture = texture.texture;

    			}

    			textures.setTexture2D( texture, slot );

    		};

    	}() );

    	this.setTexture = ( function() {

    		var warned = false;

    		return function setTexture( texture, slot ) {

    			if ( ! warned ) {

    				console.warn( "THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead." );
    				warned = true;

    			}

    			textures.setTexture2D( texture, slot );

    		};

    	}() );

    	this.setTextureCube = ( function() {

    		var warned = false;

    		return function setTextureCube( texture, slot ) {

    			// backwards compatibility: peel texture.texture
    			if ( texture && texture.isWebGLRenderTargetCube ) {

    				if ( ! warned ) {

    					console.warn( "THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead." );
    					warned = true;

    				}

    				texture = texture.texture;

    			}

    			// currently relying on the fact that WebGLRenderTargetCube.texture is a Texture and NOT a CubeTexture
    			// TODO: unify these code paths
    			if ( ( texture && texture.isCubeTexture ) ||
    				 ( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {

    				// CompressedTexture can have Array in image :/

    				// this function alone should take care of cube textures
    				textures.setTextureCube( texture, slot );

    			} else {

    				// assumed: texture property of THREE.WebGLRenderTargetCube

    				textures.setTextureCubeDynamic( texture, slot );

    			}

    		};

    	}() );

    	this.getCurrentRenderTarget = function() {

    		return _currentRenderTarget;

    	};

    	this.setRenderTarget = function ( renderTarget ) {

    		_currentRenderTarget = renderTarget;

    		if ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {

    			textures.setupRenderTarget( renderTarget );

    		}

    		var isCube = ( renderTarget && renderTarget.isWebGLRenderTargetCube );
    		var framebuffer;

    		if ( renderTarget ) {

    			var renderTargetProperties = properties.get( renderTarget );

    			if ( isCube ) {

    				framebuffer = renderTargetProperties.__webglFramebuffer[ renderTarget.activeCubeFace ];

    			} else {

    				framebuffer = renderTargetProperties.__webglFramebuffer;

    			}

    			_currentScissor.copy( renderTarget.scissor );
    			_currentScissorTest = renderTarget.scissorTest;

    			_currentViewport.copy( renderTarget.viewport );

    		} else {

    			framebuffer = null;

    			_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio );
    			_currentScissorTest = _scissorTest;

    			_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio );

    		}

    		if ( _currentFramebuffer !== framebuffer ) {

    			_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
    			_currentFramebuffer = framebuffer;

    		}

    		state.scissor( _currentScissor );
    		state.setScissorTest( _currentScissorTest );

    		state.viewport( _currentViewport );

    		if ( isCube ) {

    			var textureProperties = properties.get( renderTarget.texture );
    			_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel );

    		}

    	};

    	this.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer ) {

    		if ( ( renderTarget && renderTarget.isWebGLRenderTarget ) === false ) {

    			console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
    			return;

    		}

    		var framebuffer = properties.get( renderTarget ).__webglFramebuffer;

    		if ( framebuffer ) {

    			var restore = false;

    			if ( framebuffer !== _currentFramebuffer ) {

    				_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

    				restore = true;

    			}

    			try {

    				var texture = renderTarget.texture;
    				var textureFormat = texture.format;
    				var textureType = texture.type;

    				if ( textureFormat !== RGBAFormat && paramThreeToGL( textureFormat ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {

    					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );
    					return;

    				}

    				if ( textureType !== UnsignedByteType && paramThreeToGL( textureType ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_TYPE ) && // IE11, Edge and Chrome Mac < 52 (#9513)
    				     ! ( textureType === FloatType && ( extensions.get( 'OES_texture_float' ) || extensions.get( 'WEBGL_color_buffer_float' ) ) ) && // Chrome Mac >= 52 and Firefox
    				     ! ( textureType === HalfFloatType && extensions.get( 'EXT_color_buffer_half_float' ) ) ) {

    					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );
    					return;

    				}

    				if ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {

    					// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)

    					if ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {

    						_gl.readPixels( x, y, width, height, paramThreeToGL( textureFormat ), paramThreeToGL( textureType ), buffer );

    					}

    				} else {

    					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );

    				}

    			} finally {

    				if ( restore ) {

    					_gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );

    				}

    			}

    		}

    	};

    	// Map three.js constants to WebGL constants

    	function paramThreeToGL( p ) {

    		var extension;

    		if ( p === RepeatWrapping ) return _gl.REPEAT;
    		if ( p === ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;
    		if ( p === MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;

    		if ( p === NearestFilter ) return _gl.NEAREST;
    		if ( p === NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;
    		if ( p === NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;

    		if ( p === LinearFilter ) return _gl.LINEAR;
    		if ( p === LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;
    		if ( p === LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;

    		if ( p === UnsignedByteType ) return _gl.UNSIGNED_BYTE;
    		if ( p === UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;
    		if ( p === UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;
    		if ( p === UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;

    		if ( p === ByteType ) return _gl.BYTE;
    		if ( p === ShortType ) return _gl.SHORT;
    		if ( p === UnsignedShortType ) return _gl.UNSIGNED_SHORT;
    		if ( p === IntType ) return _gl.INT;
    		if ( p === UnsignedIntType ) return _gl.UNSIGNED_INT;
    		if ( p === FloatType ) return _gl.FLOAT;

    		extension = extensions.get( 'OES_texture_half_float' );

    		if ( extension !== null ) {

    			if ( p === HalfFloatType ) return extension.HALF_FLOAT_OES;

    		}

    		if ( p === AlphaFormat ) return _gl.ALPHA;
    		if ( p === RGBFormat ) return _gl.RGB;
    		if ( p === RGBAFormat ) return _gl.RGBA;
    		if ( p === LuminanceFormat ) return _gl.LUMINANCE;
    		if ( p === LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;
    		if ( p === DepthFormat ) return _gl.DEPTH_COMPONENT;
    		if ( p === DepthStencilFormat ) return _gl.DEPTH_STENCIL;

    		if ( p === AddEquation ) return _gl.FUNC_ADD;
    		if ( p === SubtractEquation ) return _gl.FUNC_SUBTRACT;
    		if ( p === ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;

    		if ( p === ZeroFactor ) return _gl.ZERO;
    		if ( p === OneFactor ) return _gl.ONE;
    		if ( p === SrcColorFactor ) return _gl.SRC_COLOR;
    		if ( p === OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;
    		if ( p === SrcAlphaFactor ) return _gl.SRC_ALPHA;
    		if ( p === OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;
    		if ( p === DstAlphaFactor ) return _gl.DST_ALPHA;
    		if ( p === OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;

    		if ( p === DstColorFactor ) return _gl.DST_COLOR;
    		if ( p === OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;
    		if ( p === SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;

    		extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );

    		if ( extension !== null ) {

    			if ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
    			if ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
    			if ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
    			if ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;

    		}

    		extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );

    		if ( extension !== null ) {

    			if ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
    			if ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
    			if ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
    			if ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

    		}

    		extension = extensions.get( 'WEBGL_compressed_texture_etc1' );

    		if ( extension !== null ) {

    			if ( p === RGB_ETC1_Format ) return extension.COMPRESSED_RGB_ETC1_WEBGL;

    		}

    		extension = extensions.get( 'EXT_blend_minmax' );

    		if ( extension !== null ) {

    			if ( p === MinEquation ) return extension.MIN_EXT;
    			if ( p === MaxEquation ) return extension.MAX_EXT;

    		}

    		extension = extensions.get( 'WEBGL_depth_texture' );

    		if ( extension !== null ){

    			if ( p === UnsignedInt248Type ) return extension.UNSIGNED_INT_24_8_WEBGL;

    		}

    		return 0;

    	}

    }

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     */

    function FogExp2 ( color, density ) {

    	this.name = '';

    	this.color = new Color( color );
    	this.density = ( density !== undefined ) ? density : 0.00025;

    }

    FogExp2.prototype.isFogExp2 = true;

    FogExp2.prototype.clone = function () {

    	return new FogExp2( this.color.getHex(), this.density );

    };

    FogExp2.prototype.toJSON = function ( meta ) {

    	return {
    		type: 'FogExp2',
    		color: this.color.getHex(),
    		density: this.density
    	};

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     */

    function Fog ( color, near, far ) {

    	this.name = '';

    	this.color = new Color( color );

    	this.near = ( near !== undefined ) ? near : 1;
    	this.far = ( far !== undefined ) ? far : 1000;

    }

    Fog.prototype.isFog = true;

    Fog.prototype.clone = function () {

    	return new Fog( this.color.getHex(), this.near, this.far );

    };

    Fog.prototype.toJSON = function ( meta ) {

    	return {
    		type: 'Fog',
    		color: this.color.getHex(),
    		near: this.near,
    		far: this.far
    	};

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function Scene () {

    	Object3D.call( this );

    	this.type = 'Scene';

    	this.background = null;
    	this.fog = null;
    	this.overrideMaterial = null;

    	this.autoUpdate = true; // checked by the renderer

    }

    Scene.prototype = Object.create( Object3D.prototype );

    Scene.prototype.constructor = Scene;

    Scene.prototype.copy = function ( source, recursive ) {

    	Object3D.prototype.copy.call( this, source, recursive );

    	if ( source.background !== null ) this.background = source.background.clone();
    	if ( source.fog !== null ) this.fog = source.fog.clone();
    	if ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();

    	this.autoUpdate = source.autoUpdate;
    	this.matrixAutoUpdate = source.matrixAutoUpdate;

    	return this;

    };

    Scene.prototype.toJSON = function ( meta ) {

    	var data = Object3D.prototype.toJSON.call( this, meta );

    	if ( this.background !== null ) data.object.background = this.background.toJSON( meta );
    	if ( this.fog !== null ) data.object.fog = this.fog.toJSON();

    	return data;

    };

    /**
     * @author mikael emtinger / http://gomo.se/
     * @author alteredq / http://alteredqualia.com/
     */

    function LensFlare( texture, size, distance, blending, color ) {

    	Object3D.call( this );

    	this.lensFlares = [];

    	this.positionScreen = new Vector3();
    	this.customUpdateCallback = undefined;

    	if ( texture !== undefined ) {

    		this.add( texture, size, distance, blending, color );

    	}

    }

    LensFlare.prototype = Object.assign( Object.create( Object3D.prototype ), {

    	constructor: LensFlare,

    	isLensFlare: true,

    	copy: function ( source ) {

    		Object3D.prototype.copy.call( this, source );

    		this.positionScreen.copy( source.positionScreen );
    		this.customUpdateCallback = source.customUpdateCallback;

    		for ( var i = 0, l = source.lensFlares.length; i < l; i ++ ) {

    			this.lensFlares.push( source.lensFlares[ i ] );

    		}

    		return this;

    	},

    	add: function ( texture, size, distance, blending, color, opacity ) {

    		if ( size === undefined ) size = - 1;
    		if ( distance === undefined ) distance = 0;
    		if ( opacity === undefined ) opacity = 1;
    		if ( color === undefined ) color = new Color( 0xffffff );
    		if ( blending === undefined ) blending = NormalBlending;

    		distance = Math.min( distance, Math.max( 0, distance ) );

    		this.lensFlares.push( {
    			texture: texture,	// THREE.Texture
    			size: size, 		// size in pixels (-1 = use texture.width)
    			distance: distance, 	// distance (0-1) from light source (0=at light source)
    			x: 0, y: 0, z: 0,	// screen position (-1 => 1) z = 0 is in front z = 1 is back
    			scale: 1, 		// scale
    			rotation: 0, 		// rotation
    			opacity: opacity,	// opacity
    			color: color,		// color
    			blending: blending	// blending
    		} );

    	},

    	/*
    	 * Update lens flares update positions on all flares based on the screen position
    	 * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.
    	 */

    	updateLensFlares: function () {

    		var f, fl = this.lensFlares.length;
    		var flare;
    		var vecX = - this.positionScreen.x * 2;
    		var vecY = - this.positionScreen.y * 2;

    		for ( f = 0; f < fl; f ++ ) {

    			flare = this.lensFlares[ f ];

    			flare.x = this.positionScreen.x + vecX * flare.distance;
    			flare.y = this.positionScreen.y + vecY * flare.distance;

    			flare.wantedRotation = flare.x * Math.PI * 0.25;
    			flare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;

    		}

    	}

    } );

    /**
     * @author alteredq / http://alteredqualia.com/
     *
     * parameters = {
     *  color: <hex>,
     *  opacity: <float>,
     *  map: new THREE.Texture( <Image> ),
     *
     *	uvOffset: new THREE.Vector2(),
     *	uvScale: new THREE.Vector2()
     * }
     */

    function SpriteMaterial( parameters ) {

    	Material.call( this );

    	this.type = 'SpriteMaterial';

    	this.color = new Color( 0xffffff );
    	this.map = null;

    	this.rotation = 0;

    	this.fog = false;
    	this.lights = false;

    	this.setValues( parameters );

    }

    SpriteMaterial.prototype = Object.create( Material.prototype );
    SpriteMaterial.prototype.constructor = SpriteMaterial;

    SpriteMaterial.prototype.copy = function ( source ) {

    	Material.prototype.copy.call( this, source );

    	this.color.copy( source.color );
    	this.map = source.map;

    	this.rotation = source.rotation;

    	return this;

    };

    /**
     * @author mikael emtinger / http://gomo.se/
     * @author alteredq / http://alteredqualia.com/
     */

    function Sprite( material ) {

    	Object3D.call( this );

    	this.type = 'Sprite';

    	this.material = ( material !== undefined ) ? material : new SpriteMaterial();

    }

    Sprite.prototype = Object.assign( Object.create( Object3D.prototype ), {

    	constructor: Sprite,

    	isSprite: true,

    	raycast: ( function () {

    		var matrixPosition = new Vector3();

    		return function raycast( raycaster, intersects ) {

    			matrixPosition.setFromMatrixPosition( this.matrixWorld );

    			var distanceSq = raycaster.ray.distanceSqToPoint( matrixPosition );
    			var guessSizeSq = this.scale.x * this.scale.y / 4;

    			if ( distanceSq > guessSizeSq ) {

    				return;

    			}

    			intersects.push( {

    				distance: Math.sqrt( distanceSq ),
    				point: this.position,
    				face: null,
    				object: this

    			} );

    		};

    	}() ),

    	clone: function () {

    		return new this.constructor( this.material ).copy( this );

    	}

    } );

    /**
     * @author mikael emtinger / http://gomo.se/
     * @author alteredq / http://alteredqualia.com/
     * @author mrdoob / http://mrdoob.com/
     */

    function LOD() {

    	Object3D.call( this );

    	this.type = 'LOD';

    	Object.defineProperties( this, {
    		levels: {
    			enumerable: true,
    			value: []
    		}
    	} );

    }


    LOD.prototype = Object.assign( Object.create( Object3D.prototype ), {

    	constructor: LOD,

    	copy: function ( source ) {

    		Object3D.prototype.copy.call( this, source, false );

    		var levels = source.levels;

    		for ( var i = 0, l = levels.length; i < l; i ++ ) {

    			var level = levels[ i ];

    			this.addLevel( level.object.clone(), level.distance );

    		}

    		return this;

    	},

    	addLevel: function ( object, distance ) {

    		if ( distance === undefined ) distance = 0;

    		distance = Math.abs( distance );

    		var levels = this.levels;

    		for ( var l = 0; l < levels.length; l ++ ) {

    			if ( distance < levels[ l ].distance ) {

    				break;

    			}

    		}

    		levels.splice( l, 0, { distance: distance, object: object } );

    		this.add( object );

    	},

    	getObjectForDistance: function ( distance ) {

    		var levels = this.levels;

    		for ( var i = 1, l = levels.length; i < l; i ++ ) {

    			if ( distance < levels[ i ].distance ) {

    				break;

    			}

    		}

    		return levels[ i - 1 ].object;

    	},

    	raycast: ( function () {

    		var matrixPosition = new Vector3();

    		return function raycast( raycaster, intersects ) {

    			matrixPosition.setFromMatrixPosition( this.matrixWorld );

    			var distance = raycaster.ray.origin.distanceTo( matrixPosition );

    			this.getObjectForDistance( distance ).raycast( raycaster, intersects );

    		};

    	}() ),

    	update: function () {

    		var v1 = new Vector3();
    		var v2 = new Vector3();

    		return function update( camera ) {

    			var levels = this.levels;

    			if ( levels.length > 1 ) {

    				v1.setFromMatrixPosition( camera.matrixWorld );
    				v2.setFromMatrixPosition( this.matrixWorld );

    				var distance = v1.distanceTo( v2 );

    				levels[ 0 ].object.visible = true;

    				for ( var i = 1, l = levels.length; i < l; i ++ ) {

    					if ( distance >= levels[ i ].distance ) {

    						levels[ i - 1 ].object.visible = false;
    						levels[ i ].object.visible = true;

    					} else {

    						break;

    					}

    				}

    				for ( ; i < l; i ++ ) {

    					levels[ i ].object.visible = false;

    				}

    			}

    		};

    	}(),

    	toJSON: function ( meta ) {

    		var data = Object3D.prototype.toJSON.call( this, meta );

    		data.object.levels = [];

    		var levels = this.levels;

    		for ( var i = 0, l = levels.length; i < l; i ++ ) {

    			var level = levels[ i ];

    			data.object.levels.push( {
    				object: level.object.uuid,
    				distance: level.distance
    			} );

    		}

    		return data;

    	}

    } );

    /**
     * @author alteredq / http://alteredqualia.com/
     */

    function DataTexture( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {

    	Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

    	this.image = { data: data, width: width, height: height };

    	this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
    	this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;

    	this.flipY = false;
    	this.generateMipmaps  = false;

    }

    DataTexture.prototype = Object.create( Texture.prototype );
    DataTexture.prototype.constructor = DataTexture;

    DataTexture.prototype.isDataTexture = true;

    /**
     * @author mikael emtinger / http://gomo.se/
     * @author alteredq / http://alteredqualia.com/
     * @author michael guerrero / http://realitymeltdown.com
     * @author ikerr / http://verold.com
     */

    function Skeleton( bones, boneInverses, useVertexTexture ) {

    	this.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;

    	this.identityMatrix = new Matrix4();

    	// copy the bone array

    	bones = bones || [];

    	this.bones = bones.slice( 0 );

    	// create a bone texture or an array of floats

    	if ( this.useVertexTexture ) {

    		// layout (1 matrix = 4 pixels)
    		//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
    		//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
    		//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
    		//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
    		//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)


    		var size = Math.sqrt( this.bones.length * 4 ); // 4 pixels needed for 1 matrix
    		size = exports.Math.nextPowerOfTwo( Math.ceil( size ) );
    		size = Math.max( size, 4 );

    		this.boneTextureWidth = size;
    		this.boneTextureHeight = size;

    		this.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel
    		this.boneTexture = new DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, RGBAFormat, FloatType );

    	} else {

    		this.boneMatrices = new Float32Array( 16 * this.bones.length );

    	}

    	// use the supplied bone inverses or calculate the inverses

    	if ( boneInverses === undefined ) {

    		this.calculateInverses();

    	} else {

    		if ( this.bones.length === boneInverses.length ) {

    			this.boneInverses = boneInverses.slice( 0 );

    		} else {

    			console.warn( 'THREE.Skeleton bonInverses is the wrong length.' );

    			this.boneInverses = [];

    			for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

    				this.boneInverses.push( new Matrix4() );

    			}

    		}

    	}

    }

    Object.assign( Skeleton.prototype, {

    	calculateInverses: function () {

    		this.boneInverses = [];

    		for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

    			var inverse = new Matrix4();

    			if ( this.bones[ b ] ) {

    				inverse.getInverse( this.bones[ b ].matrixWorld );

    			}

    			this.boneInverses.push( inverse );

    		}

    	},

    	pose: function () {

    		var bone;

    		// recover the bind-time world matrices

    		for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

    			bone = this.bones[ b ];

    			if ( bone ) {

    				bone.matrixWorld.getInverse( this.boneInverses[ b ] );

    			}

    		}

    		// compute the local matrices, positions, rotations and scales

    		for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

    			bone = this.bones[ b ];

    			if ( bone ) {

    				if ( (bone.parent && bone.parent.isBone) ) {

    					bone.matrix.getInverse( bone.parent.matrixWorld );
    					bone.matrix.multiply( bone.matrixWorld );

    				} else {

    					bone.matrix.copy( bone.matrixWorld );

    				}

    				bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );

    			}

    		}

    	},

    	update: ( function () {

    		var offsetMatrix = new Matrix4();

    		return function update() {

    			// flatten bone matrices to array

    			for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

    				// compute the offset between the current and the original transform

    				var matrix = this.bones[ b ] ? this.bones[ b ].matrixWorld : this.identityMatrix;

    				offsetMatrix.multiplyMatrices( matrix, this.boneInverses[ b ] );
    				offsetMatrix.toArray( this.boneMatrices, b * 16 );

    			}

    			if ( this.useVertexTexture ) {

    				this.boneTexture.needsUpdate = true;

    			}

    		};

    	} )(),

    	clone: function () {

    		return new Skeleton( this.bones, this.boneInverses, this.useVertexTexture );

    	}

    } );

    /**
     * @author mikael emtinger / http://gomo.se/
     * @author alteredq / http://alteredqualia.com/
     * @author ikerr / http://verold.com
     */

    function Bone( skin ) {

    	Object3D.call( this );

    	this.type = 'Bone';

    	this.skin = skin;

    }

    Bone.prototype = Object.assign( Object.create( Object3D.prototype ), {

    	constructor: Bone,

    	isBone: true,

    	copy: function ( source ) {

    		Object3D.prototype.copy.call( this, source );

    		this.skin = source.skin;

    		return this;

    	}

    } );

    /**
     * @author mikael emtinger / http://gomo.se/
     * @author alteredq / http://alteredqualia.com/
     * @author ikerr / http://verold.com
     */

    function SkinnedMesh( geometry, material, useVertexTexture ) {

    	Mesh.call( this, geometry, material );

    	this.type = 'SkinnedMesh';

    	this.bindMode = "attached";
    	this.bindMatrix = new Matrix4();
    	this.bindMatrixInverse = new Matrix4();

    	// init bones

    	// TODO: remove bone creation as there is no reason (other than
    	// convenience) for THREE.SkinnedMesh to do this.

    	var bones = [];

    	if ( this.geometry && this.geometry.bones !== undefined ) {

    		var bone, gbone;

    		for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {

    			gbone = this.geometry.bones[ b ];

    			bone = new Bone( this );
    			bones.push( bone );

    			bone.name = gbone.name;
    			bone.position.fromArray( gbone.pos );
    			bone.quaternion.fromArray( gbone.rotq );
    			if ( gbone.scl !== undefined ) bone.scale.fromArray( gbone.scl );

    		}

    		for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {

    			gbone = this.geometry.bones[ b ];

    			if ( gbone.parent !== - 1 && gbone.parent !== null &&
    					bones[ gbone.parent ] !== undefined ) {

    				bones[ gbone.parent ].add( bones[ b ] );

    			} else {

    				this.add( bones[ b ] );

    			}

    		}

    	}

    	this.normalizeSkinWeights();

    	this.updateMatrixWorld( true );
    	this.bind( new Skeleton( bones, undefined, useVertexTexture ), this.matrixWorld );

    }


    SkinnedMesh.prototype = Object.assign( Object.create( Mesh.prototype ), {

    	constructor: SkinnedMesh,

    	isSkinnedMesh: true,

    	bind: function( skeleton, bindMatrix ) {

    		this.skeleton = skeleton;

    		if ( bindMatrix === undefined ) {

    			this.updateMatrixWorld( true );

    			this.skeleton.calculateInverses();

    			bindMatrix = this.matrixWorld;

    		}

    		this.bindMatrix.copy( bindMatrix );
    		this.bindMatrixInverse.getInverse( bindMatrix );

    	},

    	pose: function () {

    		this.skeleton.pose();

    	},

    	normalizeSkinWeights: function () {

    		if ( (this.geometry && this.geometry.isGeometry) ) {

    			for ( var i = 0; i < this.geometry.skinWeights.length; i ++ ) {

    				var sw = this.geometry.skinWeights[ i ];

    				var scale = 1.0 / sw.lengthManhattan();

    				if ( scale !== Infinity ) {

    					sw.multiplyScalar( scale );

    				} else {

    					sw.set( 1, 0, 0, 0 ); // do something reasonable

    				}

    			}

    		} else if ( (this.geometry && this.geometry.isBufferGeometry) ) {

    			var vec = new Vector4();

    			var skinWeight = this.geometry.attributes.skinWeight;

    			for ( var i = 0; i < skinWeight.count; i ++ ) {

    				vec.x = skinWeight.getX( i );
    				vec.y = skinWeight.getY( i );
    				vec.z = skinWeight.getZ( i );
    				vec.w = skinWeight.getW( i );

    				var scale = 1.0 / vec.lengthManhattan();

    				if ( scale !== Infinity ) {

    					vec.multiplyScalar( scale );

    				} else {

    					vec.set( 1, 0, 0, 0 ); // do something reasonable

    				}

    				skinWeight.setXYZW( i, vec.x, vec.y, vec.z, vec.w );

    			}

    		}

    	},

    	updateMatrixWorld: function( force ) {

    		Mesh.prototype.updateMatrixWorld.call( this, true );

    		if ( this.bindMode === "attached" ) {

    			this.bindMatrixInverse.getInverse( this.matrixWorld );

    		} else if ( this.bindMode === "detached" ) {

    			this.bindMatrixInverse.getInverse( this.bindMatrix );

    		} else {

    			console.warn( 'THREE.SkinnedMesh unrecognized bindMode: ' + this.bindMode );

    		}

    	},

    	clone: function() {

    		return new this.constructor( this.geometry, this.material, this.skeleton.useVertexTexture ).copy( this );

    	}

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     *
     * parameters = {
     *  color: <hex>,
     *  opacity: <float>,
     *
     *  linewidth: <float>,
     *  linecap: "round",
     *  linejoin: "round"
     * }
     */

    function LineBasicMaterial( parameters ) {

    	Material.call( this );

    	this.type = 'LineBasicMaterial';

    	this.color = new Color( 0xffffff );

    	this.linewidth = 1;
    	this.linecap = 'round';
    	this.linejoin = 'round';

    	this.lights = false;

    	this.setValues( parameters );

    }

    LineBasicMaterial.prototype = Object.create( Material.prototype );
    LineBasicMaterial.prototype.constructor = LineBasicMaterial;

    LineBasicMaterial.prototype.isLineBasicMaterial = true;

    LineBasicMaterial.prototype.copy = function ( source ) {

    	Material.prototype.copy.call( this, source );

    	this.color.copy( source.color );

    	this.linewidth = source.linewidth;
    	this.linecap = source.linecap;
    	this.linejoin = source.linejoin;

    	return this;

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function Line( geometry, material, mode ) {

    	if ( mode === 1 ) {

    		console.warn( 'THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.' );
    		return new LineSegments( geometry, material );

    	}

    	Object3D.call( this );

    	this.type = 'Line';

    	this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
    	this.material = material !== undefined ? material : new LineBasicMaterial( { color: Math.random() * 0xffffff } );

    }

    Line.prototype = Object.assign( Object.create( Object3D.prototype ), {

    	constructor: Line,

    	isLine: true,

    	raycast: ( function () {

    		var inverseMatrix = new Matrix4();
    		var ray = new Ray();
    		var sphere = new Sphere();

    		return function raycast( raycaster, intersects ) {

    			var precision = raycaster.linePrecision;
    			var precisionSq = precision * precision;

    			var geometry = this.geometry;
    			var matrixWorld = this.matrixWorld;

    			// Checking boundingSphere distance to ray

    			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

    			sphere.copy( geometry.boundingSphere );
    			sphere.applyMatrix4( matrixWorld );

    			if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;

    			//

    			inverseMatrix.getInverse( matrixWorld );
    			ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

    			var vStart = new Vector3();
    			var vEnd = new Vector3();
    			var interSegment = new Vector3();
    			var interRay = new Vector3();
    			var step = (this && this.isLineSegments) ? 2 : 1;

    			if ( (geometry && geometry.isBufferGeometry) ) {

    				var index = geometry.index;
    				var attributes = geometry.attributes;
    				var positions = attributes.position.array;

    				if ( index !== null ) {

    					var indices = index.array;

    					for ( var i = 0, l = indices.length - 1; i < l; i += step ) {

    						var a = indices[ i ];
    						var b = indices[ i + 1 ];

    						vStart.fromArray( positions, a * 3 );
    						vEnd.fromArray( positions, b * 3 );

    						var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

    						if ( distSq > precisionSq ) continue;

    						interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

    						var distance = raycaster.ray.origin.distanceTo( interRay );

    						if ( distance < raycaster.near || distance > raycaster.far ) continue;

    						intersects.push( {

    							distance: distance,
    							// What do we want? intersection point on the ray or on the segment??
    							// point: raycaster.ray.at( distance ),
    							point: interSegment.clone().applyMatrix4( this.matrixWorld ),
    							index: i,
    							face: null,
    							faceIndex: null,
    							object: this

    						} );

    					}

    				} else {

    					for ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {

    						vStart.fromArray( positions, 3 * i );
    						vEnd.fromArray( positions, 3 * i + 3 );

    						var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

    						if ( distSq > precisionSq ) continue;

    						interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

    						var distance = raycaster.ray.origin.distanceTo( interRay );

    						if ( distance < raycaster.near || distance > raycaster.far ) continue;

    						intersects.push( {

    							distance: distance,
    							// What do we want? intersection point on the ray or on the segment??
    							// point: raycaster.ray.at( distance ),
    							point: interSegment.clone().applyMatrix4( this.matrixWorld ),
    							index: i,
    							face: null,
    							faceIndex: null,
    							object: this

    						} );

    					}

    				}

    			} else if ( (geometry && geometry.isGeometry) ) {

    				var vertices = geometry.vertices;
    				var nbVertices = vertices.length;

    				for ( var i = 0; i < nbVertices - 1; i += step ) {

    					var distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );

    					if ( distSq > precisionSq ) continue;

    					interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

    					var distance = raycaster.ray.origin.distanceTo( interRay );

    					if ( distance < raycaster.near || distance > raycaster.far ) continue;

    					intersects.push( {

    						distance: distance,
    						// What do we want? intersection point on the ray or on the segment??
    						// point: raycaster.ray.at( distance ),
    						point: interSegment.clone().applyMatrix4( this.matrixWorld ),
    						index: i,
    						face: null,
    						faceIndex: null,
    						object: this

    					} );

    				}

    			}

    		};

    	}() ),

    	clone: function () {

    		return new this.constructor( this.geometry, this.material ).copy( this );

    	}

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function LineSegments( geometry, material ) {

    	Line.call( this, geometry, material );

    	this.type = 'LineSegments';

    }

    LineSegments.prototype = Object.assign( Object.create( Line.prototype ), {

    	constructor: LineSegments,

    	isLineSegments: true

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     *
     * parameters = {
     *  color: <hex>,
     *  opacity: <float>,
     *  map: new THREE.Texture( <Image> ),
     *
     *  size: <float>,
     *  sizeAttenuation: <bool>
     * }
     */

    function PointsMaterial( parameters ) {

    	Material.call( this );

    	this.type = 'PointsMaterial';

    	this.color = new Color( 0xffffff );

    	this.map = null;

    	this.size = 1;
    	this.sizeAttenuation = true;

    	this.lights = false;

    	this.setValues( parameters );

    }

    PointsMaterial.prototype = Object.create( Material.prototype );
    PointsMaterial.prototype.constructor = PointsMaterial;

    PointsMaterial.prototype.isPointsMaterial = true;

    PointsMaterial.prototype.copy = function ( source ) {

    	Material.prototype.copy.call( this, source );

    	this.color.copy( source.color );

    	this.map = source.map;

    	this.size = source.size;
    	this.sizeAttenuation = source.sizeAttenuation;

    	return this;

    };

    /**
     * @author alteredq / http://alteredqualia.com/
     */

    function Points( geometry, material ) {

    	Object3D.call( this );

    	this.type = 'Points';

    	this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
    	this.material = material !== undefined ? material : new PointsMaterial( { color: Math.random() * 0xffffff } );

    }

    Points.prototype = Object.assign( Object.create( Object3D.prototype ), {

    	constructor: Points,

    	isPoints: true,

    	raycast: ( function () {

    		var inverseMatrix = new Matrix4();
    		var ray = new Ray();
    		var sphere = new Sphere();

    		return function raycast( raycaster, intersects ) {

    			var object = this;
    			var geometry = this.geometry;
    			var matrixWorld = this.matrixWorld;
    			var threshold = raycaster.params.Points.threshold;

    			// Checking boundingSphere distance to ray

    			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

    			sphere.copy( geometry.boundingSphere );
    			sphere.applyMatrix4( matrixWorld );

    			if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;

    			//

    			inverseMatrix.getInverse( matrixWorld );
    			ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

    			var localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
    			var localThresholdSq = localThreshold * localThreshold;
    			var position = new Vector3();

    			function testPoint( point, index ) {

    				var rayPointDistanceSq = ray.distanceSqToPoint( point );

    				if ( rayPointDistanceSq < localThresholdSq ) {

    					var intersectPoint = ray.closestPointToPoint( point );
    					intersectPoint.applyMatrix4( matrixWorld );

    					var distance = raycaster.ray.origin.distanceTo( intersectPoint );

    					if ( distance < raycaster.near || distance > raycaster.far ) return;

    					intersects.push( {

    						distance: distance,
    						distanceToRay: Math.sqrt( rayPointDistanceSq ),
    						point: intersectPoint.clone(),
    						index: index,
    						face: null,
    						object: object

    					} );

    				}

    			}

    			if ( (geometry && geometry.isBufferGeometry) ) {

    				var index = geometry.index;
    				var attributes = geometry.attributes;
    				var positions = attributes.position.array;

    				if ( index !== null ) {

    					var indices = index.array;

    					for ( var i = 0, il = indices.length; i < il; i ++ ) {

    						var a = indices[ i ];

    						position.fromArray( positions, a * 3 );

    						testPoint( position, a );

    					}

    				} else {

    					for ( var i = 0, l = positions.length / 3; i < l; i ++ ) {

    						position.fromArray( positions, i * 3 );

    						testPoint( position, i );

    					}

    				}

    			} else {

    				var vertices = geometry.vertices;

    				for ( var i = 0, l = vertices.length; i < l; i ++ ) {

    					testPoint( vertices[ i ], i );

    				}

    			}

    		};

    	}() ),

    	clone: function () {

    		return new this.constructor( this.geometry, this.material ).copy( this );

    	}

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function Group() {

    	Object3D.call( this );

    	this.type = 'Group';

    }

    Group.prototype = Object.assign( Object.create( Object3D.prototype ), {

    	constructor: Group

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function VideoTexture( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

    	Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

    	this.generateMipmaps = false;

    	var scope = this;

    	function update() {

    		requestAnimationFrame( update );

    		if ( video.readyState >= video.HAVE_CURRENT_DATA ) {

    			scope.needsUpdate = true;

    		}

    	}

    	update();

    }

    VideoTexture.prototype = Object.create( Texture.prototype );
    VideoTexture.prototype.constructor = VideoTexture;

    /**
     * @author alteredq / http://alteredqualia.com/
     */

    function CompressedTexture( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {

    	Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

    	this.image = { width: width, height: height };
    	this.mipmaps = mipmaps;

    	// no flipping for cube textures
    	// (also flipping doesn't work for compressed textures )

    	this.flipY = false;

    	// can't generate mipmaps for compressed textures
    	// mips must be embedded in DDS files

    	this.generateMipmaps = false;

    }

    CompressedTexture.prototype = Object.create( Texture.prototype );
    CompressedTexture.prototype.constructor = CompressedTexture;

    CompressedTexture.prototype.isCompressedTexture = true;

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function CanvasTexture( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

    	Texture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

    	this.needsUpdate = true;

    }

    CanvasTexture.prototype = Object.create( Texture.prototype );
    CanvasTexture.prototype.constructor = CanvasTexture;

    /**
     * @author Matt DesLauriers / @mattdesl
     * @author atix / arthursilber.de
     */

    function DepthTexture( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format ) {

    	format = format !== undefined ? format : DepthFormat;

    	if ( format !== DepthFormat && format !== DepthStencilFormat ) {

    		throw new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' )

    	}

    	Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

    	this.image = { width: width, height: height };

    	this.type = type !== undefined ? type : UnsignedShortType;

    	this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
    	this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;

    	this.flipY = false;
    	this.generateMipmaps	= false;

    }

    DepthTexture.prototype = Object.create( Texture.prototype );
    DepthTexture.prototype.constructor = DepthTexture;
    DepthTexture.prototype.isDepthTexture = true;

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function WireframeGeometry( geometry ) {

    	BufferGeometry.call( this );

    	var edge = [ 0, 0 ], hash = {};

    	function sortFunction( a, b ) {

    		return a - b;

    	}

    	var keys = [ 'a', 'b', 'c' ];

    	if ( (geometry && geometry.isGeometry) ) {

    		var vertices = geometry.vertices;
    		var faces = geometry.faces;
    		var numEdges = 0;

    		// allocate maximal size
    		var edges = new Uint32Array( 6 * faces.length );

    		for ( var i = 0, l = faces.length; i < l; i ++ ) {

    			var face = faces[ i ];

    			for ( var j = 0; j < 3; j ++ ) {

    				edge[ 0 ] = face[ keys[ j ] ];
    				edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
    				edge.sort( sortFunction );

    				var key = edge.toString();

    				if ( hash[ key ] === undefined ) {

    					edges[ 2 * numEdges ] = edge[ 0 ];
    					edges[ 2 * numEdges + 1 ] = edge[ 1 ];
    					hash[ key ] = true;
    					numEdges ++;

    				}

    			}

    		}

    		var coords = new Float32Array( numEdges * 2 * 3 );

    		for ( var i = 0, l = numEdges; i < l; i ++ ) {

    			for ( var j = 0; j < 2; j ++ ) {

    				var vertex = vertices[ edges [ 2 * i + j ] ];

    				var index = 6 * i + 3 * j;
    				coords[ index + 0 ] = vertex.x;
    				coords[ index + 1 ] = vertex.y;
    				coords[ index + 2 ] = vertex.z;

    			}

    		}

    		this.addAttribute( 'position', new BufferAttribute( coords, 3 ) );

    	} else if ( (geometry && geometry.isBufferGeometry) ) {

    		if ( geometry.index !== null ) {

    			// Indexed BufferGeometry

    			var indices = geometry.index.array;
    			var vertices = geometry.attributes.position;
    			var groups = geometry.groups;
    			var numEdges = 0;

    			if ( groups.length === 0 ) {

    				geometry.addGroup( 0, indices.length );

    			}

    			// allocate maximal size
    			var edges = new Uint32Array( 2 * indices.length );

    			for ( var o = 0, ol = groups.length; o < ol; ++ o ) {

    				var group = groups[ o ];

    				var start = group.start;
    				var count = group.count;

    				for ( var i = start, il = start + count; i < il; i += 3 ) {

    					for ( var j = 0; j < 3; j ++ ) {

    						edge[ 0 ] = indices[ i + j ];
    						edge[ 1 ] = indices[ i + ( j + 1 ) % 3 ];
    						edge.sort( sortFunction );

    						var key = edge.toString();

    						if ( hash[ key ] === undefined ) {

    							edges[ 2 * numEdges ] = edge[ 0 ];
    							edges[ 2 * numEdges + 1 ] = edge[ 1 ];
    							hash[ key ] = true;
    							numEdges ++;

    						}

    					}

    				}

    			}

    			var coords = new Float32Array( numEdges * 2 * 3 );

    			for ( var i = 0, l = numEdges; i < l; i ++ ) {

    				for ( var j = 0; j < 2; j ++ ) {

    					var index = 6 * i + 3 * j;
    					var index2 = edges[ 2 * i + j ];

    					coords[ index + 0 ] = vertices.getX( index2 );
    					coords[ index + 1 ] = vertices.getY( index2 );
    					coords[ index + 2 ] = vertices.getZ( index2 );

    				}

    			}

    			this.addAttribute( 'position', new BufferAttribute( coords, 3 ) );

    		} else {

    			// non-indexed BufferGeometry

    			var vertices = geometry.attributes.position.array;
    			var numEdges = vertices.length / 3;
    			var numTris = numEdges / 3;

    			var coords = new Float32Array( numEdges * 2 * 3 );

    			for ( var i = 0, l = numTris; i < l; i ++ ) {

    				for ( var j = 0; j < 3; j ++ ) {

    					var index = 18 * i + 6 * j;

    					var index1 = 9 * i + 3 * j;
    					coords[ index + 0 ] = vertices[ index1 ];
    					coords[ index + 1 ] = vertices[ index1 + 1 ];
    					coords[ index + 2 ] = vertices[ index1 + 2 ];

    					var index2 = 9 * i + 3 * ( ( j + 1 ) % 3 );
    					coords[ index + 3 ] = vertices[ index2 ];
    					coords[ index + 4 ] = vertices[ index2 + 1 ];
    					coords[ index + 5 ] = vertices[ index2 + 2 ];

    				}

    			}

    			this.addAttribute( 'position', new BufferAttribute( coords, 3 ) );

    		}

    	}

    }

    WireframeGeometry.prototype = Object.create( BufferGeometry.prototype );
    WireframeGeometry.prototype.constructor = WireframeGeometry;

    /**
     * @author zz85 / https://github.com/zz85
     * Parametric Surfaces Geometry
     * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
     *
     * new THREE.ParametricGeometry( parametricFunction, uSegments, ySegements );
     *
     */

    function ParametricGeometry( func, slices, stacks ) {

    	Geometry.call( this );

    	this.type = 'ParametricGeometry';

    	this.parameters = {
    		func: func,
    		slices: slices,
    		stacks: stacks
    	};

    	var verts = this.vertices;
    	var faces = this.faces;
    	var uvs = this.faceVertexUvs[ 0 ];

    	var i, j, p;
    	var u, v;

    	var sliceCount = slices + 1;

    	for ( i = 0; i <= stacks; i ++ ) {

    		v = i / stacks;

    		for ( j = 0; j <= slices; j ++ ) {

    			u = j / slices;

    			p = func( u, v );
    			verts.push( p );

    		}

    	}

    	var a, b, c, d;
    	var uva, uvb, uvc, uvd;

    	for ( i = 0; i < stacks; i ++ ) {

    		for ( j = 0; j < slices; j ++ ) {

    			a = i * sliceCount + j;
    			b = i * sliceCount + j + 1;
    			c = ( i + 1 ) * sliceCount + j + 1;
    			d = ( i + 1 ) * sliceCount + j;

    			uva = new Vector2( j / slices, i / stacks );
    			uvb = new Vector2( ( j + 1 ) / slices, i / stacks );
    			uvc = new Vector2( ( j + 1 ) / slices, ( i + 1 ) / stacks );
    			uvd = new Vector2( j / slices, ( i + 1 ) / stacks );

    			faces.push( new Face3( a, b, d ) );
    			uvs.push( [ uva, uvb, uvd ] );

    			faces.push( new Face3( b, c, d ) );
    			uvs.push( [ uvb.clone(), uvc, uvd.clone() ] );

    		}

    	}

    	// console.log(this);

    	// magic bullet
    	// var diff = this.mergeVertices();
    	// console.log('removed ', diff, ' vertices by merging');

    	this.computeFaceNormals();
    	this.computeVertexNormals();

    }

    ParametricGeometry.prototype = Object.create( Geometry.prototype );
    ParametricGeometry.prototype.constructor = ParametricGeometry;

    /**
     * @author clockworkgeek / https://github.com/clockworkgeek
     * @author timothypratley / https://github.com/timothypratley
     * @author WestLangley / http://github.com/WestLangley
    */

    function PolyhedronGeometry( vertices, indices, radius, detail ) {

    	Geometry.call( this );

    	this.type = 'PolyhedronGeometry';

    	this.parameters = {
    		vertices: vertices,
    		indices: indices,
    		radius: radius,
    		detail: detail
    	};

    	radius = radius || 1;
    	detail = detail || 0;

    	var that = this;

    	for ( var i = 0, l = vertices.length; i < l; i += 3 ) {

    		prepare( new Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );

    	}

    	var p = this.vertices;

    	var faces = [];

    	for ( var i = 0, j = 0, l = indices.length; i < l; i += 3, j ++ ) {

    		var v1 = p[ indices[ i ] ];
    		var v2 = p[ indices[ i + 1 ] ];
    		var v3 = p[ indices[ i + 2 ] ];

    		faces[ j ] = new Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );

    	}

    	var centroid = new Vector3();

    	for ( var i = 0, l = faces.length; i < l; i ++ ) {

    		subdivide( faces[ i ], detail );

    	}


    	// Handle case when face straddles the seam

    	for ( var i = 0, l = this.faceVertexUvs[ 0 ].length; i < l; i ++ ) {

    		var uvs = this.faceVertexUvs[ 0 ][ i ];

    		var x0 = uvs[ 0 ].x;
    		var x1 = uvs[ 1 ].x;
    		var x2 = uvs[ 2 ].x;

    		var max = Math.max( x0, x1, x2 );
    		var min = Math.min( x0, x1, x2 );

    		if ( max > 0.9 && min < 0.1 ) {

    			// 0.9 is somewhat arbitrary

    			if ( x0 < 0.2 ) uvs[ 0 ].x += 1;
    			if ( x1 < 0.2 ) uvs[ 1 ].x += 1;
    			if ( x2 < 0.2 ) uvs[ 2 ].x += 1;

    		}

    	}


    	// Apply radius

    	for ( var i = 0, l = this.vertices.length; i < l; i ++ ) {

    		this.vertices[ i ].multiplyScalar( radius );

    	}


    	// Merge vertices

    	this.mergeVertices();

    	this.computeFaceNormals();

    	this.boundingSphere = new Sphere( new Vector3(), radius );


    	// Project vector onto sphere's surface

    	function prepare( vector ) {

    		var vertex = vector.normalize().clone();
    		vertex.index = that.vertices.push( vertex ) - 1;

    		// Texture coords are equivalent to map coords, calculate angle and convert to fraction of a circle.

    		var u = azimuth( vector ) / 2 / Math.PI + 0.5;
    		var v = inclination( vector ) / Math.PI + 0.5;
    		vertex.uv = new Vector2( u, 1 - v );

    		return vertex;

    	}


    	// Approximate a curved face with recursively sub-divided triangles.

    	function make( v1, v2, v3 ) {

    		var face = new Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );
    		that.faces.push( face );

    		centroid.copy( v1 ).add( v2 ).add( v3 ).divideScalar( 3 );

    		var azi = azimuth( centroid );

    		that.faceVertexUvs[ 0 ].push( [
    			correctUV( v1.uv, v1, azi ),
    			correctUV( v2.uv, v2, azi ),
    			correctUV( v3.uv, v3, azi )
    		] );

    	}


    	// Analytically subdivide a face to the required detail level.

    	function subdivide( face, detail ) {

    		var cols = Math.pow( 2, detail );
    		var a = prepare( that.vertices[ face.a ] );
    		var b = prepare( that.vertices[ face.b ] );
    		var c = prepare( that.vertices[ face.c ] );
    		var v = [];

    		// Construct all of the vertices for this subdivision.

    		for ( var i = 0 ; i <= cols; i ++ ) {

    			v[ i ] = [];

    			var aj = prepare( a.clone().lerp( c, i / cols ) );
    			var bj = prepare( b.clone().lerp( c, i / cols ) );
    			var rows = cols - i;

    			for ( var j = 0; j <= rows; j ++ ) {

    				if ( j === 0 && i === cols ) {

    					v[ i ][ j ] = aj;

    				} else {

    					v[ i ][ j ] = prepare( aj.clone().lerp( bj, j / rows ) );

    				}

    			}

    		}

    		// Construct all of the faces.

    		for ( var i = 0; i < cols ; i ++ ) {

    			for ( var j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {

    				var k = Math.floor( j / 2 );

    				if ( j % 2 === 0 ) {

    					make(
    						v[ i ][ k + 1 ],
    						v[ i + 1 ][ k ],
    						v[ i ][ k ]
    					);

    				} else {

    					make(
    						v[ i ][ k + 1 ],
    						v[ i + 1 ][ k + 1 ],
    						v[ i + 1 ][ k ]
    					);

    				}

    			}

    		}

    	}


    	// Angle around the Y axis, counter-clockwise when looking from above.

    	function azimuth( vector ) {

    		return Math.atan2( vector.z, - vector.x );

    	}


    	// Angle above the XZ plane.

    	function inclination( vector ) {

    		return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );

    	}


    	// Texture fixing helper. Spheres have some odd behaviours.

    	function correctUV( uv, vector, azimuth ) {

    		if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) uv = new Vector2( uv.x - 1, uv.y );
    		if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) uv = new Vector2( azimuth / 2 / Math.PI + 0.5, uv.y );
    		return uv.clone();

    	}

    }

    PolyhedronGeometry.prototype = Object.create( Geometry.prototype );
    PolyhedronGeometry.prototype.constructor = PolyhedronGeometry;

    /**
     * @author timothypratley / https://github.com/timothypratley
     */

    function TetrahedronGeometry( radius, detail ) {

    	var vertices = [
    		 1,  1,  1,   - 1, - 1,  1,   - 1,  1, - 1,    1, - 1, - 1
    	];

    	var indices = [
    		 2,  1,  0,    0,  3,  2,    1,  3,  0,    2,  3,  1
    	];

    	PolyhedronGeometry.call( this, vertices, indices, radius, detail );

    	this.type = 'TetrahedronGeometry';

    	this.parameters = {
    		radius: radius,
    		detail: detail
    	};

    }

    TetrahedronGeometry.prototype = Object.create( PolyhedronGeometry.prototype );
    TetrahedronGeometry.prototype.constructor = TetrahedronGeometry;

    /**
     * @author timothypratley / https://github.com/timothypratley
     */

    function OctahedronGeometry( radius, detail ) {

    	var vertices = [
    		1, 0, 0,   - 1, 0, 0,    0, 1, 0,    0, - 1, 0,    0, 0, 1,    0, 0, - 1
    	];

    	var indices = [
    		0, 2, 4,    0, 4, 3,    0, 3, 5,    0, 5, 2,    1, 2, 5,    1, 5, 3,    1, 3, 4,    1, 4, 2
    	];

    	PolyhedronGeometry.call( this, vertices, indices, radius, detail );

    	this.type = 'OctahedronGeometry';

    	this.parameters = {
    		radius: radius,
    		detail: detail
    	};

    }

    OctahedronGeometry.prototype = Object.create( PolyhedronGeometry.prototype );
    OctahedronGeometry.prototype.constructor = OctahedronGeometry;

    /**
     * @author timothypratley / https://github.com/timothypratley
     */

    function IcosahedronGeometry( radius, detail ) {

    	var t = ( 1 + Math.sqrt( 5 ) ) / 2;

    	var vertices = [
    		- 1,  t,  0,    1,  t,  0,   - 1, - t,  0,    1, - t,  0,
    		 0, - 1,  t,    0,  1,  t,    0, - 1, - t,    0,  1, - t,
    		 t,  0, - 1,    t,  0,  1,   - t,  0, - 1,   - t,  0,  1
    	];

    	var indices = [
    		 0, 11,  5,    0,  5,  1,    0,  1,  7,    0,  7, 10,    0, 10, 11,
    		 1,  5,  9,    5, 11,  4,   11, 10,  2,   10,  7,  6,    7,  1,  8,
    		 3,  9,  4,    3,  4,  2,    3,  2,  6,    3,  6,  8,    3,  8,  9,
    		 4,  9,  5,    2,  4, 11,    6,  2, 10,    8,  6,  7,    9,  8,  1
    	];

    	PolyhedronGeometry.call( this, vertices, indices, radius, detail );

    	this.type = 'IcosahedronGeometry';

    	this.parameters = {
    		radius: radius,
    		detail: detail
    	};

    }

    IcosahedronGeometry.prototype = Object.create( PolyhedronGeometry.prototype );
    IcosahedronGeometry.prototype.constructor = IcosahedronGeometry;

    /**
     * @author Abe Pazos / https://hamoid.com
     */

    function DodecahedronGeometry( radius, detail ) {

    	var t = ( 1 + Math.sqrt( 5 ) ) / 2;
    	var r = 1 / t;

    	var vertices = [

    		// (±1, ±1, ±1)
    		- 1, - 1, - 1,    - 1, - 1,  1,
    		- 1,  1, - 1,    - 1,  1,  1,
    		 1, - 1, - 1,     1, - 1,  1,
    		 1,  1, - 1,     1,  1,  1,

    		// (0, ±1/φ, ±φ)
    		 0, - r, - t,     0, - r,  t,
    		 0,  r, - t,     0,  r,  t,

    		// (±1/φ, ±φ, 0)
    		- r, - t,  0,    - r,  t,  0,
    		 r, - t,  0,     r,  t,  0,

    		// (±φ, 0, ±1/φ)
    		- t,  0, - r,     t,  0, - r,
    		- t,  0,  r,     t,  0,  r
    	];

    	var indices = [
    		 3, 11,  7,      3,  7, 15,      3, 15, 13,
    		 7, 19, 17,      7, 17,  6,      7,  6, 15,
    		17,  4,  8,     17,  8, 10,     17, 10,  6,
    		 8,  0, 16,      8, 16,  2,      8,  2, 10,
    		 0, 12,  1,      0,  1, 18,      0, 18, 16,
    		 6, 10,  2,      6,  2, 13,      6, 13, 15,
    		 2, 16, 18,      2, 18,  3,      2,  3, 13,
    		18,  1,  9,     18,  9, 11,     18, 11,  3,
    		 4, 14, 12,      4, 12,  0,      4,  0,  8,
    		11,  9,  5,     11,  5, 19,     11, 19,  7,
    		19,  5, 14,     19, 14,  4,     19,  4, 17,
    		 1, 12, 14,      1, 14,  5,      1,  5,  9
    	];

    	PolyhedronGeometry.call( this, vertices, indices, radius, detail );

    	this.type = 'DodecahedronGeometry';

    	this.parameters = {
    		radius: radius,
    		detail: detail
    	};

    }

    DodecahedronGeometry.prototype = Object.create( PolyhedronGeometry.prototype );
    DodecahedronGeometry.prototype.constructor = DodecahedronGeometry;

    /**
     * @author WestLangley / https://github.com/WestLangley
     * @author zz85 / https://github.com/zz85
     * @author miningold / https://github.com/miningold
     * @author jonobr1 / https://github.com/jonobr1
     *
     * Modified from the TorusKnotGeometry by @oosmoxiecode
     *
     * Creates a tube which extrudes along a 3d spline
     *
     * Uses parallel transport frames as described in
     * http://www.cs.indiana.edu/pub/techreports/TR425.pdf
     */

    function TubeGeometry( path, segments, radius, radialSegments, closed, taper ) {

    	Geometry.call( this );

    	this.type = 'TubeGeometry';

    	this.parameters = {
    		path: path,
    		segments: segments,
    		radius: radius,
    		radialSegments: radialSegments,
    		closed: closed,
    		taper: taper
    	};

    	segments = segments || 64;
    	radius = radius || 1;
    	radialSegments = radialSegments || 8;
    	closed = closed || false;
    	taper = taper || TubeGeometry.NoTaper;

    	var grid = [];

    	var scope = this,

    		tangent,
    		normal,
    		binormal,

    		numpoints = segments + 1,

    		u, v, r,

    		cx, cy,
    		pos, pos2 = new Vector3(),
    		i, j,
    		ip, jp,
    		a, b, c, d,
    		uva, uvb, uvc, uvd;

    	var frames = new TubeGeometry.FrenetFrames( path, segments, closed ),
    		tangents = frames.tangents,
    		normals = frames.normals,
    		binormals = frames.binormals;

    	// proxy internals
    	this.tangents = tangents;
    	this.normals = normals;
    	this.binormals = binormals;

    	function vert( x, y, z ) {

    		return scope.vertices.push( new Vector3( x, y, z ) ) - 1;

    	}

    	// construct the grid

    	for ( i = 0; i < numpoints; i ++ ) {

    		grid[ i ] = [];

    		u = i / ( numpoints - 1 );

    		pos = path.getPointAt( u );

    		tangent = tangents[ i ];
    		normal = normals[ i ];
    		binormal = binormals[ i ];

    		r = radius * taper( u );

    		for ( j = 0; j < radialSegments; j ++ ) {

    			v = j / radialSegments * 2 * Math.PI;

    			cx = - r * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.
    			cy = r * Math.sin( v );

    			pos2.copy( pos );
    			pos2.x += cx * normal.x + cy * binormal.x;
    			pos2.y += cx * normal.y + cy * binormal.y;
    			pos2.z += cx * normal.z + cy * binormal.z;

    			grid[ i ][ j ] = vert( pos2.x, pos2.y, pos2.z );

    		}

    	}


    	// construct the mesh

    	for ( i = 0; i < segments; i ++ ) {

    		for ( j = 0; j < radialSegments; j ++ ) {

    			ip = ( closed ) ? ( i + 1 ) % segments : i + 1;
    			jp = ( j + 1 ) % radialSegments;

    			a = grid[ i ][ j ];		// *** NOT NECESSARILY PLANAR ! ***
    			b = grid[ ip ][ j ];
    			c = grid[ ip ][ jp ];
    			d = grid[ i ][ jp ];

    			uva = new Vector2( i / segments, j / radialSegments );
    			uvb = new Vector2( ( i + 1 ) / segments, j / radialSegments );
    			uvc = new Vector2( ( i + 1 ) / segments, ( j + 1 ) / radialSegments );
    			uvd = new Vector2( i / segments, ( j + 1 ) / radialSegments );

    			this.faces.push( new Face3( a, b, d ) );
    			this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

    			this.faces.push( new Face3( b, c, d ) );
    			this.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

    		}

    	}

    	this.computeFaceNormals();
    	this.computeVertexNormals();

    }

    TubeGeometry.prototype = Object.create( Geometry.prototype );
    TubeGeometry.prototype.constructor = TubeGeometry;

    TubeGeometry.NoTaper = function ( u ) {

    	return 1;

    };

    TubeGeometry.SinusoidalTaper = function ( u ) {

    	return Math.sin( Math.PI * u );

    };

    // For computing of Frenet frames, exposing the tangents, normals and binormals the spline
    TubeGeometry.FrenetFrames = function ( path, segments, closed ) {

    	var	normal = new Vector3(),

    		tangents = [],
    		normals = [],
    		binormals = [],

    		vec = new Vector3(),
    		mat = new Matrix4(),

    		numpoints = segments + 1,
    		theta,
    		smallest,

    		tx, ty, tz,
    		i, u;


    	// expose internals
    	this.tangents = tangents;
    	this.normals = normals;
    	this.binormals = binormals;

    	// compute the tangent vectors for each segment on the path

    	for ( i = 0; i < numpoints; i ++ ) {

    		u = i / ( numpoints - 1 );

    		tangents[ i ] = path.getTangentAt( u );
    		tangents[ i ].normalize();

    	}

    	initialNormal3();

    	/*
    	function initialNormal1(lastBinormal) {
    		// fixed start binormal. Has dangers of 0 vectors
    		normals[ 0 ] = new THREE.Vector3();
    		binormals[ 0 ] = new THREE.Vector3();
    		if (lastBinormal===undefined) lastBinormal = new THREE.Vector3( 0, 0, 1 );
    		normals[ 0 ].crossVectors( lastBinormal, tangents[ 0 ] ).normalize();
    		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();
    	}

    	function initialNormal2() {

    		// This uses the Frenet-Serret formula for deriving binormal
    		var t2 = path.getTangentAt( epsilon );

    		normals[ 0 ] = new THREE.Vector3().subVectors( t2, tangents[ 0 ] ).normalize();
    		binormals[ 0 ] = new THREE.Vector3().crossVectors( tangents[ 0 ], normals[ 0 ] );

    		normals[ 0 ].crossVectors( binormals[ 0 ], tangents[ 0 ] ).normalize(); // last binormal x tangent
    		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();

    	}
    	*/

    	function initialNormal3() {

    		// select an initial normal vector perpendicular to the first tangent vector,
    		// and in the direction of the smallest tangent xyz component

    		normals[ 0 ] = new Vector3();
    		binormals[ 0 ] = new Vector3();
    		smallest = Number.MAX_VALUE;
    		tx = Math.abs( tangents[ 0 ].x );
    		ty = Math.abs( tangents[ 0 ].y );
    		tz = Math.abs( tangents[ 0 ].z );

    		if ( tx <= smallest ) {

    			smallest = tx;
    			normal.set( 1, 0, 0 );

    		}

    		if ( ty <= smallest ) {

    			smallest = ty;
    			normal.set( 0, 1, 0 );

    		}

    		if ( tz <= smallest ) {

    			normal.set( 0, 0, 1 );

    		}

    		vec.crossVectors( tangents[ 0 ], normal ).normalize();

    		normals[ 0 ].crossVectors( tangents[ 0 ], vec );
    		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );

    	}


    	// compute the slowly-varying normal and binormal vectors for each segment on the path

    	for ( i = 1; i < numpoints; i ++ ) {

    		normals[ i ] = normals[ i - 1 ].clone();

    		binormals[ i ] = binormals[ i - 1 ].clone();

    		vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );

    		if ( vec.length() > Number.EPSILON ) {

    			vec.normalize();

    			theta = Math.acos( exports.Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors

    			normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );

    		}

    		binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

    	}


    	// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

    	if ( closed ) {

    		theta = Math.acos( exports.Math.clamp( normals[ 0 ].dot( normals[ numpoints - 1 ] ), - 1, 1 ) );
    		theta /= ( numpoints - 1 );

    		if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ numpoints - 1 ] ) ) > 0 ) {

    			theta = - theta;

    		}

    		for ( i = 1; i < numpoints; i ++ ) {

    			// twist a little...
    			normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
    			binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

    		}

    	}

    };

    /**
     * @author Mugen87 / https://github.com/Mugen87
     *
     * see: http://www.blackpawn.com/texts/pqtorus/
     */
    function TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) {

    	BufferGeometry.call( this );

    	this.type = 'TorusKnotBufferGeometry';

    	this.parameters = {
    		radius: radius,
    		tube: tube,
    		tubularSegments: tubularSegments,
    		radialSegments: radialSegments,
    		p: p,
    		q: q
    	};

    	radius = radius || 100;
    	tube = tube || 40;
    	tubularSegments = Math.floor( tubularSegments ) || 64;
    	radialSegments = Math.floor( radialSegments ) || 8;
    	p = p || 2;
    	q = q || 3;

    	// used to calculate buffer length
    	var vertexCount = ( ( radialSegments + 1 ) * ( tubularSegments + 1 ) );
    	var indexCount = radialSegments * tubularSegments * 2 * 3;

    	// buffers
    	var indices = new BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );
    	var vertices = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
    	var normals = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
    	var uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );

    	// helper variables
    	var i, j, index = 0, indexOffset = 0;

    	var vertex = new Vector3();
    	var normal = new Vector3();
    	var uv = new Vector2();

    	var P1 = new Vector3();
    	var P2 = new Vector3();

    	var B = new Vector3();
    	var T = new Vector3();
    	var N = new Vector3();

    	// generate vertices, normals and uvs

    	for ( i = 0; i <= tubularSegments; ++ i ) {

    		// the radian "u" is used to calculate the position on the torus curve of the current tubular segement

    		var u = i / tubularSegments * p * Math.PI * 2;

    		// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
    		// these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions

    		calculatePositionOnCurve( u, p, q, radius, P1 );
    		calculatePositionOnCurve( u + 0.01, p, q, radius, P2 );

    		// calculate orthonormal basis

    		T.subVectors( P2, P1 );
    		N.addVectors( P2, P1 );
    		B.crossVectors( T, N );
    		N.crossVectors( B, T );

    		// normalize B, N. T can be ignored, we don't use it

    		B.normalize();
    		N.normalize();

    		for ( j = 0; j <= radialSegments; ++ j ) {

    			// now calculate the vertices. they are nothing more than an extrusion of the torus curve.
    			// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.

    			var v = j / radialSegments * Math.PI * 2;
    			var cx = - tube * Math.cos( v );
    			var cy = tube * Math.sin( v );

    			// now calculate the final vertex position.
    			// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve

    			vertex.x = P1.x + ( cx * N.x + cy * B.x );
    			vertex.y = P1.y + ( cx * N.y + cy * B.y );
    			vertex.z = P1.z + ( cx * N.z + cy * B.z );

    			// vertex
    			vertices.setXYZ( index, vertex.x, vertex.y, vertex.z );

    			// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)
    			normal.subVectors( vertex, P1 ).normalize();
    			normals.setXYZ( index, normal.x, normal.y, normal.z );

    			// uv
    			uv.x = i / tubularSegments;
    			uv.y = j / radialSegments;
    			uvs.setXY( index, uv.x, uv.y );

    			// increase index
    			index ++;

    		}

    	}

    	// generate indices

    	for ( j = 1; j <= tubularSegments; j ++ ) {

    		for ( i = 1; i <= radialSegments; i ++ ) {

    			// indices
    			var a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
    			var b = ( radialSegments + 1 ) * j + ( i - 1 );
    			var c = ( radialSegments + 1 ) * j + i;
    			var d = ( radialSegments + 1 ) * ( j - 1 ) + i;

    			// face one
    			indices.setX( indexOffset, a ); indexOffset++;
    			indices.setX( indexOffset, b ); indexOffset++;
    			indices.setX( indexOffset, d ); indexOffset++;

    			// face two
    			indices.setX( indexOffset, b ); indexOffset++;
    			indices.setX( indexOffset, c ); indexOffset++;
    			indices.setX( indexOffset, d ); indexOffset++;

    		}

    	}

    	// build geometry

    	this.setIndex( indices );
    	this.addAttribute( 'position', vertices );
    	this.addAttribute( 'normal', normals );
    	this.addAttribute( 'uv', uvs );

    	// this function calculates the current position on the torus curve

    	function calculatePositionOnCurve( u, p, q, radius, position ) {

    		var cu = Math.cos( u );
    		var su = Math.sin( u );
    		var quOverP = q / p * u;
    		var cs = Math.cos( quOverP );

    		position.x = radius * ( 2 + cs ) * 0.5 * cu;
    		position.y = radius * ( 2 + cs ) * su * 0.5;
    		position.z = radius * Math.sin( quOverP ) * 0.5;

    	}

    }

    TorusKnotBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
    TorusKnotBufferGeometry.prototype.constructor = TorusKnotBufferGeometry;

    /**
     * @author oosmoxiecode
     */

    function TorusKnotGeometry( radius, tube, tubularSegments, radialSegments, p, q, heightScale ) {

    	Geometry.call( this );

    	this.type = 'TorusKnotGeometry';

    	this.parameters = {
    		radius: radius,
    		tube: tube,
    		tubularSegments: tubularSegments,
    		radialSegments: radialSegments,
    		p: p,
    		q: q
    	};

    	if( heightScale !== undefined ) console.warn( 'THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.' );

    	this.fromBufferGeometry( new TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) );
    	this.mergeVertices();

    }

    TorusKnotGeometry.prototype = Object.create( Geometry.prototype );
    TorusKnotGeometry.prototype.constructor = TorusKnotGeometry;

    /**
     * @author Mugen87 / https://github.com/Mugen87
     */

    function TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) {

    	BufferGeometry.call( this );

    	this.type = 'TorusBufferGeometry';

    	this.parameters = {
    		radius: radius,
    		tube: tube,
    		radialSegments: radialSegments,
    		tubularSegments: tubularSegments,
    		arc: arc
    	};

    	radius = radius || 100;
    	tube = tube || 40;
    	radialSegments = Math.floor( radialSegments ) || 8;
    	tubularSegments = Math.floor( tubularSegments ) || 6;
    	arc = arc || Math.PI * 2;

    	// used to calculate buffer length
    	var vertexCount = ( ( radialSegments + 1 ) * ( tubularSegments + 1 ) );
    	var indexCount = radialSegments * tubularSegments * 2 * 3;

    	// buffers
    	var indices = new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount );
    	var vertices = new Float32Array( vertexCount * 3 );
    	var normals = new Float32Array( vertexCount * 3 );
    	var uvs = new Float32Array( vertexCount * 2 );

    	// offset variables
    	var vertexBufferOffset = 0;
    	var uvBufferOffset = 0;
    	var indexBufferOffset = 0;

    	// helper variables
    	var center = new Vector3();
    	var vertex = new Vector3();
    	var normal = new Vector3();

    	var j, i;

    	// generate vertices, normals and uvs

    	for ( j = 0; j <= radialSegments; j ++ ) {

    		for ( i = 0; i <= tubularSegments; i ++ ) {

    			var u = i / tubularSegments * arc;
    			var v = j / radialSegments * Math.PI * 2;

    			// vertex
    			vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
    			vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
    			vertex.z = tube * Math.sin( v );

    			vertices[ vertexBufferOffset ] = vertex.x;
    			vertices[ vertexBufferOffset + 1 ] = vertex.y;
    			vertices[ vertexBufferOffset + 2 ] = vertex.z;

    			// this vector is used to calculate the normal
    			center.x = radius * Math.cos( u );
    			center.y = radius * Math.sin( u );

    			// normal
    			normal.subVectors( vertex, center ).normalize();

    			normals[ vertexBufferOffset ] = normal.x;
    			normals[ vertexBufferOffset + 1 ] = normal.y;
    			normals[ vertexBufferOffset + 2 ] = normal.z;

    			// uv
    			uvs[ uvBufferOffset ] = i / tubularSegments;
    			uvs[ uvBufferOffset + 1 ] = j / radialSegments;

    			// update offsets
    			vertexBufferOffset += 3;
    			uvBufferOffset += 2;

    		}

    	}

    	// generate indices

    	for ( j = 1; j <= radialSegments; j ++ ) {

    		for ( i = 1; i <= tubularSegments; i ++ ) {

    			// indices
    			var a = ( tubularSegments + 1 ) * j + i - 1;
    			var b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
    			var c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
    			var d = ( tubularSegments + 1 ) * j + i;

    			// face one
    			indices[ indexBufferOffset ] = a;
    			indices[ indexBufferOffset + 1 ] = b;
    			indices[ indexBufferOffset + 2 ] = d;

    			// face two
    			indices[ indexBufferOffset + 3 ] = b;
    			indices[ indexBufferOffset + 4 ] = c;
    			indices[ indexBufferOffset + 5 ] = d;

    			// update offset
    			indexBufferOffset += 6;

    		}

    	}

    	// build geometry
    	this.setIndex( new BufferAttribute( indices, 1 ) );
    	this.addAttribute( 'position', new BufferAttribute( vertices, 3 ) );
    	this.addAttribute( 'normal', new BufferAttribute( normals, 3 ) );
    	this.addAttribute( 'uv', new BufferAttribute( uvs, 2 ) );

    }

    TorusBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
    TorusBufferGeometry.prototype.constructor = TorusBufferGeometry;

    /**
     * @author oosmoxiecode
     * @author mrdoob / http://mrdoob.com/
     * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888
     */

    function TorusGeometry( radius, tube, radialSegments, tubularSegments, arc ) {

    	Geometry.call( this );

    	this.type = 'TorusGeometry';

    	this.parameters = {
    		radius: radius,
    		tube: tube,
    		radialSegments: radialSegments,
    		tubularSegments: tubularSegments,
    		arc: arc
    	};

    	this.fromBufferGeometry( new TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) );

    }

    TorusGeometry.prototype = Object.create( Geometry.prototype );
    TorusGeometry.prototype.constructor = TorusGeometry;

    /**
     * @author zz85 / http://www.lab4games.net/zz85/blog
     */

    exports.ShapeUtils = {

    	// calculate area of the contour polygon

    	area: function ( contour ) {

    		var n = contour.length;
    		var a = 0.0;

    		for ( var p = n - 1, q = 0; q < n; p = q ++ ) {

    			a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;

    		}

    		return a * 0.5;

    	},

    	triangulate: ( function () {

    		/**
    		 * This code is a quick port of code written in C++ which was submitted to
    		 * flipcode.com by John W. Ratcliff  // July 22, 2000
    		 * See original code and more information here:
    		 * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml
    		 *
    		 * ported to actionscript by Zevan Rosser
    		 * www.actionsnippet.com
    		 *
    		 * ported to javascript by Joshua Koo
    		 * http://www.lab4games.net/zz85/blog
    		 *
    		 */

    		function snip( contour, u, v, w, n, verts ) {

    			var p;
    			var ax, ay, bx, by;
    			var cx, cy, px, py;

    			ax = contour[ verts[ u ] ].x;
    			ay = contour[ verts[ u ] ].y;

    			bx = contour[ verts[ v ] ].x;
    			by = contour[ verts[ v ] ].y;

    			cx = contour[ verts[ w ] ].x;
    			cy = contour[ verts[ w ] ].y;

    			if ( Number.EPSILON > ( ( ( bx - ax ) * ( cy - ay ) ) - ( ( by - ay ) * ( cx - ax ) ) ) ) return false;

    			var aX, aY, bX, bY, cX, cY;
    			var apx, apy, bpx, bpy, cpx, cpy;
    			var cCROSSap, bCROSScp, aCROSSbp;

    			aX = cx - bx;  aY = cy - by;
    			bX = ax - cx;  bY = ay - cy;
    			cX = bx - ax;  cY = by - ay;

    			for ( p = 0; p < n; p ++ ) {

    				px = contour[ verts[ p ] ].x;
    				py = contour[ verts[ p ] ].y;

    				if ( ( ( px === ax ) && ( py === ay ) ) ||
    					 ( ( px === bx ) && ( py === by ) ) ||
    					 ( ( px === cx ) && ( py === cy ) ) )	continue;

    				apx = px - ax;  apy = py - ay;
    				bpx = px - bx;  bpy = py - by;
    				cpx = px - cx;  cpy = py - cy;

    				// see if p is inside triangle abc

    				aCROSSbp = aX * bpy - aY * bpx;
    				cCROSSap = cX * apy - cY * apx;
    				bCROSScp = bX * cpy - bY * cpx;

    				if ( ( aCROSSbp >= - Number.EPSILON ) && ( bCROSScp >= - Number.EPSILON ) && ( cCROSSap >= - Number.EPSILON ) ) return false;

    			}

    			return true;

    		}

    		// takes in an contour array and returns

    		return function triangulate( contour, indices ) {

    			var n = contour.length;

    			if ( n < 3 ) return null;

    			var result = [],
    				verts = [],
    				vertIndices = [];

    			/* we want a counter-clockwise polygon in verts */

    			var u, v, w;

    			if ( exports.ShapeUtils.area( contour ) > 0.0 ) {

    				for ( v = 0; v < n; v ++ ) verts[ v ] = v;

    			} else {

    				for ( v = 0; v < n; v ++ ) verts[ v ] = ( n - 1 ) - v;

    			}

    			var nv = n;

    			/*  remove nv - 2 vertices, creating 1 triangle every time */

    			var count = 2 * nv;   /* error detection */

    			for ( v = nv - 1; nv > 2; ) {

    				/* if we loop, it is probably a non-simple polygon */

    				if ( ( count -- ) <= 0 ) {

    					//** Triangulate: ERROR - probable bad polygon!

    					//throw ( "Warning, unable to triangulate polygon!" );
    					//return null;
    					// Sometimes warning is fine, especially polygons are triangulated in reverse.
    					console.warn( 'THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()' );

    					if ( indices ) return vertIndices;
    					return result;

    				}

    				/* three consecutive vertices in current polygon, <u,v,w> */

    				u = v; 	 	if ( nv <= u ) u = 0;     /* previous */
    				v = u + 1;  if ( nv <= v ) v = 0;     /* new v    */
    				w = v + 1;  if ( nv <= w ) w = 0;     /* next     */

    				if ( snip( contour, u, v, w, nv, verts ) ) {

    					var a, b, c, s, t;

    					/* true names of the vertices */

    					a = verts[ u ];
    					b = verts[ v ];
    					c = verts[ w ];

    					/* output Triangle */

    					result.push( [ contour[ a ],
    						contour[ b ],
    						contour[ c ] ] );


    					vertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );

    					/* remove v from the remaining polygon */

    					for ( s = v, t = v + 1; t < nv; s ++, t ++ ) {

    						verts[ s ] = verts[ t ];

    					}

    					nv --;

    					/* reset error detection counter */

    					count = 2 * nv;

    				}

    			}

    			if ( indices ) return vertIndices;
    			return result;

    		}

    	} )(),

    	triangulateShape: function ( contour, holes ) {

    		function removeDupEndPts(points) {

    			var l = points.length;

    			if ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {

    				points.pop();

    			}

    		}

    		removeDupEndPts( contour );
    		holes.forEach( removeDupEndPts );

    		function point_in_segment_2D_colin( inSegPt1, inSegPt2, inOtherPt ) {

    			// inOtherPt needs to be collinear to the inSegment
    			if ( inSegPt1.x !== inSegPt2.x ) {

    				if ( inSegPt1.x < inSegPt2.x ) {

    					return	( ( inSegPt1.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt2.x ) );

    				} else {

    					return	( ( inSegPt2.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt1.x ) );

    				}

    			} else {

    				if ( inSegPt1.y < inSegPt2.y ) {

    					return	( ( inSegPt1.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt2.y ) );

    				} else {

    					return	( ( inSegPt2.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt1.y ) );

    				}

    			}

    		}

    		function intersect_segments_2D( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs ) {

    			var seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,   seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;
    			var seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,   seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;

    			var seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;
    			var seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;

    			var limit		= seg1dy * seg2dx - seg1dx * seg2dy;
    			var perpSeg1	= seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;

    			if ( Math.abs( limit ) > Number.EPSILON ) {

    				// not parallel

    				var perpSeg2;
    				if ( limit > 0 ) {

    					if ( ( perpSeg1 < 0 ) || ( perpSeg1 > limit ) ) 		return [];
    					perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
    					if ( ( perpSeg2 < 0 ) || ( perpSeg2 > limit ) ) 		return [];

    				} else {

    					if ( ( perpSeg1 > 0 ) || ( perpSeg1 < limit ) ) 		return [];
    					perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
    					if ( ( perpSeg2 > 0 ) || ( perpSeg2 < limit ) ) 		return [];

    				}

    				// i.e. to reduce rounding errors
    				// intersection at endpoint of segment#1?
    				if ( perpSeg2 === 0 ) {

    					if ( ( inExcludeAdjacentSegs ) &&
    						 ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )		return [];
    					return [ inSeg1Pt1 ];

    				}
    				if ( perpSeg2 === limit ) {

    					if ( ( inExcludeAdjacentSegs ) &&
    						 ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )		return [];
    					return [ inSeg1Pt2 ];

    				}
    				// intersection at endpoint of segment#2?
    				if ( perpSeg1 === 0 )		return [ inSeg2Pt1 ];
    				if ( perpSeg1 === limit )	return [ inSeg2Pt2 ];

    				// return real intersection point
    				var factorSeg1 = perpSeg2 / limit;
    				return	[ { x: inSeg1Pt1.x + factorSeg1 * seg1dx,
    							y: inSeg1Pt1.y + factorSeg1 * seg1dy } ];

    			} else {

    				// parallel or collinear
    				if ( ( perpSeg1 !== 0 ) ||
    					 ( seg2dy * seg1seg2dx !== seg2dx * seg1seg2dy ) ) 			return [];

    				// they are collinear or degenerate
    				var seg1Pt = ( ( seg1dx === 0 ) && ( seg1dy === 0 ) );	// segment1 is just a point?
    				var seg2Pt = ( ( seg2dx === 0 ) && ( seg2dy === 0 ) );	// segment2 is just a point?
    				// both segments are points
    				if ( seg1Pt && seg2Pt ) {

    					if ( ( inSeg1Pt1.x !== inSeg2Pt1.x ) ||
    						 ( inSeg1Pt1.y !== inSeg2Pt1.y ) )		return [];	// they are distinct  points
    					return [ inSeg1Pt1 ];                 						// they are the same point

    				}
    				// segment#1  is a single point
    				if ( seg1Pt ) {

    					if ( ! point_in_segment_2D_colin( inSeg2Pt1, inSeg2Pt2, inSeg1Pt1 ) )		return [];		// but not in segment#2
    					return [ inSeg1Pt1 ];

    				}
    				// segment#2  is a single point
    				if ( seg2Pt ) {

    					if ( ! point_in_segment_2D_colin( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1 ) )		return [];		// but not in segment#1
    					return [ inSeg2Pt1 ];

    				}

    				// they are collinear segments, which might overlap
    				var seg1min, seg1max, seg1minVal, seg1maxVal;
    				var seg2min, seg2max, seg2minVal, seg2maxVal;
    				if ( seg1dx !== 0 ) {

    					// the segments are NOT on a vertical line
    					if ( inSeg1Pt1.x < inSeg1Pt2.x ) {

    						seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.x;
    						seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.x;

    					} else {

    						seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.x;
    						seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.x;

    					}
    					if ( inSeg2Pt1.x < inSeg2Pt2.x ) {

    						seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.x;
    						seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.x;

    					} else {

    						seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.x;
    						seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.x;

    					}

    				} else {

    					// the segments are on a vertical line
    					if ( inSeg1Pt1.y < inSeg1Pt2.y ) {

    						seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.y;
    						seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.y;

    					} else {

    						seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.y;
    						seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.y;

    					}
    					if ( inSeg2Pt1.y < inSeg2Pt2.y ) {

    						seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.y;
    						seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.y;

    					} else {

    						seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.y;
    						seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.y;

    					}

    				}
    				if ( seg1minVal <= seg2minVal ) {

    					if ( seg1maxVal <  seg2minVal )	return [];
    					if ( seg1maxVal === seg2minVal )	{

    						if ( inExcludeAdjacentSegs )		return [];
    						return [ seg2min ];

    					}
    					if ( seg1maxVal <= seg2maxVal )	return [ seg2min, seg1max ];
    					return	[ seg2min, seg2max ];

    				} else {

    					if ( seg1minVal >  seg2maxVal )	return [];
    					if ( seg1minVal === seg2maxVal )	{

    						if ( inExcludeAdjacentSegs )		return [];
    						return [ seg1min ];

    					}
    					if ( seg1maxVal <= seg2maxVal )	return [ seg1min, seg1max ];
    					return	[ seg1min, seg2max ];

    				}

    			}

    		}

    		function isPointInsideAngle( inVertex, inLegFromPt, inLegToPt, inOtherPt ) {

    			// The order of legs is important

    			// translation of all points, so that Vertex is at (0,0)
    			var legFromPtX	= inLegFromPt.x - inVertex.x,  legFromPtY	= inLegFromPt.y - inVertex.y;
    			var legToPtX	= inLegToPt.x	- inVertex.x,  legToPtY		= inLegToPt.y	- inVertex.y;
    			var otherPtX	= inOtherPt.x	- inVertex.x,  otherPtY		= inOtherPt.y	- inVertex.y;

    			// main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.
    			var from2toAngle	= legFromPtX * legToPtY - legFromPtY * legToPtX;
    			var from2otherAngle	= legFromPtX * otherPtY - legFromPtY * otherPtX;

    			if ( Math.abs( from2toAngle ) > Number.EPSILON ) {

    				// angle != 180 deg.

    				var other2toAngle		= otherPtX * legToPtY - otherPtY * legToPtX;
    				// console.log( "from2to: " + from2toAngle + ", from2other: " + from2otherAngle + ", other2to: " + other2toAngle );

    				if ( from2toAngle > 0 ) {

    					// main angle < 180 deg.
    					return	( ( from2otherAngle >= 0 ) && ( other2toAngle >= 0 ) );

    				} else {

    					// main angle > 180 deg.
    					return	( ( from2otherAngle >= 0 ) || ( other2toAngle >= 0 ) );

    				}

    			} else {

    				// angle == 180 deg.
    				// console.log( "from2to: 180 deg., from2other: " + from2otherAngle  );
    				return	( from2otherAngle > 0 );

    			}

    		}


    		function removeHoles( contour, holes ) {

    			var shape = contour.concat(); // work on this shape
    			var hole;

    			function isCutLineInsideAngles( inShapeIdx, inHoleIdx ) {

    				// Check if hole point lies within angle around shape point
    				var lastShapeIdx = shape.length - 1;

    				var prevShapeIdx = inShapeIdx - 1;
    				if ( prevShapeIdx < 0 )			prevShapeIdx = lastShapeIdx;

    				var nextShapeIdx = inShapeIdx + 1;
    				if ( nextShapeIdx > lastShapeIdx )	nextShapeIdx = 0;

    				var insideAngle = isPointInsideAngle( shape[ inShapeIdx ], shape[ prevShapeIdx ], shape[ nextShapeIdx ], hole[ inHoleIdx ] );
    				if ( ! insideAngle ) {

    					// console.log( "Vertex (Shape): " + inShapeIdx + ", Point: " + hole[inHoleIdx].x + "/" + hole[inHoleIdx].y );
    					return	false;

    				}

    				// Check if shape point lies within angle around hole point
    				var lastHoleIdx = hole.length - 1;

    				var prevHoleIdx = inHoleIdx - 1;
    				if ( prevHoleIdx < 0 )			prevHoleIdx = lastHoleIdx;

    				var nextHoleIdx = inHoleIdx + 1;
    				if ( nextHoleIdx > lastHoleIdx )	nextHoleIdx = 0;

    				insideAngle = isPointInsideAngle( hole[ inHoleIdx ], hole[ prevHoleIdx ], hole[ nextHoleIdx ], shape[ inShapeIdx ] );
    				if ( ! insideAngle ) {

    					// console.log( "Vertex (Hole): " + inHoleIdx + ", Point: " + shape[inShapeIdx].x + "/" + shape[inShapeIdx].y );
    					return	false;

    				}

    				return	true;

    			}

    			function intersectsShapeEdge( inShapePt, inHolePt ) {

    				// checks for intersections with shape edges
    				var sIdx, nextIdx, intersection;
    				for ( sIdx = 0; sIdx < shape.length; sIdx ++ ) {

    					nextIdx = sIdx + 1; nextIdx %= shape.length;
    					intersection = intersect_segments_2D( inShapePt, inHolePt, shape[ sIdx ], shape[ nextIdx ], true );
    					if ( intersection.length > 0 )		return	true;

    				}

    				return	false;

    			}

    			var indepHoles = [];

    			function intersectsHoleEdge( inShapePt, inHolePt ) {

    				// checks for intersections with hole edges
    				var ihIdx, chkHole,
    					hIdx, nextIdx, intersection;
    				for ( ihIdx = 0; ihIdx < indepHoles.length; ihIdx ++ ) {

    					chkHole = holes[ indepHoles[ ihIdx ]];
    					for ( hIdx = 0; hIdx < chkHole.length; hIdx ++ ) {

    						nextIdx = hIdx + 1; nextIdx %= chkHole.length;
    						intersection = intersect_segments_2D( inShapePt, inHolePt, chkHole[ hIdx ], chkHole[ nextIdx ], true );
    						if ( intersection.length > 0 )		return	true;

    					}

    				}
    				return	false;

    			}

    			var holeIndex, shapeIndex,
    				shapePt, holePt,
    				holeIdx, cutKey, failedCuts = [],
    				tmpShape1, tmpShape2,
    				tmpHole1, tmpHole2;

    			for ( var h = 0, hl = holes.length; h < hl; h ++ ) {

    				indepHoles.push( h );

    			}

    			var minShapeIndex = 0;
    			var counter = indepHoles.length * 2;
    			while ( indepHoles.length > 0 ) {

    				counter --;
    				if ( counter < 0 ) {

    					console.log( "Infinite Loop! Holes left:" + indepHoles.length + ", Probably Hole outside Shape!" );
    					break;

    				}

    				// search for shape-vertex and hole-vertex,
    				// which can be connected without intersections
    				for ( shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex ++ ) {

    					shapePt = shape[ shapeIndex ];
    					holeIndex	= - 1;

    					// search for hole which can be reached without intersections
    					for ( var h = 0; h < indepHoles.length; h ++ ) {

    						holeIdx = indepHoles[ h ];

    						// prevent multiple checks
    						cutKey = shapePt.x + ":" + shapePt.y + ":" + holeIdx;
    						if ( failedCuts[ cutKey ] !== undefined )			continue;

    						hole = holes[ holeIdx ];
    						for ( var h2 = 0; h2 < hole.length; h2 ++ ) {

    							holePt = hole[ h2 ];
    							if ( ! isCutLineInsideAngles( shapeIndex, h2 ) )		continue;
    							if ( intersectsShapeEdge( shapePt, holePt ) )		continue;
    							if ( intersectsHoleEdge( shapePt, holePt ) )		continue;

    							holeIndex = h2;
    							indepHoles.splice( h, 1 );

    							tmpShape1 = shape.slice( 0, shapeIndex + 1 );
    							tmpShape2 = shape.slice( shapeIndex );
    							tmpHole1 = hole.slice( holeIndex );
    							tmpHole2 = hole.slice( 0, holeIndex + 1 );

    							shape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );

    							minShapeIndex = shapeIndex;

    							// Debug only, to show the selected cuts
    							// glob_CutLines.push( [ shapePt, holePt ] );

    							break;

    						}
    						if ( holeIndex >= 0 )	break;		// hole-vertex found

    						failedCuts[ cutKey ] = true;			// remember failure

    					}
    					if ( holeIndex >= 0 )	break;		// hole-vertex found

    				}

    			}

    			return shape; 			/* shape with no holes */

    		}


    		var i, il, f, face,
    			key, index,
    			allPointsMap = {};

    		// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.

    		var allpoints = contour.concat();

    		for ( var h = 0, hl = holes.length; h < hl; h ++ ) {

    			Array.prototype.push.apply( allpoints, holes[ h ] );

    		}

    		//console.log( "allpoints",allpoints, allpoints.length );

    		// prepare all points map

    		for ( i = 0, il = allpoints.length; i < il; i ++ ) {

    			key = allpoints[ i ].x + ":" + allpoints[ i ].y;

    			if ( allPointsMap[ key ] !== undefined ) {

    				console.warn( "THREE.ShapeUtils: Duplicate point", key, i );

    			}

    			allPointsMap[ key ] = i;

    		}

    		// remove holes by cutting paths to holes and adding them to the shape
    		var shapeWithoutHoles = removeHoles( contour, holes );

    		var triangles = exports.ShapeUtils.triangulate( shapeWithoutHoles, false ); // True returns indices for points of spooled shape
    		//console.log( "triangles",triangles, triangles.length );

    		// check all face vertices against all points map

    		for ( i = 0, il = triangles.length; i < il; i ++ ) {

    			face = triangles[ i ];

    			for ( f = 0; f < 3; f ++ ) {

    				key = face[ f ].x + ":" + face[ f ].y;

    				index = allPointsMap[ key ];

    				if ( index !== undefined ) {

    					face[ f ] = index;

    				}

    			}

    		}

    		return triangles.concat();

    	},

    	isClockWise: function ( pts ) {

    		return exports.ShapeUtils.area( pts ) < 0;

    	},

    	// Bezier Curves formulas obtained from
    	// http://en.wikipedia.org/wiki/B%C3%A9zier_curve

    	// Quad Bezier Functions

    	b2: ( function () {

    		function b2p0( t, p ) {

    			var k = 1 - t;
    			return k * k * p;

    		}

    		function b2p1( t, p ) {

    			return 2 * ( 1 - t ) * t * p;

    		}

    		function b2p2( t, p ) {

    			return t * t * p;

    		}

    		return function b2( t, p0, p1, p2 ) {

    			return b2p0( t, p0 ) + b2p1( t, p1 ) + b2p2( t, p2 );

    		};

    	} )(),

    	// Cubic Bezier Functions

    	b3: ( function () {

    		function b3p0( t, p ) {

    			var k = 1 - t;
    			return k * k * k * p;

    		}

    		function b3p1( t, p ) {

    			var k = 1 - t;
    			return 3 * k * k * t * p;

    		}

    		function b3p2( t, p ) {

    			var k = 1 - t;
    			return 3 * k * t * t * p;

    		}

    		function b3p3( t, p ) {

    			return t * t * t * p;

    		}

    		return function b3( t, p0, p1, p2, p3 ) {

    			return b3p0( t, p0 ) + b3p1( t, p1 ) + b3p2( t, p2 ) + b3p3( t, p3 );

    		};

    	} )()

    };

    /**
     * @author zz85 / http://www.lab4games.net/zz85/blog
     *
     * Creates extruded geometry from a path shape.
     *
     * parameters = {
     *
     *  curveSegments: <int>, // number of points on the curves
     *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
     *  amount: <int>, // Depth to extrude the shape
     *
     *  bevelEnabled: <bool>, // turn on bevel
     *  bevelThickness: <float>, // how deep into the original shape bevel goes
     *  bevelSize: <float>, // how far from shape outline is bevel
     *  bevelSegments: <int>, // number of bevel layers
     *
     *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)
     *  frames: <THREE.TubeGeometry.FrenetFrames> // containing arrays of tangents, normals, binormals
     *
     *  uvGenerator: <Object> // object that provides UV generator functions
     *
     * }
     **/

    function ExtrudeGeometry( shapes, options ) {

    	if ( typeof( shapes ) === "undefined" ) {

    		shapes = [];
    		return;

    	}

    	Geometry.call( this );

    	this.type = 'ExtrudeGeometry';

    	shapes = Array.isArray( shapes ) ? shapes : [ shapes ];

    	this.addShapeList( shapes, options );

    	this.computeFaceNormals();

    	// can't really use automatic vertex normals
    	// as then front and back sides get smoothed too
    	// should do separate smoothing just for sides

    	//this.computeVertexNormals();

    	//console.log( "took", ( Date.now() - startTime ) );

    }

    ExtrudeGeometry.prototype = Object.create( Geometry.prototype );
    ExtrudeGeometry.prototype.constructor = ExtrudeGeometry;

    ExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {

    	var sl = shapes.length;

    	for ( var s = 0; s < sl; s ++ ) {

    		var shape = shapes[ s ];
    		this.addShape( shape, options );

    	}

    };

    ExtrudeGeometry.prototype.addShape = function ( shape, options ) {

    	var amount = options.amount !== undefined ? options.amount : 100;

    	var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10
    	var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8
    	var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;

    	var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false

    	var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

    	var steps = options.steps !== undefined ? options.steps : 1;

    	var extrudePath = options.extrudePath;
    	var extrudePts, extrudeByPath = false;

    	// Use default WorldUVGenerator if no UV generators are specified.
    	var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : ExtrudeGeometry.WorldUVGenerator;

    	var splineTube, binormal, normal, position2;
    	if ( extrudePath ) {

    		extrudePts = extrudePath.getSpacedPoints( steps );

    		extrudeByPath = true;
    		bevelEnabled = false; // bevels not supported for path extrusion

    		// SETUP TNB variables

    		// Reuse TNB from TubeGeomtry for now.
    		// TODO1 - have a .isClosed in spline?

    		splineTube = options.frames !== undefined ? options.frames : new TubeGeometry.FrenetFrames( extrudePath, steps, false );

    		// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

    		binormal = new Vector3();
    		normal = new Vector3();
    		position2 = new Vector3();

    	}

    	// Safeguards if bevels are not enabled

    	if ( ! bevelEnabled ) {

    		bevelSegments = 0;
    		bevelThickness = 0;
    		bevelSize = 0;

    	}

    	// Variables initialization

    	var ahole, h, hl; // looping of holes
    	var scope = this;

    	var shapesOffset = this.vertices.length;

    	var shapePoints = shape.extractPoints( curveSegments );

    	var vertices = shapePoints.shape;
    	var holes = shapePoints.holes;

    	var reverse = ! exports.ShapeUtils.isClockWise( vertices );

    	if ( reverse ) {

    		vertices = vertices.reverse();

    		// Maybe we should also check if holes are in the opposite direction, just to be safe ...

    		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

    			ahole = holes[ h ];

    			if ( exports.ShapeUtils.isClockWise( ahole ) ) {

    				holes[ h ] = ahole.reverse();

    			}

    		}

    		reverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!

    	}


    	var faces = exports.ShapeUtils.triangulateShape( vertices, holes );

    	/* Vertices */

    	var contour = vertices; // vertices has all points but contour has only points of circumference

    	for ( h = 0, hl = holes.length; h < hl; h ++ ) {

    		ahole = holes[ h ];

    		vertices = vertices.concat( ahole );

    	}


    	function scalePt2( pt, vec, size ) {

    		if ( ! vec ) console.error( "THREE.ExtrudeGeometry: vec does not exist" );

    		return vec.clone().multiplyScalar( size ).add( pt );

    	}

    	var b, bs, t, z,
    		vert, vlen = vertices.length,
    		face, flen = faces.length;


    	// Find directions for point movement


    	function getBevelVec( inPt, inPrev, inNext ) {

    		// computes for inPt the corresponding point inPt' on a new contour
    		//   shifted by 1 unit (length of normalized vector) to the left
    		// if we walk along contour clockwise, this new contour is outside the old one
    		//
    		// inPt' is the intersection of the two lines parallel to the two
    		//  adjacent edges of inPt at a distance of 1 unit on the left side.

    		var v_trans_x, v_trans_y, shrink_by = 1;		// resulting translation vector for inPt

    		// good reading for geometry algorithms (here: line-line intersection)
    		// http://geomalgorithms.com/a05-_intersect-1.html

    		var v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
    		var v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;

    		var v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );

    		// check for collinear edges
    		var collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );

    		if ( Math.abs( collinear0 ) > Number.EPSILON ) {

    			// not collinear

    			// length of vectors for normalizing

    			var v_prev_len = Math.sqrt( v_prev_lensq );
    			var v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );

    			// shift adjacent points by unit vectors to the left

    			var ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
    			var ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );

    			var ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
    			var ptNextShift_y = ( inNext.y + v_next_x / v_next_len );

    			// scaling factor for v_prev to intersection point

    			var sf = (  ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
    						( ptNextShift_y - ptPrevShift_y ) * v_next_x    ) /
    					  ( v_prev_x * v_next_y - v_prev_y * v_next_x );

    			// vector from inPt to intersection point

    			v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
    			v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );

    			// Don't normalize!, otherwise sharp corners become ugly
    			//  but prevent crazy spikes
    			var v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );
    			if ( v_trans_lensq <= 2 ) {

    				return	new Vector2( v_trans_x, v_trans_y );

    			} else {

    				shrink_by = Math.sqrt( v_trans_lensq / 2 );

    			}

    		} else {

    			// handle special case of collinear edges

    			var direction_eq = false;		// assumes: opposite
    			if ( v_prev_x > Number.EPSILON ) {

    				if ( v_next_x > Number.EPSILON ) {

    					direction_eq = true;

    				}

    			} else {

    				if ( v_prev_x < - Number.EPSILON ) {

    					if ( v_next_x < - Number.EPSILON ) {

    						direction_eq = true;

    					}

    				} else {

    					if ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {

    						direction_eq = true;

    					}

    				}

    			}

    			if ( direction_eq ) {

    				// console.log("Warning: lines are a straight sequence");
    				v_trans_x = - v_prev_y;
    				v_trans_y =  v_prev_x;
    				shrink_by = Math.sqrt( v_prev_lensq );

    			} else {

    				// console.log("Warning: lines are a straight spike");
    				v_trans_x = v_prev_x;
    				v_trans_y = v_prev_y;
    				shrink_by = Math.sqrt( v_prev_lensq / 2 );

    			}

    		}

    		return	new Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );

    	}


    	var contourMovements = [];

    	for ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

    		if ( j === il ) j = 0;
    		if ( k === il ) k = 0;

    		//  (j)---(i)---(k)
    		// console.log('i,j,k', i, j , k)

    		contourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );

    	}

    	var holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();

    	for ( h = 0, hl = holes.length; h < hl; h ++ ) {

    		ahole = holes[ h ];

    		oneHoleMovements = [];

    		for ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

    			if ( j === il ) j = 0;
    			if ( k === il ) k = 0;

    			//  (j)---(i)---(k)
    			oneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );

    		}

    		holesMovements.push( oneHoleMovements );
    		verticesMovements = verticesMovements.concat( oneHoleMovements );

    	}


    	// Loop bevelSegments, 1 for the front, 1 for the back

    	for ( b = 0; b < bevelSegments; b ++ ) {

    		//for ( b = bevelSegments; b > 0; b -- ) {

    		t = b / bevelSegments;
    		z = bevelThickness * Math.cos( t * Math.PI / 2 );
    		bs = bevelSize * Math.sin( t * Math.PI / 2 );

    		// contract shape

    		for ( i = 0, il = contour.length; i < il; i ++ ) {

    			vert = scalePt2( contour[ i ], contourMovements[ i ], bs );

    			v( vert.x, vert.y,  - z );

    		}

    		// expand holes

    		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

    			ahole = holes[ h ];
    			oneHoleMovements = holesMovements[ h ];

    			for ( i = 0, il = ahole.length; i < il; i ++ ) {

    				vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

    				v( vert.x, vert.y,  - z );

    			}

    		}

    	}

    	bs = bevelSize;

    	// Back facing vertices

    	for ( i = 0; i < vlen; i ++ ) {

    		vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

    		if ( ! extrudeByPath ) {

    			v( vert.x, vert.y, 0 );

    		} else {

    			// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

    			normal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );
    			binormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );

    			position2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );

    			v( position2.x, position2.y, position2.z );

    		}

    	}

    	// Add stepped vertices...
    	// Including front facing vertices

    	var s;

    	for ( s = 1; s <= steps; s ++ ) {

    		for ( i = 0; i < vlen; i ++ ) {

    			vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

    			if ( ! extrudeByPath ) {

    				v( vert.x, vert.y, amount / steps * s );

    			} else {

    				// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

    				normal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );
    				binormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );

    				position2.copy( extrudePts[ s ] ).add( normal ).add( binormal );

    				v( position2.x, position2.y, position2.z );

    			}

    		}

    	}


    	// Add bevel segments planes

    	//for ( b = 1; b <= bevelSegments; b ++ ) {
    	for ( b = bevelSegments - 1; b >= 0; b -- ) {

    		t = b / bevelSegments;
    		z = bevelThickness * Math.cos ( t * Math.PI / 2 );
    		bs = bevelSize * Math.sin( t * Math.PI / 2 );

    		// contract shape

    		for ( i = 0, il = contour.length; i < il; i ++ ) {

    			vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
    			v( vert.x, vert.y,  amount + z );

    		}

    		// expand holes

    		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

    			ahole = holes[ h ];
    			oneHoleMovements = holesMovements[ h ];

    			for ( i = 0, il = ahole.length; i < il; i ++ ) {

    				vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

    				if ( ! extrudeByPath ) {

    					v( vert.x, vert.y,  amount + z );

    				} else {

    					v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );

    				}

    			}

    		}

    	}

    	/* Faces */

    	// Top and bottom faces

    	buildLidFaces();

    	// Sides faces

    	buildSideFaces();


    	/////  Internal functions

    	function buildLidFaces() {

    		if ( bevelEnabled ) {

    			var layer = 0; // steps + 1
    			var offset = vlen * layer;

    			// Bottom faces

    			for ( i = 0; i < flen; i ++ ) {

    				face = faces[ i ];
    				f3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );

    			}

    			layer = steps + bevelSegments * 2;
    			offset = vlen * layer;

    			// Top faces

    			for ( i = 0; i < flen; i ++ ) {

    				face = faces[ i ];
    				f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );

    			}

    		} else {

    			// Bottom faces

    			for ( i = 0; i < flen; i ++ ) {

    				face = faces[ i ];
    				f3( face[ 2 ], face[ 1 ], face[ 0 ] );

    			}

    			// Top faces

    			for ( i = 0; i < flen; i ++ ) {

    				face = faces[ i ];
    				f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );

    			}

    		}

    	}

    	// Create faces for the z-sides of the shape

    	function buildSideFaces() {

    		var layeroffset = 0;
    		sidewalls( contour, layeroffset );
    		layeroffset += contour.length;

    		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

    			ahole = holes[ h ];
    			sidewalls( ahole, layeroffset );

    			//, true
    			layeroffset += ahole.length;

    		}

    	}

    	function sidewalls( contour, layeroffset ) {

    		var j, k;
    		i = contour.length;

    		while ( -- i >= 0 ) {

    			j = i;
    			k = i - 1;
    			if ( k < 0 ) k = contour.length - 1;

    			//console.log('b', i,j, i-1, k,vertices.length);

    			var s = 0, sl = steps  + bevelSegments * 2;

    			for ( s = 0; s < sl; s ++ ) {

    				var slen1 = vlen * s;
    				var slen2 = vlen * ( s + 1 );

    				var a = layeroffset + j + slen1,
    					b = layeroffset + k + slen1,
    					c = layeroffset + k + slen2,
    					d = layeroffset + j + slen2;

    				f4( a, b, c, d, contour, s, sl, j, k );

    			}

    		}

    	}


    	function v( x, y, z ) {

    		scope.vertices.push( new Vector3( x, y, z ) );

    	}

    	function f3( a, b, c ) {

    		a += shapesOffset;
    		b += shapesOffset;
    		c += shapesOffset;

    		scope.faces.push( new Face3( a, b, c, null, null, 0 ) );

    		var uvs = uvgen.generateTopUV( scope, a, b, c );

    		scope.faceVertexUvs[ 0 ].push( uvs );

    	}

    	function f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {

    		a += shapesOffset;
    		b += shapesOffset;
    		c += shapesOffset;
    		d += shapesOffset;

    		scope.faces.push( new Face3( a, b, d, null, null, 1 ) );
    		scope.faces.push( new Face3( b, c, d, null, null, 1 ) );

    		var uvs = uvgen.generateSideWallUV( scope, a, b, c, d );

    		scope.faceVertexUvs[ 0 ].push( [ uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] ] );
    		scope.faceVertexUvs[ 0 ].push( [ uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] ] );

    	}

    };

    ExtrudeGeometry.WorldUVGenerator = {

    	generateTopUV: function ( geometry, indexA, indexB, indexC ) {

    		var vertices = geometry.vertices;

    		var a = vertices[ indexA ];
    		var b = vertices[ indexB ];
    		var c = vertices[ indexC ];

    		return [
    			new Vector2( a.x, a.y ),
    			new Vector2( b.x, b.y ),
    			new Vector2( c.x, c.y )
    		];

    	},

    	generateSideWallUV: function ( geometry, indexA, indexB, indexC, indexD ) {

    		var vertices = geometry.vertices;

    		var a = vertices[ indexA ];
    		var b = vertices[ indexB ];
    		var c = vertices[ indexC ];
    		var d = vertices[ indexD ];

    		if ( Math.abs( a.y - b.y ) < 0.01 ) {

    			return [
    				new Vector2( a.x, 1 - a.z ),
    				new Vector2( b.x, 1 - b.z ),
    				new Vector2( c.x, 1 - c.z ),
    				new Vector2( d.x, 1 - d.z )
    			];

    		} else {

    			return [
    				new Vector2( a.y, 1 - a.z ),
    				new Vector2( b.y, 1 - b.z ),
    				new Vector2( c.y, 1 - c.z ),
    				new Vector2( d.y, 1 - d.z )
    			];

    		}

    	}
    };

    /**
     * @author zz85 / http://www.lab4games.net/zz85/blog
     * @author alteredq / http://alteredqualia.com/
     *
     * Text = 3D Text
     *
     * parameters = {
     *  font: <THREE.Font>, // font
     *
     *  size: <float>, // size of the text
     *  height: <float>, // thickness to extrude text
     *  curveSegments: <int>, // number of points on the curves
     *
     *  bevelEnabled: <bool>, // turn on bevel
     *  bevelThickness: <float>, // how deep into text bevel goes
     *  bevelSize: <float> // how far from text outline is bevel
     * }
     */

    function TextGeometry( text, parameters ) {

    	parameters = parameters || {};

    	var font = parameters.font;

    	if ( (font && font.isFont) === false ) {

    		console.error( 'THREE.TextGeometry: font parameter is not an instance of THREE.Font.' );
    		return new Geometry();

    	}

    	var shapes = font.generateShapes( text, parameters.size, parameters.curveSegments );

    	// translate parameters to ExtrudeGeometry API

    	parameters.amount = parameters.height !== undefined ? parameters.height : 50;

    	// defaults

    	if ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;
    	if ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;
    	if ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;

    	ExtrudeGeometry.call( this, shapes, parameters );

    	this.type = 'TextGeometry';

    }

    TextGeometry.prototype = Object.create( ExtrudeGeometry.prototype );
    TextGeometry.prototype.constructor = TextGeometry;

    /**
     * @author benaadams / https://twitter.com/ben_a_adams
     * based on THREE.SphereGeometry
     */

    function SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

    	BufferGeometry.call( this );

    	this.type = 'SphereBufferGeometry';

    	this.parameters = {
    		radius: radius,
    		widthSegments: widthSegments,
    		heightSegments: heightSegments,
    		phiStart: phiStart,
    		phiLength: phiLength,
    		thetaStart: thetaStart,
    		thetaLength: thetaLength
    	};

    	radius = radius || 50;

    	widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );
    	heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );

    	phiStart = phiStart !== undefined ? phiStart : 0;
    	phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;

    	thetaStart = thetaStart !== undefined ? thetaStart : 0;
    	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;

    	var thetaEnd = thetaStart + thetaLength;

    	var vertexCount = ( ( widthSegments + 1 ) * ( heightSegments + 1 ) );

    	var positions = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
    	var normals = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
    	var uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );

    	var index = 0, vertices = [], normal = new Vector3();

    	for ( var y = 0; y <= heightSegments; y ++ ) {

    		var verticesRow = [];

    		var v = y / heightSegments;

    		for ( var x = 0; x <= widthSegments; x ++ ) {

    			var u = x / widthSegments;

    			var px = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
    			var py = radius * Math.cos( thetaStart + v * thetaLength );
    			var pz = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

    			normal.set( px, py, pz ).normalize();

    			positions.setXYZ( index, px, py, pz );
    			normals.setXYZ( index, normal.x, normal.y, normal.z );
    			uvs.setXY( index, u, 1 - v );

    			verticesRow.push( index );

    			index ++;

    		}

    		vertices.push( verticesRow );

    	}

    	var indices = [];

    	for ( var y = 0; y < heightSegments; y ++ ) {

    		for ( var x = 0; x < widthSegments; x ++ ) {

    			var v1 = vertices[ y ][ x + 1 ];
    			var v2 = vertices[ y ][ x ];
    			var v3 = vertices[ y + 1 ][ x ];
    			var v4 = vertices[ y + 1 ][ x + 1 ];

    			if ( y !== 0 || thetaStart > 0 ) indices.push( v1, v2, v4 );
    			if ( y !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( v2, v3, v4 );

    		}

    	}

    	this.setIndex( new ( positions.count > 65535 ? Uint32Attribute : Uint16Attribute )( indices, 1 ) );
    	this.addAttribute( 'position', positions );
    	this.addAttribute( 'normal', normals );
    	this.addAttribute( 'uv', uvs );

    	this.boundingSphere = new Sphere( new Vector3(), radius );

    }

    SphereBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
    SphereBufferGeometry.prototype.constructor = SphereBufferGeometry;

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function SphereGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

    	Geometry.call( this );

    	this.type = 'SphereGeometry';

    	this.parameters = {
    		radius: radius,
    		widthSegments: widthSegments,
    		heightSegments: heightSegments,
    		phiStart: phiStart,
    		phiLength: phiLength,
    		thetaStart: thetaStart,
    		thetaLength: thetaLength
    	};

    	this.fromBufferGeometry( new SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );

    }

    SphereGeometry.prototype = Object.create( Geometry.prototype );
    SphereGeometry.prototype.constructor = SphereGeometry;

    /**
     * @author Mugen87 / https://github.com/Mugen87
     */

    function RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

    	BufferGeometry.call( this );

    	this.type = 'RingBufferGeometry';

    	this.parameters = {
    		innerRadius: innerRadius,
    		outerRadius: outerRadius,
    		thetaSegments: thetaSegments,
    		phiSegments: phiSegments,
    		thetaStart: thetaStart,
    		thetaLength: thetaLength
    	};

    	innerRadius = innerRadius || 20;
    	outerRadius = outerRadius || 50;

    	thetaStart = thetaStart !== undefined ? thetaStart : 0;
    	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

    	thetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;
    	phiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 1;

    	// these are used to calculate buffer length
    	var vertexCount = ( thetaSegments + 1 ) * ( phiSegments + 1 );
    	var indexCount = thetaSegments * phiSegments * 2 * 3;

    	// buffers
    	var indices = new BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );
    	var vertices = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
    	var normals = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
    	var uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );

    	// some helper variables
    	var index = 0, indexOffset = 0, segment;
    	var radius = innerRadius;
    	var radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );
    	var vertex = new Vector3();
    	var uv = new Vector2();
    	var j, i;

    	// generate vertices, normals and uvs

    	// values are generate from the inside of the ring to the outside

    	for ( j = 0; j <= phiSegments; j ++ ) {

    		for ( i = 0; i <= thetaSegments; i ++ ) {

    			segment = thetaStart + i / thetaSegments * thetaLength;

    			// vertex
    			vertex.x = radius * Math.cos( segment );
    			vertex.y = radius * Math.sin( segment );
    			vertices.setXYZ( index, vertex.x, vertex.y, vertex.z );

    			// normal
    			normals.setXYZ( index, 0, 0, 1 );

    			// uv
    			uv.x = ( vertex.x / outerRadius + 1 ) / 2;
    			uv.y = ( vertex.y / outerRadius + 1 ) / 2;
    			uvs.setXY( index, uv.x, uv.y );

    			// increase index
    			index++;

    		}

    		// increase the radius for next row of vertices
    		radius += radiusStep;

    	}

    	// generate indices

    	for ( j = 0; j < phiSegments; j ++ ) {

    		var thetaSegmentLevel = j * ( thetaSegments + 1 );

    		for ( i = 0; i < thetaSegments; i ++ ) {

    			segment = i + thetaSegmentLevel;

    			// indices
    			var a = segment;
    			var b = segment + thetaSegments + 1;
    			var c = segment + thetaSegments + 2;
    			var d = segment + 1;

    			// face one
    			indices.setX( indexOffset, a ); indexOffset++;
    			indices.setX( indexOffset, b ); indexOffset++;
    			indices.setX( indexOffset, c ); indexOffset++;

    			// face two
    			indices.setX( indexOffset, a ); indexOffset++;
    			indices.setX( indexOffset, c ); indexOffset++;
    			indices.setX( indexOffset, d ); indexOffset++;

    		}

    	}

    	// build geometry

    	this.setIndex( indices );
    	this.addAttribute( 'position', vertices );
    	this.addAttribute( 'normal', normals );
    	this.addAttribute( 'uv', uvs );

    }

    RingBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
    RingBufferGeometry.prototype.constructor = RingBufferGeometry;

    /**
     * @author Kaleb Murphy
     */

    function RingGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

    	Geometry.call( this );

    	this.type = 'RingGeometry';

    	this.parameters = {
    		innerRadius: innerRadius,
    		outerRadius: outerRadius,
    		thetaSegments: thetaSegments,
    		phiSegments: phiSegments,
    		thetaStart: thetaStart,
    		thetaLength: thetaLength
    	};

    	this.fromBufferGeometry( new RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) );

    }

    RingGeometry.prototype = Object.create( Geometry.prototype );
    RingGeometry.prototype.constructor = RingGeometry;

    /**
     * @author mrdoob / http://mrdoob.com/
     * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
     */

    function PlaneGeometry( width, height, widthSegments, heightSegments ) {

    	Geometry.call( this );

    	this.type = 'PlaneGeometry';

    	this.parameters = {
    		width: width,
    		height: height,
    		widthSegments: widthSegments,
    		heightSegments: heightSegments
    	};

    	this.fromBufferGeometry( new PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );

    }

    PlaneGeometry.prototype = Object.create( Geometry.prototype );
    PlaneGeometry.prototype.constructor = PlaneGeometry;

    /**
     * @author Mugen87 / https://github.com/Mugen87
     */

     // points - to create a closed torus, one must use a set of points
     //    like so: [ a, b, c, d, a ], see first is the same as last.
     // segments - the number of circumference segments to create
     // phiStart - the starting radian
     // phiLength - the radian (0 to 2PI) range of the lathed section
     //    2PI is a closed lathe, less than 2PI is a portion.

    function LatheBufferGeometry( points, segments, phiStart, phiLength ) {

    	BufferGeometry.call( this );

    	this.type = 'LatheBufferGeometry';

    	this.parameters = {
    		points: points,
    		segments: segments,
    		phiStart: phiStart,
    		phiLength: phiLength
    	};

    	segments = Math.floor( segments ) || 12;
    	phiStart = phiStart || 0;
    	phiLength = phiLength || Math.PI * 2;

    	// clamp phiLength so it's in range of [ 0, 2PI ]
    	phiLength = exports.Math.clamp( phiLength, 0, Math.PI * 2 );

    	// these are used to calculate buffer length
    	var vertexCount = ( segments + 1 ) * points.length;
    	var indexCount = segments * points.length * 2 * 3;

    	// buffers
    	var indices = new BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );
    	var vertices = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
    	var uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );

    	// helper variables
    	var index = 0, indexOffset = 0, base;
    	var inverseSegments = 1.0 / segments;
    	var vertex = new Vector3();
    	var uv = new Vector2();
    	var i, j;

    	// generate vertices and uvs

    	for ( i = 0; i <= segments; i ++ ) {

    		var phi = phiStart + i * inverseSegments * phiLength;

    		var sin = Math.sin( phi );
    		var cos = Math.cos( phi );

    		for ( j = 0; j <= ( points.length - 1 ); j ++ ) {

    			// vertex
    			vertex.x = points[ j ].x * sin;
    			vertex.y = points[ j ].y;
    			vertex.z = points[ j ].x * cos;
    			vertices.setXYZ( index, vertex.x, vertex.y, vertex.z );

    			// uv
    			uv.x = i / segments;
    			uv.y = j / ( points.length - 1 );
    			uvs.setXY( index, uv.x, uv.y );

    			// increase index
    			index ++;

    		}

    	}

    	// generate indices

    	for ( i = 0; i < segments; i ++ ) {

    		for ( j = 0; j < ( points.length - 1 ); j ++ ) {

    			base = j + i * points.length;

    			// indices
    			var a = base;
    			var b = base + points.length;
    			var c = base + points.length + 1;
    			var d = base + 1;

    			// face one
    			indices.setX( indexOffset, a ); indexOffset++;
    			indices.setX( indexOffset, b ); indexOffset++;
    			indices.setX( indexOffset, d ); indexOffset++;

    			// face two
    			indices.setX( indexOffset, b ); indexOffset++;
    			indices.setX( indexOffset, c ); indexOffset++;
    			indices.setX( indexOffset, d ); indexOffset++;

    		}

    	}

    	// build geometry

    	this.setIndex( indices );
    	this.addAttribute( 'position', vertices );
    	this.addAttribute( 'uv', uvs );

    	// generate normals

    	this.computeVertexNormals();

    	// if the geometry is closed, we need to average the normals along the seam.
    	// because the corresponding vertices are identical (but still have different UVs).

    	if( phiLength === Math.PI * 2 ) {

    		var normals = this.attributes.normal.array;
    		var n1 = new Vector3();
    		var n2 = new Vector3();
    		var n = new Vector3();

    		// this is the buffer offset for the last line of vertices
    		base = segments * points.length * 3;

    		for( i = 0, j = 0; i < points.length; i ++, j += 3 ) {

    			// select the normal of the vertex in the first line
    			n1.x = normals[ j + 0 ];
    			n1.y = normals[ j + 1 ];
    			n1.z = normals[ j + 2 ];

    			// select the normal of the vertex in the last line
    			n2.x = normals[ base + j + 0 ];
    			n2.y = normals[ base + j + 1 ];
    			n2.z = normals[ base + j + 2 ];

    			// average normals
    			n.addVectors( n1, n2 ).normalize();

    			// assign the new values to both normals
    			normals[ j + 0 ] = normals[ base + j + 0 ] = n.x;
    			normals[ j + 1 ] = normals[ base + j + 1 ] = n.y;
    			normals[ j + 2 ] = normals[ base + j + 2 ] = n.z;

    		} // next row

    	}

    }

    LatheBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
    LatheBufferGeometry.prototype.constructor = LatheBufferGeometry;

    /**
     * @author astrodud / http://astrodud.isgreat.org/
     * @author zz85 / https://github.com/zz85
     * @author bhouston / http://clara.io
     */

    // points - to create a closed torus, one must use a set of points
    //    like so: [ a, b, c, d, a ], see first is the same as last.
    // segments - the number of circumference segments to create
    // phiStart - the starting radian
    // phiLength - the radian (0 to 2PI) range of the lathed section
    //    2PI is a closed lathe, less than 2PI is a portion.

    function LatheGeometry( points, segments, phiStart, phiLength ) {

    	Geometry.call( this );

    	this.type = 'LatheGeometry';

    	this.parameters = {
    		points: points,
    		segments: segments,
    		phiStart: phiStart,
    		phiLength: phiLength
    	};

    	this.fromBufferGeometry( new LatheBufferGeometry( points, segments, phiStart, phiLength ) );
    	this.mergeVertices();

    }

    LatheGeometry.prototype = Object.create( Geometry.prototype );
    LatheGeometry.prototype.constructor = LatheGeometry;

    /**
     * @author jonobr1 / http://jonobr1.com
     *
     * Creates a one-sided polygonal geometry from a path shape. Similar to
     * ExtrudeGeometry.
     *
     * parameters = {
     *
     *	curveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.
     *
     *	material: <int> // material index for front and back faces
     *	uvGenerator: <Object> // object that provides UV generator functions
     *
     * }
     **/

    function ShapeGeometry( shapes, options ) {

    	Geometry.call( this );

    	this.type = 'ShapeGeometry';

    	if ( Array.isArray( shapes ) === false ) shapes = [ shapes ];

    	this.addShapeList( shapes, options );

    	this.computeFaceNormals();

    }

    ShapeGeometry.prototype = Object.create( Geometry.prototype );
    ShapeGeometry.prototype.constructor = ShapeGeometry;

    /**
     * Add an array of shapes to THREE.ShapeGeometry.
     */
    ShapeGeometry.prototype.addShapeList = function ( shapes, options ) {

    	for ( var i = 0, l = shapes.length; i < l; i ++ ) {

    		this.addShape( shapes[ i ], options );

    	}

    	return this;

    };

    /**
     * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.
     */
    ShapeGeometry.prototype.addShape = function ( shape, options ) {

    	if ( options === undefined ) options = {};
    	var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

    	var material = options.material;
    	var uvgen = options.UVGenerator === undefined ? ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;

    	//

    	var i, l, hole;

    	var shapesOffset = this.vertices.length;
    	var shapePoints = shape.extractPoints( curveSegments );

    	var vertices = shapePoints.shape;
    	var holes = shapePoints.holes;

    	var reverse = ! exports.ShapeUtils.isClockWise( vertices );

    	if ( reverse ) {

    		vertices = vertices.reverse();

    		// Maybe we should also check if holes are in the opposite direction, just to be safe...

    		for ( i = 0, l = holes.length; i < l; i ++ ) {

    			hole = holes[ i ];

    			if ( exports.ShapeUtils.isClockWise( hole ) ) {

    				holes[ i ] = hole.reverse();

    			}

    		}

    		reverse = false;

    	}

    	var faces = exports.ShapeUtils.triangulateShape( vertices, holes );

    	// Vertices

    	for ( i = 0, l = holes.length; i < l; i ++ ) {

    		hole = holes[ i ];
    		vertices = vertices.concat( hole );

    	}

    	//

    	var vert, vlen = vertices.length;
    	var face, flen = faces.length;

    	for ( i = 0; i < vlen; i ++ ) {

    		vert = vertices[ i ];

    		this.vertices.push( new Vector3( vert.x, vert.y, 0 ) );

    	}

    	for ( i = 0; i < flen; i ++ ) {

    		face = faces[ i ];

    		var a = face[ 0 ] + shapesOffset;
    		var b = face[ 1 ] + shapesOffset;
    		var c = face[ 2 ] + shapesOffset;

    		this.faces.push( new Face3( a, b, c, null, null, material ) );
    		this.faceVertexUvs[ 0 ].push( uvgen.generateTopUV( this, a, b, c ) );

    	}

    };

    /**
     * @author WestLangley / http://github.com/WestLangley
     */

    function EdgesGeometry( geometry, thresholdAngle ) {

    	BufferGeometry.call( this );

    	thresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;

    	var thresholdDot = Math.cos( exports.Math.DEG2RAD * thresholdAngle );

    	var edge = [ 0, 0 ], hash = {};

    	function sortFunction( a, b ) {

    		return a - b;

    	}

    	var keys = [ 'a', 'b', 'c' ];

    	var geometry2;

    	if ( (geometry && geometry.isBufferGeometry) ) {

    		geometry2 = new Geometry();
    		geometry2.fromBufferGeometry( geometry );

    	} else {

    		geometry2 = geometry.clone();

    	}

    	geometry2.mergeVertices();
    	geometry2.computeFaceNormals();

    	var vertices = geometry2.vertices;
    	var faces = geometry2.faces;

    	for ( var i = 0, l = faces.length; i < l; i ++ ) {

    		var face = faces[ i ];

    		for ( var j = 0; j < 3; j ++ ) {

    			edge[ 0 ] = face[ keys[ j ] ];
    			edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
    			edge.sort( sortFunction );

    			var key = edge.toString();

    			if ( hash[ key ] === undefined ) {

    				hash[ key ] = { vert1: edge[ 0 ], vert2: edge[ 1 ], face1: i, face2: undefined };

    			} else {

    				hash[ key ].face2 = i;

    			}

    		}

    	}

    	var coords = [];

    	for ( var key in hash ) {

    		var h = hash[ key ];

    		if ( h.face2 === undefined || faces[ h.face1 ].normal.dot( faces[ h.face2 ].normal ) <= thresholdDot ) {

    			var vertex = vertices[ h.vert1 ];
    			coords.push( vertex.x );
    			coords.push( vertex.y );
    			coords.push( vertex.z );

    			vertex = vertices[ h.vert2 ];
    			coords.push( vertex.x );
    			coords.push( vertex.y );
    			coords.push( vertex.z );

    		}

    	}

    	this.addAttribute( 'position', new BufferAttribute( new Float32Array( coords ), 3 ) );

    }

    EdgesGeometry.prototype = Object.create( BufferGeometry.prototype );
    EdgesGeometry.prototype.constructor = EdgesGeometry;

    /**
     * @author Mugen87 / https://github.com/Mugen87
     */

    function CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

    	BufferGeometry.call( this );

    	this.type = 'CylinderBufferGeometry';

    	this.parameters = {
    		radiusTop: radiusTop,
    		radiusBottom: radiusBottom,
    		height: height,
    		radialSegments: radialSegments,
    		heightSegments: heightSegments,
    		openEnded: openEnded,
    		thetaStart: thetaStart,
    		thetaLength: thetaLength
    	};

    	var scope = this;

    	radiusTop = radiusTop !== undefined ? radiusTop : 20;
    	radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;
    	height = height !== undefined ? height : 100;

    	radialSegments = Math.floor( radialSegments ) || 8;
    	heightSegments = Math.floor( heightSegments ) || 1;

    	openEnded = openEnded !== undefined ? openEnded : false;
    	thetaStart = thetaStart !== undefined ? thetaStart : 0.0;
    	thetaLength = thetaLength !== undefined ? thetaLength : 2.0 * Math.PI;

    	// used to calculate buffer length

    	var nbCap = 0;

    	if ( openEnded === false ) {

    		if ( radiusTop > 0 ) nbCap ++;
    		if ( radiusBottom > 0 ) nbCap ++;

    	}

    	var vertexCount = calculateVertexCount();
    	var indexCount = calculateIndexCount();

    	// buffers

    	var indices = new BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ), 1 );
    	var vertices = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
    	var normals = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
    	var uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );

    	// helper variables

    	var index = 0,
    	    indexOffset = 0,
    	    indexArray = [],
    	    halfHeight = height / 2;

    	// group variables
    	var groupStart = 0;

    	// generate geometry

    	generateTorso();

    	if ( openEnded === false ) {

    		if ( radiusTop > 0 ) generateCap( true );
    		if ( radiusBottom > 0 ) generateCap( false );

    	}

    	// build geometry

    	this.setIndex( indices );
    	this.addAttribute( 'position', vertices );
    	this.addAttribute( 'normal', normals );
    	this.addAttribute( 'uv', uvs );

    	// helper functions

    	function calculateVertexCount() {

    		var count = ( radialSegments + 1 ) * ( heightSegments + 1 );

    		if ( openEnded === false ) {

    			count += ( ( radialSegments + 1 ) * nbCap ) + ( radialSegments * nbCap );

    		}

    		return count;

    	}

    	function calculateIndexCount() {

    		var count = radialSegments * heightSegments * 2 * 3;

    		if ( openEnded === false ) {

    			count += radialSegments * nbCap * 3;

    		}

    		return count;

    	}

    	function generateTorso() {

    		var x, y;
    		var normal = new Vector3();
    		var vertex = new Vector3();

    		var groupCount = 0;

    		// this will be used to calculate the normal
    		var slope = ( radiusBottom - radiusTop ) / height;

    		// generate vertices, normals and uvs

    		for ( y = 0; y <= heightSegments; y ++ ) {

    			var indexRow = [];

    			var v = y / heightSegments;

    			// calculate the radius of the current row
    			var radius = v * ( radiusBottom - radiusTop ) + radiusTop;

    			for ( x = 0; x <= radialSegments; x ++ ) {

    				var u = x / radialSegments;

    				var theta = u * thetaLength + thetaStart;

    				var sinTheta = Math.sin( theta );
    				var cosTheta = Math.cos( theta );

    				// vertex
    				vertex.x = radius * sinTheta;
    				vertex.y = - v * height + halfHeight;
    				vertex.z = radius * cosTheta;
    				vertices.setXYZ( index, vertex.x, vertex.y, vertex.z );

    				// normal
    				normal.set( sinTheta, slope, cosTheta ).normalize();
    				normals.setXYZ( index, normal.x, normal.y, normal.z );

    				// uv
    				uvs.setXY( index, u, 1 - v );

    				// save index of vertex in respective row
    				indexRow.push( index );

    				// increase index
    				index ++;

    			}

    			// now save vertices of the row in our index array
    			indexArray.push( indexRow );

    		}

    		// generate indices

    		for ( x = 0; x < radialSegments; x ++ ) {

    			for ( y = 0; y < heightSegments; y ++ ) {

    				// we use the index array to access the correct indices
    				var i1 = indexArray[ y ][ x ];
    				var i2 = indexArray[ y + 1 ][ x ];
    				var i3 = indexArray[ y + 1 ][ x + 1 ];
    				var i4 = indexArray[ y ][ x + 1 ];

    				// face one
    				indices.setX( indexOffset, i1 ); indexOffset ++;
    				indices.setX( indexOffset, i2 ); indexOffset ++;
    				indices.setX( indexOffset, i4 ); indexOffset ++;

    				// face two
    				indices.setX( indexOffset, i2 ); indexOffset ++;
    				indices.setX( indexOffset, i3 ); indexOffset ++;
    				indices.setX( indexOffset, i4 ); indexOffset ++;

    				// update counters
    				groupCount += 6;

    			}

    		}

    		// add a group to the geometry. this will ensure multi material support
    		scope.addGroup( groupStart, groupCount, 0 );

    		// calculate new start value for groups
    		groupStart += groupCount;

    	}

    	function generateCap( top ) {

    		var x, centerIndexStart, centerIndexEnd;

    		var uv = new Vector2();
    		var vertex = new Vector3();

    		var groupCount = 0;

    		var radius = ( top === true ) ? radiusTop : radiusBottom;
    		var sign = ( top === true ) ? 1 : - 1;

    		// save the index of the first center vertex
    		centerIndexStart = index;

    		// first we generate the center vertex data of the cap.
    		// because the geometry needs one set of uvs per face,
    		// we must generate a center vertex per face/segment

    		for ( x = 1; x <= radialSegments; x ++ ) {

    			// vertex
    			vertices.setXYZ( index, 0, halfHeight * sign, 0 );

    			// normal
    			normals.setXYZ( index, 0, sign, 0 );

    			// uv
    			uv.x = 0.5;
    			uv.y = 0.5;

    			uvs.setXY( index, uv.x, uv.y );

    			// increase index
    			index ++;

    		}

    		// save the index of the last center vertex
    		centerIndexEnd = index;

    		// now we generate the surrounding vertices, normals and uvs

    		for ( x = 0; x <= radialSegments; x ++ ) {

    			var u = x / radialSegments;
    			var theta = u * thetaLength + thetaStart;

    			var cosTheta = Math.cos( theta );
    			var sinTheta = Math.sin( theta );

    			// vertex
    			vertex.x = radius * sinTheta;
    			vertex.y = halfHeight * sign;
    			vertex.z = radius * cosTheta;
    			vertices.setXYZ( index, vertex.x, vertex.y, vertex.z );

    			// normal
    			normals.setXYZ( index, 0, sign, 0 );

    			// uv
    			uv.x = ( cosTheta * 0.5 ) + 0.5;
    			uv.y = ( sinTheta * 0.5 * sign ) + 0.5;
    			uvs.setXY( index, uv.x, uv.y );

    			// increase index
    			index ++;

    		}

    		// generate indices

    		for ( x = 0; x < radialSegments; x ++ ) {

    			var c = centerIndexStart + x;
    			var i = centerIndexEnd + x;

    			if ( top === true ) {

    				// face top
    				indices.setX( indexOffset, i ); indexOffset ++;
    				indices.setX( indexOffset, i + 1 ); indexOffset ++;
    				indices.setX( indexOffset, c ); indexOffset ++;

    			} else {

    				// face bottom
    				indices.setX( indexOffset, i + 1 ); indexOffset ++;
    				indices.setX( indexOffset, i ); indexOffset ++;
    				indices.setX( indexOffset, c ); indexOffset ++;

    			}

    			// update counters
    			groupCount += 3;

    		}

    		// add a group to the geometry. this will ensure multi material support
    		scope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );

    		// calculate new start value for groups
    		groupStart += groupCount;

    	}

    }

    CylinderBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
    CylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry;

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function CylinderGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

    	Geometry.call( this );

    	this.type = 'CylinderGeometry';

    	this.parameters = {
    		radiusTop: radiusTop,
    		radiusBottom: radiusBottom,
    		height: height,
    		radialSegments: radialSegments,
    		heightSegments: heightSegments,
    		openEnded: openEnded,
    		thetaStart: thetaStart,
    		thetaLength: thetaLength
    	};

    	this.fromBufferGeometry( new CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) );
    	this.mergeVertices();

    }

    CylinderGeometry.prototype = Object.create( Geometry.prototype );
    CylinderGeometry.prototype.constructor = CylinderGeometry;

    /**
     * @author abelnation / http://github.com/abelnation
     */

    function ConeGeometry(
    	radius, height,
    	radialSegments, heightSegments,
    	openEnded, thetaStart, thetaLength ) {

    	CylinderGeometry.call( this,
    		0, radius, height,
    		radialSegments, heightSegments,
    		openEnded, thetaStart, thetaLength );

    	this.type = 'ConeGeometry';

    	this.parameters = {
    		radius: radius,
    		height: height,
    		radialSegments: radialSegments,
    		heightSegments: heightSegments,
    		openEnded: openEnded,
    		thetaStart: thetaStart,
    		thetaLength: thetaLength
    	};

    }

    ConeGeometry.prototype = Object.create( CylinderGeometry.prototype );
    ConeGeometry.prototype.constructor = ConeGeometry;

    /*
     * @author: abelnation / http://github.com/abelnation
     */

    function ConeBufferGeometry(
    	radius, height,
    	radialSegments, heightSegments,
    	openEnded, thetaStart, thetaLength ) {

    	CylinderBufferGeometry.call( this,
    		0, radius, height,
    		radialSegments, heightSegments,
    		openEnded, thetaStart, thetaLength );

    	this.type = 'ConeBufferGeometry';

    	this.parameters = {
    		radius: radius,
    		height: height,
    		radialSegments: radialSegments,
    		heightSegments: heightSegments,
    		thetaStart: thetaStart,
    		thetaLength: thetaLength
    	};

    }

    ConeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
    ConeBufferGeometry.prototype.constructor = ConeBufferGeometry;

    /**
     * @author benaadams / https://twitter.com/ben_a_adams
     */

    function CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) {

    	BufferGeometry.call( this );

    	this.type = 'CircleBufferGeometry';

    	this.parameters = {
    		radius: radius,
    		segments: segments,
    		thetaStart: thetaStart,
    		thetaLength: thetaLength
    	};

    	radius = radius || 50;
    	segments = segments !== undefined ? Math.max( 3, segments ) : 8;

    	thetaStart = thetaStart !== undefined ? thetaStart : 0;
    	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

    	var vertices = segments + 2;

    	var positions = new Float32Array( vertices * 3 );
    	var normals = new Float32Array( vertices * 3 );
    	var uvs = new Float32Array( vertices * 2 );

    	// center data is already zero, but need to set a few extras
    	normals[ 2 ] = 1.0;
    	uvs[ 0 ] = 0.5;
    	uvs[ 1 ] = 0.5;

    	for ( var s = 0, i = 3, ii = 2 ; s <= segments; s ++, i += 3, ii += 2 ) {

    		var segment = thetaStart + s / segments * thetaLength;

    		positions[ i ] = radius * Math.cos( segment );
    		positions[ i + 1 ] = radius * Math.sin( segment );

    		normals[ i + 2 ] = 1; // normal z

    		uvs[ ii ] = ( positions[ i ] / radius + 1 ) / 2;
    		uvs[ ii + 1 ] = ( positions[ i + 1 ] / radius + 1 ) / 2;

    	}

    	var indices = [];

    	for ( var i = 1; i <= segments; i ++ ) {

    		indices.push( i, i + 1, 0 );

    	}

    	this.setIndex( new BufferAttribute( new Uint16Array( indices ), 1 ) );
    	this.addAttribute( 'position', new BufferAttribute( positions, 3 ) );
    	this.addAttribute( 'normal', new BufferAttribute( normals, 3 ) );
    	this.addAttribute( 'uv', new BufferAttribute( uvs, 2 ) );

    	this.boundingSphere = new Sphere( new Vector3(), radius );

    }

    CircleBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
    CircleBufferGeometry.prototype.constructor = CircleBufferGeometry;

    /**
     * @author hughes
     */

    function CircleGeometry( radius, segments, thetaStart, thetaLength ) {

    	Geometry.call( this );

    	this.type = 'CircleGeometry';

    	this.parameters = {
    		radius: radius,
    		segments: segments,
    		thetaStart: thetaStart,
    		thetaLength: thetaLength
    	};

    	this.fromBufferGeometry( new CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) );

    }

    CircleGeometry.prototype = Object.create( Geometry.prototype );
    CircleGeometry.prototype.constructor = CircleGeometry;

    /**
     * @author mrdoob / http://mrdoob.com/
     * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as
     */

    function BoxGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {

    	Geometry.call( this );

    	this.type = 'BoxGeometry';

    	this.parameters = {
    		width: width,
    		height: height,
    		depth: depth,
    		widthSegments: widthSegments,
    		heightSegments: heightSegments,
    		depthSegments: depthSegments
    	};

    	this.fromBufferGeometry( new BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) );
    	this.mergeVertices();

    }

    BoxGeometry.prototype = Object.create( Geometry.prototype );
    BoxGeometry.prototype.constructor = BoxGeometry;



    var Geometries = Object.freeze({
    	WireframeGeometry: WireframeGeometry,
    	ParametricGeometry: ParametricGeometry,
    	TetrahedronGeometry: TetrahedronGeometry,
    	OctahedronGeometry: OctahedronGeometry,
    	IcosahedronGeometry: IcosahedronGeometry,
    	DodecahedronGeometry: DodecahedronGeometry,
    	PolyhedronGeometry: PolyhedronGeometry,
    	TubeGeometry: TubeGeometry,
    	TorusKnotGeometry: TorusKnotGeometry,
    	TorusKnotBufferGeometry: TorusKnotBufferGeometry,
    	TorusGeometry: TorusGeometry,
    	TorusBufferGeometry: TorusBufferGeometry,
    	TextGeometry: TextGeometry,
    	SphereBufferGeometry: SphereBufferGeometry,
    	SphereGeometry: SphereGeometry,
    	RingGeometry: RingGeometry,
    	RingBufferGeometry: RingBufferGeometry,
    	PlaneBufferGeometry: PlaneBufferGeometry,
    	PlaneGeometry: PlaneGeometry,
    	LatheGeometry: LatheGeometry,
    	LatheBufferGeometry: LatheBufferGeometry,
    	ShapeGeometry: ShapeGeometry,
    	ExtrudeGeometry: ExtrudeGeometry,
    	EdgesGeometry: EdgesGeometry,
    	ConeGeometry: ConeGeometry,
    	ConeBufferGeometry: ConeBufferGeometry,
    	CylinderGeometry: CylinderGeometry,
    	CylinderBufferGeometry: CylinderBufferGeometry,
    	CircleBufferGeometry: CircleBufferGeometry,
    	CircleGeometry: CircleGeometry,
    	BoxBufferGeometry: BoxBufferGeometry,
    	BoxGeometry: BoxGeometry
    });

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function ShadowMaterial() {

    	ShaderMaterial.call( this, {
    		uniforms: exports.UniformsUtils.merge( [
    			UniformsLib[ "lights" ],
    			{
    				opacity: { value: 1.0 }
    			}
    		] ),
    		vertexShader: ShaderChunk[ 'shadow_vert' ],
    		fragmentShader: ShaderChunk[ 'shadow_frag' ]
    	} );

    	this.lights = true;
    	this.transparent = true;

    	Object.defineProperties( this, {
    		opacity: {
    			enumerable: true,
    			get: function () {
    				return this.uniforms.opacity.value;
    			},
    			set: function ( value ) {
    				this.uniforms.opacity.value = value;
    			}
    		}
    	} );

    }

    ShadowMaterial.prototype = Object.create( ShaderMaterial.prototype );
    ShadowMaterial.prototype.constructor = ShadowMaterial;

    ShadowMaterial.prototype.isShadowMaterial = true;

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function RawShaderMaterial( parameters ) {

    	ShaderMaterial.call( this, parameters );

    	this.type = 'RawShaderMaterial';

    }

    RawShaderMaterial.prototype = Object.create( ShaderMaterial.prototype );
    RawShaderMaterial.prototype.constructor = RawShaderMaterial;

    RawShaderMaterial.prototype.isRawShaderMaterial = true;

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function MultiMaterial( materials ) {

    	this.uuid = exports.Math.generateUUID();

    	this.type = 'MultiMaterial';

    	this.materials = materials instanceof Array ? materials : [];

    	this.visible = true;

    }

    MultiMaterial.prototype = {

    	constructor: MultiMaterial,

    	isMultiMaterial: true,

    	toJSON: function ( meta ) {

    		var output = {
    			metadata: {
    				version: 4.2,
    				type: 'material',
    				generator: 'MaterialExporter'
    			},
    			uuid: this.uuid,
    			type: this.type,
    			materials: []
    		};

    		var materials = this.materials;

    		for ( var i = 0, l = materials.length; i < l; i ++ ) {

    			var material = materials[ i ].toJSON( meta );
    			delete material.metadata;

    			output.materials.push( material );

    		}

    		output.visible = this.visible;

    		return output;

    	},

    	clone: function () {

    		var material = new this.constructor();

    		for ( var i = 0; i < this.materials.length; i ++ ) {

    			material.materials.push( this.materials[ i ].clone() );

    		}

    		material.visible = this.visible;

    		return material;

    	}

    };

    /**
     * @author WestLangley / http://github.com/WestLangley
     *
     * parameters = {
     *  color: <hex>,
     *  roughness: <float>,
     *  metalness: <float>,
     *  opacity: <float>,
     *
     *  map: new THREE.Texture( <Image> ),
     *
     *  lightMap: new THREE.Texture( <Image> ),
     *  lightMapIntensity: <float>
     *
     *  aoMap: new THREE.Texture( <Image> ),
     *  aoMapIntensity: <float>
     *
     *  emissive: <hex>,
     *  emissiveIntensity: <float>
     *  emissiveMap: new THREE.Texture( <Image> ),
     *
     *  bumpMap: new THREE.Texture( <Image> ),
     *  bumpScale: <float>,
     *
     *  normalMap: new THREE.Texture( <Image> ),
     *  normalScale: <Vector2>,
     *
     *  displacementMap: new THREE.Texture( <Image> ),
     *  displacementScale: <float>,
     *  displacementBias: <float>,
     *
     *  roughnessMap: new THREE.Texture( <Image> ),
     *
     *  metalnessMap: new THREE.Texture( <Image> ),
     *
     *  alphaMap: new THREE.Texture( <Image> ),
     *
     *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
     *  envMapIntensity: <float>
     *
     *  refractionRatio: <float>,
     *
     *  wireframe: <boolean>,
     *  wireframeLinewidth: <float>,
     *
     *  skinning: <bool>,
     *  morphTargets: <bool>,
     *  morphNormals: <bool>
     * }
     */

    function MeshStandardMaterial( parameters ) {

    	Material.call( this );

    	this.defines = { 'STANDARD': '' };

    	this.type = 'MeshStandardMaterial';

    	this.color = new Color( 0xffffff ); // diffuse
    	this.roughness = 0.5;
    	this.metalness = 0.5;

    	this.map = null;

    	this.lightMap = null;
    	this.lightMapIntensity = 1.0;

    	this.aoMap = null;
    	this.aoMapIntensity = 1.0;

    	this.emissive = new Color( 0x000000 );
    	this.emissiveIntensity = 1.0;
    	this.emissiveMap = null;

    	this.bumpMap = null;
    	this.bumpScale = 1;

    	this.normalMap = null;
    	this.normalScale = new Vector2( 1, 1 );

    	this.displacementMap = null;
    	this.displacementScale = 1;
    	this.displacementBias = 0;

    	this.roughnessMap = null;

    	this.metalnessMap = null;

    	this.alphaMap = null;

    	this.envMap = null;
    	this.envMapIntensity = 1.0;

    	this.refractionRatio = 0.98;

    	this.wireframe = false;
    	this.wireframeLinewidth = 1;
    	this.wireframeLinecap = 'round';
    	this.wireframeLinejoin = 'round';

    	this.skinning = false;
    	this.morphTargets = false;
    	this.morphNormals = false;

    	this.setValues( parameters );

    }

    MeshStandardMaterial.prototype = Object.create( Material.prototype );
    MeshStandardMaterial.prototype.constructor = MeshStandardMaterial;

    MeshStandardMaterial.prototype.isMeshStandardMaterial = true;

    MeshStandardMaterial.prototype.copy = function ( source ) {

    	Material.prototype.copy.call( this, source );

    	this.defines = { 'STANDARD': '' };

    	this.color.copy( source.color );
    	this.roughness = source.roughness;
    	this.metalness = source.metalness;

    	this.map = source.map;

    	this.lightMap = source.lightMap;
    	this.lightMapIntensity = source.lightMapIntensity;

    	this.aoMap = source.aoMap;
    	this.aoMapIntensity = source.aoMapIntensity;

    	this.emissive.copy( source.emissive );
    	this.emissiveMap = source.emissiveMap;
    	this.emissiveIntensity = source.emissiveIntensity;

    	this.bumpMap = source.bumpMap;
    	this.bumpScale = source.bumpScale;

    	this.normalMap = source.normalMap;
    	this.normalScale.copy( source.normalScale );

    	this.displacementMap = source.displacementMap;
    	this.displacementScale = source.displacementScale;
    	this.displacementBias = source.displacementBias;

    	this.roughnessMap = source.roughnessMap;

    	this.metalnessMap = source.metalnessMap;

    	this.alphaMap = source.alphaMap;

    	this.envMap = source.envMap;
    	this.envMapIntensity = source.envMapIntensity;

    	this.refractionRatio = source.refractionRatio;

    	this.wireframe = source.wireframe;
    	this.wireframeLinewidth = source.wireframeLinewidth;
    	this.wireframeLinecap = source.wireframeLinecap;
    	this.wireframeLinejoin = source.wireframeLinejoin;

    	this.skinning = source.skinning;
    	this.morphTargets = source.morphTargets;
    	this.morphNormals = source.morphNormals;

    	return this;

    };

    /**
     * @author WestLangley / http://github.com/WestLangley
     *
     * parameters = {
     *  reflectivity: <float>
     * }
     */

    function MeshPhysicalMaterial( parameters ) {

    	MeshStandardMaterial.call( this );

    	this.defines = { 'PHYSICAL': '' };

    	this.type = 'MeshPhysicalMaterial';

    	this.reflectivity = 0.5; // maps to F0 = 0.04

    	this.clearCoat = 0.0;
    	this.clearCoatRoughness = 0.0;

    	this.setValues( parameters );

    }

    MeshPhysicalMaterial.prototype = Object.create( MeshStandardMaterial.prototype );
    MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;

    MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;

    MeshPhysicalMaterial.prototype.copy = function ( source ) {

    	MeshStandardMaterial.prototype.copy.call( this, source );

    	this.defines = { 'PHYSICAL': '' };

    	this.reflectivity = source.reflectivity;

    	this.clearCoat = source.clearCoat;
    	this.clearCoatRoughness = source.clearCoatRoughness;

    	return this;

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     *
     * parameters = {
     *  color: <hex>,
     *  specular: <hex>,
     *  shininess: <float>,
     *  opacity: <float>,
     *
     *  map: new THREE.Texture( <Image> ),
     *
     *  lightMap: new THREE.Texture( <Image> ),
     *  lightMapIntensity: <float>
     *
     *  aoMap: new THREE.Texture( <Image> ),
     *  aoMapIntensity: <float>
     *
     *  emissive: <hex>,
     *  emissiveIntensity: <float>
     *  emissiveMap: new THREE.Texture( <Image> ),
     *
     *  bumpMap: new THREE.Texture( <Image> ),
     *  bumpScale: <float>,
     *
     *  normalMap: new THREE.Texture( <Image> ),
     *  normalScale: <Vector2>,
     *
     *  displacementMap: new THREE.Texture( <Image> ),
     *  displacementScale: <float>,
     *  displacementBias: <float>,
     *
     *  specularMap: new THREE.Texture( <Image> ),
     *
     *  alphaMap: new THREE.Texture( <Image> ),
     *
     *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
     *  combine: THREE.Multiply,
     *  reflectivity: <float>,
     *  refractionRatio: <float>,
     *
     *  wireframe: <boolean>,
     *  wireframeLinewidth: <float>,
     *
     *  skinning: <bool>,
     *  morphTargets: <bool>,
     *  morphNormals: <bool>
     * }
     */

    function MeshPhongMaterial( parameters ) {

    	Material.call( this );

    	this.type = 'MeshPhongMaterial';

    	this.color = new Color( 0xffffff ); // diffuse
    	this.specular = new Color( 0x111111 );
    	this.shininess = 30;

    	this.map = null;

    	this.lightMap = null;
    	this.lightMapIntensity = 1.0;

    	this.aoMap = null;
    	this.aoMapIntensity = 1.0;

    	this.emissive = new Color( 0x000000 );
    	this.emissiveIntensity = 1.0;
    	this.emissiveMap = null;

    	this.bumpMap = null;
    	this.bumpScale = 1;

    	this.normalMap = null;
    	this.normalScale = new Vector2( 1, 1 );

    	this.displacementMap = null;
    	this.displacementScale = 1;
    	this.displacementBias = 0;

    	this.specularMap = null;

    	this.alphaMap = null;

    	this.envMap = null;
    	this.combine = MultiplyOperation;
    	this.reflectivity = 1;
    	this.refractionRatio = 0.98;

    	this.wireframe = false;
    	this.wireframeLinewidth = 1;
    	this.wireframeLinecap = 'round';
    	this.wireframeLinejoin = 'round';

    	this.skinning = false;
    	this.morphTargets = false;
    	this.morphNormals = false;

    	this.setValues( parameters );

    }

    MeshPhongMaterial.prototype = Object.create( Material.prototype );
    MeshPhongMaterial.prototype.constructor = MeshPhongMaterial;

    MeshPhongMaterial.prototype.isMeshPhongMaterial = true;

    MeshPhongMaterial.prototype.copy = function ( source ) {

    	Material.prototype.copy.call( this, source );

    	this.color.copy( source.color );
    	this.specular.copy( source.specular );
    	this.shininess = source.shininess;

    	this.map = source.map;

    	this.lightMap = source.lightMap;
    	this.lightMapIntensity = source.lightMapIntensity;

    	this.aoMap = source.aoMap;
    	this.aoMapIntensity = source.aoMapIntensity;

    	this.emissive.copy( source.emissive );
    	this.emissiveMap = source.emissiveMap;
    	this.emissiveIntensity = source.emissiveIntensity;

    	this.bumpMap = source.bumpMap;
    	this.bumpScale = source.bumpScale;

    	this.normalMap = source.normalMap;
    	this.normalScale.copy( source.normalScale );

    	this.displacementMap = source.displacementMap;
    	this.displacementScale = source.displacementScale;
    	this.displacementBias = source.displacementBias;

    	this.specularMap = source.specularMap;

    	this.alphaMap = source.alphaMap;

    	this.envMap = source.envMap;
    	this.combine = source.combine;
    	this.reflectivity = source.reflectivity;
    	this.refractionRatio = source.refractionRatio;

    	this.wireframe = source.wireframe;
    	this.wireframeLinewidth = source.wireframeLinewidth;
    	this.wireframeLinecap = source.wireframeLinecap;
    	this.wireframeLinejoin = source.wireframeLinejoin;

    	this.skinning = source.skinning;
    	this.morphTargets = source.morphTargets;
    	this.morphNormals = source.morphNormals;

    	return this;

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     *
     * parameters = {
     *  opacity: <float>,
     *
     *  wireframe: <boolean>,
     *  wireframeLinewidth: <float>
     * }
     */

    function MeshNormalMaterial( parameters ) {

    	Material.call( this, parameters );

    	this.type = 'MeshNormalMaterial';

    	this.wireframe = false;
    	this.wireframeLinewidth = 1;

    	this.fog = false;
    	this.lights = false;
    	this.morphTargets = false;

    	this.setValues( parameters );

    }

    MeshNormalMaterial.prototype = Object.create( Material.prototype );
    MeshNormalMaterial.prototype.constructor = MeshNormalMaterial;

    MeshNormalMaterial.prototype.isMeshNormalMaterial = true;

    MeshNormalMaterial.prototype.copy = function ( source ) {

    	Material.prototype.copy.call( this, source );

    	this.wireframe = source.wireframe;
    	this.wireframeLinewidth = source.wireframeLinewidth;

    	return this;

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     *
     * parameters = {
     *  color: <hex>,
     *  opacity: <float>,
     *
     *  map: new THREE.Texture( <Image> ),
     *
     *  lightMap: new THREE.Texture( <Image> ),
     *  lightMapIntensity: <float>
     *
     *  aoMap: new THREE.Texture( <Image> ),
     *  aoMapIntensity: <float>
     *
     *  emissive: <hex>,
     *  emissiveIntensity: <float>
     *  emissiveMap: new THREE.Texture( <Image> ),
     *
     *  specularMap: new THREE.Texture( <Image> ),
     *
     *  alphaMap: new THREE.Texture( <Image> ),
     *
     *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
     *  combine: THREE.Multiply,
     *  reflectivity: <float>,
     *  refractionRatio: <float>,
     *
     *  wireframe: <boolean>,
     *  wireframeLinewidth: <float>,
     *
     *  skinning: <bool>,
     *  morphTargets: <bool>,
     *  morphNormals: <bool>
     * }
     */

    function MeshLambertMaterial( parameters ) {

    	Material.call( this );

    	this.type = 'MeshLambertMaterial';

    	this.color = new Color( 0xffffff ); // diffuse

    	this.map = null;

    	this.lightMap = null;
    	this.lightMapIntensity = 1.0;

    	this.aoMap = null;
    	this.aoMapIntensity = 1.0;

    	this.emissive = new Color( 0x000000 );
    	this.emissiveIntensity = 1.0;
    	this.emissiveMap = null;

    	this.specularMap = null;

    	this.alphaMap = null;

    	this.envMap = null;
    	this.combine = MultiplyOperation;
    	this.reflectivity = 1;
    	this.refractionRatio = 0.98;

    	this.wireframe = false;
    	this.wireframeLinewidth = 1;
    	this.wireframeLinecap = 'round';
    	this.wireframeLinejoin = 'round';

    	this.skinning = false;
    	this.morphTargets = false;
    	this.morphNormals = false;

    	this.setValues( parameters );

    }

    MeshLambertMaterial.prototype = Object.create( Material.prototype );
    MeshLambertMaterial.prototype.constructor = MeshLambertMaterial;

    MeshLambertMaterial.prototype.isMeshLambertMaterial = true;

    MeshLambertMaterial.prototype.copy = function ( source ) {

    	Material.prototype.copy.call( this, source );

    	this.color.copy( source.color );

    	this.map = source.map;

    	this.lightMap = source.lightMap;
    	this.lightMapIntensity = source.lightMapIntensity;

    	this.aoMap = source.aoMap;
    	this.aoMapIntensity = source.aoMapIntensity;

    	this.emissive.copy( source.emissive );
    	this.emissiveMap = source.emissiveMap;
    	this.emissiveIntensity = source.emissiveIntensity;

    	this.specularMap = source.specularMap;

    	this.alphaMap = source.alphaMap;

    	this.envMap = source.envMap;
    	this.combine = source.combine;
    	this.reflectivity = source.reflectivity;
    	this.refractionRatio = source.refractionRatio;

    	this.wireframe = source.wireframe;
    	this.wireframeLinewidth = source.wireframeLinewidth;
    	this.wireframeLinecap = source.wireframeLinecap;
    	this.wireframeLinejoin = source.wireframeLinejoin;

    	this.skinning = source.skinning;
    	this.morphTargets = source.morphTargets;
    	this.morphNormals = source.morphNormals;

    	return this;

    };

    /**
     * @author alteredq / http://alteredqualia.com/
     *
     * parameters = {
     *  color: <hex>,
     *  opacity: <float>,
     *
     *  linewidth: <float>,
     *
     *  scale: <float>,
     *  dashSize: <float>,
     *  gapSize: <float>
     * }
     */

    function LineDashedMaterial( parameters ) {

    	Material.call( this );

    	this.type = 'LineDashedMaterial';

    	this.color = new Color( 0xffffff );

    	this.linewidth = 1;

    	this.scale = 1;
    	this.dashSize = 3;
    	this.gapSize = 1;

    	this.lights = false;

    	this.setValues( parameters );

    }

    LineDashedMaterial.prototype = Object.create( Material.prototype );
    LineDashedMaterial.prototype.constructor = LineDashedMaterial;

    LineDashedMaterial.prototype.isLineDashedMaterial = true;

    LineDashedMaterial.prototype.copy = function ( source ) {

    	Material.prototype.copy.call( this, source );

    	this.color.copy( source.color );

    	this.linewidth = source.linewidth;

    	this.scale = source.scale;
    	this.dashSize = source.dashSize;
    	this.gapSize = source.gapSize;

    	return this;

    };



    var Materials = Object.freeze({
    	ShadowMaterial: ShadowMaterial,
    	SpriteMaterial: SpriteMaterial,
    	RawShaderMaterial: RawShaderMaterial,
    	ShaderMaterial: ShaderMaterial,
    	PointsMaterial: PointsMaterial,
    	MultiMaterial: MultiMaterial,
    	MeshPhysicalMaterial: MeshPhysicalMaterial,
    	MeshStandardMaterial: MeshStandardMaterial,
    	MeshPhongMaterial: MeshPhongMaterial,
    	MeshNormalMaterial: MeshNormalMaterial,
    	MeshLambertMaterial: MeshLambertMaterial,
    	MeshDepthMaterial: MeshDepthMaterial,
    	MeshBasicMaterial: MeshBasicMaterial,
    	LineDashedMaterial: LineDashedMaterial,
    	LineBasicMaterial: LineBasicMaterial,
    	Material: Material
    });

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    exports.Cache = {

    	enabled: false,

    	files: {},

    	add: function ( key, file ) {

    		if ( this.enabled === false ) return;

    		// console.log( 'THREE.Cache', 'Adding key:', key );

    		this.files[ key ] = file;

    	},

    	get: function ( key ) {

    		if ( this.enabled === false ) return;

    		// console.log( 'THREE.Cache', 'Checking key:', key );

    		return this.files[ key ];

    	},

    	remove: function ( key ) {

    		delete this.files[ key ];

    	},

    	clear: function () {

    		this.files = {};

    	}

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function LoadingManager( onLoad, onProgress, onError ) {

    	var scope = this;

    	var isLoading = false, itemsLoaded = 0, itemsTotal = 0;

    	this.onStart = undefined;
    	this.onLoad = onLoad;
    	this.onProgress = onProgress;
    	this.onError = onError;

    	this.itemStart = function ( url ) {

    		itemsTotal ++;

    		if ( isLoading === false ) {

    			if ( scope.onStart !== undefined ) {

    				scope.onStart( url, itemsLoaded, itemsTotal );

    			}

    		}

    		isLoading = true;

    	};

    	this.itemEnd = function ( url ) {

    		itemsLoaded ++;

    		if ( scope.onProgress !== undefined ) {

    			scope.onProgress( url, itemsLoaded, itemsTotal );

    		}

    		if ( itemsLoaded === itemsTotal ) {

    			isLoading = false;

    			if ( scope.onLoad !== undefined ) {

    				scope.onLoad();

    			}

    		}

    	};

    	this.itemError = function ( url ) {

    		if ( scope.onError !== undefined ) {

    			scope.onError( url );

    		}

    	};

    }

    exports.DefaultLoadingManager = new LoadingManager();

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function XHRLoader( manager ) {

    	this.manager = ( manager !== undefined ) ? manager : exports.DefaultLoadingManager;

    }

    Object.assign( XHRLoader.prototype, {

    	load: function ( url, onLoad, onProgress, onError ) {

    		if ( this.path !== undefined ) url = this.path + url;

    		var scope = this;

    		var cached = exports.Cache.get( url );

    		if ( cached !== undefined ) {

    			scope.manager.itemStart( url );

    			setTimeout( function () {

    				if ( onLoad ) onLoad( cached );

    				scope.manager.itemEnd( url );

    			}, 0 );

    			return cached;

    		}

    		var request = new XMLHttpRequest();
    		request.open( 'GET', url, true );

    		request.addEventListener( 'load', function ( event ) {

    			var response = event.target.response;

    			exports.Cache.add( url, response );

    			if ( this.status === 200 ) {

    				if ( onLoad ) onLoad( response );

    				scope.manager.itemEnd( url );

    			} else if ( this.status === 0 ) {

    				// Some browsers return HTTP Status 0 when using non-http protocol
    				// e.g. 'file://' or 'data://'. Handle as success.

    				console.warn( 'THREE.XHRLoader: HTTP Status 0 received.' );

    				if ( onLoad ) onLoad( response );

    				scope.manager.itemEnd( url );

    			} else {

    				if ( onError ) onError( event );

    				scope.manager.itemError( url );

    			}

    		}, false );

    		if ( onProgress !== undefined ) {

    			request.addEventListener( 'progress', function ( event ) {

    				onProgress( event );

    			}, false );

    		}

    		request.addEventListener( 'error', function ( event ) {

    			if ( onError ) onError( event );

    			scope.manager.itemError( url );

    		}, false );

    		if ( this.responseType !== undefined ) request.responseType = this.responseType;
    		if ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;

    		if ( request.overrideMimeType ) request.overrideMimeType( 'text/plain' );

    		request.send( null );

    		scope.manager.itemStart( url );

    		return request;

    	},

    	setPath: function ( value ) {

    		this.path = value;
    		return this;

    	},

    	setResponseType: function ( value ) {

    		this.responseType = value;
    		return this;

    	},

    	setWithCredentials: function ( value ) {

    		this.withCredentials = value;
    		return this;

    	}

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     *
     * Abstract Base class to block based textures loader (dds, pvr, ...)
     */

    function CompressedTextureLoader( manager ) {

    	this.manager = ( manager !== undefined ) ? manager : exports.DefaultLoadingManager;

    	// override in sub classes
    	this._parser = null;

    }

    Object.assign( CompressedTextureLoader.prototype, {

    	load: function ( url, onLoad, onProgress, onError ) {

    		var scope = this;

    		var images = [];

    		var texture = new CompressedTexture();
    		texture.image = images;

    		var loader = new XHRLoader( this.manager );
    		loader.setPath( this.path );
    		loader.setResponseType( 'arraybuffer' );

    		function loadTexture( i ) {

    			loader.load( url[ i ], function ( buffer ) {

    				var texDatas = scope._parser( buffer, true );

    				images[ i ] = {
    					width: texDatas.width,
    					height: texDatas.height,
    					format: texDatas.format,
    					mipmaps: texDatas.mipmaps
    				};

    				loaded += 1;

    				if ( loaded === 6 ) {

    					if ( texDatas.mipmapCount === 1 )
    						texture.minFilter = LinearFilter;

    					texture.format = texDatas.format;
    					texture.needsUpdate = true;

    					if ( onLoad ) onLoad( texture );

    				}

    			}, onProgress, onError );

    		}

    		if ( Array.isArray( url ) ) {

    			var loaded = 0;

    			for ( var i = 0, il = url.length; i < il; ++ i ) {

    				loadTexture( i );

    			}

    		} else {

    			// compressed cubemap texture stored in a single DDS file

    			loader.load( url, function ( buffer ) {

    				var texDatas = scope._parser( buffer, true );

    				if ( texDatas.isCubemap ) {

    					var faces = texDatas.mipmaps.length / texDatas.mipmapCount;

    					for ( var f = 0; f < faces; f ++ ) {

    						images[ f ] = { mipmaps : [] };

    						for ( var i = 0; i < texDatas.mipmapCount; i ++ ) {

    							images[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );
    							images[ f ].format = texDatas.format;
    							images[ f ].width = texDatas.width;
    							images[ f ].height = texDatas.height;

    						}

    					}

    				} else {

    					texture.image.width = texDatas.width;
    					texture.image.height = texDatas.height;
    					texture.mipmaps = texDatas.mipmaps;

    				}

    				if ( texDatas.mipmapCount === 1 ) {

    					texture.minFilter = LinearFilter;

    				}

    				texture.format = texDatas.format;
    				texture.needsUpdate = true;

    				if ( onLoad ) onLoad( texture );

    			}, onProgress, onError );

    		}

    		return texture;

    	},

    	setPath: function ( value ) {

    		this.path = value;
    		return this;

    	}

    } );

    /**
     * @author Nikos M. / https://github.com/foo123/
     *
     * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
     */

    var DataTextureLoader = BinaryTextureLoader;
    function BinaryTextureLoader( manager ) {

    	this.manager = ( manager !== undefined ) ? manager : exports.DefaultLoadingManager;

    	// override in sub classes
    	this._parser = null;

    }

    Object.assign( BinaryTextureLoader.prototype, {

    	load: function ( url, onLoad, onProgress, onError ) {

    		var scope = this;

    		var texture = new DataTexture();

    		var loader = new XHRLoader( this.manager );
    		loader.setResponseType( 'arraybuffer' );

    		loader.load( url, function ( buffer ) {

    			var texData = scope._parser( buffer );

    			if ( ! texData ) return;

    			if ( undefined !== texData.image ) {

    				texture.image = texData.image;

    			} else if ( undefined !== texData.data ) {

    				texture.image.width = texData.width;
    				texture.image.height = texData.height;
    				texture.image.data = texData.data;

    			}

    			texture.wrapS = undefined !== texData.wrapS ? texData.wrapS : ClampToEdgeWrapping;
    			texture.wrapT = undefined !== texData.wrapT ? texData.wrapT : ClampToEdgeWrapping;

    			texture.magFilter = undefined !== texData.magFilter ? texData.magFilter : LinearFilter;
    			texture.minFilter = undefined !== texData.minFilter ? texData.minFilter : LinearMipMapLinearFilter;

    			texture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;

    			if ( undefined !== texData.format ) {

    				texture.format = texData.format;

    			}
    			if ( undefined !== texData.type ) {

    				texture.type = texData.type;

    			}

    			if ( undefined !== texData.mipmaps ) {

    				texture.mipmaps = texData.mipmaps;

    			}

    			if ( 1 === texData.mipmapCount ) {

    				texture.minFilter = LinearFilter;

    			}

    			texture.needsUpdate = true;

    			if ( onLoad ) onLoad( texture, texData );

    		}, onProgress, onError );


    		return texture;

    	}

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function ImageLoader( manager ) {

    	this.manager = ( manager !== undefined ) ? manager : exports.DefaultLoadingManager;

    }

    Object.assign( ImageLoader.prototype, {

    	load: function ( url, onLoad, onProgress, onError ) {

    		var scope = this;

    		var image = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'img' );
    		image.onload = function () {

    			image.onload = null;

    			URL.revokeObjectURL( image.src );

    			if ( onLoad ) onLoad( image );

    			scope.manager.itemEnd( url );

    		};

    		if ( url.indexOf( 'data:' ) === 0 ) {

    			image.src = url;

    		} else {

    			var loader = new XHRLoader();
    			loader.setPath( this.path );
    			loader.setResponseType( 'blob' );
    			loader.setWithCredentials( this.withCredentials );
    			loader.load( url, function ( blob ) {

    				image.src = URL.createObjectURL( blob );

    			}, onProgress, onError );

    		}

    		scope.manager.itemStart( url );

    		return image;

    	},

    	setCrossOrigin: function ( value ) {

    		this.crossOrigin = value;
    		return this;

    	},

    	setWithCredentials: function ( value ) {

    		this.withCredentials = value;
    		return this;

    	},

    	setPath: function ( value ) {

    		this.path = value;
    		return this;

    	}

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function CubeTextureLoader( manager ) {

    	this.manager = ( manager !== undefined ) ? manager : exports.DefaultLoadingManager;

    }

    Object.assign( CubeTextureLoader.prototype, {

    	load: function ( urls, onLoad, onProgress, onError ) {

    		var texture = new CubeTexture();

    		var loader = new ImageLoader( this.manager );
    		loader.setCrossOrigin( this.crossOrigin );
    		loader.setPath( this.path );

    		var loaded = 0;

    		function loadTexture( i ) {

    			loader.load( urls[ i ], function ( image ) {

    				texture.images[ i ] = image;

    				loaded ++;

    				if ( loaded === 6 ) {

    					texture.needsUpdate = true;

    					if ( onLoad ) onLoad( texture );

    				}

    			}, undefined, onError );

    		}

    		for ( var i = 0; i < urls.length; ++ i ) {

    			loadTexture( i );

    		}

    		return texture;

    	},

    	setCrossOrigin: function ( value ) {

    		this.crossOrigin = value;
    		return this;

    	},

    	setPath: function ( value ) {

    		this.path = value;
    		return this;

    	}

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function TextureLoader( manager ) {

    	this.manager = ( manager !== undefined ) ? manager : exports.DefaultLoadingManager;

    }

    Object.assign( TextureLoader.prototype, {

    	load: function ( url, onLoad, onProgress, onError ) {

    		var texture = new Texture();

    		var loader = new ImageLoader( this.manager );
    		loader.setCrossOrigin( this.crossOrigin );
    		loader.setWithCredentials( this.withCredentials );
    		loader.setPath( this.path );
    		loader.load( url, function ( image ) {

    			// JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.
    			var isJPEG = url.search( /\.(jpg|jpeg)$/ ) > 0 || url.search( /^data\:image\/jpeg/ ) === 0;

    			texture.format = isJPEG ? RGBFormat : RGBAFormat;
    			texture.image = image;
    			texture.needsUpdate = true;

    			if ( onLoad !== undefined ) {

    				onLoad( texture );

    			}

    		}, onProgress, onError );

    		return texture;

    	},

    	setCrossOrigin: function ( value ) {

    		this.crossOrigin = value;
    		return this;

    	},

    	setWithCredentials: function ( value ) {

    		this.withCredentials = value;
    		return this;

    	},

    	setPath: function ( value ) {

    		this.path = value;
    		return this;

    	}



    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     */

    function Light( color, intensity ) {

    	Object3D.call( this );

    	this.type = 'Light';

    	this.color = new Color( color );
    	this.intensity = intensity !== undefined ? intensity : 1;

    	this.receiveShadow = undefined;

    }

    Light.prototype = Object.assign( Object.create( Object3D.prototype ), {

    	constructor: Light,

    	isLight: true,

    	copy: function ( source ) {

    		Object3D.prototype.copy.call( this, source );

    		this.color.copy( source.color );
    		this.intensity = source.intensity;

    		return this;

    	},

    	toJSON: function ( meta ) {

    		var data = Object3D.prototype.toJSON.call( this, meta );

    		data.object.color = this.color.getHex();
    		data.object.intensity = this.intensity;

    		if ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();

    		if ( this.distance !== undefined ) data.object.distance = this.distance;
    		if ( this.angle !== undefined ) data.object.angle = this.angle;
    		if ( this.decay !== undefined ) data.object.decay = this.decay;
    		if ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;

    		if ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();

    		return data;

    	}

    } );

    /**
     * @author alteredq / http://alteredqualia.com/
     */

    function HemisphereLight( skyColor, groundColor, intensity ) {

    	Light.call( this, skyColor, intensity );

    	this.type = 'HemisphereLight';

    	this.castShadow = undefined;

    	this.position.copy( Object3D.DefaultUp );
    	this.updateMatrix();

    	this.groundColor = new Color( groundColor );

    }

    HemisphereLight.prototype = Object.assign( Object.create( Light.prototype ), {

    	constructor: HemisphereLight,

    	isHemisphereLight: true,

    	copy: function ( source ) {

    		Light.prototype.copy.call( this, source );

    		this.groundColor.copy( source.groundColor );

    		return this;

    	}

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function LightShadow( camera ) {

    	this.camera = camera;

    	this.bias = 0;
    	this.radius = 1;

    	this.mapSize = new Vector2( 512, 512 );

    	this.map = null;
    	this.matrix = new Matrix4();

    }

    Object.assign( LightShadow.prototype, {

    	copy: function ( source ) {

    		this.camera = source.camera.clone();

    		this.bias = source.bias;
    		this.radius = source.radius;

    		this.mapSize.copy( source.mapSize );

    		return this;

    	},

    	clone: function () {

    		return new this.constructor().copy( this );

    	},

    	toJSON: function () {

    		var object = {};

    		if ( this.bias !== 0 ) object.bias = this.bias;
    		if ( this.radius !== 1 ) object.radius = this.radius;
    		if ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();

    		object.camera = this.camera.toJSON( false ).object;
    		delete object.camera.matrix;

    		return object;

    	}

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function SpotLightShadow() {

    	LightShadow.call( this, new PerspectiveCamera( 50, 1, 0.5, 500 ) );

    }

    SpotLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {

    	constructor: SpotLightShadow,

    	isSpotLightShadow: true,

    	update: function ( light ) {

    		var fov = exports.Math.RAD2DEG * 2 * light.angle;
    		var aspect = this.mapSize.width / this.mapSize.height;
    		var far = light.distance || 500;

    		var camera = this.camera;

    		if ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {

    			camera.fov = fov;
    			camera.aspect = aspect;
    			camera.far = far;
    			camera.updateProjectionMatrix();

    		}

    	}

    } );

    /**
     * @author alteredq / http://alteredqualia.com/
     */

    function SpotLight( color, intensity, distance, angle, penumbra, decay ) {

    	Light.call( this, color, intensity );

    	this.type = 'SpotLight';

    	this.position.copy( Object3D.DefaultUp );
    	this.updateMatrix();

    	this.target = new Object3D();

    	Object.defineProperty( this, 'power', {
    		get: function () {
    			// intensity = power per solid angle.
    			// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
    			return this.intensity * Math.PI;
    		},
    		set: function ( power ) {
    			// intensity = power per solid angle.
    			// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
    			this.intensity = power / Math.PI;
    		}
    	} );

    	this.distance = ( distance !== undefined ) ? distance : 0;
    	this.angle = ( angle !== undefined ) ? angle : Math.PI / 3;
    	this.penumbra = ( penumbra !== undefined ) ? penumbra : 0;
    	this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.

    	this.shadow = new SpotLightShadow();

    }

    SpotLight.prototype = Object.assign( Object.create( Light.prototype ), {

    	constructor: SpotLight,

    	isSpotLight: true,

    	copy: function ( source ) {

    		Light.prototype.copy.call( this, source );

    		this.distance = source.distance;
    		this.angle = source.angle;
    		this.penumbra = source.penumbra;
    		this.decay = source.decay;

    		this.target = source.target.clone();

    		this.shadow = source.shadow.clone();

    		return this;

    	}

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     */


    function PointLight( color, intensity, distance, decay ) {

    	Light.call( this, color, intensity );

    	this.type = 'PointLight';

    	Object.defineProperty( this, 'power', {
    		get: function () {
    			// intensity = power per solid angle.
    			// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
    			return this.intensity * 4 * Math.PI;

    		},
    		set: function ( power ) {
    			// intensity = power per solid angle.
    			// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
    			this.intensity = power / ( 4 * Math.PI );
    		}
    	} );

    	this.distance = ( distance !== undefined ) ? distance : 0;
    	this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.

    	this.shadow = new LightShadow( new PerspectiveCamera( 90, 1, 0.5, 500 ) );

    }

    PointLight.prototype = Object.assign( Object.create( Light.prototype ), {

    	constructor: PointLight,

    	isPointLight: true,

    	copy: function ( source ) {

    		Light.prototype.copy.call( this, source );

    		this.distance = source.distance;
    		this.decay = source.decay;

    		this.shadow = source.shadow.clone();

    		return this;

    	}

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function DirectionalLightShadow( light ) {

    	LightShadow.call( this, new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );

    }

    DirectionalLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {

    	constructor: DirectionalLightShadow

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     */

    function DirectionalLight( color, intensity ) {

    	Light.call( this, color, intensity );

    	this.type = 'DirectionalLight';

    	this.position.copy( Object3D.DefaultUp );
    	this.updateMatrix();

    	this.target = new Object3D();

    	this.shadow = new DirectionalLightShadow();

    }

    DirectionalLight.prototype = Object.assign( Object.create( Light.prototype ), {

    	constructor: DirectionalLight,

    	isDirectionalLight: true,

    	copy: function ( source ) {

    		Light.prototype.copy.call( this, source );

    		this.target = source.target.clone();

    		this.shadow = source.shadow.clone();

    		return this;

    	}

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function AmbientLight( color, intensity ) {

    	Light.call( this, color, intensity );

    	this.type = 'AmbientLight';

    	this.castShadow = undefined;

    }

    AmbientLight.prototype = Object.assign( Object.create( Light.prototype ), {

    	constructor: AmbientLight,

    	isAmbientLight: true,

    } );

    /**
     * @author tschw
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     */

    exports.AnimationUtils = {

    	// same as Array.prototype.slice, but also works on typed arrays
    	arraySlice: function( array, from, to ) {

    		if ( exports.AnimationUtils.isTypedArray( array ) ) {

    			return new array.constructor( array.subarray( from, to ) );

    		}

    		return array.slice( from, to );

    	},

    	// converts an array to a specific type
    	convertArray: function( array, type, forceClone ) {

    		if ( ! array || // let 'undefined' and 'null' pass
    				! forceClone && array.constructor === type ) return array;

    		if ( typeof type.BYTES_PER_ELEMENT === 'number' ) {

    			return new type( array ); // create typed array

    		}

    		return Array.prototype.slice.call( array ); // create Array

    	},

    	isTypedArray: function( object ) {

    		return ArrayBuffer.isView( object ) &&
    				! ( object instanceof DataView );

    	},

    	// returns an array by which times and values can be sorted
    	getKeyframeOrder: function( times ) {

    		function compareTime( i, j ) {

    			return times[ i ] - times[ j ];

    		}

    		var n = times.length;
    		var result = new Array( n );
    		for ( var i = 0; i !== n; ++ i ) result[ i ] = i;

    		result.sort( compareTime );

    		return result;

    	},

    	// uses the array previously returned by 'getKeyframeOrder' to sort data
    	sortedArray: function( values, stride, order ) {

    		var nValues = values.length;
    		var result = new values.constructor( nValues );

    		for ( var i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {

    			var srcOffset = order[ i ] * stride;

    			for ( var j = 0; j !== stride; ++ j ) {

    				result[ dstOffset ++ ] = values[ srcOffset + j ];

    			}

    		}

    		return result;

    	},

    	// function for parsing AOS keyframe formats
    	flattenJSON: function( jsonKeys, times, values, valuePropertyName ) {

    		var i = 1, key = jsonKeys[ 0 ];

    		while ( key !== undefined && key[ valuePropertyName ] === undefined ) {

    			key = jsonKeys[ i ++ ];

    		}

    		if ( key === undefined ) return; // no data

    		var value = key[ valuePropertyName ];
    		if ( value === undefined ) return; // no data

    		if ( Array.isArray( value ) ) {

    			do {

    				value = key[ valuePropertyName ];

    				if ( value !== undefined ) {

    					times.push( key.time );
    					values.push.apply( values, value ); // push all elements

    				}

    				key = jsonKeys[ i ++ ];

    			} while ( key !== undefined );

    		} else if ( value.toArray !== undefined ) {
    			// ...assume THREE.Math-ish

    			do {

    				value = key[ valuePropertyName ];

    				if ( value !== undefined ) {

    					times.push( key.time );
    					value.toArray( values, values.length );

    				}

    				key = jsonKeys[ i ++ ];

    			} while ( key !== undefined );

    		} else {
    			// otherwise push as-is

    			do {

    				value = key[ valuePropertyName ];

    				if ( value !== undefined ) {

    					times.push( key.time );
    					values.push( value );

    				}

    				key = jsonKeys[ i ++ ];

    			} while ( key !== undefined );

    		}

    	}

    };

    /**
     * Abstract base class of interpolants over parametric samples.
     *
     * The parameter domain is one dimensional, typically the time or a path
     * along a curve defined by the data.
     *
     * The sample values can have any dimensionality and derived classes may
     * apply special interpretations to the data.
     *
     * This class provides the interval seek in a Template Method, deferring
     * the actual interpolation to derived classes.
     *
     * Time complexity is O(1) for linear access crossing at most two points
     * and O(log N) for random access, where N is the number of positions.
     *
     * References:
     *
     * 		http://www.oodesign.com/template-method-pattern.html
     *
     * @author tschw
     */

    function Interpolant(
    		parameterPositions, sampleValues, sampleSize, resultBuffer ) {

    	this.parameterPositions = parameterPositions;
    	this._cachedIndex = 0;

    	this.resultBuffer = resultBuffer !== undefined ?
    			resultBuffer : new sampleValues.constructor( sampleSize );
    	this.sampleValues = sampleValues;
    	this.valueSize = sampleSize;

    }

    Interpolant.prototype = {

    	constructor: Interpolant,

    	evaluate: function( t ) {

    		var pp = this.parameterPositions,
    			i1 = this._cachedIndex,

    			t1 = pp[   i1   ],
    			t0 = pp[ i1 - 1 ];

    		validate_interval: {

    			seek: {

    				var right;

    				linear_scan: {
    //- See http://jsperf.com/comparison-to-undefined/3
    //- slower code:
    //-
    //- 				if ( t >= t1 || t1 === undefined ) {
    					forward_scan: if ( ! ( t < t1 ) ) {

    						for ( var giveUpAt = i1 + 2; ;) {

    							if ( t1 === undefined ) {

    								if ( t < t0 ) break forward_scan;

    								// after end

    								i1 = pp.length;
    								this._cachedIndex = i1;
    								return this.afterEnd_( i1 - 1, t, t0 );

    							}

    							if ( i1 === giveUpAt ) break; // this loop

    							t0 = t1;
    							t1 = pp[ ++ i1 ];

    							if ( t < t1 ) {

    								// we have arrived at the sought interval
    								break seek;

    							}

    						}

    						// prepare binary search on the right side of the index
    						right = pp.length;
    						break linear_scan;

    					}

    //- slower code:
    //-					if ( t < t0 || t0 === undefined ) {
    					if ( ! ( t >= t0 ) ) {

    						// looping?

    						var t1global = pp[ 1 ];

    						if ( t < t1global ) {

    							i1 = 2; // + 1, using the scan for the details
    							t0 = t1global;

    						}

    						// linear reverse scan

    						for ( var giveUpAt = i1 - 2; ;) {

    							if ( t0 === undefined ) {

    								// before start

    								this._cachedIndex = 0;
    								return this.beforeStart_( 0, t, t1 );

    							}

    							if ( i1 === giveUpAt ) break; // this loop

    							t1 = t0;
    							t0 = pp[ -- i1 - 1 ];

    							if ( t >= t0 ) {

    								// we have arrived at the sought interval
    								break seek;

    							}

    						}

    						// prepare binary search on the left side of the index
    						right = i1;
    						i1 = 0;
    						break linear_scan;

    					}

    					// the interval is valid

    					break validate_interval;

    				} // linear scan

    				// binary search

    				while ( i1 < right ) {

    					var mid = ( i1 + right ) >>> 1;

    					if ( t < pp[ mid ] ) {

    						right = mid;

    					} else {

    						i1 = mid + 1;

    					}

    				}

    				t1 = pp[   i1   ];
    				t0 = pp[ i1 - 1 ];

    				// check boundary cases, again

    				if ( t0 === undefined ) {

    					this._cachedIndex = 0;
    					return this.beforeStart_( 0, t, t1 );

    				}

    				if ( t1 === undefined ) {

    					i1 = pp.length;
    					this._cachedIndex = i1;
    					return this.afterEnd_( i1 - 1, t0, t );

    				}

    			} // seek

    			this._cachedIndex = i1;

    			this.intervalChanged_( i1, t0, t1 );

    		} // validate_interval

    		return this.interpolate_( i1, t0, t, t1 );

    	},

    	settings: null, // optional, subclass-specific settings structure
    	// Note: The indirection allows central control of many interpolants.

    	// --- Protected interface

    	DefaultSettings_: {},

    	getSettings_: function() {

    		return this.settings || this.DefaultSettings_;

    	},

    	copySampleValue_: function( index ) {

    		// copies a sample value to the result buffer

    		var result = this.resultBuffer,
    			values = this.sampleValues,
    			stride = this.valueSize,
    			offset = index * stride;

    		for ( var i = 0; i !== stride; ++ i ) {

    			result[ i ] = values[ offset + i ];

    		}

    		return result;

    	},

    	// Template methods for derived classes:

    	interpolate_: function( i1, t0, t, t1 ) {

    		throw new Error( "call to abstract method" );
    		// implementations shall return this.resultBuffer

    	},

    	intervalChanged_: function( i1, t0, t1 ) {

    		// empty

    	}

    };

    Object.assign( Interpolant.prototype, {

    	beforeStart_: //( 0, t, t0 ), returns this.resultBuffer
    		Interpolant.prototype.copySampleValue_,

    	afterEnd_: //( N-1, tN-1, t ), returns this.resultBuffer
    		Interpolant.prototype.copySampleValue_

    } );

    /**
     * Fast and simple cubic spline interpolant.
     *
     * It was derived from a Hermitian construction setting the first derivative
     * at each sample position to the linear slope between neighboring positions
     * over their parameter interval.
     *
     * @author tschw
     */

    function CubicInterpolant(
    		parameterPositions, sampleValues, sampleSize, resultBuffer ) {

    	Interpolant.call(
    			this, parameterPositions, sampleValues, sampleSize, resultBuffer );

    	this._weightPrev = -0;
    	this._offsetPrev = -0;
    	this._weightNext = -0;
    	this._offsetNext = -0;

    }

    CubicInterpolant.prototype =
    		Object.assign( Object.create( Interpolant.prototype ), {

    	constructor: CubicInterpolant,

    	DefaultSettings_: {

    		endingStart: 	ZeroCurvatureEnding,
    		endingEnd:		ZeroCurvatureEnding

    	},

    	intervalChanged_: function( i1, t0, t1 ) {

    		var pp = this.parameterPositions,
    			iPrev = i1 - 2,
    			iNext = i1 + 1,

    			tPrev = pp[ iPrev ],
    			tNext = pp[ iNext ];

    		if ( tPrev === undefined ) {

    			switch ( this.getSettings_().endingStart ) {

    				case ZeroSlopeEnding:

    					// f'(t0) = 0
    					iPrev = i1;
    					tPrev = 2 * t0 - t1;

    					break;

    				case WrapAroundEnding:

    					// use the other end of the curve
    					iPrev = pp.length - 2;
    					tPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];

    					break;

    				default: // ZeroCurvatureEnding

    					// f''(t0) = 0 a.k.a. Natural Spline
    					iPrev = i1;
    					tPrev = t1;

    			}

    		}

    		if ( tNext === undefined ) {

    			switch ( this.getSettings_().endingEnd ) {

    				case ZeroSlopeEnding:

    					// f'(tN) = 0
    					iNext = i1;
    					tNext = 2 * t1 - t0;

    					break;

    				case WrapAroundEnding:

    					// use the other end of the curve
    					iNext = 1;
    					tNext = t1 + pp[ 1 ] - pp[ 0 ];

    					break;

    				default: // ZeroCurvatureEnding

    					// f''(tN) = 0, a.k.a. Natural Spline
    					iNext = i1 - 1;
    					tNext = t0;

    			}

    		}

    		var halfDt = ( t1 - t0 ) * 0.5,
    			stride = this.valueSize;

    		this._weightPrev = halfDt / ( t0 - tPrev );
    		this._weightNext = halfDt / ( tNext - t1 );
    		this._offsetPrev = iPrev * stride;
    		this._offsetNext = iNext * stride;

    	},

    	interpolate_: function( i1, t0, t, t1 ) {

    		var result = this.resultBuffer,
    			values = this.sampleValues,
    			stride = this.valueSize,

    			o1 = i1 * stride,		o0 = o1 - stride,
    			oP = this._offsetPrev, 	oN = this._offsetNext,
    			wP = this._weightPrev,	wN = this._weightNext,

    			p = ( t - t0 ) / ( t1 - t0 ),
    			pp = p * p,
    			ppp = pp * p;

    		// evaluate polynomials

    		var sP =     - wP   * ppp   +         2 * wP    * pp    -          wP   * p;
    		var s0 = ( 1 + wP ) * ppp   + (-1.5 - 2 * wP )  * pp    + ( -0.5 + wP ) * p     + 1;
    		var s1 = (-1 - wN ) * ppp   + ( 1.5 +   wN   )  * pp    +    0.5        * p;
    		var sN =       wN   * ppp   -           wN      * pp;

    		// combine data linearly

    		for ( var i = 0; i !== stride; ++ i ) {

    			result[ i ] =
    					sP * values[ oP + i ] +
    					s0 * values[ o0 + i ] +
    					s1 * values[ o1 + i ] +
    					sN * values[ oN + i ];

    		}

    		return result;

    	}

    } );

    /**
     * @author tschw
     */

    function LinearInterpolant(
    		parameterPositions, sampleValues, sampleSize, resultBuffer ) {

    	Interpolant.call(
    			this, parameterPositions, sampleValues, sampleSize, resultBuffer );

    }

    LinearInterpolant.prototype =
    		Object.assign( Object.create( Interpolant.prototype ), {

    	constructor: LinearInterpolant,

    	interpolate_: function( i1, t0, t, t1 ) {

    		var result = this.resultBuffer,
    			values = this.sampleValues,
    			stride = this.valueSize,

    			offset1 = i1 * stride,
    			offset0 = offset1 - stride,

    			weight1 = ( t - t0 ) / ( t1 - t0 ),
    			weight0 = 1 - weight1;

    		for ( var i = 0; i !== stride; ++ i ) {

    			result[ i ] =
    					values[ offset0 + i ] * weight0 +
    					values[ offset1 + i ] * weight1;

    		}

    		return result;

    	}

    } );

    /**
     *
     * Interpolant that evaluates to the sample value at the position preceeding
     * the parameter.
     *
     * @author tschw
     */

    function DiscreteInterpolant(
    		parameterPositions, sampleValues, sampleSize, resultBuffer ) {

    	Interpolant.call(
    			this, parameterPositions, sampleValues, sampleSize, resultBuffer );

    }

    DiscreteInterpolant.prototype =
    		Object.assign( Object.create( Interpolant.prototype ), {

    	constructor: DiscreteInterpolant,

    	interpolate_: function( i1, t0, t, t1 ) {

    		return this.copySampleValue_( i1 - 1 );

    	}

    } );

    var KeyframeTrackPrototype;

    KeyframeTrackPrototype = {

    	TimeBufferType: Float32Array,
    	ValueBufferType: Float32Array,

    	DefaultInterpolation: InterpolateLinear,

    	InterpolantFactoryMethodDiscrete: function( result ) {

    		return new DiscreteInterpolant(
    				this.times, this.values, this.getValueSize(), result );

    	},

    	InterpolantFactoryMethodLinear: function( result ) {

    		return new LinearInterpolant(
    				this.times, this.values, this.getValueSize(), result );

    	},

    	InterpolantFactoryMethodSmooth: function( result ) {

    		return new CubicInterpolant(
    				this.times, this.values, this.getValueSize(), result );

    	},

    	setInterpolation: function( interpolation ) {

    		var factoryMethod;

    		switch ( interpolation ) {

    			case InterpolateDiscrete:

    				factoryMethod = this.InterpolantFactoryMethodDiscrete;

    				break;

    			case InterpolateLinear:

    				factoryMethod = this.InterpolantFactoryMethodLinear;

    				break;

    			case InterpolateSmooth:

    				factoryMethod = this.InterpolantFactoryMethodSmooth;

    				break;

    		}

    		if ( factoryMethod === undefined ) {

    			var message = "unsupported interpolation for " +
    					this.ValueTypeName + " keyframe track named " + this.name;

    			if ( this.createInterpolant === undefined ) {

    				// fall back to default, unless the default itself is messed up
    				if ( interpolation !== this.DefaultInterpolation ) {

    					this.setInterpolation( this.DefaultInterpolation );

    				} else {

    					throw new Error( message ); // fatal, in this case

    				}

    			}

    			console.warn( message );
    			return;

    		}

    		this.createInterpolant = factoryMethod;

    	},

    	getInterpolation: function() {

    		switch ( this.createInterpolant ) {

    			case this.InterpolantFactoryMethodDiscrete:

    				return InterpolateDiscrete;

    			case this.InterpolantFactoryMethodLinear:

    				return InterpolateLinear;

    			case this.InterpolantFactoryMethodSmooth:

    				return InterpolateSmooth;

    		}

    	},

    	getValueSize: function() {

    		return this.values.length / this.times.length;

    	},

    	// move all keyframes either forwards or backwards in time
    	shift: function( timeOffset ) {

    		if( timeOffset !== 0.0 ) {

    			var times = this.times;

    			for( var i = 0, n = times.length; i !== n; ++ i ) {

    				times[ i ] += timeOffset;

    			}

    		}

    		return this;

    	},

    	// scale all keyframe times by a factor (useful for frame <-> seconds conversions)
    	scale: function( timeScale ) {

    		if( timeScale !== 1.0 ) {

    			var times = this.times;

    			for( var i = 0, n = times.length; i !== n; ++ i ) {

    				times[ i ] *= timeScale;

    			}

    		}

    		return this;

    	},

    	// removes keyframes before and after animation without changing any values within the range [startTime, endTime].
    	// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
    	trim: function( startTime, endTime ) {

    		var times = this.times,
    			nKeys = times.length,
    			from = 0,
    			to = nKeys - 1;

    		while ( from !== nKeys && times[ from ] < startTime ) ++ from;
    		while ( to !== -1 && times[ to ] > endTime ) -- to;

    		++ to; // inclusive -> exclusive bound

    		if( from !== 0 || to !== nKeys ) {

    			// empty tracks are forbidden, so keep at least one keyframe
    			if ( from >= to ) to = Math.max( to , 1 ), from = to - 1;

    			var stride = this.getValueSize();
    			this.times = exports.AnimationUtils.arraySlice( times, from, to );
    			this.values = exports.AnimationUtils.
    					arraySlice( this.values, from * stride, to * stride );

    		}

    		return this;

    	},

    	// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
    	validate: function() {

    		var valid = true;

    		var valueSize = this.getValueSize();
    		if ( valueSize - Math.floor( valueSize ) !== 0 ) {

    			console.error( "invalid value size in track", this );
    			valid = false;

    		}

    		var times = this.times,
    			values = this.values,

    			nKeys = times.length;

    		if( nKeys === 0 ) {

    			console.error( "track is empty", this );
    			valid = false;

    		}

    		var prevTime = null;

    		for( var i = 0; i !== nKeys; i ++ ) {

    			var currTime = times[ i ];

    			if ( typeof currTime === 'number' && isNaN( currTime ) ) {

    				console.error( "time is not a valid number", this, i, currTime );
    				valid = false;
    				break;

    			}

    			if( prevTime !== null && prevTime > currTime ) {

    				console.error( "out of order keys", this, i, currTime, prevTime );
    				valid = false;
    				break;

    			}

    			prevTime = currTime;

    		}

    		if ( values !== undefined ) {

    			if ( exports.AnimationUtils.isTypedArray( values ) ) {

    				for ( var i = 0, n = values.length; i !== n; ++ i ) {

    					var value = values[ i ];

    					if ( isNaN( value ) ) {

    						console.error( "value is not a valid number", this, i, value );
    						valid = false;
    						break;

    					}

    				}

    			}

    		}

    		return valid;

    	},

    	// removes equivalent sequential keys as common in morph target sequences
    	// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
    	optimize: function() {

    		var times = this.times,
    			values = this.values,
    			stride = this.getValueSize(),

    			smoothInterpolation = this.getInterpolation() === InterpolateSmooth,

    			writeIndex = 1,
    			lastIndex = times.length - 1;

    		for( var i = 1; i < lastIndex; ++ i ) {

    			var keep = false;

    			var time = times[ i ];
    			var timeNext = times[ i + 1 ];

    			// remove adjacent keyframes scheduled at the same time

    			if ( time !== timeNext && ( i !== 1 || time !== time[ 0 ] ) ) {

    				if ( ! smoothInterpolation ) {

    					// remove unnecessary keyframes same as their neighbors

    					var offset = i * stride,
    						offsetP = offset - stride,
    						offsetN = offset + stride;

    					for ( var j = 0; j !== stride; ++ j ) {

    						var value = values[ offset + j ];

    						if ( value !== values[ offsetP + j ] ||
    								value !== values[ offsetN + j ] ) {

    							keep = true;
    							break;

    						}

    					}

    				} else keep = true;

    			}

    			// in-place compaction

    			if ( keep ) {

    				if ( i !== writeIndex ) {

    					times[ writeIndex ] = times[ i ];

    					var readOffset = i * stride,
    						writeOffset = writeIndex * stride;

    					for ( var j = 0; j !== stride; ++ j )

    						values[ writeOffset + j ] = values[ readOffset + j ];

    				}

    				++ writeIndex;

    			}

    		}

    		// flush last keyframe (compaction looks ahead)

    		if ( lastIndex > 0 ) {

    			times[ writeIndex ] = times[ lastIndex ];

    			for ( var readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j )

    				values[ writeOffset + j ] = values[ readOffset + j ];

    			++ writeIndex;

    		}

    		if ( writeIndex !== times.length ) {

    			this.times = exports.AnimationUtils.arraySlice( times, 0, writeIndex );
    			this.values = exports.AnimationUtils.arraySlice( values, 0, writeIndex * stride );

    		}

    		return this;

    	}

    }

    function KeyframeTrackConstructor( name, times, values, interpolation ) {

    	if( name === undefined ) throw new Error( "track name is undefined" );

    	if( times === undefined || times.length === 0 ) {

    		throw new Error( "no keyframes in track named " + name );

    	}

    	this.name = name;

    	this.times = exports.AnimationUtils.convertArray( times, this.TimeBufferType );
    	this.values = exports.AnimationUtils.convertArray( values, this.ValueBufferType );

    	this.setInterpolation( interpolation || this.DefaultInterpolation );

    	this.validate();
    	this.optimize();

    }

    /**
     *
     * A Track of vectored keyframe values.
     *
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     */

    function VectorKeyframeTrack( name, times, values, interpolation ) {

    	KeyframeTrackConstructor.call( this, name, times, values, interpolation );

    }

    VectorKeyframeTrack.prototype =
    		Object.assign( Object.create( KeyframeTrackPrototype ), {

    	constructor: VectorKeyframeTrack,

    	ValueTypeName: 'vector'

    	// ValueBufferType is inherited

    	// DefaultInterpolation is inherited

    } );

    /**
     * Spherical linear unit quaternion interpolant.
     *
     * @author tschw
     */

    function QuaternionLinearInterpolant(
    		parameterPositions, sampleValues, sampleSize, resultBuffer ) {

    	Interpolant.call(
    			this, parameterPositions, sampleValues, sampleSize, resultBuffer );

    }

    QuaternionLinearInterpolant.prototype =
    		Object.assign( Object.create( Interpolant.prototype ), {

    	constructor: QuaternionLinearInterpolant,

    	interpolate_: function( i1, t0, t, t1 ) {

    		var result = this.resultBuffer,
    			values = this.sampleValues,
    			stride = this.valueSize,

    			offset = i1 * stride,

    			alpha = ( t - t0 ) / ( t1 - t0 );

    		for ( var end = offset + stride; offset !== end; offset += 4 ) {

    			Quaternion.slerpFlat( result, 0,
    					values, offset - stride, values, offset, alpha );

    		}

    		return result;

    	}

    } );

    /**
     *
     * A Track of quaternion keyframe values.
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     */

    function QuaternionKeyframeTrack( name, times, values, interpolation ) {

    	KeyframeTrackConstructor.call( this, name, times, values, interpolation );

    }

    QuaternionKeyframeTrack.prototype =
    		Object.assign( Object.create( KeyframeTrackPrototype ), {

    	constructor: QuaternionKeyframeTrack,

    	ValueTypeName: 'quaternion',

    	// ValueBufferType is inherited

    	DefaultInterpolation: InterpolateLinear,

    	InterpolantFactoryMethodLinear: function( result ) {

    		return new QuaternionLinearInterpolant(
    				this.times, this.values, this.getValueSize(), result );

    	},

    	InterpolantFactoryMethodSmooth: undefined // not yet implemented

    } );

    /**
     *
     * A Track of numeric keyframe values.
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     */

    function NumberKeyframeTrack( name, times, values, interpolation ) {

    	KeyframeTrackConstructor.call( this, name, times, values, interpolation );

    }

    NumberKeyframeTrack.prototype =
    		Object.assign( Object.create( KeyframeTrackPrototype ), {

    	constructor: NumberKeyframeTrack,

    	ValueTypeName: 'number',

    	// ValueBufferType is inherited

    	// DefaultInterpolation is inherited

    } );

    /**
     *
     * A Track that interpolates Strings
     *
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     */

    function StringKeyframeTrack( name, times, values, interpolation ) {

    	KeyframeTrackConstructor.call( this, name, times, values, interpolation );

    }

    StringKeyframeTrack.prototype =
    		Object.assign( Object.create( KeyframeTrackPrototype ), {

    	constructor: StringKeyframeTrack,

    	ValueTypeName: 'string',
    	ValueBufferType: Array,

    	DefaultInterpolation: InterpolateDiscrete,

    	InterpolantFactoryMethodLinear: undefined,

    	InterpolantFactoryMethodSmooth: undefined

    } );

    /**
     *
     * A Track of Boolean keyframe values.
     *
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     */

    function BooleanKeyframeTrack( name, times, values ) {

    	KeyframeTrackConstructor.call( this, name, times, values );

    }

    BooleanKeyframeTrack.prototype =
    		Object.assign( Object.create( KeyframeTrackPrototype ), {

    	constructor: BooleanKeyframeTrack,

    	ValueTypeName: 'bool',
    	ValueBufferType: Array,

    	DefaultInterpolation: InterpolateDiscrete,

    	InterpolantFactoryMethodLinear: undefined,
    	InterpolantFactoryMethodSmooth: undefined

    	// Note: Actually this track could have a optimized / compressed
    	// representation of a single value and a custom interpolant that
    	// computes "firstValue ^ isOdd( index )".

    } );

    /**
     *
     * A Track of keyframe values that represent color.
     *
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     */

    function ColorKeyframeTrack( name, times, values, interpolation ) {

    	KeyframeTrackConstructor.call( this, name, times, values, interpolation );

    }

    ColorKeyframeTrack.prototype =
    		Object.assign( Object.create( KeyframeTrackPrototype ), {

    	constructor: ColorKeyframeTrack,

    	ValueTypeName: 'color'

    	// ValueBufferType is inherited

    	// DefaultInterpolation is inherited


    	// Note: Very basic implementation and nothing special yet.
    	// However, this is the place for color space parameterization.

    } );

    /**
     *
     * A timed sequence of keyframes for a specific property.
     *
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     */

    function KeyframeTrack( name, times, values, interpolation ) {

    	KeyframeTrackConstructor.apply( this, arguments );

    }

    KeyframeTrack.prototype = KeyframeTrackPrototype;
    KeyframeTrackPrototype.constructor = KeyframeTrack;

    // Static methods:

    Object.assign( KeyframeTrack, {

    	// Serialization (in static context, because of constructor invocation
    	// and automatic invocation of .toJSON):

    	parse: function( json ) {

    		if( json.type === undefined ) {

    			throw new Error( "track type undefined, can not parse" );

    		}

    		var trackType = KeyframeTrack._getTrackTypeForValueTypeName( json.type );

    		if ( json.times === undefined ) {

    			var times = [], values = [];

    			exports.AnimationUtils.flattenJSON( json.keys, times, values, 'value' );

    			json.times = times;
    			json.values = values;

    		}

    		// derived classes can define a static parse method
    		if ( trackType.parse !== undefined ) {

    			return trackType.parse( json );

    		} else {

    			// by default, we asssume a constructor compatible with the base
    			return new trackType(
    					json.name, json.times, json.values, json.interpolation );

    		}

    	},

    	toJSON: function( track ) {

    		var trackType = track.constructor;

    		var json;

    		// derived classes can define a static toJSON method
    		if ( trackType.toJSON !== undefined ) {

    			json = trackType.toJSON( track );

    		} else {

    			// by default, we assume the data can be serialized as-is
    			json = {

    				'name': track.name,
    				'times': exports.AnimationUtils.convertArray( track.times, Array ),
    				'values': exports.AnimationUtils.convertArray( track.values, Array )

    			};

    			var interpolation = track.getInterpolation();

    			if ( interpolation !== track.DefaultInterpolation ) {

    				json.interpolation = interpolation;

    			}

    		}

    		json.type = track.ValueTypeName; // mandatory

    		return json;

    	},

    	_getTrackTypeForValueTypeName: function( typeName ) {

    		switch( typeName.toLowerCase() ) {

    			case "scalar":
    			case "double":
    			case "float":
    			case "number":
    			case "integer":

    				return NumberKeyframeTrack;

    			case "vector":
    			case "vector2":
    			case "vector3":
    			case "vector4":

    				return VectorKeyframeTrack;

    			case "color":

    				return ColorKeyframeTrack;

    			case "quaternion":

    				return QuaternionKeyframeTrack;

    			case "bool":
    			case "boolean":

    				return BooleanKeyframeTrack;

    			case "string":

    				return StringKeyframeTrack;

    		}

    		throw new Error( "Unsupported typeName: " + typeName );

    	}

    } );

    /**
     *
     * Reusable set of Tracks that represent an animation.
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     */

    function AnimationClip( name, duration, tracks ) {

    	this.name = name;
    	this.tracks = tracks;
    	this.duration = ( duration !== undefined ) ? duration : -1;

    	this.uuid = exports.Math.generateUUID();

    	// this means it should figure out its duration by scanning the tracks
    	if ( this.duration < 0 ) {

    		this.resetDuration();

    	}

    	this.optimize();

    }

    AnimationClip.prototype = {

    	constructor: AnimationClip,

    	resetDuration: function() {

    		var tracks = this.tracks,
    			duration = 0;

    		for ( var i = 0, n = tracks.length; i !== n; ++ i ) {

    			var track = this.tracks[ i ];

    			duration = Math.max(
    					duration, track.times[ track.times.length - 1 ] );

    		}

    		this.duration = duration;

    	},

    	trim: function() {

    		for ( var i = 0; i < this.tracks.length; i ++ ) {

    			this.tracks[ i ].trim( 0, this.duration );

    		}

    		return this;

    	},

    	optimize: function() {

    		for ( var i = 0; i < this.tracks.length; i ++ ) {

    			this.tracks[ i ].optimize();

    		}

    		return this;

    	}

    };

    // Static methods:

    Object.assign( AnimationClip, {

    	parse: function( json ) {

    		var tracks = [],
    			jsonTracks = json.tracks,
    			frameTime = 1.0 / ( json.fps || 1.0 );

    		for ( var i = 0, n = jsonTracks.length; i !== n; ++ i ) {

    			tracks.push( KeyframeTrack.parse( jsonTracks[ i ] ).scale( frameTime ) );

    		}

    		return new AnimationClip( json.name, json.duration, tracks );

    	},


    	toJSON: function( clip ) {

    		var tracks = [],
    			clipTracks = clip.tracks;

    		var json = {

    			'name': clip.name,
    			'duration': clip.duration,
    			'tracks': tracks

    		};

    		for ( var i = 0, n = clipTracks.length; i !== n; ++ i ) {

    			tracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );

    		}

    		return json;

    	},


    	CreateFromMorphTargetSequence: function( name, morphTargetSequence, fps, noLoop ) {

    		var numMorphTargets = morphTargetSequence.length;
    		var tracks = [];

    		for ( var i = 0; i < numMorphTargets; i ++ ) {

    			var times = [];
    			var values = [];

    			times.push(
    					( i + numMorphTargets - 1 ) % numMorphTargets,
    					i,
    					( i + 1 ) % numMorphTargets );

    			values.push( 0, 1, 0 );

    			var order = exports.AnimationUtils.getKeyframeOrder( times );
    			times = exports.AnimationUtils.sortedArray( times, 1, order );
    			values = exports.AnimationUtils.sortedArray( values, 1, order );

    			// if there is a key at the first frame, duplicate it as the
    			// last frame as well for perfect loop.
    			if ( ! noLoop && times[ 0 ] === 0 ) {

    				times.push( numMorphTargets );
    				values.push( values[ 0 ] );

    			}

    			tracks.push(
    					new NumberKeyframeTrack(
    						'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',
    						times, values
    					).scale( 1.0 / fps ) );
    		}

    		return new AnimationClip( name, -1, tracks );

    	},

    	findByName: function( objectOrClipArray, name ) {

    		var clipArray = objectOrClipArray;

    		if ( ! Array.isArray( objectOrClipArray ) ) {

    			var o = objectOrClipArray;
    			clipArray = o.geometry && o.geometry.animations || o.animations;

    		}

    		for ( var i = 0; i < clipArray.length; i ++ ) {

    			if ( clipArray[ i ].name === name ) {

    				return clipArray[ i ];

    			}
    		}

    		return null;

    	},

    	CreateClipsFromMorphTargetSequences: function( morphTargets, fps, noLoop ) {

    		var animationToMorphTargets = {};

    		// tested with https://regex101.com/ on trick sequences
    		// such flamingo_flyA_003, flamingo_run1_003, crdeath0059
    		var pattern = /^([\w-]*?)([\d]+)$/;

    		// sort morph target names into animation groups based
    		// patterns like Walk_001, Walk_002, Run_001, Run_002
    		for ( var i = 0, il = morphTargets.length; i < il; i ++ ) {

    			var morphTarget = morphTargets[ i ];
    			var parts = morphTarget.name.match( pattern );

    			if ( parts && parts.length > 1 ) {

    				var name = parts[ 1 ];

    				var animationMorphTargets = animationToMorphTargets[ name ];
    				if ( ! animationMorphTargets ) {

    					animationToMorphTargets[ name ] = animationMorphTargets = [];

    				}

    				animationMorphTargets.push( morphTarget );

    			}

    		}

    		var clips = [];

    		for ( var name in animationToMorphTargets ) {

    			clips.push( AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );

    		}

    		return clips;

    	},

    	// parse the animation.hierarchy format
    	parseAnimation: function( animation, bones ) {

    		if ( ! animation ) {

    			console.error( "  no animation in JSONLoader data" );
    			return null;

    		}

    		var addNonemptyTrack = function(
    				trackType, trackName, animationKeys, propertyName, destTracks ) {

    			// only return track if there are actually keys.
    			if ( animationKeys.length !== 0 ) {

    				var times = [];
    				var values = [];

    				exports.AnimationUtils.flattenJSON(
    						animationKeys, times, values, propertyName );

    				// empty keys are filtered out, so check again
    				if ( times.length !== 0 ) {

    					destTracks.push( new trackType( trackName, times, values ) );

    				}

    			}

    		};

    		var tracks = [];

    		var clipName = animation.name || 'default';
    		// automatic length determination in AnimationClip.
    		var duration = animation.length || -1;
    		var fps = animation.fps || 30;

    		var hierarchyTracks = animation.hierarchy || [];

    		for ( var h = 0; h < hierarchyTracks.length; h ++ ) {

    			var animationKeys = hierarchyTracks[ h ].keys;

    			// skip empty tracks
    			if ( ! animationKeys || animationKeys.length === 0 ) continue;

    			// process morph targets in a way exactly compatible
    			// with AnimationHandler.init( animation )
    			if ( animationKeys[0].morphTargets ) {

    				// figure out all morph targets used in this track
    				var morphTargetNames = {};
    				for ( var k = 0; k < animationKeys.length; k ++ ) {

    					if ( animationKeys[k].morphTargets ) {

    						for ( var m = 0; m < animationKeys[k].morphTargets.length; m ++ ) {

    							morphTargetNames[ animationKeys[k].morphTargets[m] ] = -1;
    						}

    					}

    				}

    				// create a track for each morph target with all zero
    				// morphTargetInfluences except for the keys in which
    				// the morphTarget is named.
    				for ( var morphTargetName in morphTargetNames ) {

    					var times = [];
    					var values = [];

    					for ( var m = 0;
    							m !== animationKeys[k].morphTargets.length; ++ m ) {

    						var animationKey = animationKeys[k];

    						times.push( animationKey.time );
    						values.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );

    					}

    					tracks.push( new NumberKeyframeTrack(
    							'.morphTargetInfluence[' + morphTargetName + ']', times, values ) );

    				}

    				duration = morphTargetNames.length * ( fps || 1.0 );

    			} else {
    				// ...assume skeletal animation

    				var boneName = '.bones[' + bones[ h ].name + ']';

    				addNonemptyTrack(
    						VectorKeyframeTrack, boneName + '.position',
    						animationKeys, 'pos', tracks );

    				addNonemptyTrack(
    						QuaternionKeyframeTrack, boneName + '.quaternion',
    						animationKeys, 'rot', tracks );

    				addNonemptyTrack(
    						VectorKeyframeTrack, boneName + '.scale',
    						animationKeys, 'scl', tracks );

    			}

    		}

    		if ( tracks.length === 0 ) {

    			return null;

    		}

    		var clip = new AnimationClip( clipName, duration, tracks );

    		return clip;

    	}

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function MaterialLoader( manager ) {

    	this.manager = ( manager !== undefined ) ? manager : exports.DefaultLoadingManager;
    	this.textures = {};

    }

    Object.assign( MaterialLoader.prototype, {

    	load: function ( url, onLoad, onProgress, onError ) {

    		var scope = this;

    		var loader = new XHRLoader( scope.manager );
    		loader.load( url, function ( text ) {

    			onLoad( scope.parse( JSON.parse( text ) ) );

    		}, onProgress, onError );

    	},

    	setTextures: function ( value ) {

    		this.textures = value;

    	},

    	parse: function ( json ) {

    		var textures = this.textures;

    		function getTexture( name ) {

    			if ( textures[ name ] === undefined ) {

    				console.warn( 'THREE.MaterialLoader: Undefined texture', name );

    			}

    			return textures[ name ];

    		}

    		var material = new Materials[ json.type ]();

    		if ( json.uuid !== undefined ) material.uuid = json.uuid;
    		if ( json.name !== undefined ) material.name = json.name;
    		if ( json.color !== undefined ) material.color.setHex( json.color );
    		if ( json.roughness !== undefined ) material.roughness = json.roughness;
    		if ( json.metalness !== undefined ) material.metalness = json.metalness;
    		if ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );
    		if ( json.specular !== undefined ) material.specular.setHex( json.specular );
    		if ( json.shininess !== undefined ) material.shininess = json.shininess;
    		if ( json.uniforms !== undefined ) material.uniforms = json.uniforms;
    		if ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;
    		if ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;
    		if ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;
    		if ( json.fog !== undefined ) material.fog = json.fog;
    		if ( json.shading !== undefined ) material.shading = json.shading;
    		if ( json.blending !== undefined ) material.blending = json.blending;
    		if ( json.side !== undefined ) material.side = json.side;
    		if ( json.opacity !== undefined ) material.opacity = json.opacity;
    		if ( json.transparent !== undefined ) material.transparent = json.transparent;
    		if ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;
    		if ( json.depthTest !== undefined ) material.depthTest = json.depthTest;
    		if ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;
    		if ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;
    		if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;
    		if ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;
    		if ( json.wireframeLinecap !== undefined ) material.wireframeLinecap = json.wireframeLinecap;
    		if ( json.wireframeLinejoin !== undefined ) material.wireframeLinejoin = json.wireframeLinejoin;
    		if ( json.skinning !== undefined ) material.skinning = json.skinning;
    		if ( json.morphTargets !== undefined ) material.morphTargets = json.morphTargets;

    		// for PointsMaterial

    		if ( json.size !== undefined ) material.size = json.size;
    		if ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;

    		// maps

    		if ( json.map !== undefined ) material.map = getTexture( json.map );

    		if ( json.alphaMap !== undefined ) {

    			material.alphaMap = getTexture( json.alphaMap );
    			material.transparent = true;

    		}

    		if ( json.bumpMap !== undefined ) material.bumpMap = getTexture( json.bumpMap );
    		if ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;

    		if ( json.normalMap !== undefined ) material.normalMap = getTexture( json.normalMap );
    		if ( json.normalScale !== undefined ) {

    			var normalScale = json.normalScale;

    			if ( Array.isArray( normalScale ) === false ) {

    				// Blender exporter used to export a scalar. See #7459

    				normalScale = [ normalScale, normalScale ];

    			}

    			material.normalScale = new Vector2().fromArray( normalScale );

    		}

    		if ( json.displacementMap !== undefined ) material.displacementMap = getTexture( json.displacementMap );
    		if ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;
    		if ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;

    		if ( json.roughnessMap !== undefined ) material.roughnessMap = getTexture( json.roughnessMap );
    		if ( json.metalnessMap !== undefined ) material.metalnessMap = getTexture( json.metalnessMap );

    		if ( json.emissiveMap !== undefined ) material.emissiveMap = getTexture( json.emissiveMap );
    		if ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;

    		if ( json.specularMap !== undefined ) material.specularMap = getTexture( json.specularMap );

    		if ( json.envMap !== undefined ) material.envMap = getTexture( json.envMap );

    		if ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity;

    		if ( json.lightMap !== undefined ) material.lightMap = getTexture( json.lightMap );
    		if ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;

    		if ( json.aoMap !== undefined ) material.aoMap = getTexture( json.aoMap );
    		if ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;

    		// MultiMaterial

    		if ( json.materials !== undefined ) {

    			for ( var i = 0, l = json.materials.length; i < l; i ++ ) {

    				material.materials.push( this.parse( json.materials[ i ] ) );

    			}

    		}

    		return material;

    	}

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function BufferGeometryLoader( manager ) {

    	this.manager = ( manager !== undefined ) ? manager : exports.DefaultLoadingManager;

    }

    Object.assign( BufferGeometryLoader.prototype, {

    	load: function ( url, onLoad, onProgress, onError ) {

    		var scope = this;

    		var loader = new XHRLoader( scope.manager );
    		loader.load( url, function ( text ) {

    			onLoad( scope.parse( JSON.parse( text ) ) );

    		}, onProgress, onError );

    	},

    	parse: function ( json ) {

    		var geometry = new BufferGeometry();

    		var index = json.data.index;

    		var TYPED_ARRAYS = {
    			'Int8Array': Int8Array,
    			'Uint8Array': Uint8Array,
    			'Uint8ClampedArray': Uint8ClampedArray,
    			'Int16Array': Int16Array,
    			'Uint16Array': Uint16Array,
    			'Int32Array': Int32Array,
    			'Uint32Array': Uint32Array,
    			'Float32Array': Float32Array,
    			'Float64Array': Float64Array
    		};

    		if ( index !== undefined ) {

    			var typedArray = new TYPED_ARRAYS[ index.type ]( index.array );
    			geometry.setIndex( new BufferAttribute( typedArray, 1 ) );

    		}

    		var attributes = json.data.attributes;

    		for ( var key in attributes ) {

    			var attribute = attributes[ key ];
    			var typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array );

    			geometry.addAttribute( key, new BufferAttribute( typedArray, attribute.itemSize, attribute.normalized ) );

    		}

    		var groups = json.data.groups || json.data.drawcalls || json.data.offsets;

    		if ( groups !== undefined ) {

    			for ( var i = 0, n = groups.length; i !== n; ++ i ) {

    				var group = groups[ i ];

    				geometry.addGroup( group.start, group.count, group.materialIndex );

    			}

    		}

    		var boundingSphere = json.data.boundingSphere;

    		if ( boundingSphere !== undefined ) {

    			var center = new Vector3();

    			if ( boundingSphere.center !== undefined ) {

    				center.fromArray( boundingSphere.center );

    			}

    			geometry.boundingSphere = new Sphere( center, boundingSphere.radius );

    		}

    		return geometry;

    	}

    } );

    /**
     * @author alteredq / http://alteredqualia.com/
     */

    function Loader() {

    	this.onLoadStart = function () {};
    	this.onLoadProgress = function () {};
    	this.onLoadComplete = function () {};

    }

    Loader.prototype = {

    	constructor: Loader,

    	crossOrigin: undefined,

    	extractUrlBase: function ( url ) {

    		var parts = url.split( '/' );

    		if ( parts.length === 1 ) return './';

    		parts.pop();

    		return parts.join( '/' ) + '/';

    	},

    	initMaterials: function ( materials, texturePath, crossOrigin ) {

    		var array = [];

    		for ( var i = 0; i < materials.length; ++ i ) {

    			array[ i ] = this.createMaterial( materials[ i ], texturePath, crossOrigin );

    		}

    		return array;

    	},

    	createMaterial: ( function () {

    		var color, textureLoader, materialLoader;

    		return function createMaterial( m, texturePath, crossOrigin ) {

    			if ( color === undefined ) color = new Color();
    			if ( textureLoader === undefined ) textureLoader = new TextureLoader();
    			if ( materialLoader === undefined ) materialLoader = new MaterialLoader();

    			// convert from old material format

    			var textures = {};

    			function loadTexture( path, repeat, offset, wrap, anisotropy ) {

    				var fullPath = texturePath + path;
    				var loader = Loader.Handlers.get( fullPath );

    				var texture;

    				if ( loader !== null ) {

    					texture = loader.load( fullPath );

    				} else {

    					textureLoader.setCrossOrigin( crossOrigin );
    					texture = textureLoader.load( fullPath );

    				}

    				if ( repeat !== undefined ) {

    					texture.repeat.fromArray( repeat );

    					if ( repeat[ 0 ] !== 1 ) texture.wrapS = RepeatWrapping;
    					if ( repeat[ 1 ] !== 1 ) texture.wrapT = RepeatWrapping;

    				}

    				if ( offset !== undefined ) {

    					texture.offset.fromArray( offset );

    				}

    				if ( wrap !== undefined ) {

    					if ( wrap[ 0 ] === 'repeat' ) texture.wrapS = RepeatWrapping;
    					if ( wrap[ 0 ] === 'mirror' ) texture.wrapS = MirroredRepeatWrapping;

    					if ( wrap[ 1 ] === 'repeat' ) texture.wrapT = RepeatWrapping;
    					if ( wrap[ 1 ] === 'mirror' ) texture.wrapT = MirroredRepeatWrapping;

    				}

    				if ( anisotropy !== undefined ) {

    					texture.anisotropy = anisotropy;

    				}

    				var uuid = exports.Math.generateUUID();

    				textures[ uuid ] = texture;

    				return uuid;

    			}

    			//

    			var json = {
    				uuid: exports.Math.generateUUID(),
    				type: 'MeshLambertMaterial'
    			};

    			for ( var name in m ) {

    				var value = m[ name ];

    				switch ( name ) {
    					case 'DbgColor':
    					case 'DbgIndex':
    					case 'opticalDensity':
    					case 'illumination':
    						break;
    					case 'DbgName':
    						json.name = value;
    						break;
    					case 'blending':
    						json.blending = BlendingMode[ value ];
    						break;
    					case 'colorAmbient':
    					case 'mapAmbient':
    						console.warn( 'THREE.Loader.createMaterial:', name, 'is no longer supported.' );
    						break;
    					case 'colorDiffuse':
    						json.color = color.fromArray( value ).getHex();
    						break;
    					case 'colorSpecular':
    						json.specular = color.fromArray( value ).getHex();
    						break;
    					case 'colorEmissive':
    						json.emissive = color.fromArray( value ).getHex();
    						break;
    					case 'specularCoef':
    						json.shininess = value;
    						break;
    					case 'shading':
    						if ( value.toLowerCase() === 'basic' ) json.type = 'MeshBasicMaterial';
    						if ( value.toLowerCase() === 'phong' ) json.type = 'MeshPhongMaterial';
    						if ( value.toLowerCase() === 'standard' ) json.type = 'MeshStandardMaterial';
    						break;
    					case 'mapDiffuse':
    						json.map = loadTexture( value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );
    						break;
    					case 'mapDiffuseRepeat':
    					case 'mapDiffuseOffset':
    					case 'mapDiffuseWrap':
    					case 'mapDiffuseAnisotropy':
    						break;
    					case 'mapEmissive':
    						json.emissiveMap = loadTexture( value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy );
    						break;
    					case 'mapEmissiveRepeat':
    					case 'mapEmissiveOffset':
    					case 'mapEmissiveWrap':
    					case 'mapEmissiveAnisotropy':
    						break;
    					case 'mapLight':
    						json.lightMap = loadTexture( value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );
    						break;
    					case 'mapLightRepeat':
    					case 'mapLightOffset':
    					case 'mapLightWrap':
    					case 'mapLightAnisotropy':
    						break;
    					case 'mapAO':
    						json.aoMap = loadTexture( value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );
    						break;
    					case 'mapAORepeat':
    					case 'mapAOOffset':
    					case 'mapAOWrap':
    					case 'mapAOAnisotropy':
    						break;
    					case 'mapBump':
    						json.bumpMap = loadTexture( value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );
    						break;
    					case 'mapBumpScale':
    						json.bumpScale = value;
    						break;
    					case 'mapBumpRepeat':
    					case 'mapBumpOffset':
    					case 'mapBumpWrap':
    					case 'mapBumpAnisotropy':
    						break;
    					case 'mapNormal':
    						json.normalMap = loadTexture( value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );
    						break;
    					case 'mapNormalFactor':
    						json.normalScale = [ value, value ];
    						break;
    					case 'mapNormalRepeat':
    					case 'mapNormalOffset':
    					case 'mapNormalWrap':
    					case 'mapNormalAnisotropy':
    						break;
    					case 'mapSpecular':
    						json.specularMap = loadTexture( value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );
    						break;
    					case 'mapSpecularRepeat':
    					case 'mapSpecularOffset':
    					case 'mapSpecularWrap':
    					case 'mapSpecularAnisotropy':
    						break;
    					case 'mapMetalness':
    						json.metalnessMap = loadTexture( value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy );
    						break;
    					case 'mapMetalnessRepeat':
    					case 'mapMetalnessOffset':
    					case 'mapMetalnessWrap':
    					case 'mapMetalnessAnisotropy':
    						break;
    					case 'mapRoughness':
    						json.roughnessMap = loadTexture( value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy );
    						break;
    					case 'mapRoughnessRepeat':
    					case 'mapRoughnessOffset':
    					case 'mapRoughnessWrap':
    					case 'mapRoughnessAnisotropy':
    						break;
    					case 'mapAlpha':
    						json.alphaMap = loadTexture( value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );
    						break;
    					case 'mapAlphaRepeat':
    					case 'mapAlphaOffset':
    					case 'mapAlphaWrap':
    					case 'mapAlphaAnisotropy':
    						break;
    					case 'flipSided':
    						json.side = BackSide;
    						break;
    					case 'doubleSided':
    						json.side = DoubleSide;
    						break;
    					case 'transparency':
    						console.warn( 'THREE.Loader.createMaterial: transparency has been renamed to opacity' );
    						json.opacity = value;
    						break;
    					case 'depthTest':
    					case 'depthWrite':
    					case 'colorWrite':
    					case 'opacity':
    					case 'reflectivity':
    					case 'transparent':
    					case 'visible':
    					case 'wireframe':
    						json[ name ] = value;
    						break;
    					case 'vertexColors':
    						if ( value === true ) json.vertexColors = VertexColors;
    						if ( value === 'face' ) json.vertexColors = FaceColors;
    						break;
    					default:
    						console.error( 'THREE.Loader.createMaterial: Unsupported', name, value );
    						break;
    				}

    			}

    			if ( json.type === 'MeshBasicMaterial' ) delete json.emissive;
    			if ( json.type !== 'MeshPhongMaterial' ) delete json.specular;

    			if ( json.opacity < 1 ) json.transparent = true;

    			materialLoader.setTextures( textures );

    			return materialLoader.parse( json );

    		};

    	} )()

    };

    Loader.Handlers = {

    	handlers: [],

    	add: function ( regex, loader ) {

    		this.handlers.push( regex, loader );

    	},

    	get: function ( file ) {

    		var handlers = this.handlers;

    		for ( var i = 0, l = handlers.length; i < l; i += 2 ) {

    			var regex = handlers[ i ];
    			var loader  = handlers[ i + 1 ];

    			if ( regex.test( file ) ) {

    				return loader;

    			}

    		}

    		return null;

    	}

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     */

    function JSONLoader( manager ) {

    	if ( typeof manager === 'boolean' ) {

    		console.warn( 'THREE.JSONLoader: showStatus parameter has been removed from constructor.' );
    		manager = undefined;

    	}

    	this.manager = ( manager !== undefined ) ? manager : exports.DefaultLoadingManager;

    	this.withCredentials = false;

    }

    Object.assign( JSONLoader.prototype, {

    	load: function( url, onLoad, onProgress, onError ) {

    		var scope = this;

    		var texturePath = this.texturePath && ( typeof this.texturePath === "string" ) ? this.texturePath : Loader.prototype.extractUrlBase( url );

    		var loader = new XHRLoader( this.manager );
    		loader.setWithCredentials( this.withCredentials );
    		loader.load( url, function ( text ) {

    			var json = JSON.parse( text );
    			var metadata = json.metadata;

    			if ( metadata !== undefined ) {

    				var type = metadata.type;

    				if ( type !== undefined ) {

    					if ( type.toLowerCase() === 'object' ) {

    						console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );
    						return;

    					}

    					if ( type.toLowerCase() === 'scene' ) {

    						console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.' );
    						return;

    					}

    				}

    			}

    			var object = scope.parse( json, texturePath );
    			onLoad( object.geometry, object.materials );

    		}, onProgress, onError );

    	},

    	setTexturePath: function ( value ) {

    		this.texturePath = value;

    	},

    	parse: function ( json, texturePath ) {

    		var geometry = new Geometry(),
    		scale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;

    		parseModel( scale );

    		parseSkin();
    		parseMorphing( scale );
    		parseAnimations();

    		geometry.computeFaceNormals();
    		geometry.computeBoundingSphere();

    		function parseModel( scale ) {

    			function isBitSet( value, position ) {

    				return value & ( 1 << position );

    			}

    			var i, j, fi,

    			offset, zLength,

    		colorIndex, normalIndex, uvIndex, materialIndex,

    			type,
    			isQuad,
    			hasMaterial,
    			hasFaceVertexUv,
    			hasFaceNormal, hasFaceVertexNormal,
    			hasFaceColor, hasFaceVertexColor,

    		vertex, face, faceA, faceB, hex, normal,

    			uvLayer, uv, u, v,

    			faces = json.faces,
    			vertices = json.vertices,
    			normals = json.normals,
    			colors = json.colors,

    			nUvLayers = 0;

    			if ( json.uvs !== undefined ) {

    				// disregard empty arrays

    				for ( i = 0; i < json.uvs.length; i ++ ) {

    					if ( json.uvs[ i ].length ) nUvLayers ++;

    				}

    				for ( i = 0; i < nUvLayers; i ++ ) {

    					geometry.faceVertexUvs[ i ] = [];

    				}

    			}

    			offset = 0;
    			zLength = vertices.length;

    			while ( offset < zLength ) {

    				vertex = new Vector3();

    				vertex.x = vertices[ offset ++ ] * scale;
    				vertex.y = vertices[ offset ++ ] * scale;
    				vertex.z = vertices[ offset ++ ] * scale;

    				geometry.vertices.push( vertex );

    			}

    			offset = 0;
    			zLength = faces.length;

    			while ( offset < zLength ) {

    				type = faces[ offset ++ ];


    				isQuad              = isBitSet( type, 0 );
    				hasMaterial         = isBitSet( type, 1 );
    				hasFaceVertexUv     = isBitSet( type, 3 );
    				hasFaceNormal       = isBitSet( type, 4 );
    				hasFaceVertexNormal = isBitSet( type, 5 );
    				hasFaceColor	     = isBitSet( type, 6 );
    				hasFaceVertexColor  = isBitSet( type, 7 );

    				// console.log("type", type, "bits", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);

    				if ( isQuad ) {

    					faceA = new Face3();
    					faceA.a = faces[ offset ];
    					faceA.b = faces[ offset + 1 ];
    					faceA.c = faces[ offset + 3 ];

    					faceB = new Face3();
    					faceB.a = faces[ offset + 1 ];
    					faceB.b = faces[ offset + 2 ];
    					faceB.c = faces[ offset + 3 ];

    					offset += 4;

    					if ( hasMaterial ) {

    						materialIndex = faces[ offset ++ ];
    						faceA.materialIndex = materialIndex;
    						faceB.materialIndex = materialIndex;

    					}

    					// to get face <=> uv index correspondence

    					fi = geometry.faces.length;

    					if ( hasFaceVertexUv ) {

    						for ( i = 0; i < nUvLayers; i ++ ) {

    							uvLayer = json.uvs[ i ];

    							geometry.faceVertexUvs[ i ][ fi ] = [];
    							geometry.faceVertexUvs[ i ][ fi + 1 ] = [];

    							for ( j = 0; j < 4; j ++ ) {

    								uvIndex = faces[ offset ++ ];

    								u = uvLayer[ uvIndex * 2 ];
    								v = uvLayer[ uvIndex * 2 + 1 ];

    								uv = new Vector2( u, v );

    								if ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );
    								if ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );

    							}

    						}

    					}

    					if ( hasFaceNormal ) {

    						normalIndex = faces[ offset ++ ] * 3;

    						faceA.normal.set(
    							normals[ normalIndex ++ ],
    							normals[ normalIndex ++ ],
    							normals[ normalIndex ]
    						);

    						faceB.normal.copy( faceA.normal );

    					}

    					if ( hasFaceVertexNormal ) {

    						for ( i = 0; i < 4; i ++ ) {

    							normalIndex = faces[ offset ++ ] * 3;

    							normal = new Vector3(
    								normals[ normalIndex ++ ],
    								normals[ normalIndex ++ ],
    								normals[ normalIndex ]
    							);


    							if ( i !== 2 ) faceA.vertexNormals.push( normal );
    							if ( i !== 0 ) faceB.vertexNormals.push( normal );

    						}

    					}


    					if ( hasFaceColor ) {

    						colorIndex = faces[ offset ++ ];
    						hex = colors[ colorIndex ];

    						faceA.color.setHex( hex );
    						faceB.color.setHex( hex );

    					}


    					if ( hasFaceVertexColor ) {

    						for ( i = 0; i < 4; i ++ ) {

    							colorIndex = faces[ offset ++ ];
    							hex = colors[ colorIndex ];

    							if ( i !== 2 ) faceA.vertexColors.push( new Color( hex ) );
    							if ( i !== 0 ) faceB.vertexColors.push( new Color( hex ) );

    						}

    					}

    					geometry.faces.push( faceA );
    					geometry.faces.push( faceB );

    				} else {

    					face = new Face3();
    					face.a = faces[ offset ++ ];
    					face.b = faces[ offset ++ ];
    					face.c = faces[ offset ++ ];

    					if ( hasMaterial ) {

    						materialIndex = faces[ offset ++ ];
    						face.materialIndex = materialIndex;

    					}

    					// to get face <=> uv index correspondence

    					fi = geometry.faces.length;

    					if ( hasFaceVertexUv ) {

    						for ( i = 0; i < nUvLayers; i ++ ) {

    							uvLayer = json.uvs[ i ];

    							geometry.faceVertexUvs[ i ][ fi ] = [];

    							for ( j = 0; j < 3; j ++ ) {

    								uvIndex = faces[ offset ++ ];

    								u = uvLayer[ uvIndex * 2 ];
    								v = uvLayer[ uvIndex * 2 + 1 ];

    								uv = new Vector2( u, v );

    								geometry.faceVertexUvs[ i ][ fi ].push( uv );

    							}

    						}

    					}

    					if ( hasFaceNormal ) {

    						normalIndex = faces[ offset ++ ] * 3;

    						face.normal.set(
    							normals[ normalIndex ++ ],
    							normals[ normalIndex ++ ],
    							normals[ normalIndex ]
    						);

    					}

    					if ( hasFaceVertexNormal ) {

    						for ( i = 0; i < 3; i ++ ) {

    							normalIndex = faces[ offset ++ ] * 3;

    							normal = new Vector3(
    								normals[ normalIndex ++ ],
    								normals[ normalIndex ++ ],
    								normals[ normalIndex ]
    							);

    							face.vertexNormals.push( normal );

    						}

    					}


    					if ( hasFaceColor ) {

    						colorIndex = faces[ offset ++ ];
    						face.color.setHex( colors[ colorIndex ] );

    					}


    					if ( hasFaceVertexColor ) {

    						for ( i = 0; i < 3; i ++ ) {

    							colorIndex = faces[ offset ++ ];
    							face.vertexColors.push( new Color( colors[ colorIndex ] ) );

    						}

    					}

    					geometry.faces.push( face );

    				}

    			}

    		}

    		function parseSkin() {

    			var influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;

    			if ( json.skinWeights ) {

    				for ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {

    					var x =                               json.skinWeights[ i ];
    					var y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;
    					var z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;
    					var w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;

    					geometry.skinWeights.push( new Vector4( x, y, z, w ) );

    				}

    			}

    			if ( json.skinIndices ) {

    				for ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {

    					var a =                               json.skinIndices[ i ];
    					var b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;
    					var c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;
    					var d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;

    					geometry.skinIndices.push( new Vector4( a, b, c, d ) );

    				}

    			}

    			geometry.bones = json.bones;

    			if ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {

    				console.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +
    					geometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );

    			}

    		}

    		function parseMorphing( scale ) {

    			if ( json.morphTargets !== undefined ) {

    				for ( var i = 0, l = json.morphTargets.length; i < l; i ++ ) {

    					geometry.morphTargets[ i ] = {};
    					geometry.morphTargets[ i ].name = json.morphTargets[ i ].name;
    					geometry.morphTargets[ i ].vertices = [];

    					var dstVertices = geometry.morphTargets[ i ].vertices;
    					var srcVertices = json.morphTargets[ i ].vertices;

    					for ( var v = 0, vl = srcVertices.length; v < vl; v += 3 ) {

    						var vertex = new Vector3();
    						vertex.x = srcVertices[ v ] * scale;
    						vertex.y = srcVertices[ v + 1 ] * scale;
    						vertex.z = srcVertices[ v + 2 ] * scale;

    						dstVertices.push( vertex );

    					}

    				}

    			}

    			if ( json.morphColors !== undefined && json.morphColors.length > 0 ) {

    				console.warn( 'THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.' );

    				var faces = geometry.faces;
    				var morphColors = json.morphColors[ 0 ].colors;

    				for ( var i = 0, l = faces.length; i < l; i ++ ) {

    					faces[ i ].color.fromArray( morphColors, i * 3 );

    				}

    			}

    		}

    		function parseAnimations() {

    			var outputAnimations = [];

    			// parse old style Bone/Hierarchy animations
    			var animations = [];

    			if ( json.animation !== undefined ) {

    				animations.push( json.animation );

    			}

    			if ( json.animations !== undefined ) {

    				if ( json.animations.length ) {

    					animations = animations.concat( json.animations );

    				} else {

    					animations.push( json.animations );

    				}

    			}

    			for ( var i = 0; i < animations.length; i ++ ) {

    				var clip = AnimationClip.parseAnimation( animations[ i ], geometry.bones );
    				if ( clip ) outputAnimations.push( clip );

    			}

    			// parse implicit morph animations
    			if ( geometry.morphTargets ) {

    				// TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.
    				var morphAnimationClips = AnimationClip.CreateClipsFromMorphTargetSequences( geometry.morphTargets, 10 );
    				outputAnimations = outputAnimations.concat( morphAnimationClips );

    			}

    			if ( outputAnimations.length > 0 ) geometry.animations = outputAnimations;

    		}

    		if ( json.materials === undefined || json.materials.length === 0 ) {

    			return { geometry: geometry };

    		} else {

    			var materials = Loader.prototype.initMaterials( json.materials, texturePath, this.crossOrigin );

    			return { geometry: geometry, materials: materials };

    		}

    	}

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function ObjectLoader ( manager ) {

    	this.manager = ( manager !== undefined ) ? manager : exports.DefaultLoadingManager;
    	this.texturePath = '';

    }

    Object.assign( ObjectLoader.prototype, {

    	load: function ( url, onLoad, onProgress, onError ) {

    		if ( this.texturePath === '' ) {

    			this.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );

    		}

    		var scope = this;

    		var loader = new XHRLoader( scope.manager );
    		loader.load( url, function ( text ) {

    			scope.parse( JSON.parse( text ), onLoad );

    		}, onProgress, onError );

    	},

    	setTexturePath: function ( value ) {

    		this.texturePath = value;

    	},

    	setCrossOrigin: function ( value ) {

    		this.crossOrigin = value;

    	},

    	parse: function ( json, onLoad ) {

    		var geometries = this.parseGeometries( json.geometries );

    		var images = this.parseImages( json.images, function () {

    			if ( onLoad !== undefined ) onLoad( object );

    		} );

    		var textures  = this.parseTextures( json.textures, images );
    		var materials = this.parseMaterials( json.materials, textures );

    		var object = this.parseObject( json.object, geometries, materials );

    		if ( json.animations ) {

    			object.animations = this.parseAnimations( json.animations );

    		}

    		if ( json.images === undefined || json.images.length === 0 ) {

    			if ( onLoad !== undefined ) onLoad( object );

    		}

    		return object;

    	},

    	parseGeometries: function ( json ) {

    		var geometries = {};

    		if ( json !== undefined ) {

    			var geometryLoader = new JSONLoader();
    			var bufferGeometryLoader = new BufferGeometryLoader();

    			for ( var i = 0, l = json.length; i < l; i ++ ) {

    				var geometry;
    				var data = json[ i ];

    				switch ( data.type ) {

    					case 'PlaneGeometry':
    					case 'PlaneBufferGeometry':

    						geometry = new Geometries[ data.type ](
    							data.width,
    							data.height,
    							data.widthSegments,
    							data.heightSegments
    						);

    						break;

    					case 'BoxGeometry':
    					case 'BoxBufferGeometry':
    					case 'CubeGeometry': // backwards compatible

    						geometry = new Geometries[ data.type ](
    							data.width,
    							data.height,
    							data.depth,
    							data.widthSegments,
    							data.heightSegments,
    							data.depthSegments
    						);

    						break;

    					case 'CircleGeometry':
    					case 'CircleBufferGeometry':

    						geometry = new Geometries[ data.type ](
    							data.radius,
    							data.segments,
    							data.thetaStart,
    							data.thetaLength
    						);

    						break;

    					case 'CylinderGeometry':
    					case 'CylinderBufferGeometry':

    						geometry = new Geometries[ data.type ](
    							data.radiusTop,
    							data.radiusBottom,
    							data.height,
    							data.radialSegments,
    							data.heightSegments,
    							data.openEnded,
    							data.thetaStart,
    							data.thetaLength
    						);

    						break;

    					case 'ConeGeometry':
    					case 'ConeBufferGeometry':

    						geometry = new Geometries[ data.type ](
    							data.radius,
    							data.height,
    							data.radialSegments,
    							data.heightSegments,
    							data.openEnded,
    							data.thetaStart,
    							data.thetaLength
    						);

    						break;

    					case 'SphereGeometry':
    					case 'SphereBufferGeometry':

    						geometry = new Geometries[ data.type ](
    							data.radius,
    							data.widthSegments,
    							data.heightSegments,
    							data.phiStart,
    							data.phiLength,
    							data.thetaStart,
    							data.thetaLength
    						);

    						break;

    					case 'DodecahedronGeometry':
    					case 'IcosahedronGeometry':
    					case 'OctahedronGeometry':
    					case 'TetrahedronGeometry':

    						geometry = new Geometries[ data.type ](
    							data.radius,
    							data.detail
    						);

    						break;

    					case 'RingGeometry':
    					case 'RingBufferGeometry':

    						geometry = new Geometries[ data.type ](
    							data.innerRadius,
    							data.outerRadius,
    							data.thetaSegments,
    							data.phiSegments,
    							data.thetaStart,
    							data.thetaLength
    						);

    						break;

    					case 'TorusGeometry':
    					case 'TorusBufferGeometry':

    						geometry = new Geometries[ data.type ](
    							data.radius,
    							data.tube,
    							data.radialSegments,
    							data.tubularSegments,
    							data.arc
    						);

    						break;

    					case 'TorusKnotGeometry':
    					case 'TorusKnotBufferGeometry':

    						geometry = new Geometries[ data.type ](
    							data.radius,
    							data.tube,
    							data.tubularSegments,
    							data.radialSegments,
    							data.p,
    							data.q
    						);

    						break;

    					case 'LatheGeometry':
    					case 'LatheBufferGeometry':

    						geometry = new Geometries[ data.type ](
    							data.points,
    							data.segments,
    							data.phiStart,
    							data.phiLength
    						);

    						break;

    					case 'BufferGeometry':

    						geometry = bufferGeometryLoader.parse( data );

    						break;

    					case 'Geometry':

    						geometry = geometryLoader.parse( data.data, this.texturePath ).geometry;

    						break;

    					default:

    						console.warn( 'THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"' );

    						continue;

    				}

    				geometry.uuid = data.uuid;

    				if ( data.name !== undefined ) geometry.name = data.name;

    				geometries[ data.uuid ] = geometry;

    			}

    		}

    		return geometries;

    	},

    	parseMaterials: function ( json, textures ) {

    		var materials = {};

    		if ( json !== undefined ) {

    			var loader = new MaterialLoader();
    			loader.setTextures( textures );

    			for ( var i = 0, l = json.length; i < l; i ++ ) {

    				var material = loader.parse( json[ i ] );
    				materials[ material.uuid ] = material;

    			}

    		}

    		return materials;

    	},

    	parseAnimations: function ( json ) {

    		var animations = [];

    		for ( var i = 0; i < json.length; i ++ ) {

    			var clip = AnimationClip.parse( json[ i ] );

    			animations.push( clip );

    		}

    		return animations;

    	},

    	parseImages: function ( json, onLoad ) {

    		var scope = this;
    		var images = {};

    		function loadImage( url ) {

    			scope.manager.itemStart( url );

    			return loader.load( url, function () {

    				scope.manager.itemEnd( url );

    			}, undefined, function () {

    				scope.manager.itemError( url );

    			} );

    		}

    		if ( json !== undefined && json.length > 0 ) {

    			var manager = new LoadingManager( onLoad );

    			var loader = new ImageLoader( manager );
    			loader.setCrossOrigin( this.crossOrigin );

    			for ( var i = 0, l = json.length; i < l; i ++ ) {

    				var image = json[ i ];
    				var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( image.url ) ? image.url : scope.texturePath + image.url;

    				images[ image.uuid ] = loadImage( path );

    			}

    		}

    		return images;

    	},

    	parseTextures: function ( json, images ) {

    		function parseConstant( value, type ) {

    			if ( typeof( value ) === 'number' ) return value;

    			console.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );

    			return type[ value ];

    		}

    		var textures = {};

    		if ( json !== undefined ) {

    			for ( var i = 0, l = json.length; i < l; i ++ ) {

    				var data = json[ i ];

    				if ( data.image === undefined ) {

    					console.warn( 'THREE.ObjectLoader: No "image" specified for', data.uuid );

    				}

    				if ( images[ data.image ] === undefined ) {

    					console.warn( 'THREE.ObjectLoader: Undefined image', data.image );

    				}

    				var texture = new Texture( images[ data.image ] );
    				texture.needsUpdate = true;

    				texture.uuid = data.uuid;

    				if ( data.name !== undefined ) texture.name = data.name;

    				if ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping, TextureMapping );

    				if ( data.offset !== undefined ) texture.offset.fromArray( data.offset );
    				if ( data.repeat !== undefined ) texture.repeat.fromArray( data.repeat );
    				if ( data.wrap !== undefined ) {

    					texture.wrapS = parseConstant( data.wrap[ 0 ], TextureWrapping );
    					texture.wrapT = parseConstant( data.wrap[ 1 ], TextureWrapping );

    				}

    				if ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter, TextureFilter );
    				if ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter, TextureFilter );
    				if ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;

    				if ( data.flipY !== undefined ) texture.flipY = data.flipY;

    				textures[ data.uuid ] = texture;

    			}

    		}

    		return textures;

    	},

    	parseObject: function () {

    		var matrix = new Matrix4();

    		return function parseObject( data, geometries, materials ) {

    			var object;

    			function getGeometry( name ) {

    				if ( geometries[ name ] === undefined ) {

    					console.warn( 'THREE.ObjectLoader: Undefined geometry', name );

    				}

    				return geometries[ name ];

    			}

    			function getMaterial( name ) {

    				if ( name === undefined ) return undefined;

    				if ( materials[ name ] === undefined ) {

    					console.warn( 'THREE.ObjectLoader: Undefined material', name );

    				}

    				return materials[ name ];

    			}

    			switch ( data.type ) {

    				case 'Scene':

    					object = new Scene();

    					if ( data.background !== undefined ) {

    						if ( Number.isInteger( data.background ) ) {

    							object.background = new Color( data.background );

    						}

    					}

    					if ( data.fog !== undefined ) {

    						if ( data.fog.type === 'Fog' ) {

    							object.fog = new Fog( data.fog.color, data.fog.near, data.fog.far );

    						} else if ( data.fog.type === 'FogExp2' ) {

    							object.fog = new FogExp2( data.fog.color, data.fog.density );

    						}

    					}

    					break;

    				case 'PerspectiveCamera':

    					object = new PerspectiveCamera( data.fov, data.aspect, data.near, data.far );

    					if ( data.focus !== undefined ) object.focus = data.focus;
    					if ( data.zoom !== undefined ) object.zoom = data.zoom;
    					if ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;
    					if ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;
    					if ( data.view !== undefined ) object.view = Object.assign( {}, data.view );

    					break;

    				case 'OrthographicCamera':

    					object = new OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );

    					break;

    				case 'AmbientLight':

    					object = new AmbientLight( data.color, data.intensity );

    					break;

    				case 'DirectionalLight':

    					object = new DirectionalLight( data.color, data.intensity );

    					break;

    				case 'PointLight':

    					object = new PointLight( data.color, data.intensity, data.distance, data.decay );

    					break;

    				case 'SpotLight':

    					object = new SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );

    					break;

    				case 'HemisphereLight':

    					object = new HemisphereLight( data.color, data.groundColor, data.intensity );

    					break;

    				case 'Mesh':

    					var geometry = getGeometry( data.geometry );
    					var material = getMaterial( data.material );

    					if ( geometry.bones && geometry.bones.length > 0 ) {

    						object = new SkinnedMesh( geometry, material );

    					} else {

    						object = new Mesh( geometry, material );

    					}

    					break;

    				case 'LOD':

    					object = new LOD();

    					break;

    				case 'Line':

    					object = new Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );

    					break;

    				case 'LineSegments':

    					object = new LineSegments( getGeometry( data.geometry ), getMaterial( data.material ) );

    					break;

    				case 'PointCloud':
    				case 'Points':

    					object = new Points( getGeometry( data.geometry ), getMaterial( data.material ) );

    					break;

    				case 'Sprite':

    					object = new Sprite( getMaterial( data.material ) );

    					break;

    				case 'Group':

    					object = new Group();

    					break;

    				default:

    					object = new Object3D();

    			}

    			object.uuid = data.uuid;

    			if ( data.name !== undefined ) object.name = data.name;
    			if ( data.matrix !== undefined ) {

    				matrix.fromArray( data.matrix );
    				matrix.decompose( object.position, object.quaternion, object.scale );

    			} else {

    				if ( data.position !== undefined ) object.position.fromArray( data.position );
    				if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );
    				if ( data.quaternion !== undefined ) object.quaternion.fromArray( data.quaternion );
    				if ( data.scale !== undefined ) object.scale.fromArray( data.scale );

    			}

    			if ( data.castShadow !== undefined ) object.castShadow = data.castShadow;
    			if ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;

    			if ( data.shadow ) {

    				if ( data.shadow.bias !== undefined ) object.shadow.bias = data.shadow.bias;
    				if ( data.shadow.radius !== undefined ) object.shadow.radius = data.shadow.radius;
    				if ( data.shadow.mapSize !== undefined ) object.shadow.mapSize.fromArray( data.shadow.mapSize );
    				if ( data.shadow.camera !== undefined ) object.shadow.camera = this.parseObject( data.shadow.camera );

    			}

    			if ( data.visible !== undefined ) object.visible = data.visible;
    			if ( data.userData !== undefined ) object.userData = data.userData;

    			if ( data.children !== undefined ) {

    				for ( var child in data.children ) {

    					object.add( this.parseObject( data.children[ child ], geometries, materials ) );

    				}

    			}

    			if ( data.type === 'LOD' ) {

    				var levels = data.levels;

    				for ( var l = 0; l < levels.length; l ++ ) {

    					var level = levels[ l ];
    					var child = object.getObjectByProperty( 'uuid', level.object );

    					if ( child !== undefined ) {

    						object.addLevel( child, level.distance );

    					}

    				}

    			}

    			return object;

    		};

    	}()

    } );

    /**
     * @author zz85 / http://www.lab4games.net/zz85/blog
     * Extensible curve object
     *
     * Some common of Curve methods
     * .getPoint(t), getTangent(t)
     * .getPointAt(u), getTangentAt(u)
     * .getPoints(), .getSpacedPoints()
     * .getLength()
     * .updateArcLengths()
     *
     * This following classes subclasses THREE.Curve:
     *
     * -- 2d classes --
     * THREE.LineCurve
     * THREE.QuadraticBezierCurve
     * THREE.CubicBezierCurve
     * THREE.SplineCurve
     * THREE.ArcCurve
     * THREE.EllipseCurve
     *
     * -- 3d classes --
     * THREE.LineCurve3
     * THREE.QuadraticBezierCurve3
     * THREE.CubicBezierCurve3
     * THREE.SplineCurve3
     *
     * A series of curves can be represented as a THREE.CurvePath
     *
     **/

    /**************************************************************
     *	Abstract Curve base class
     **************************************************************/

    function Curve() {}

    Curve.prototype = {

    	constructor: Curve,

    	// Virtual base class method to overwrite and implement in subclasses
    	//	- t [0 .. 1]

    	getPoint: function ( t ) {

    		console.warn( "THREE.Curve: Warning, getPoint() not implemented!" );
    		return null;

    	},

    	// Get point at relative position in curve according to arc length
    	// - u [0 .. 1]

    	getPointAt: function ( u ) {

    		var t = this.getUtoTmapping( u );
    		return this.getPoint( t );

    	},

    	// Get sequence of points using getPoint( t )

    	getPoints: function ( divisions ) {

    		if ( ! divisions ) divisions = 5;

    		var points = [];

    		for ( var d = 0; d <= divisions; d ++ ) {

    			points.push( this.getPoint( d / divisions ) );

    		}

    		return points;

    	},

    	// Get sequence of points using getPointAt( u )

    	getSpacedPoints: function ( divisions ) {

    		if ( ! divisions ) divisions = 5;

    		var points = [];

    		for ( var d = 0; d <= divisions; d ++ ) {

    			points.push( this.getPointAt( d / divisions ) );

    		}

    		return points;

    	},

    	// Get total curve arc length

    	getLength: function () {

    		var lengths = this.getLengths();
    		return lengths[ lengths.length - 1 ];

    	},

    	// Get list of cumulative segment lengths

    	getLengths: function ( divisions ) {

    		if ( ! divisions ) divisions = ( this.__arcLengthDivisions ) ? ( this.__arcLengthDivisions ) : 200;

    		if ( this.cacheArcLengths
    			&& ( this.cacheArcLengths.length === divisions + 1 )
    			&& ! this.needsUpdate ) {

    			//console.log( "cached", this.cacheArcLengths );
    			return this.cacheArcLengths;

    		}

    		this.needsUpdate = false;

    		var cache = [];
    		var current, last = this.getPoint( 0 );
    		var p, sum = 0;

    		cache.push( 0 );

    		for ( p = 1; p <= divisions; p ++ ) {

    			current = this.getPoint ( p / divisions );
    			sum += current.distanceTo( last );
    			cache.push( sum );
    			last = current;

    		}

    		this.cacheArcLengths = cache;

    		return cache; // { sums: cache, sum:sum }; Sum is in the last element.

    	},

    	updateArcLengths: function() {

    		this.needsUpdate = true;
    		this.getLengths();

    	},

    	// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant

    	getUtoTmapping: function ( u, distance ) {

    		var arcLengths = this.getLengths();

    		var i = 0, il = arcLengths.length;

    		var targetArcLength; // The targeted u distance value to get

    		if ( distance ) {

    			targetArcLength = distance;

    		} else {

    			targetArcLength = u * arcLengths[ il - 1 ];

    		}

    		//var time = Date.now();

    		// binary search for the index with largest value smaller than target u distance

    		var low = 0, high = il - 1, comparison;

    		while ( low <= high ) {

    			i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

    			comparison = arcLengths[ i ] - targetArcLength;

    			if ( comparison < 0 ) {

    				low = i + 1;

    			} else if ( comparison > 0 ) {

    				high = i - 1;

    			} else {

    				high = i;
    				break;

    				// DONE

    			}

    		}

    		i = high;

    		//console.log('b' , i, low, high, Date.now()- time);

    		if ( arcLengths[ i ] === targetArcLength ) {

    			var t = i / ( il - 1 );
    			return t;

    		}

    		// we could get finer grain at lengths, or use simple interpolation between two points

    		var lengthBefore = arcLengths[ i ];
    		var lengthAfter = arcLengths[ i + 1 ];

    		var segmentLength = lengthAfter - lengthBefore;

    		// determine where we are between the 'before' and 'after' points

    		var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;

    		// add that fractional amount to t

    		var t = ( i + segmentFraction ) / ( il - 1 );

    		return t;

    	},

    	// Returns a unit vector tangent at t
    	// In case any sub curve does not implement its tangent derivation,
    	// 2 points a small delta apart will be used to find its gradient
    	// which seems to give a reasonable approximation

    	getTangent: function( t ) {

    		var delta = 0.0001;
    		var t1 = t - delta;
    		var t2 = t + delta;

    		// Capping in case of danger

    		if ( t1 < 0 ) t1 = 0;
    		if ( t2 > 1 ) t2 = 1;

    		var pt1 = this.getPoint( t1 );
    		var pt2 = this.getPoint( t2 );

    		var vec = pt2.clone().sub( pt1 );
    		return vec.normalize();

    	},

    	getTangentAt: function ( u ) {

    		var t = this.getUtoTmapping( u );
    		return this.getTangent( t );

    	}

    };

    // TODO: Transformation for Curves?

    /**************************************************************
     *	3D Curves
     **************************************************************/

    // A Factory method for creating new curve subclasses

    Curve.create = function ( constructor, getPointFunc ) {

    	constructor.prototype = Object.create( Curve.prototype );
    	constructor.prototype.constructor = constructor;
    	constructor.prototype.getPoint = getPointFunc;

    	return constructor;

    };

    /**************************************************************
     *	Line
     **************************************************************/

    function LineCurve( v1, v2 ) {

    	this.v1 = v1;
    	this.v2 = v2;

    }

    LineCurve.prototype = Object.create( Curve.prototype );
    LineCurve.prototype.constructor = LineCurve;

    LineCurve.prototype.isLineCurve = true;

    LineCurve.prototype.getPoint = function ( t ) {

    	if ( t === 1 ) {

    		return this.v2.clone();

    	}

    	var point = this.v2.clone().sub( this.v1 );
    	point.multiplyScalar( t ).add( this.v1 );

    	return point;

    };

    // Line curve is linear, so we can overwrite default getPointAt

    LineCurve.prototype.getPointAt = function ( u ) {

    	return this.getPoint( u );

    };

    LineCurve.prototype.getTangent = function( t ) {

    	var tangent = this.v2.clone().sub( this.v1 );

    	return tangent.normalize();

    };

    /**
     * @author zz85 / http://www.lab4games.net/zz85/blog
     *
     **/

    /**************************************************************
     *	Curved Path - a curve path is simply a array of connected
     *  curves, but retains the api of a curve
     **************************************************************/

    function CurvePath() {

    	this.curves = [];

    	this.autoClose = false; // Automatically closes the path

    }

    CurvePath.prototype = Object.assign( Object.create( Curve.prototype ), {

    	constructor: CurvePath,

    	add: function ( curve ) {

    		this.curves.push( curve );

    	},

    	closePath: function () {

    		// Add a line curve if start and end of lines are not connected
    		var startPoint = this.curves[ 0 ].getPoint( 0 );
    		var endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );

    		if ( ! startPoint.equals( endPoint ) ) {

    			this.curves.push( new LineCurve( endPoint, startPoint ) );

    		}

    	},

    	// To get accurate point with reference to
    	// entire path distance at time t,
    	// following has to be done:

    	// 1. Length of each sub path have to be known
    	// 2. Locate and identify type of curve
    	// 3. Get t for the curve
    	// 4. Return curve.getPointAt(t')

    	getPoint: function ( t ) {

    		var d = t * this.getLength();
    		var curveLengths = this.getCurveLengths();
    		var i = 0;

    		// To think about boundaries points.

    		while ( i < curveLengths.length ) {

    			if ( curveLengths[ i ] >= d ) {

    				var diff = curveLengths[ i ] - d;
    				var curve = this.curves[ i ];

    				var segmentLength = curve.getLength();
    				var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;

    				return curve.getPointAt( u );

    			}

    			i ++;

    		}

    		return null;

    		// loop where sum != 0, sum > d , sum+1 <d

    	},

    	// We cannot use the default THREE.Curve getPoint() with getLength() because in
    	// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
    	// getPoint() depends on getLength

    	getLength: function () {

    		var lens = this.getCurveLengths();
    		return lens[ lens.length - 1 ];

    	},

    	// cacheLengths must be recalculated.
    	updateArcLengths: function () {

    		this.needsUpdate = true;
    		this.cacheLengths = null;
    		this.getLengths();

    	},

    	// Compute lengths and cache them
    	// We cannot overwrite getLengths() because UtoT mapping uses it.

    	getCurveLengths: function () {

    		// We use cache values if curves and cache array are same length

    		if ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {

    			return this.cacheLengths;

    		}

    		// Get length of sub-curve
    		// Push sums into cached array

    		var lengths = [], sums = 0;

    		for ( var i = 0, l = this.curves.length; i < l; i ++ ) {

    			sums += this.curves[ i ].getLength();
    			lengths.push( sums );

    		}

    		this.cacheLengths = lengths;

    		return lengths;

    	},

    	getSpacedPoints: function ( divisions ) {

    		if ( ! divisions ) divisions = 40;

    		var points = [];

    		for ( var i = 0; i <= divisions; i ++ ) {

    			points.push( this.getPoint( i / divisions ) );

    		}

    		if ( this.autoClose ) {

    			points.push( points[ 0 ] );

    		}

    		return points;

    	},

    	getPoints: function ( divisions ) {

    		divisions = divisions || 12;

    		var points = [], last;

    		for ( var i = 0, curves = this.curves; i < curves.length; i ++ ) {

    			var curve = curves[ i ];
    			var resolution = (curve && curve.isEllipseCurve) ? divisions * 2
    				: (curve && curve.isLineCurve) ? 1
    				: (curve && curve.isSplineCurve) ? divisions * curve.points.length
    				: divisions;

    			var pts = curve.getPoints( resolution );

    			for ( var j = 0; j < pts.length; j++ ) {

    				var point = pts[ j ];

    				if ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates

    				points.push( point );
    				last = point;

    			}

    		}

    		if ( this.autoClose && points.length > 1 && !points[ points.length - 1 ].equals( points[ 0 ] ) ) {

    			points.push( points[ 0 ] );

    		}

    		return points;

    	},

    	/**************************************************************
    	 *	Create Geometries Helpers
    	 **************************************************************/

    	/// Generate geometry from path points (for Line or Points objects)

    	createPointsGeometry: function ( divisions ) {

    		var pts = this.getPoints( divisions );
    		return this.createGeometry( pts );

    	},

    	// Generate geometry from equidistant sampling along the path

    	createSpacedPointsGeometry: function ( divisions ) {

    		var pts = this.getSpacedPoints( divisions );
    		return this.createGeometry( pts );

    	},

    	createGeometry: function ( points ) {

    		var geometry = new Geometry();

    		for ( var i = 0, l = points.length; i < l; i ++ ) {

    			var point = points[ i ];
    			geometry.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );

    		}

    		return geometry;

    	}

    } );

    /**************************************************************
     *	Ellipse curve
     **************************************************************/

    function EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

    	this.aX = aX;
    	this.aY = aY;

    	this.xRadius = xRadius;
    	this.yRadius = yRadius;

    	this.aStartAngle = aStartAngle;
    	this.aEndAngle = aEndAngle;

    	this.aClockwise = aClockwise;

    	this.aRotation = aRotation || 0;

    }

    EllipseCurve.prototype = Object.create( Curve.prototype );
    EllipseCurve.prototype.constructor = EllipseCurve;

    EllipseCurve.prototype.isEllipseCurve = true;

    EllipseCurve.prototype.getPoint = function( t ) {

    	var twoPi = Math.PI * 2;
    	var deltaAngle = this.aEndAngle - this.aStartAngle;
    	var samePoints = Math.abs( deltaAngle ) < Number.EPSILON;

    	// ensures that deltaAngle is 0 .. 2 PI
    	while ( deltaAngle < 0 ) deltaAngle += twoPi;
    	while ( deltaAngle > twoPi ) deltaAngle -= twoPi;

    	if ( deltaAngle < Number.EPSILON ) {

    		if ( samePoints ) {

    			deltaAngle = 0;

    		} else {

    			deltaAngle = twoPi;

    		}

    	}

    	if ( this.aClockwise === true && ! samePoints ) {

    		if ( deltaAngle === twoPi ) {

    			deltaAngle = - twoPi;

    		} else {

    			deltaAngle = deltaAngle - twoPi;

    		}

    	}

    	var angle = this.aStartAngle + t * deltaAngle;
    	var x = this.aX + this.xRadius * Math.cos( angle );
    	var y = this.aY + this.yRadius * Math.sin( angle );

    	if ( this.aRotation !== 0 ) {

    		var cos = Math.cos( this.aRotation );
    		var sin = Math.sin( this.aRotation );

    		var tx = x - this.aX;
    		var ty = y - this.aY;

    		// Rotate the point about the center of the ellipse.
    		x = tx * cos - ty * sin + this.aX;
    		y = tx * sin + ty * cos + this.aY;

    	}

    	return new Vector2( x, y );

    };

    /**
     * @author zz85 / http://www.lab4games.net/zz85/blog
     */

    exports.CurveUtils = {

    	tangentQuadraticBezier: function ( t, p0, p1, p2 ) {

    		return 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );

    	},

    	// Puay Bing, thanks for helping with this derivative!

    	tangentCubicBezier: function ( t, p0, p1, p2, p3 ) {

    		return - 3 * p0 * ( 1 - t ) * ( 1 - t )  +
    			3 * p1 * ( 1 - t ) * ( 1 - t ) - 6 * t * p1 * ( 1 - t ) +
    			6 * t *  p2 * ( 1 - t ) - 3 * t * t * p2 +
    			3 * t * t * p3;

    	},

    	tangentSpline: function ( t, p0, p1, p2, p3 ) {

    		// To check if my formulas are correct

    		var h00 = 6 * t * t - 6 * t; 	// derived from 2t^3 − 3t^2 + 1
    		var h10 = 3 * t * t - 4 * t + 1; // t^3 − 2t^2 + t
    		var h01 = - 6 * t * t + 6 * t; 	// − 2t3 + 3t2
    		var h11 = 3 * t * t - 2 * t;	// t3 − t2

    		return h00 + h10 + h01 + h11;

    	},

    	// Catmull-Rom

    	interpolate: function( p0, p1, p2, p3, t ) {

    		var v0 = ( p2 - p0 ) * 0.5;
    		var v1 = ( p3 - p1 ) * 0.5;
    		var t2 = t * t;
    		var t3 = t * t2;
    		return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

    	}

    };

    /**************************************************************
     *	Spline curve
     **************************************************************/

    function SplineCurve( points /* array of Vector2 */ ) {

    	this.points = ( points === undefined ) ? [] : points;

    }

    SplineCurve.prototype = Object.create( Curve.prototype );
    SplineCurve.prototype.constructor = SplineCurve;

    SplineCurve.prototype.isSplineCurve = true;

    SplineCurve.prototype.getPoint = function ( t ) {

    	var points = this.points;
    	var point = ( points.length - 1 ) * t;

    	var intPoint = Math.floor( point );
    	var weight = point - intPoint;

    	var point0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];
    	var point1 = points[ intPoint ];
    	var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
    	var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

    	var interpolate = exports.CurveUtils.interpolate;

    	return new Vector2(
    		interpolate( point0.x, point1.x, point2.x, point3.x, weight ),
    		interpolate( point0.y, point1.y, point2.y, point3.y, weight )
    	);

    };

    /**************************************************************
     *	Cubic Bezier curve
     **************************************************************/

    function CubicBezierCurve( v0, v1, v2, v3 ) {

    	this.v0 = v0;
    	this.v1 = v1;
    	this.v2 = v2;
    	this.v3 = v3;

    }

    CubicBezierCurve.prototype = Object.create( Curve.prototype );
    CubicBezierCurve.prototype.constructor = CubicBezierCurve;

    CubicBezierCurve.prototype.getPoint = function ( t ) {

    	var b3 = exports.ShapeUtils.b3;

    	return new Vector2(
    		b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),
    		b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )
    	);

    };

    CubicBezierCurve.prototype.getTangent = function( t ) {

    	var tangentCubicBezier = exports.CurveUtils.tangentCubicBezier;

    	return new Vector2(
    		tangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),
    		tangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )
    	).normalize();

    };

    /**************************************************************
     *	Quadratic Bezier curve
     **************************************************************/


    function QuadraticBezierCurve( v0, v1, v2 ) {

    	this.v0 = v0;
    	this.v1 = v1;
    	this.v2 = v2;

    }

    QuadraticBezierCurve.prototype = Object.create( Curve.prototype );
    QuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;


    QuadraticBezierCurve.prototype.getPoint = function ( t ) {

    	var b2 = exports.ShapeUtils.b2;

    	return new Vector2(
    		b2( t, this.v0.x, this.v1.x, this.v2.x ),
    		b2( t, this.v0.y, this.v1.y, this.v2.y )
    	);

    };


    QuadraticBezierCurve.prototype.getTangent = function( t ) {

    	var tangentQuadraticBezier = exports.CurveUtils.tangentQuadraticBezier;

    	return new Vector2(
    		tangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x ),
    		tangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y )
    	).normalize();

    };

    var PathPrototype = Object.assign( Object.create( CurvePath.prototype ), {

    	fromPoints: function ( vectors ) {

    		this.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );

    		for ( var i = 1, l = vectors.length; i < l; i ++ ) {

    			this.lineTo( vectors[ i ].x, vectors[ i ].y );

    		}

    	},

    	moveTo: function ( x, y ) {

    		this.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?

    	},

    	lineTo: function ( x, y ) {

    		var curve = new LineCurve( this.currentPoint.clone(), new Vector2( x, y ) );
    		this.curves.push( curve );

    		this.currentPoint.set( x, y );

    	},

    	quadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {

    		var curve = new QuadraticBezierCurve(
    			this.currentPoint.clone(),
    			new Vector2( aCPx, aCPy ),
    			new Vector2( aX, aY )
    		);

    		this.curves.push( curve );

    		this.currentPoint.set( aX, aY );

    	},

    	bezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

    		var curve = new CubicBezierCurve(
    			this.currentPoint.clone(),
    			new Vector2( aCP1x, aCP1y ),
    			new Vector2( aCP2x, aCP2y ),
    			new Vector2( aX, aY )
    		);

    		this.curves.push( curve );

    		this.currentPoint.set( aX, aY );

    	},

    	splineThru: function ( pts /*Array of Vector*/ ) {

    		var npts = [ this.currentPoint.clone() ].concat( pts );

    		var curve = new SplineCurve( npts );
    		this.curves.push( curve );

    		this.currentPoint.copy( pts[ pts.length - 1 ] );

    	},

    	arc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

    		var x0 = this.currentPoint.x;
    		var y0 = this.currentPoint.y;

    		this.absarc( aX + x0, aY + y0, aRadius,
    			aStartAngle, aEndAngle, aClockwise );

    	},

    	absarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

    		this.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

    	},

    	ellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

    		var x0 = this.currentPoint.x;
    		var y0 = this.currentPoint.y;

    		this.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

    	},

    	absellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

    		var curve = new EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

    		if ( this.curves.length > 0 ) {

    			// if a previous curve is present, attempt to join
    			var firstPoint = curve.getPoint( 0 );

    			if ( ! firstPoint.equals( this.currentPoint ) ) {

    				this.lineTo( firstPoint.x, firstPoint.y );

    			}

    		}

    		this.curves.push( curve );

    		var lastPoint = curve.getPoint( 1 );
    		this.currentPoint.copy( lastPoint );

    	}

    } );

    /**
     * @author zz85 / http://www.lab4games.net/zz85/blog
     * Defines a 2d shape plane using paths.
     **/

    // STEP 1 Create a path.
    // STEP 2 Turn path into shape.
    // STEP 3 ExtrudeGeometry takes in Shape/Shapes
    // STEP 3a - Extract points from each shape, turn to vertices
    // STEP 3b - Triangulate each shape, add faces.

    function Shape() {

    	Path.apply( this, arguments );

    	this.holes = [];

    }

    Shape.prototype = Object.assign( Object.create( PathPrototype ), {

    	constructor: Shape,

    	getPointsHoles: function ( divisions ) {

    		var holesPts = [];

    		for ( var i = 0, l = this.holes.length; i < l; i ++ ) {

    			holesPts[ i ] = this.holes[ i ].getPoints( divisions );

    		}

    		return holesPts;

    	},

    	// Get points of shape and holes (keypoints based on segments parameter)

    	extractAllPoints: function ( divisions ) {

    		return {

    			shape: this.getPoints( divisions ),
    			holes: this.getPointsHoles( divisions )

    		};

    	},

    	extractPoints: function ( divisions ) {

    		return this.extractAllPoints( divisions );

    	}

    } );

    /**
     * @author zz85 / http://www.lab4games.net/zz85/blog
     * Creates free form 2d path using series of points, lines or curves.
     *
     **/

    function Path( points ) {

    	CurvePath.call( this );
    	this.currentPoint = new Vector2();

    	if ( points ) {

    		this.fromPoints( points );

    	}

    }

    Path.prototype = PathPrototype;
    PathPrototype.constructor = Path;


    // minimal class for proxing functions to Path. Replaces old "extractSubpaths()"
    function ShapePath() {
    	this.subPaths = [];
    	this.currentPath = null;
    }

    ShapePath.prototype = {
    	moveTo: function ( x, y ) {
    		this.currentPath = new Path();
    		this.subPaths.push(this.currentPath);
    		this.currentPath.moveTo( x, y );
    	},
    	lineTo: function ( x, y ) {
    		this.currentPath.lineTo( x, y );
    	},
    	quadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {
    		this.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY );
    	},
    	bezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {
    		this.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY );
    	},
    	splineThru: function ( pts ) {
    		this.currentPath.splineThru( pts );
    	},

    	toShapes: function ( isCCW, noHoles ) {

    		function toShapesNoHoles( inSubpaths ) {

    			var shapes = [];

    			for ( var i = 0, l = inSubpaths.length; i < l; i ++ ) {

    				var tmpPath = inSubpaths[ i ];

    				var tmpShape = new Shape();
    				tmpShape.curves = tmpPath.curves;

    				shapes.push( tmpShape );

    			}

    			return shapes;

    		}

    		function isPointInsidePolygon( inPt, inPolygon ) {

    			var polyLen = inPolygon.length;

    			// inPt on polygon contour => immediate success    or
    			// toggling of inside/outside at every single! intersection point of an edge
    			//  with the horizontal line through inPt, left of inPt
    			//  not counting lowerY endpoints of edges and whole edges on that line
    			var inside = false;
    			for ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {

    				var edgeLowPt  = inPolygon[ p ];
    				var edgeHighPt = inPolygon[ q ];

    				var edgeDx = edgeHighPt.x - edgeLowPt.x;
    				var edgeDy = edgeHighPt.y - edgeLowPt.y;

    				if ( Math.abs( edgeDy ) > Number.EPSILON ) {

    					// not parallel
    					if ( edgeDy < 0 ) {

    						edgeLowPt  = inPolygon[ q ]; edgeDx = - edgeDx;
    						edgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;

    					}
    					if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) 		continue;

    					if ( inPt.y === edgeLowPt.y ) {

    						if ( inPt.x === edgeLowPt.x )		return	true;		// inPt is on contour ?
    						// continue;				// no intersection or edgeLowPt => doesn't count !!!

    					} else {

    						var perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );
    						if ( perpEdge === 0 )				return	true;		// inPt is on contour ?
    						if ( perpEdge < 0 ) 				continue;
    						inside = ! inside;		// true intersection left of inPt

    					}

    				} else {

    					// parallel or collinear
    					if ( inPt.y !== edgeLowPt.y ) 		continue;			// parallel
    					// edge lies on the same horizontal line as inPt
    					if ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||
    						 ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )		return	true;	// inPt: Point on contour !
    					// continue;

    				}

    			}

    			return	inside;

    		}

    		var isClockWise = exports.ShapeUtils.isClockWise;

    		var subPaths = this.subPaths;
    		if ( subPaths.length === 0 ) return [];

    		if ( noHoles === true )	return	toShapesNoHoles( subPaths );


    		var solid, tmpPath, tmpShape, shapes = [];

    		if ( subPaths.length === 1 ) {

    			tmpPath = subPaths[ 0 ];
    			tmpShape = new Shape();
    			tmpShape.curves = tmpPath.curves;
    			shapes.push( tmpShape );
    			return shapes;

    		}

    		var holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );
    		holesFirst = isCCW ? ! holesFirst : holesFirst;

    		// console.log("Holes first", holesFirst);

    		var betterShapeHoles = [];
    		var newShapes = [];
    		var newShapeHoles = [];
    		var mainIdx = 0;
    		var tmpPoints;

    		newShapes[ mainIdx ] = undefined;
    		newShapeHoles[ mainIdx ] = [];

    		for ( var i = 0, l = subPaths.length; i < l; i ++ ) {

    			tmpPath = subPaths[ i ];
    			tmpPoints = tmpPath.getPoints();
    			solid = isClockWise( tmpPoints );
    			solid = isCCW ? ! solid : solid;

    			if ( solid ) {

    				if ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )	mainIdx ++;

    				newShapes[ mainIdx ] = { s: new Shape(), p: tmpPoints };
    				newShapes[ mainIdx ].s.curves = tmpPath.curves;

    				if ( holesFirst )	mainIdx ++;
    				newShapeHoles[ mainIdx ] = [];

    				//console.log('cw', i);

    			} else {

    				newShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );

    				//console.log('ccw', i);

    			}

    		}

    		// only Holes? -> probably all Shapes with wrong orientation
    		if ( ! newShapes[ 0 ] )	return	toShapesNoHoles( subPaths );


    		if ( newShapes.length > 1 ) {

    			var ambiguous = false;
    			var toChange = [];

    			for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

    				betterShapeHoles[ sIdx ] = [];

    			}

    			for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

    				var sho = newShapeHoles[ sIdx ];

    				for ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {

    					var ho = sho[ hIdx ];
    					var hole_unassigned = true;

    					for ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {

    						if ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {

    							if ( sIdx !== s2Idx )	toChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );
    							if ( hole_unassigned ) {

    								hole_unassigned = false;
    								betterShapeHoles[ s2Idx ].push( ho );

    							} else {

    								ambiguous = true;

    							}

    						}

    					}
    					if ( hole_unassigned ) {

    						betterShapeHoles[ sIdx ].push( ho );

    					}

    				}

    			}
    			// console.log("ambiguous: ", ambiguous);
    			if ( toChange.length > 0 ) {

    				// console.log("to change: ", toChange);
    				if ( ! ambiguous )	newShapeHoles = betterShapeHoles;

    			}

    		}

    		var tmpHoles;

    		for ( var i = 0, il = newShapes.length; i < il; i ++ ) {

    			tmpShape = newShapes[ i ].s;
    			shapes.push( tmpShape );
    			tmpHoles = newShapeHoles[ i ];

    			for ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) {

    				tmpShape.holes.push( tmpHoles[ j ].h );

    			}

    		}

    		//console.log("shape", shapes);

    		return shapes;

    	}
    }

    /**
     * @author zz85 / http://www.lab4games.net/zz85/blog
     * @author mrdoob / http://mrdoob.com/
     */

    function Font( data ) {

    	this.data = data;

    }

    Object.assign( Font.prototype, {

    	isFont: true,

    	generateShapes: function ( text, size, divisions ) {

    		function createPaths( text ) {

    			var chars = String( text ).split( '' );
    			var scale = size / data.resolution;
    			var offset = 0;

    			var paths = [];

    			for ( var i = 0; i < chars.length; i ++ ) {

    				var ret = createPath( chars[ i ], scale, offset );
    				offset += ret.offset;

    				paths.push( ret.path );

    			}

    			return paths;

    		}

    		function createPath( c, scale, offset ) {

    			var glyph = data.glyphs[ c ] || data.glyphs[ '?' ];

    			if ( ! glyph ) return;

    			var path = new ShapePath();

    			var pts = [], b2 = exports.ShapeUtils.b2, b3 = exports.ShapeUtils.b3;
    			var x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2, laste;

    			if ( glyph.o ) {

    				var outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );

    				for ( var i = 0, l = outline.length; i < l; ) {

    					var action = outline[ i ++ ];

    					switch ( action ) {

    						case 'm': // moveTo

    							x = outline[ i ++ ] * scale + offset;
    							y = outline[ i ++ ] * scale;

    							path.moveTo( x, y );

    							break;

    						case 'l': // lineTo

    							x = outline[ i ++ ] * scale + offset;
    							y = outline[ i ++ ] * scale;

    							path.lineTo( x, y );

    							break;

    						case 'q': // quadraticCurveTo

    							cpx  = outline[ i ++ ] * scale + offset;
    							cpy  = outline[ i ++ ] * scale;
    							cpx1 = outline[ i ++ ] * scale + offset;
    							cpy1 = outline[ i ++ ] * scale;

    							path.quadraticCurveTo( cpx1, cpy1, cpx, cpy );

    							laste = pts[ pts.length - 1 ];

    							if ( laste ) {

    								cpx0 = laste.x;
    								cpy0 = laste.y;

    								for ( var i2 = 1; i2 <= divisions; i2 ++ ) {

    									var t = i2 / divisions;
    									b2( t, cpx0, cpx1, cpx );
    									b2( t, cpy0, cpy1, cpy );

    								}

    							}

    							break;

    						case 'b': // bezierCurveTo

    							cpx  = outline[ i ++ ] * scale + offset;
    							cpy  = outline[ i ++ ] * scale;
    							cpx1 = outline[ i ++ ] * scale + offset;
    							cpy1 = outline[ i ++ ] * scale;
    							cpx2 = outline[ i ++ ] * scale + offset;
    							cpy2 = outline[ i ++ ] * scale;

    							path.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );

    							laste = pts[ pts.length - 1 ];

    							if ( laste ) {

    								cpx0 = laste.x;
    								cpy0 = laste.y;

    								for ( var i2 = 1; i2 <= divisions; i2 ++ ) {

    									var t = i2 / divisions;
    									b3( t, cpx0, cpx1, cpx2, cpx );
    									b3( t, cpy0, cpy1, cpy2, cpy );

    								}

    							}

    							break;

    					}

    				}

    			}

    			return { offset: glyph.ha * scale, path: path };

    		}

    		//

    		if ( size === undefined ) size = 100;
    		if ( divisions === undefined ) divisions = 4;

    		var data = this.data;

    		var paths = createPaths( text );
    		var shapes = [];

    		for ( var p = 0, pl = paths.length; p < pl; p ++ ) {

    			Array.prototype.push.apply( shapes, paths[ p ].toShapes() );

    		}

    		return shapes;

    	}

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function FontLoader( manager ) {

    	this.manager = ( manager !== undefined ) ? manager : exports.DefaultLoadingManager;

    }

    Object.assign( FontLoader.prototype, {

    	load: function ( url, onLoad, onProgress, onError ) {

    		var scope = this;

    		var loader = new XHRLoader( this.manager );
    		loader.load( url, function ( text ) {

    			var json;

    			try {

    				json = JSON.parse( text );

    			} catch ( e ) {

    				console.warn( 'THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.' );
    				json = JSON.parse( text.substring( 65, text.length - 2 ) );

    			}

    			var font = scope.parse( json );

    			if ( onLoad ) onLoad( font );

    		}, onProgress, onError );

    	},

    	parse: function ( json ) {

    		return new Font( json );

    	}

    } );

    var context;

    function getAudioContext() {

    	if ( context === undefined ) {

    		context = new ( window.AudioContext || window.webkitAudioContext )();

    	}

    	return context;

    }

    /**
     * @author Reece Aaron Lecrivain / http://reecenotes.com/
     */

    function AudioLoader( manager ) {

    	this.manager = ( manager !== undefined ) ? manager : exports.DefaultLoadingManager;

    }

    Object.assign( AudioLoader.prototype, {

    	load: function ( url, onLoad, onProgress, onError ) {

    		var loader = new XHRLoader( this.manager );
    		loader.setResponseType( 'arraybuffer' );
    		loader.load( url, function ( buffer ) {

    			var context = getAudioContext();

    			context.decodeAudioData( buffer, function ( audioBuffer ) {

    				onLoad( audioBuffer );

    			} );

    		}, onProgress, onError );

    	}

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function StereoCamera() {

    	this.type = 'StereoCamera';

    	this.aspect = 1;

    	this.eyeSep = 0.064;

    	this.cameraL = new PerspectiveCamera();
    	this.cameraL.layers.enable( 1 );
    	this.cameraL.matrixAutoUpdate = false;

    	this.cameraR = new PerspectiveCamera();
    	this.cameraR.layers.enable( 2 );
    	this.cameraR.matrixAutoUpdate = false;

    }

    Object.assign( StereoCamera.prototype, {

    	update: ( function () {

    		var instance, focus, fov, aspect, near, far, zoom;

    		var eyeRight = new Matrix4();
    		var eyeLeft = new Matrix4();

    		return function update( camera ) {

    			var needsUpdate = instance !== this || focus !== camera.focus || fov !== camera.fov ||
    												aspect !== camera.aspect * this.aspect || near !== camera.near ||
    												far !== camera.far || zoom !== camera.zoom;

    			if ( needsUpdate ) {

    				instance = this;
    				focus = camera.focus;
    				fov = camera.fov;
    				aspect = camera.aspect * this.aspect;
    				near = camera.near;
    				far = camera.far;
    				zoom = camera.zoom;

    				// Off-axis stereoscopic effect based on
    				// http://paulbourke.net/stereographics/stereorender/

    				var projectionMatrix = camera.projectionMatrix.clone();
    				var eyeSep = this.eyeSep / 2;
    				var eyeSepOnProjection = eyeSep * near / focus;
    				var ymax = ( near * Math.tan( exports.Math.DEG2RAD * fov * 0.5 ) ) / zoom;
    				var xmin, xmax;

    				// translate xOffset

    				eyeLeft.elements[ 12 ] = - eyeSep;
    				eyeRight.elements[ 12 ] = eyeSep;

    				// for left eye

    				xmin = - ymax * aspect + eyeSepOnProjection;
    				xmax = ymax * aspect + eyeSepOnProjection;

    				projectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );
    				projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

    				this.cameraL.projectionMatrix.copy( projectionMatrix );

    				// for right eye

    				xmin = - ymax * aspect - eyeSepOnProjection;
    				xmax = ymax * aspect - eyeSepOnProjection;

    				projectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );
    				projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

    				this.cameraR.projectionMatrix.copy( projectionMatrix );

    			}

    			this.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( eyeLeft );
    			this.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( eyeRight );

    		};

    	} )()

    } );

    /**
     * Camera for rendering cube maps
     *	- renders scene into axis-aligned cube
     *
     * @author alteredq / http://alteredqualia.com/
     */

    function CubeCamera( near, far, cubeResolution ) {

    	Object3D.call( this );

    	this.type = 'CubeCamera';

    	var fov = 90, aspect = 1;

    	var cameraPX = new PerspectiveCamera( fov, aspect, near, far );
    	cameraPX.up.set( 0, - 1, 0 );
    	cameraPX.lookAt( new Vector3( 1, 0, 0 ) );
    	this.add( cameraPX );

    	var cameraNX = new PerspectiveCamera( fov, aspect, near, far );
    	cameraNX.up.set( 0, - 1, 0 );
    	cameraNX.lookAt( new Vector3( - 1, 0, 0 ) );
    	this.add( cameraNX );

    	var cameraPY = new PerspectiveCamera( fov, aspect, near, far );
    	cameraPY.up.set( 0, 0, 1 );
    	cameraPY.lookAt( new Vector3( 0, 1, 0 ) );
    	this.add( cameraPY );

    	var cameraNY = new PerspectiveCamera( fov, aspect, near, far );
    	cameraNY.up.set( 0, 0, - 1 );
    	cameraNY.lookAt( new Vector3( 0, - 1, 0 ) );
    	this.add( cameraNY );

    	var cameraPZ = new PerspectiveCamera( fov, aspect, near, far );
    	cameraPZ.up.set( 0, - 1, 0 );
    	cameraPZ.lookAt( new Vector3( 0, 0, 1 ) );
    	this.add( cameraPZ );

    	var cameraNZ = new PerspectiveCamera( fov, aspect, near, far );
    	cameraNZ.up.set( 0, - 1, 0 );
    	cameraNZ.lookAt( new Vector3( 0, 0, - 1 ) );
    	this.add( cameraNZ );

    	var options = { format: RGBFormat, magFilter: LinearFilter, minFilter: LinearFilter };

    	this.renderTarget = new WebGLRenderTargetCube( cubeResolution, cubeResolution, options );

    	this.updateCubeMap = function ( renderer, scene ) {

    		if ( this.parent === null ) this.updateMatrixWorld();

    		var renderTarget = this.renderTarget;
    		var generateMipmaps = renderTarget.texture.generateMipmaps;

    		renderTarget.texture.generateMipmaps = false;

    		renderTarget.activeCubeFace = 0;
    		renderer.render( scene, cameraPX, renderTarget );

    		renderTarget.activeCubeFace = 1;
    		renderer.render( scene, cameraNX, renderTarget );

    		renderTarget.activeCubeFace = 2;
    		renderer.render( scene, cameraPY, renderTarget );

    		renderTarget.activeCubeFace = 3;
    		renderer.render( scene, cameraNY, renderTarget );

    		renderTarget.activeCubeFace = 4;
    		renderer.render( scene, cameraPZ, renderTarget );

    		renderTarget.texture.generateMipmaps = generateMipmaps;

    		renderTarget.activeCubeFace = 5;
    		renderer.render( scene, cameraNZ, renderTarget );

    		renderer.setRenderTarget( null );

    	};

    }

    CubeCamera.prototype = Object.create( Object3D.prototype );
    CubeCamera.prototype.constructor = CubeCamera;

    function AudioListener() {

    	Object3D.call( this );

    	this.type = 'AudioListener';

    	this.context = getAudioContext();

    	this.gain = this.context.createGain();
    	this.gain.connect( this.context.destination );

    	this.filter = null;

    }

    AudioListener.prototype = Object.assign( Object.create( Object3D.prototype ), {

    	constructor: AudioListener,

    	getInput: function () {

    		return this.gain;

    	},

    	removeFilter: function ( ) {

    		if ( this.filter !== null ) {

    			this.gain.disconnect( this.filter );
    			this.filter.disconnect( this.context.destination );
    			this.gain.connect( this.context.destination );
    			this.filter = null;

    		}

    	},

    	getFilter: function () {

    		return this.filter;

    	},

    	setFilter: function ( value ) {

    		if ( this.filter !== null ) {

    			this.gain.disconnect( this.filter );
    			this.filter.disconnect( this.context.destination );

    		} else {

    			this.gain.disconnect( this.context.destination );

    		}

    		this.filter = value;
    		this.gain.connect( this.filter );
    		this.filter.connect( this.context.destination );

    	},

    	getMasterVolume: function () {

    		return this.gain.gain.value;

    	},

    	setMasterVolume: function ( value ) {

    		this.gain.gain.value = value;

    	},

    	updateMatrixWorld: ( function () {

    		var position = new Vector3();
    		var quaternion = new Quaternion();
    		var scale = new Vector3();

    		var orientation = new Vector3();

    		return function updateMatrixWorld( force ) {

    			Object3D.prototype.updateMatrixWorld.call( this, force );

    			var listener = this.context.listener;
    			var up = this.up;

    			this.matrixWorld.decompose( position, quaternion, scale );

    			orientation.set( 0, 0, - 1 ).applyQuaternion( quaternion );

    			listener.setPosition( position.x, position.y, position.z );
    			listener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );

    		};

    	} )()

    } );

    function Audio( listener ) {

    	Object3D.call( this );

    	this.type = 'Audio';

    	this.context = listener.context;
    	this.source = this.context.createBufferSource();
    	this.source.onended = this.onEnded.bind( this );

    	this.gain = this.context.createGain();
    	this.gain.connect( listener.getInput() );

    	this.autoplay = false;

    	this.startTime = 0;
    	this.playbackRate = 1;
    	this.isPlaying = false;
    	this.hasPlaybackControl = true;
    	this.sourceType = 'empty';

    	this.filters = [];

    }

    Audio.prototype = Object.assign( Object.create( Object3D.prototype ), {

    	constructor: Audio,

    	getOutput: function () {

    		return this.gain;

    	},

    	setNodeSource: function ( audioNode ) {

    		this.hasPlaybackControl = false;
    		this.sourceType = 'audioNode';
    		this.source = audioNode;
    		this.connect();

    		return this;

    	},

    	setBuffer: function ( audioBuffer ) {

    		this.source.buffer = audioBuffer;
    		this.sourceType = 'buffer';

    		if ( this.autoplay ) this.play();

    		return this;

    	},

    	play: function () {

    		if ( this.isPlaying === true ) {

    			console.warn( 'THREE.Audio: Audio is already playing.' );
    			return;

    		}

    		if ( this.hasPlaybackControl === false ) {

    			console.warn( 'THREE.Audio: this Audio has no playback control.' );
    			return;

    		}

    		var source = this.context.createBufferSource();

    		source.buffer = this.source.buffer;
    		source.loop = this.source.loop;
    		source.onended = this.source.onended;
    		source.start( 0, this.startTime );
    		source.playbackRate.value = this.playbackRate;

    		this.isPlaying = true;

    		this.source = source;

    		return this.connect();

    	},

    	pause: function () {

    		if ( this.hasPlaybackControl === false ) {

    			console.warn( 'THREE.Audio: this Audio has no playback control.' );
    			return;

    		}

    		this.source.stop();
    		this.startTime = this.context.currentTime;
    		this.isPlaying = false;

    		return this;

    	},

    	stop: function () {

    		if ( this.hasPlaybackControl === false ) {

    			console.warn( 'THREE.Audio: this Audio has no playback control.' );
    			return;

    		}

    		this.source.stop();
    		this.startTime = 0;
    		this.isPlaying = false;

    		return this;

    	},

    	connect: function () {

    		if ( this.filters.length > 0 ) {

    			this.source.connect( this.filters[ 0 ] );

    			for ( var i = 1, l = this.filters.length; i < l; i ++ ) {

    				this.filters[ i - 1 ].connect( this.filters[ i ] );

    			}

    			this.filters[ this.filters.length - 1 ].connect( this.getOutput() );

    		} else {

    			this.source.connect( this.getOutput() );

    		}

    		return this;

    	},

    	disconnect: function () {

    		if ( this.filters.length > 0 ) {

    			this.source.disconnect( this.filters[ 0 ] );

    			for ( var i = 1, l = this.filters.length; i < l; i ++ ) {

    				this.filters[ i - 1 ].disconnect( this.filters[ i ] );

    			}

    			this.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );

    		} else {

    			this.source.disconnect( this.getOutput() );

    		}

    		return this;

    	},

    	getFilters: function () {

    		return this.filters;

    	},

    	setFilters: function ( value ) {

    		if ( ! value ) value = [];

    		if ( this.isPlaying === true ) {

    			this.disconnect();
    			this.filters = value;
    			this.connect();

    		} else {

    			this.filters = value;

    		}

    		return this;

    	},

    	getFilter: function () {

    		return this.getFilters()[ 0 ];

    	},

    	setFilter: function ( filter ) {

    		return this.setFilters( filter ? [ filter ] : [] );

    	},

    	setPlaybackRate: function ( value ) {

    		if ( this.hasPlaybackControl === false ) {

    			console.warn( 'THREE.Audio: this Audio has no playback control.' );
    			return;

    		}

    		this.playbackRate = value;

    		if ( this.isPlaying === true ) {

    			this.source.playbackRate.value = this.playbackRate;

    		}

    		return this;

    	},

    	getPlaybackRate: function () {

    		return this.playbackRate;

    	},

    	onEnded: function () {

    		this.isPlaying = false;

    	},

    	getLoop: function () {

    		if ( this.hasPlaybackControl === false ) {

    			console.warn( 'THREE.Audio: this Audio has no playback control.' );
    			return false;

    		}

    		return this.source.loop;

    	},

    	setLoop: function ( value ) {

    		if ( this.hasPlaybackControl === false ) {

    			console.warn( 'THREE.Audio: this Audio has no playback control.' );
    			return;

    		}

    		this.source.loop = value;

    	},

    	getVolume: function () {

    		return this.gain.gain.value;

    	},


    	setVolume: function ( value ) {

    		this.gain.gain.value = value;

    		return this;

    	}

    } );

    function PositionalAudio( listener ) {

    	Audio.call( this, listener );

    	this.panner = this.context.createPanner();
    	this.panner.connect( this.gain );

    }

    PositionalAudio.prototype = Object.assign( Object.create( Audio.prototype ), {

    	constructor: PositionalAudio,

    	getOutput: function () {

    		return this.panner;

    	},

    	getRefDistance: function () {

    		return this.panner.refDistance;

    	},

    	setRefDistance: function ( value ) {

    		this.panner.refDistance = value;

    	},

    	getRolloffFactor: function () {

    		return this.panner.rolloffFactor;

    	},

    	setRolloffFactor: function ( value ) {

    		this.panner.rolloffFactor = value;

    	},

    	getDistanceModel: function () {

    		return this.panner.distanceModel;

    	},

    	setDistanceModel: function ( value ) {

    		this.panner.distanceModel = value;

    	},

    	getMaxDistance: function () {

    		return this.panner.maxDistance;

    	},

    	setMaxDistance: function ( value ) {

    		this.panner.maxDistance = value;

    	},

    	updateMatrixWorld: ( function () {

    		var position = new Vector3();

    		return function updateMatrixWorld( force ) {

    			Object3D.prototype.updateMatrixWorld.call( this, force );

    			position.setFromMatrixPosition( this.matrixWorld );

    			this.panner.setPosition( position.x, position.y, position.z );

    		};

    	} )()


    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function AudioAnalyser( audio, fftSize ) {

    	this.analyser = audio.context.createAnalyser();
    	this.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;

    	this.data = new Uint8Array( this.analyser.frequencyBinCount );

    	audio.getOutput().connect( this.analyser );

    }

    Object.assign( AudioAnalyser.prototype, {

    	getFrequencyData: function () {

    		this.analyser.getByteFrequencyData( this.data );

    		return this.data;

    	},

    	getAverageFrequency: function () {

    		var value = 0, data = this.getFrequencyData();

    		for ( var i = 0; i < data.length; i ++ ) {

    			value += data[ i ];

    		}

    		return value / data.length;

    	}

    } );

    /**
     *
     * Buffered scene graph property that allows weighted accumulation.
     *
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     */

    function PropertyMixer( binding, typeName, valueSize ) {

    	this.binding = binding;
    	this.valueSize = valueSize;

    	var bufferType = Float64Array,
    		mixFunction;

    	switch ( typeName ) {

    		case 'quaternion':			mixFunction = this._slerp;		break;

    		case 'string':
    		case 'bool':

    			bufferType = Array,		mixFunction = this._select;		break;

    		default:					mixFunction = this._lerp;

    	}

    	this.buffer = new bufferType( valueSize * 4 );
    	// layout: [ incoming | accu0 | accu1 | orig ]
    	//
    	// interpolators can use .buffer as their .result
    	// the data then goes to 'incoming'
    	//
    	// 'accu0' and 'accu1' are used frame-interleaved for
    	// the cumulative result and are compared to detect
    	// changes
    	//
    	// 'orig' stores the original state of the property

    	this._mixBufferRegion = mixFunction;

    	this.cumulativeWeight = 0;

    	this.useCount = 0;
    	this.referenceCount = 0;

    }

    PropertyMixer.prototype = {

    	constructor: PropertyMixer,

    	// accumulate data in the 'incoming' region into 'accu<i>'
    	accumulate: function( accuIndex, weight ) {

    		// note: happily accumulating nothing when weight = 0, the caller knows
    		// the weight and shouldn't have made the call in the first place

    		var buffer = this.buffer,
    			stride = this.valueSize,
    			offset = accuIndex * stride + stride,

    			currentWeight = this.cumulativeWeight;

    		if ( currentWeight === 0 ) {

    			// accuN := incoming * weight

    			for ( var i = 0; i !== stride; ++ i ) {

    				buffer[ offset + i ] = buffer[ i ];

    			}

    			currentWeight = weight;

    		} else {

    			// accuN := accuN + incoming * weight

    			currentWeight += weight;
    			var mix = weight / currentWeight;
    			this._mixBufferRegion( buffer, offset, 0, mix, stride );

    		}

    		this.cumulativeWeight = currentWeight;

    	},

    	// apply the state of 'accu<i>' to the binding when accus differ
    	apply: function( accuIndex ) {

    		var stride = this.valueSize,
    			buffer = this.buffer,
    			offset = accuIndex * stride + stride,

    			weight = this.cumulativeWeight,

    			binding = this.binding;

    		this.cumulativeWeight = 0;

    		if ( weight < 1 ) {

    			// accuN := accuN + original * ( 1 - cumulativeWeight )

    			var originalValueOffset = stride * 3;

    			this._mixBufferRegion(
    					buffer, offset, originalValueOffset, 1 - weight, stride );

    		}

    		for ( var i = stride, e = stride + stride; i !== e; ++ i ) {

    			if ( buffer[ i ] !== buffer[ i + stride ] ) {

    				// value has changed -> update scene graph

    				binding.setValue( buffer, offset );
    				break;

    			}

    		}

    	},

    	// remember the state of the bound property and copy it to both accus
    	saveOriginalState: function() {

    		var binding = this.binding;

    		var buffer = this.buffer,
    			stride = this.valueSize,

    			originalValueOffset = stride * 3;

    		binding.getValue( buffer, originalValueOffset );

    		// accu[0..1] := orig -- initially detect changes against the original
    		for ( var i = stride, e = originalValueOffset; i !== e; ++ i ) {

    			buffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];

    		}

    		this.cumulativeWeight = 0;

    	},

    	// apply the state previously taken via 'saveOriginalState' to the binding
    	restoreOriginalState: function() {

    		var originalValueOffset = this.valueSize * 3;
    		this.binding.setValue( this.buffer, originalValueOffset );

    	},


    	// mix functions

    	_select: function( buffer, dstOffset, srcOffset, t, stride ) {

    		if ( t >= 0.5 ) {

    			for ( var i = 0; i !== stride; ++ i ) {

    				buffer[ dstOffset + i ] = buffer[ srcOffset + i ];

    			}

    		}

    	},

    	_slerp: function( buffer, dstOffset, srcOffset, t, stride ) {

    		Quaternion.slerpFlat( buffer, dstOffset,
    				buffer, dstOffset, buffer, srcOffset, t );

    	},

    	_lerp: function( buffer, dstOffset, srcOffset, t, stride ) {

    		var s = 1 - t;

    		for ( var i = 0; i !== stride; ++ i ) {

    			var j = dstOffset + i;

    			buffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;

    		}

    	}

    };

    /**
     *
     * A reference to a real property in the scene graph.
     *
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     */

    function PropertyBinding( rootNode, path, parsedPath ) {

    	this.path = path;
    	this.parsedPath = parsedPath ||
    			PropertyBinding.parseTrackName( path );

    	this.node = PropertyBinding.findNode(
    			rootNode, this.parsedPath.nodeName ) || rootNode;

    	this.rootNode = rootNode;

    }

    PropertyBinding.prototype = {

    	constructor: PropertyBinding,

    	getValue: function getValue_unbound( targetArray, offset ) {

    		this.bind();
    		this.getValue( targetArray, offset );

    		// Note: This class uses a State pattern on a per-method basis:
    		// 'bind' sets 'this.getValue' / 'setValue' and shadows the
    		// prototype version of these methods with one that represents
    		// the bound state. When the property is not found, the methods
    		// become no-ops.

    	},

    	setValue: function getValue_unbound( sourceArray, offset ) {

    		this.bind();
    		this.setValue( sourceArray, offset );

    	},

    	// create getter / setter pair for a property in the scene graph
    	bind: function() {

    		var targetObject = this.node,
    			parsedPath = this.parsedPath,

    			objectName = parsedPath.objectName,
    			propertyName = parsedPath.propertyName,
    			propertyIndex = parsedPath.propertyIndex;

    		if ( ! targetObject ) {

    			targetObject = PropertyBinding.findNode(
    					this.rootNode, parsedPath.nodeName ) || this.rootNode;

    			this.node = targetObject;

    		}

    		// set fail state so we can just 'return' on error
    		this.getValue = this._getValue_unavailable;
    		this.setValue = this._setValue_unavailable;

     		// ensure there is a value node
    		if ( ! targetObject ) {

    			console.error( "  trying to update node for track: " + this.path + " but it wasn't found." );
    			return;

    		}

    		if ( objectName ) {

    			var objectIndex = parsedPath.objectIndex;

    			// special cases were we need to reach deeper into the hierarchy to get the face materials....
    			switch ( objectName ) {

    				case 'materials':

    					if ( ! targetObject.material ) {

    						console.error( '  can not bind to material as node does not have a material', this );
    						return;

    					}

    					if ( ! targetObject.material.materials ) {

    						console.error( '  can not bind to material.materials as node.material does not have a materials array', this );
    						return;

    					}

    					targetObject = targetObject.material.materials;

    					break;

    				case 'bones':

    					if ( ! targetObject.skeleton ) {

    						console.error( '  can not bind to bones as node does not have a skeleton', this );
    						return;

    					}

    					// potential future optimization: skip this if propertyIndex is already an integer
    					// and convert the integer string to a true integer.

    					targetObject = targetObject.skeleton.bones;

    					// support resolving morphTarget names into indices.
    					for ( var i = 0; i < targetObject.length; i ++ ) {

    						if ( targetObject[ i ].name === objectIndex ) {

    							objectIndex = i;
    							break;

    						}

    					}

    					break;

    				default:

    					if ( targetObject[ objectName ] === undefined ) {

    						console.error( '  can not bind to objectName of node, undefined', this );
    						return;

    					}

    					targetObject = targetObject[ objectName ];

    			}


    			if ( objectIndex !== undefined ) {

    				if ( targetObject[ objectIndex ] === undefined ) {

    					console.error( "  trying to bind to objectIndex of objectName, but is undefined:", this, targetObject );
    					return;

    				}

    				targetObject = targetObject[ objectIndex ];

    			}

    		}

    		// resolve property
    		var nodeProperty = targetObject[ propertyName ];

    		if ( nodeProperty === undefined ) {

    			var nodeName = parsedPath.nodeName;

    			console.error( "  trying to update property for track: " + nodeName +
    					'.' + propertyName + " but it wasn't found.", targetObject );
    			return;

    		}

    		// determine versioning scheme
    		var versioning = this.Versioning.None;

    		if ( targetObject.needsUpdate !== undefined ) { // material

    			versioning = this.Versioning.NeedsUpdate;
    			this.targetObject = targetObject;

    		} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform

    			versioning = this.Versioning.MatrixWorldNeedsUpdate;
    			this.targetObject = targetObject;

    		}

    		// determine how the property gets bound
    		var bindingType = this.BindingType.Direct;

    		if ( propertyIndex !== undefined ) {
    			// access a sub element of the property array (only primitives are supported right now)

    			if ( propertyName === "morphTargetInfluences" ) {
    				// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.

    				// support resolving morphTarget names into indices.
    				if ( ! targetObject.geometry ) {

    					console.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry', this );
    					return;

    				}

    				if ( ! targetObject.geometry.morphTargets ) {

    					console.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets', this );
    					return;

    				}

    				for ( var i = 0; i < this.node.geometry.morphTargets.length; i ++ ) {

    					if ( targetObject.geometry.morphTargets[ i ].name === propertyIndex ) {

    						propertyIndex = i;
    						break;

    					}

    				}

    			}

    			bindingType = this.BindingType.ArrayElement;

    			this.resolvedProperty = nodeProperty;
    			this.propertyIndex = propertyIndex;

    		} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {
    			// must use copy for Object3D.Euler/Quaternion

    			bindingType = this.BindingType.HasFromToArray;

    			this.resolvedProperty = nodeProperty;

    		} else if ( nodeProperty.length !== undefined ) {

    			bindingType = this.BindingType.EntireArray;

    			this.resolvedProperty = nodeProperty;

    		} else {

    			this.propertyName = propertyName;

    		}

    		// select getter / setter
    		this.getValue = this.GetterByBindingType[ bindingType ];
    		this.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];

    	},

    	unbind: function() {

    		this.node = null;

    		// back to the prototype version of getValue / setValue
    		// note: avoiding to mutate the shape of 'this' via 'delete'
    		this.getValue = this._getValue_unbound;
    		this.setValue = this._setValue_unbound;

    	}

    };

    Object.assign( PropertyBinding.prototype, { // prototype, continued

    	// these are used to "bind" a nonexistent property
    	_getValue_unavailable: function() {},
    	_setValue_unavailable: function() {},

    	// initial state of these methods that calls 'bind'
    	_getValue_unbound: PropertyBinding.prototype.getValue,
    	_setValue_unbound: PropertyBinding.prototype.setValue,

    	BindingType: {
    		Direct: 0,
    		EntireArray: 1,
    		ArrayElement: 2,
    		HasFromToArray: 3
    	},

    	Versioning: {
    		None: 0,
    		NeedsUpdate: 1,
    		MatrixWorldNeedsUpdate: 2
    	},

    	GetterByBindingType: [

    		function getValue_direct( buffer, offset ) {

    			buffer[ offset ] = this.node[ this.propertyName ];

    		},

    		function getValue_array( buffer, offset ) {

    			var source = this.resolvedProperty;

    			for ( var i = 0, n = source.length; i !== n; ++ i ) {

    				buffer[ offset ++ ] = source[ i ];

    			}

    		},

    		function getValue_arrayElement( buffer, offset ) {

    			buffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];

    		},

    		function getValue_toArray( buffer, offset ) {

    			this.resolvedProperty.toArray( buffer, offset );

    		}

    	],

    	SetterByBindingTypeAndVersioning: [

    		[
    			// Direct

    			function setValue_direct( buffer, offset ) {

    				this.node[ this.propertyName ] = buffer[ offset ];

    			},

    			function setValue_direct_setNeedsUpdate( buffer, offset ) {

    				this.node[ this.propertyName ] = buffer[ offset ];
    				this.targetObject.needsUpdate = true;

    			},

    			function setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {

    				this.node[ this.propertyName ] = buffer[ offset ];
    				this.targetObject.matrixWorldNeedsUpdate = true;

    			}

    		], [

    			// EntireArray

    			function setValue_array( buffer, offset ) {

    				var dest = this.resolvedProperty;

    				for ( var i = 0, n = dest.length; i !== n; ++ i ) {

    					dest[ i ] = buffer[ offset ++ ];

    				}

    			},

    			function setValue_array_setNeedsUpdate( buffer, offset ) {

    				var dest = this.resolvedProperty;

    				for ( var i = 0, n = dest.length; i !== n; ++ i ) {

    					dest[ i ] = buffer[ offset ++ ];

    				}

    				this.targetObject.needsUpdate = true;

    			},

    			function setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {

    				var dest = this.resolvedProperty;

    				for ( var i = 0, n = dest.length; i !== n; ++ i ) {

    					dest[ i ] = buffer[ offset ++ ];

    				}

    				this.targetObject.matrixWorldNeedsUpdate = true;

    			}

    		], [

    			// ArrayElement

    			function setValue_arrayElement( buffer, offset ) {

    				this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];

    			},

    			function setValue_arrayElement_setNeedsUpdate( buffer, offset ) {

    				this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
    				this.targetObject.needsUpdate = true;

    			},

    			function setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {

    				this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
    				this.targetObject.matrixWorldNeedsUpdate = true;

    			}

    		], [

    			// HasToFromArray

    			function setValue_fromArray( buffer, offset ) {

    				this.resolvedProperty.fromArray( buffer, offset );

    			},

    			function setValue_fromArray_setNeedsUpdate( buffer, offset ) {

    				this.resolvedProperty.fromArray( buffer, offset );
    				this.targetObject.needsUpdate = true;

    			},

    			function setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {

    				this.resolvedProperty.fromArray( buffer, offset );
    				this.targetObject.matrixWorldNeedsUpdate = true;

    			}

    		]

    	]

    } );

    PropertyBinding.Composite =
    		function( targetGroup, path, optionalParsedPath ) {

    	var parsedPath = optionalParsedPath ||
    			PropertyBinding.parseTrackName( path );

    	this._targetGroup = targetGroup;
    	this._bindings = targetGroup.subscribe_( path, parsedPath );

    };

    PropertyBinding.Composite.prototype = {

    	constructor: PropertyBinding.Composite,

    	getValue: function( array, offset ) {

    		this.bind(); // bind all binding

    		var firstValidIndex = this._targetGroup.nCachedObjects_,
    			binding = this._bindings[ firstValidIndex ];

    		// and only call .getValue on the first
    		if ( binding !== undefined ) binding.getValue( array, offset );

    	},

    	setValue: function( array, offset ) {

    		var bindings = this._bindings;

    		for ( var i = this._targetGroup.nCachedObjects_,
    				n = bindings.length; i !== n; ++ i ) {

    			bindings[ i ].setValue( array, offset );

    		}

    	},

    	bind: function() {

    		var bindings = this._bindings;

    		for ( var i = this._targetGroup.nCachedObjects_,
    				n = bindings.length; i !== n; ++ i ) {

    			bindings[ i ].bind();

    		}

    	},

    	unbind: function() {

    		var bindings = this._bindings;

    		for ( var i = this._targetGroup.nCachedObjects_,
    				n = bindings.length; i !== n; ++ i ) {

    			bindings[ i ].unbind();

    		}

    	}

    };

    PropertyBinding.create = function( root, path, parsedPath ) {

    	if ( ! ( (root && root.isAnimationObjectGroup) ) ) {

    		return new PropertyBinding( root, path, parsedPath );

    	} else {

    		return new PropertyBinding.Composite( root, path, parsedPath );

    	}

    };

    PropertyBinding.parseTrackName = function( trackName ) {

    	// matches strings in the form of:
    	//    nodeName.property
    	//    nodeName.property[accessor]
    	//    nodeName.material.property[accessor]
    	//    uuid.property[accessor]
    	//    uuid.objectName[objectIndex].propertyName[propertyIndex]
    	//    parentName/nodeName.property
    	//    parentName/parentName/nodeName.property[index]
    	//    .bone[Armature.DEF_cog].position
    	//    scene:helium_balloon_model:helium_balloon_model.position
    	// created and tested via https://regex101.com/#javascript

    	var re = /^((?:\w+[\/:])*)(\w+)?(?:\.(\w+)(?:\[(.+)\])?)?\.(\w+)(?:\[(.+)\])?$/;
    	var matches = re.exec( trackName );

    	if ( ! matches ) {

    		throw new Error( "cannot parse trackName at all: " + trackName );

    	}

    	var results = {
    		// directoryName: matches[ 1 ], // (tschw) currently unused
    		nodeName: matches[ 2 ], 	// allowed to be null, specified root node.
    		objectName: matches[ 3 ],
    		objectIndex: matches[ 4 ],
    		propertyName: matches[ 5 ],
    		propertyIndex: matches[ 6 ]	// allowed to be null, specifies that the whole property is set.
    	};

    	if ( results.propertyName === null || results.propertyName.length === 0 ) {

    		throw new Error( "can not parse propertyName from trackName: " + trackName );

    	}

    	return results;

    };

    PropertyBinding.findNode = function( root, nodeName ) {

    	if ( ! nodeName || nodeName === "" || nodeName === "root" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid ) {

    		return root;

    	}

    	// search into skeleton bones.
    	if ( root.skeleton ) {

    		var searchSkeleton = function( skeleton ) {

    			for( var i = 0; i < skeleton.bones.length; i ++ ) {

    				var bone = skeleton.bones[ i ];

    				if ( bone.name === nodeName ) {

    					return bone;

    				}
    			}

    			return null;

    		};

    		var bone = searchSkeleton( root.skeleton );

    		if ( bone ) {

    			return bone;

    		}
    	}

    	// search into node subtree.
    	if ( root.children ) {

    		var searchNodeSubtree = function( children ) {

    			for( var i = 0; i < children.length; i ++ ) {

    				var childNode = children[ i ];

    				if ( childNode.name === nodeName || childNode.uuid === nodeName ) {

    					return childNode;

    				}

    				var result = searchNodeSubtree( childNode.children );

    				if ( result ) return result;

    			}

    			return null;

    		};

    		var subTreeNode = searchNodeSubtree( root.children );

    		if ( subTreeNode ) {

    			return subTreeNode;

    		}

    	}

    	return null;

    };

    /**
     *
     * A group of objects that receives a shared animation state.
     *
     * Usage:
     *
     * 	-	Add objects you would otherwise pass as 'root' to the
     * 		constructor or the .clipAction method of AnimationMixer.
     *
     * 	-	Instead pass this object as 'root'.
     *
     * 	-	You can also add and remove objects later when the mixer
     * 		is running.
     *
     * Note:
     *
     *  	Objects of this class appear as one object to the mixer,
     *  	so cache control of the individual objects must be done
     *  	on the group.
     *
     * Limitation:
     *
     * 	- 	The animated properties must be compatible among the
     * 		all objects in the group.
     *
     *  -	A single property can either be controlled through a
     *  	target group or directly, but not both.
     *
     * @author tschw
     */

    function AnimationObjectGroup( var_args ) {

    	this.uuid = exports.Math.generateUUID();

    	// cached objects followed by the active ones
    	this._objects = Array.prototype.slice.call( arguments );

    	this.nCachedObjects_ = 0;			// threshold
    	// note: read by PropertyBinding.Composite

    	var indices = {};
    	this._indicesByUUID = indices;		// for bookkeeping

    	for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

    		indices[ arguments[ i ].uuid ] = i;

    	}

    	this._paths = [];					// inside: string
    	this._parsedPaths = [];				// inside: { we don't care, here }
    	this._bindings = []; 				// inside: Array< PropertyBinding >
    	this._bindingsIndicesByPath = {}; 	// inside: indices in these arrays

    	var scope = this;

    	this.stats = {

    		objects: {
    			get total() { return scope._objects.length; },
    			get inUse() { return this.total - scope.nCachedObjects_;  }
    		},

    		get bindingsPerObject() { return scope._bindings.length; }

    	};

    }

    AnimationObjectGroup.prototype = {

    	constructor: AnimationObjectGroup,

    	isAnimationObjectGroup: true,

    	add: function( var_args ) {

    		var objects = this._objects,
    			nObjects = objects.length,
    			nCachedObjects = this.nCachedObjects_,
    			indicesByUUID = this._indicesByUUID,
    			paths = this._paths,
    			parsedPaths = this._parsedPaths,
    			bindings = this._bindings,
    			nBindings = bindings.length;

    		for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

    			var object = arguments[ i ],
    				uuid = object.uuid,
    				index = indicesByUUID[ uuid ];

    			if ( index === undefined ) {

    				// unknown object -> add it to the ACTIVE region

    				index = nObjects ++;
    				indicesByUUID[ uuid ] = index;
    				objects.push( object );

    				// accounting is done, now do the same for all bindings

    				for ( var j = 0, m = nBindings; j !== m; ++ j ) {

    					bindings[ j ].push(
    							new PropertyBinding(
    								object, paths[ j ], parsedPaths[ j ] ) );

    				}

    			} else if ( index < nCachedObjects ) {

    				var knownObject = objects[ index ];

    				// move existing object to the ACTIVE region

    				var firstActiveIndex = -- nCachedObjects,
    					lastCachedObject = objects[ firstActiveIndex ];

    				indicesByUUID[ lastCachedObject.uuid ] = index;
    				objects[ index ] = lastCachedObject;

    				indicesByUUID[ uuid ] = firstActiveIndex;
    				objects[ firstActiveIndex ] = object;

    				// accounting is done, now do the same for all bindings

    				for ( var j = 0, m = nBindings; j !== m; ++ j ) {

    					var bindingsForPath = bindings[ j ],
    						lastCached = bindingsForPath[ firstActiveIndex ],
    						binding = bindingsForPath[ index ];

    					bindingsForPath[ index ] = lastCached;

    					if ( binding === undefined ) {

    						// since we do not bother to create new bindings
    						// for objects that are cached, the binding may
    						// or may not exist

    						binding = new PropertyBinding(
    								object, paths[ j ], parsedPaths[ j ] );

    					}

    					bindingsForPath[ firstActiveIndex ] = binding;

    				}

    			} else if ( objects[ index ] !== knownObject) {

    				console.error( "Different objects with the same UUID " +
    						"detected. Clean the caches or recreate your " +
    						"infrastructure when reloading scenes..." );

    			} // else the object is already where we want it to be

    		} // for arguments

    		this.nCachedObjects_ = nCachedObjects;

    	},

    	remove: function( var_args ) {

    		var objects = this._objects,
    			nCachedObjects = this.nCachedObjects_,
    			indicesByUUID = this._indicesByUUID,
    			bindings = this._bindings,
    			nBindings = bindings.length;

    		for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

    			var object = arguments[ i ],
    				uuid = object.uuid,
    				index = indicesByUUID[ uuid ];

    			if ( index !== undefined && index >= nCachedObjects ) {

    				// move existing object into the CACHED region

    				var lastCachedIndex = nCachedObjects ++,
    					firstActiveObject = objects[ lastCachedIndex ];

    				indicesByUUID[ firstActiveObject.uuid ] = index;
    				objects[ index ] = firstActiveObject;

    				indicesByUUID[ uuid ] = lastCachedIndex;
    				objects[ lastCachedIndex ] = object;

    				// accounting is done, now do the same for all bindings

    				for ( var j = 0, m = nBindings; j !== m; ++ j ) {

    					var bindingsForPath = bindings[ j ],
    						firstActive = bindingsForPath[ lastCachedIndex ],
    						binding = bindingsForPath[ index ];

    					bindingsForPath[ index ] = firstActive;
    					bindingsForPath[ lastCachedIndex ] = binding;

    				}

    			}

    		} // for arguments

    		this.nCachedObjects_ = nCachedObjects;

    	},

    	// remove & forget
    	uncache: function( var_args ) {

    		var objects = this._objects,
    			nObjects = objects.length,
    			nCachedObjects = this.nCachedObjects_,
    			indicesByUUID = this._indicesByUUID,
    			bindings = this._bindings,
    			nBindings = bindings.length;

    		for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

    			var object = arguments[ i ],
    				uuid = object.uuid,
    				index = indicesByUUID[ uuid ];

    			if ( index !== undefined ) {

    				delete indicesByUUID[ uuid ];

    				if ( index < nCachedObjects ) {

    					// object is cached, shrink the CACHED region

    					var firstActiveIndex = -- nCachedObjects,
    						lastCachedObject = objects[ firstActiveIndex ],
    						lastIndex = -- nObjects,
    						lastObject = objects[ lastIndex ];

    					// last cached object takes this object's place
    					indicesByUUID[ lastCachedObject.uuid ] = index;
    					objects[ index ] = lastCachedObject;

    					// last object goes to the activated slot and pop
    					indicesByUUID[ lastObject.uuid ] = firstActiveIndex;
    					objects[ firstActiveIndex ] = lastObject;
    					objects.pop();

    					// accounting is done, now do the same for all bindings

    					for ( var j = 0, m = nBindings; j !== m; ++ j ) {

    						var bindingsForPath = bindings[ j ],
    							lastCached = bindingsForPath[ firstActiveIndex ],
    							last = bindingsForPath[ lastIndex ];

    						bindingsForPath[ index ] = lastCached;
    						bindingsForPath[ firstActiveIndex ] = last;
    						bindingsForPath.pop();

    					}

    				} else {

    					// object is active, just swap with the last and pop

    					var lastIndex = -- nObjects,
    						lastObject = objects[ lastIndex ];

    					indicesByUUID[ lastObject.uuid ] = index;
    					objects[ index ] = lastObject;
    					objects.pop();

    					// accounting is done, now do the same for all bindings

    					for ( var j = 0, m = nBindings; j !== m; ++ j ) {

    						var bindingsForPath = bindings[ j ];

    						bindingsForPath[ index ] = bindingsForPath[ lastIndex ];
    						bindingsForPath.pop();

    					}

    				} // cached or active

    			} // if object is known

    		} // for arguments

    		this.nCachedObjects_ = nCachedObjects;

    	},

    	// Internal interface used by befriended PropertyBinding.Composite:

    	subscribe_: function( path, parsedPath ) {
    		// returns an array of bindings for the given path that is changed
    		// according to the contained objects in the group

    		var indicesByPath = this._bindingsIndicesByPath,
    			index = indicesByPath[ path ],
    			bindings = this._bindings;

    		if ( index !== undefined ) return bindings[ index ];

    		var paths = this._paths,
    			parsedPaths = this._parsedPaths,
    			objects = this._objects,
    			nObjects = objects.length,
    			nCachedObjects = this.nCachedObjects_,
    			bindingsForPath = new Array( nObjects );

    		index = bindings.length;

    		indicesByPath[ path ] = index;

    		paths.push( path );
    		parsedPaths.push( parsedPath );
    		bindings.push( bindingsForPath );

    		for ( var i = nCachedObjects,
    				n = objects.length; i !== n; ++ i ) {

    			var object = objects[ i ];

    			bindingsForPath[ i ] =
    					new PropertyBinding( object, path, parsedPath );

    		}

    		return bindingsForPath;

    	},

    	unsubscribe_: function( path ) {
    		// tells the group to forget about a property path and no longer
    		// update the array previously obtained with 'subscribe_'

    		var indicesByPath = this._bindingsIndicesByPath,
    			index = indicesByPath[ path ];

    		if ( index !== undefined ) {

    			var paths = this._paths,
    				parsedPaths = this._parsedPaths,
    				bindings = this._bindings,
    				lastBindingsIndex = bindings.length - 1,
    				lastBindings = bindings[ lastBindingsIndex ],
    				lastBindingsPath = path[ lastBindingsIndex ];

    			indicesByPath[ lastBindingsPath ] = index;

    			bindings[ index ] = lastBindings;
    			bindings.pop();

    			parsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];
    			parsedPaths.pop();

    			paths[ index ] = paths[ lastBindingsIndex ];
    			paths.pop();

    		}

    	}

    };

    /**
     *
     * Action provided by AnimationMixer for scheduling clip playback on specific
     * objects.
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     *
     */

    function AnimationAction( mixer, clip, localRoot ) {

    	this._mixer = mixer;
    	this._clip = clip;
    	this._localRoot = localRoot || null;

    	var tracks = clip.tracks,
    		nTracks = tracks.length,
    		interpolants = new Array( nTracks );

    	var interpolantSettings = {
    			endingStart: 	ZeroCurvatureEnding,
    			endingEnd:		ZeroCurvatureEnding
    	};

    	for ( var i = 0; i !== nTracks; ++ i ) {

    		var interpolant = tracks[ i ].createInterpolant( null );
    		interpolants[ i ] = interpolant;
    		interpolant.settings = interpolantSettings;

    	}

    	this._interpolantSettings = interpolantSettings;

    	this._interpolants = interpolants;	// bound by the mixer

    	// inside: PropertyMixer (managed by the mixer)
    	this._propertyBindings = new Array( nTracks );

    	this._cacheIndex = null;			// for the memory manager
    	this._byClipCacheIndex = null;		// for the memory manager

    	this._timeScaleInterpolant = null;
    	this._weightInterpolant = null;

    	this.loop = LoopRepeat;
    	this._loopCount = -1;

    	// global mixer time when the action is to be started
    	// it's set back to 'null' upon start of the action
    	this._startTime = null;

    	// scaled local time of the action
    	// gets clamped or wrapped to 0..clip.duration according to loop
    	this.time = 0;

    	this.timeScale = 1;
    	this._effectiveTimeScale = 1;

    	this.weight = 1;
    	this._effectiveWeight = 1;

    	this.repetitions = Infinity; 		// no. of repetitions when looping

    	this.paused = false;				// false -> zero effective time scale
    	this.enabled = true;				// true -> zero effective weight

    	this.clampWhenFinished 	= false;	// keep feeding the last frame?

    	this.zeroSlopeAtStart 	= true;		// for smooth interpolation w/o separate
    	this.zeroSlopeAtEnd		= true;		// clips for start, loop and end

    };

    AnimationAction.prototype = {

    	constructor: AnimationAction,

    	// State & Scheduling

    	play: function() {

    		this._mixer._activateAction( this );

    		return this;

    	},

    	stop: function() {

    		this._mixer._deactivateAction( this );

    		return this.reset();

    	},

    	reset: function() {

    		this.paused = false;
    		this.enabled = true;

    		this.time = 0;			// restart clip
    		this._loopCount = -1;	// forget previous loops
    		this._startTime = null;	// forget scheduling

    		return this.stopFading().stopWarping();

    	},

    	isRunning: function() {

    		return this.enabled && ! this.paused && this.timeScale !== 0 &&
    				this._startTime === null && this._mixer._isActiveAction( this );

    	},

    	// return true when play has been called
    	isScheduled: function() {

    		return this._mixer._isActiveAction( this );

    	},

    	startAt: function( time ) {

    		this._startTime = time;

    		return this;

    	},

    	setLoop: function( mode, repetitions ) {

    		this.loop = mode;
    		this.repetitions = repetitions;

    		return this;

    	},

    	// Weight

    	// set the weight stopping any scheduled fading
    	// although .enabled = false yields an effective weight of zero, this
    	// method does *not* change .enabled, because it would be confusing
    	setEffectiveWeight: function( weight ) {

    		this.weight = weight;

    		// note: same logic as when updated at runtime
    		this._effectiveWeight = this.enabled ? weight : 0;

    		return this.stopFading();

    	},

    	// return the weight considering fading and .enabled
    	getEffectiveWeight: function() {

    		return this._effectiveWeight;

    	},

    	fadeIn: function( duration ) {

    		return this._scheduleFading( duration, 0, 1 );

    	},

    	fadeOut: function( duration ) {

    		return this._scheduleFading( duration, 1, 0 );

    	},

    	crossFadeFrom: function( fadeOutAction, duration, warp ) {

    		fadeOutAction.fadeOut( duration );
    		this.fadeIn( duration );

    		if( warp ) {

    			var fadeInDuration = this._clip.duration,
    				fadeOutDuration = fadeOutAction._clip.duration,

    				startEndRatio = fadeOutDuration / fadeInDuration,
    				endStartRatio = fadeInDuration / fadeOutDuration;

    			fadeOutAction.warp( 1.0, startEndRatio, duration );
    			this.warp( endStartRatio, 1.0, duration );

    		}

    		return this;

    	},

    	crossFadeTo: function( fadeInAction, duration, warp ) {

    		return fadeInAction.crossFadeFrom( this, duration, warp );

    	},

    	stopFading: function() {

    		var weightInterpolant = this._weightInterpolant;

    		if ( weightInterpolant !== null ) {

    			this._weightInterpolant = null;
    			this._mixer._takeBackControlInterpolant( weightInterpolant );

    		}

    		return this;

    	},

    	// Time Scale Control

    	// set the weight stopping any scheduled warping
    	// although .paused = true yields an effective time scale of zero, this
    	// method does *not* change .paused, because it would be confusing
    	setEffectiveTimeScale: function( timeScale ) {

    		this.timeScale = timeScale;
    		this._effectiveTimeScale = this.paused ? 0 :timeScale;

    		return this.stopWarping();

    	},

    	// return the time scale considering warping and .paused
    	getEffectiveTimeScale: function() {

    		return this._effectiveTimeScale;

    	},

    	setDuration: function( duration ) {

    		this.timeScale = this._clip.duration / duration;

    		return this.stopWarping();

    	},

    	syncWith: function( action ) {

    		this.time = action.time;
    		this.timeScale = action.timeScale;

    		return this.stopWarping();

    	},

    	halt: function( duration ) {

    		return this.warp( this._effectiveTimeScale, 0, duration );

    	},

    	warp: function( startTimeScale, endTimeScale, duration ) {

    		var mixer = this._mixer, now = mixer.time,
    			interpolant = this._timeScaleInterpolant,

    			timeScale = this.timeScale;

    		if ( interpolant === null ) {

    			interpolant = mixer._lendControlInterpolant(),
    			this._timeScaleInterpolant = interpolant;

    		}

    		var times = interpolant.parameterPositions,
    			values = interpolant.sampleValues;

    		times[ 0 ] = now;
    		times[ 1 ] = now + duration;

    		values[ 0 ] = startTimeScale / timeScale;
    		values[ 1 ] = endTimeScale / timeScale;

    		return this;

    	},

    	stopWarping: function() {

    		var timeScaleInterpolant = this._timeScaleInterpolant;

    		if ( timeScaleInterpolant !== null ) {

    			this._timeScaleInterpolant = null;
    			this._mixer._takeBackControlInterpolant( timeScaleInterpolant );

    		}

    		return this;

    	},

    	// Object Accessors

    	getMixer: function() {

    		return this._mixer;

    	},

    	getClip: function() {

    		return this._clip;

    	},

    	getRoot: function() {

    		return this._localRoot || this._mixer._root;

    	},

    	// Interna

    	_update: function( time, deltaTime, timeDirection, accuIndex ) {
    		// called by the mixer

    		var startTime = this._startTime;

    		if ( startTime !== null ) {

    			// check for scheduled start of action

    			var timeRunning = ( time - startTime ) * timeDirection;
    			if ( timeRunning < 0 || timeDirection === 0 ) {

    				return; // yet to come / don't decide when delta = 0

    			}

    			// start

    			this._startTime = null; // unschedule
    			deltaTime = timeDirection * timeRunning;

    		}

    		// apply time scale and advance time

    		deltaTime *= this._updateTimeScale( time );
    		var clipTime = this._updateTime( deltaTime );

    		// note: _updateTime may disable the action resulting in
    		// an effective weight of 0

    		var weight = this._updateWeight( time );

    		if ( weight > 0 ) {

    			var interpolants = this._interpolants;
    			var propertyMixers = this._propertyBindings;

    			for ( var j = 0, m = interpolants.length; j !== m; ++ j ) {

    				interpolants[ j ].evaluate( clipTime );
    				propertyMixers[ j ].accumulate( accuIndex, weight );

    			}

    		}

    	},

    	_updateWeight: function( time ) {

    		var weight = 0;

    		if ( this.enabled ) {

    			weight = this.weight;
    			var interpolant = this._weightInterpolant;

    			if ( interpolant !== null ) {

    				var interpolantValue = interpolant.evaluate( time )[ 0 ];

    				weight *= interpolantValue;

    				if ( time > interpolant.parameterPositions[ 1 ] ) {

    					this.stopFading();

    					if ( interpolantValue === 0 ) {

    						// faded out, disable
    						this.enabled = false;

    					}

    				}

    			}

    		}

    		this._effectiveWeight = weight;
    		return weight;

    	},

    	_updateTimeScale: function( time ) {

    		var timeScale = 0;

    		if ( ! this.paused ) {

    			timeScale = this.timeScale;

    			var interpolant = this._timeScaleInterpolant;

    			if ( interpolant !== null ) {

    				var interpolantValue = interpolant.evaluate( time )[ 0 ];

    				timeScale *= interpolantValue;

    				if ( time > interpolant.parameterPositions[ 1 ] ) {

    					this.stopWarping();

    					if ( timeScale === 0 ) {

    						// motion has halted, pause
    						this.paused = true;

    					} else {

    						// warp done - apply final time scale
    						this.timeScale = timeScale;

    					}

    				}

    			}

    		}

    		this._effectiveTimeScale = timeScale;
    		return timeScale;

    	},

    	_updateTime: function( deltaTime ) {

    		var time = this.time + deltaTime;

    		if ( deltaTime === 0 ) return time;

    		var duration = this._clip.duration,

    			loop = this.loop,
    			loopCount = this._loopCount;

    		if ( loop === LoopOnce ) {

    			if ( loopCount === -1 ) {
    				// just started

    				this.loopCount = 0;
    				this._setEndings( true, true, false );

    			}

    			handle_stop: {

    				if ( time >= duration ) {

    					time = duration;

    				} else if ( time < 0 ) {

    					time = 0;

    				} else break handle_stop;

    				if ( this.clampWhenFinished ) this.paused = true;
    				else this.enabled = false;

    				this._mixer.dispatchEvent( {
    					type: 'finished', action: this,
    					direction: deltaTime < 0 ? -1 : 1
    				} );

    			}

    		} else { // repetitive Repeat or PingPong

    			var pingPong = ( loop === LoopPingPong );

    			if ( loopCount === -1 ) {
    				// just started

    				if ( deltaTime >= 0 ) {

    					loopCount = 0;

    					this._setEndings(
    							true, this.repetitions === 0, pingPong );

    				} else {

    					// when looping in reverse direction, the initial
    					// transition through zero counts as a repetition,
    					// so leave loopCount at -1

    					this._setEndings(
    							this.repetitions === 0, true, pingPong );

    				}

    			}

    			if ( time >= duration || time < 0 ) {
    				// wrap around

    				var loopDelta = Math.floor( time / duration ); // signed
    				time -= duration * loopDelta;

    				loopCount += Math.abs( loopDelta );

    				var pending = this.repetitions - loopCount;

    				if ( pending < 0 ) {
    					// have to stop (switch state, clamp time, fire event)

    					if ( this.clampWhenFinished ) this.paused = true;
    					else this.enabled = false;

    					time = deltaTime > 0 ? duration : 0;

    					this._mixer.dispatchEvent( {
    						type: 'finished', action: this,
    						direction: deltaTime > 0 ? 1 : -1
    					} );

    				} else {
    					// keep running

    					if ( pending === 0 ) {
    						// entering the last round

    						var atStart = deltaTime < 0;
    						this._setEndings( atStart, ! atStart, pingPong );

    					} else {

    						this._setEndings( false, false, pingPong );

    					}

    					this._loopCount = loopCount;

    					this._mixer.dispatchEvent( {
    						type: 'loop', action: this, loopDelta: loopDelta
    					} );

    				}

    			}

    			if ( pingPong && ( loopCount & 1 ) === 1 ) {
    				// invert time for the "pong round"

    				this.time = time;
    				return duration - time;

    			}

    		}

    		this.time = time;
    		return time;

    	},

    	_setEndings: function( atStart, atEnd, pingPong ) {

    		var settings = this._interpolantSettings;

    		if ( pingPong ) {

    			settings.endingStart 	= ZeroSlopeEnding;
    			settings.endingEnd		= ZeroSlopeEnding;

    		} else {

    			// assuming for LoopOnce atStart == atEnd == true

    			if ( atStart ) {

    				settings.endingStart = this.zeroSlopeAtStart ?
    						ZeroSlopeEnding : ZeroCurvatureEnding;

    			} else {

    				settings.endingStart = WrapAroundEnding;

    			}

    			if ( atEnd ) {

    				settings.endingEnd = this.zeroSlopeAtEnd ?
    						ZeroSlopeEnding : ZeroCurvatureEnding;

    			} else {

    				settings.endingEnd 	 = WrapAroundEnding;

    			}

    		}

    	},

    	_scheduleFading: function( duration, weightNow, weightThen ) {

    		var mixer = this._mixer, now = mixer.time,
    			interpolant = this._weightInterpolant;

    		if ( interpolant === null ) {

    			interpolant = mixer._lendControlInterpolant(),
    			this._weightInterpolant = interpolant;

    		}

    		var times = interpolant.parameterPositions,
    			values = interpolant.sampleValues;

    		times[ 0 ] = now; 				values[ 0 ] = weightNow;
    		times[ 1 ] = now + duration;	values[ 1 ] = weightThen;

    		return this;

    	}

    };

    /**
     *
     * Player for AnimationClips.
     *
     *
     * @author Ben Houston / http://clara.io/
     * @author David Sarno / http://lighthaus.us/
     * @author tschw
     */

    function AnimationMixer( root ) {

    	this._root = root;
    	this._initMemoryManager();
    	this._accuIndex = 0;

    	this.time = 0;

    	this.timeScale = 1.0;

    }

    Object.assign( AnimationMixer.prototype, EventDispatcher.prototype, {

    	// return an action for a clip optionally using a custom root target
    	// object (this method allocates a lot of dynamic memory in case a
    	// previously unknown clip/root combination is specified)
    	clipAction: function( clip, optionalRoot ) {

    		var root = optionalRoot || this._root,
    			rootUuid = root.uuid,

    			clipObject = typeof clip === 'string' ?
    					AnimationClip.findByName( root, clip ) : clip,

    			clipUuid = clipObject !== null ? clipObject.uuid : clip,

    			actionsForClip = this._actionsByClip[ clipUuid ],
    			prototypeAction = null;

    		if ( actionsForClip !== undefined ) {

    			var existingAction =
    					actionsForClip.actionByRoot[ rootUuid ];

    			if ( existingAction !== undefined ) {

    				return existingAction;

    			}

    			// we know the clip, so we don't have to parse all
    			// the bindings again but can just copy
    			prototypeAction = actionsForClip.knownActions[ 0 ];

    			// also, take the clip from the prototype action
    			if ( clipObject === null )
    				clipObject = prototypeAction._clip;

    		}

    		// clip must be known when specified via string
    		if ( clipObject === null ) return null;

    		// allocate all resources required to run it
    		var newAction = new AnimationAction( this, clipObject, optionalRoot );

    		this._bindAction( newAction, prototypeAction );

    		// and make the action known to the memory manager
    		this._addInactiveAction( newAction, clipUuid, rootUuid );

    		return newAction;

    	},

    	// get an existing action
    	existingAction: function( clip, optionalRoot ) {

    		var root = optionalRoot || this._root,
    			rootUuid = root.uuid,

    			clipObject = typeof clip === 'string' ?
    					AnimationClip.findByName( root, clip ) : clip,

    			clipUuid = clipObject ? clipObject.uuid : clip,

    			actionsForClip = this._actionsByClip[ clipUuid ];

    		if ( actionsForClip !== undefined ) {

    			return actionsForClip.actionByRoot[ rootUuid ] || null;

    		}

    		return null;

    	},

    	// deactivates all previously scheduled actions
    	stopAllAction: function() {

    		var actions = this._actions,
    			nActions = this._nActiveActions,
    			bindings = this._bindings,
    			nBindings = this._nActiveBindings;

    		this._nActiveActions = 0;
    		this._nActiveBindings = 0;

    		for ( var i = 0; i !== nActions; ++ i ) {

    			actions[ i ].reset();

    		}

    		for ( var i = 0; i !== nBindings; ++ i ) {

    			bindings[ i ].useCount = 0;

    		}

    		return this;

    	},

    	// advance the time and update apply the animation
    	update: function( deltaTime ) {

    		deltaTime *= this.timeScale;

    		var actions = this._actions,
    			nActions = this._nActiveActions,

    			time = this.time += deltaTime,
    			timeDirection = Math.sign( deltaTime ),

    			accuIndex = this._accuIndex ^= 1;

    		// run active actions

    		for ( var i = 0; i !== nActions; ++ i ) {

    			var action = actions[ i ];

    			if ( action.enabled ) {

    				action._update( time, deltaTime, timeDirection, accuIndex );

    			}

    		}

    		// update scene graph

    		var bindings = this._bindings,
    			nBindings = this._nActiveBindings;

    		for ( var i = 0; i !== nBindings; ++ i ) {

    			bindings[ i ].apply( accuIndex );

    		}

    		return this;

    	},

    	// return this mixer's root target object
    	getRoot: function() {

    		return this._root;

    	},

    	// free all resources specific to a particular clip
    	uncacheClip: function( clip ) {

    		var actions = this._actions,
    			clipUuid = clip.uuid,
    			actionsByClip = this._actionsByClip,
    			actionsForClip = actionsByClip[ clipUuid ];

    		if ( actionsForClip !== undefined ) {

    			// note: just calling _removeInactiveAction would mess up the
    			// iteration state and also require updating the state we can
    			// just throw away

    			var actionsToRemove = actionsForClip.knownActions;

    			for ( var i = 0, n = actionsToRemove.length; i !== n; ++ i ) {

    				var action = actionsToRemove[ i ];

    				this._deactivateAction( action );

    				var cacheIndex = action._cacheIndex,
    					lastInactiveAction = actions[ actions.length - 1 ];

    				action._cacheIndex = null;
    				action._byClipCacheIndex = null;

    				lastInactiveAction._cacheIndex = cacheIndex;
    				actions[ cacheIndex ] = lastInactiveAction;
    				actions.pop();

    				this._removeInactiveBindingsForAction( action );

    			}

    			delete actionsByClip[ clipUuid ];

    		}

    	},

    	// free all resources specific to a particular root target object
    	uncacheRoot: function( root ) {

    		var rootUuid = root.uuid,
    			actionsByClip = this._actionsByClip;

    		for ( var clipUuid in actionsByClip ) {

    			var actionByRoot = actionsByClip[ clipUuid ].actionByRoot,
    				action = actionByRoot[ rootUuid ];

    			if ( action !== undefined ) {

    				this._deactivateAction( action );
    				this._removeInactiveAction( action );

    			}

    		}

    		var bindingsByRoot = this._bindingsByRootAndName,
    			bindingByName = bindingsByRoot[ rootUuid ];

    		if ( bindingByName !== undefined ) {

    			for ( var trackName in bindingByName ) {

    				var binding = bindingByName[ trackName ];
    				binding.restoreOriginalState();
    				this._removeInactiveBinding( binding );

    			}

    		}

    	},

    	// remove a targeted clip from the cache
    	uncacheAction: function( clip, optionalRoot ) {

    		var action = this.existingAction( clip, optionalRoot );

    		if ( action !== null ) {

    			this._deactivateAction( action );
    			this._removeInactiveAction( action );

    		}

    	}

    } );

    // Implementation details:

    Object.assign( AnimationMixer.prototype, {

    	_bindAction: function( action, prototypeAction ) {

    		var root = action._localRoot || this._root,
    			tracks = action._clip.tracks,
    			nTracks = tracks.length,
    			bindings = action._propertyBindings,
    			interpolants = action._interpolants,
    			rootUuid = root.uuid,
    			bindingsByRoot = this._bindingsByRootAndName,
    			bindingsByName = bindingsByRoot[ rootUuid ];

    		if ( bindingsByName === undefined ) {

    			bindingsByName = {};
    			bindingsByRoot[ rootUuid ] = bindingsByName;

    		}

    		for ( var i = 0; i !== nTracks; ++ i ) {

    			var track = tracks[ i ],
    				trackName = track.name,
    				binding = bindingsByName[ trackName ];

    			if ( binding !== undefined ) {

    				bindings[ i ] = binding;

    			} else {

    				binding = bindings[ i ];

    				if ( binding !== undefined ) {

    					// existing binding, make sure the cache knows

    					if ( binding._cacheIndex === null ) {

    						++ binding.referenceCount;
    						this._addInactiveBinding( binding, rootUuid, trackName );

    					}

    					continue;

    				}

    				var path = prototypeAction && prototypeAction.
    						_propertyBindings[ i ].binding.parsedPath;

    				binding = new PropertyMixer(
    						PropertyBinding.create( root, trackName, path ),
    						track.ValueTypeName, track.getValueSize() );

    				++ binding.referenceCount;
    				this._addInactiveBinding( binding, rootUuid, trackName );

    				bindings[ i ] = binding;

    			}

    			interpolants[ i ].resultBuffer = binding.buffer;

    		}

    	},

    	_activateAction: function( action ) {

    		if ( ! this._isActiveAction( action ) ) {

    			if ( action._cacheIndex === null ) {

    				// this action has been forgotten by the cache, but the user
    				// appears to be still using it -> rebind

    				var rootUuid = ( action._localRoot || this._root ).uuid,
    					clipUuid = action._clip.uuid,
    					actionsForClip = this._actionsByClip[ clipUuid ];

    				this._bindAction( action,
    						actionsForClip && actionsForClip.knownActions[ 0 ] );

    				this._addInactiveAction( action, clipUuid, rootUuid );

    			}

    			var bindings = action._propertyBindings;

    			// increment reference counts / sort out state
    			for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

    				var binding = bindings[ i ];

    				if ( binding.useCount ++ === 0 ) {

    					this._lendBinding( binding );
    					binding.saveOriginalState();

    				}

    			}

    			this._lendAction( action );

    		}

    	},

    	_deactivateAction: function( action ) {

    		if ( this._isActiveAction( action ) ) {

    			var bindings = action._propertyBindings;

    			// decrement reference counts / sort out state
    			for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

    				var binding = bindings[ i ];

    				if ( -- binding.useCount === 0 ) {

    					binding.restoreOriginalState();
    					this._takeBackBinding( binding );

    				}

    			}

    			this._takeBackAction( action );

    		}

    	},

    	// Memory manager

    	_initMemoryManager: function() {

    		this._actions = []; // 'nActiveActions' followed by inactive ones
    		this._nActiveActions = 0;

    		this._actionsByClip = {};
    		// inside:
    		// {
    		// 		knownActions: Array< AnimationAction >	- used as prototypes
    		// 		actionByRoot: AnimationAction			- lookup
    		// }


    		this._bindings = []; // 'nActiveBindings' followed by inactive ones
    		this._nActiveBindings = 0;

    		this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >


    		this._controlInterpolants = []; // same game as above
    		this._nActiveControlInterpolants = 0;

    		var scope = this;

    		this.stats = {

    			actions: {
    				get total() { return scope._actions.length; },
    				get inUse() { return scope._nActiveActions; }
    			},
    			bindings: {
    				get total() { return scope._bindings.length; },
    				get inUse() { return scope._nActiveBindings; }
    			},
    			controlInterpolants: {
    				get total() { return scope._controlInterpolants.length; },
    				get inUse() { return scope._nActiveControlInterpolants; }
    			}

    		};

    	},

    	// Memory management for AnimationAction objects

    	_isActiveAction: function( action ) {

    		var index = action._cacheIndex;
    		return index !== null && index < this._nActiveActions;

    	},

    	_addInactiveAction: function( action, clipUuid, rootUuid ) {

    		var actions = this._actions,
    			actionsByClip = this._actionsByClip,
    			actionsForClip = actionsByClip[ clipUuid ];

    		if ( actionsForClip === undefined ) {

    			actionsForClip = {

    				knownActions: [ action ],
    				actionByRoot: {}

    			};

    			action._byClipCacheIndex = 0;

    			actionsByClip[ clipUuid ] = actionsForClip;

    		} else {

    			var knownActions = actionsForClip.knownActions;

    			action._byClipCacheIndex = knownActions.length;
    			knownActions.push( action );

    		}

    		action._cacheIndex = actions.length;
    		actions.push( action );

    		actionsForClip.actionByRoot[ rootUuid ] = action;

    	},

    	_removeInactiveAction: function( action ) {

    		var actions = this._actions,
    			lastInactiveAction = actions[ actions.length - 1 ],
    			cacheIndex = action._cacheIndex;

    		lastInactiveAction._cacheIndex = cacheIndex;
    		actions[ cacheIndex ] = lastInactiveAction;
    		actions.pop();

    		action._cacheIndex = null;


    		var clipUuid = action._clip.uuid,
    			actionsByClip = this._actionsByClip,
    			actionsForClip = actionsByClip[ clipUuid ],
    			knownActionsForClip = actionsForClip.knownActions,

    			lastKnownAction =
    				knownActionsForClip[ knownActionsForClip.length - 1 ],

    			byClipCacheIndex = action._byClipCacheIndex;

    		lastKnownAction._byClipCacheIndex = byClipCacheIndex;
    		knownActionsForClip[ byClipCacheIndex ] = lastKnownAction;
    		knownActionsForClip.pop();

    		action._byClipCacheIndex = null;


    		var actionByRoot = actionsForClip.actionByRoot,
    			rootUuid = ( actions._localRoot || this._root ).uuid;

    		delete actionByRoot[ rootUuid ];

    		if ( knownActionsForClip.length === 0 ) {

    			delete actionsByClip[ clipUuid ];

    		}

    		this._removeInactiveBindingsForAction( action );

    	},

    	_removeInactiveBindingsForAction: function( action ) {

    		var bindings = action._propertyBindings;
    		for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

    			var binding = bindings[ i ];

    			if ( -- binding.referenceCount === 0 ) {

    				this._removeInactiveBinding( binding );

    			}

    		}

    	},

    	_lendAction: function( action ) {

    		// [ active actions |  inactive actions  ]
    		// [  active actions >| inactive actions ]
    		//                 s        a
    		//                  <-swap->
    		//                 a        s

    		var actions = this._actions,
    			prevIndex = action._cacheIndex,

    			lastActiveIndex = this._nActiveActions ++,

    			firstInactiveAction = actions[ lastActiveIndex ];

    		action._cacheIndex = lastActiveIndex;
    		actions[ lastActiveIndex ] = action;

    		firstInactiveAction._cacheIndex = prevIndex;
    		actions[ prevIndex ] = firstInactiveAction;

    	},

    	_takeBackAction: function( action ) {

    		// [  active actions  | inactive actions ]
    		// [ active actions |< inactive actions  ]
    		//        a        s
    		//         <-swap->
    		//        s        a

    		var actions = this._actions,
    			prevIndex = action._cacheIndex,

    			firstInactiveIndex = -- this._nActiveActions,

    			lastActiveAction = actions[ firstInactiveIndex ];

    		action._cacheIndex = firstInactiveIndex;
    		actions[ firstInactiveIndex ] = action;

    		lastActiveAction._cacheIndex = prevIndex;
    		actions[ prevIndex ] = lastActiveAction;

    	},

    	// Memory management for PropertyMixer objects

    	_addInactiveBinding: function( binding, rootUuid, trackName ) {

    		var bindingsByRoot = this._bindingsByRootAndName,
    			bindingByName = bindingsByRoot[ rootUuid ],

    			bindings = this._bindings;

    		if ( bindingByName === undefined ) {

    			bindingByName = {};
    			bindingsByRoot[ rootUuid ] = bindingByName;

    		}

    		bindingByName[ trackName ] = binding;

    		binding._cacheIndex = bindings.length;
    		bindings.push( binding );

    	},

    	_removeInactiveBinding: function( binding ) {

    		var bindings = this._bindings,
    			propBinding = binding.binding,
    			rootUuid = propBinding.rootNode.uuid,
    			trackName = propBinding.path,
    			bindingsByRoot = this._bindingsByRootAndName,
    			bindingByName = bindingsByRoot[ rootUuid ],

    			lastInactiveBinding = bindings[ bindings.length - 1 ],
    			cacheIndex = binding._cacheIndex;

    		lastInactiveBinding._cacheIndex = cacheIndex;
    		bindings[ cacheIndex ] = lastInactiveBinding;
    		bindings.pop();

    		delete bindingByName[ trackName ];

    		remove_empty_map: {

    			for ( var _ in bindingByName ) break remove_empty_map;

    			delete bindingsByRoot[ rootUuid ];

    		}

    	},

    	_lendBinding: function( binding ) {

    		var bindings = this._bindings,
    			prevIndex = binding._cacheIndex,

    			lastActiveIndex = this._nActiveBindings ++,

    			firstInactiveBinding = bindings[ lastActiveIndex ];

    		binding._cacheIndex = lastActiveIndex;
    		bindings[ lastActiveIndex ] = binding;

    		firstInactiveBinding._cacheIndex = prevIndex;
    		bindings[ prevIndex ] = firstInactiveBinding;

    	},

    	_takeBackBinding: function( binding ) {

    		var bindings = this._bindings,
    			prevIndex = binding._cacheIndex,

    			firstInactiveIndex = -- this._nActiveBindings,

    			lastActiveBinding = bindings[ firstInactiveIndex ];

    		binding._cacheIndex = firstInactiveIndex;
    		bindings[ firstInactiveIndex ] = binding;

    		lastActiveBinding._cacheIndex = prevIndex;
    		bindings[ prevIndex ] = lastActiveBinding;

    	},


    	// Memory management of Interpolants for weight and time scale

    	_lendControlInterpolant: function() {

    		var interpolants = this._controlInterpolants,
    			lastActiveIndex = this._nActiveControlInterpolants ++,
    			interpolant = interpolants[ lastActiveIndex ];

    		if ( interpolant === undefined ) {

    			interpolant = new LinearInterpolant(
    					new Float32Array( 2 ), new Float32Array( 2 ),
    						1, this._controlInterpolantsResultBuffer );

    			interpolant.__cacheIndex = lastActiveIndex;
    			interpolants[ lastActiveIndex ] = interpolant;

    		}

    		return interpolant;

    	},

    	_takeBackControlInterpolant: function( interpolant ) {

    		var interpolants = this._controlInterpolants,
    			prevIndex = interpolant.__cacheIndex,

    			firstInactiveIndex = -- this._nActiveControlInterpolants,

    			lastActiveInterpolant = interpolants[ firstInactiveIndex ];

    		interpolant.__cacheIndex = firstInactiveIndex;
    		interpolants[ firstInactiveIndex ] = interpolant;

    		lastActiveInterpolant.__cacheIndex = prevIndex;
    		interpolants[ prevIndex ] = lastActiveInterpolant;

    	},

    	_controlInterpolantsResultBuffer: new Float32Array( 1 )

    } );

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function Uniform( value ) {

    	if ( typeof value === 'string' ) {

    		console.warn( 'THREE.Uniform: Type parameter is no longer needed.' );
    		value = arguments[ 1 ];

    	}

    	this.value = value;

    	this.dynamic = false;

    }

    Uniform.prototype = {

    	constructor: Uniform,

    	onUpdate: function ( callback ) {

    		this.dynamic = true;
    		this.onUpdateCallback = callback;

    		return this;

    	}

    };

    /**
     * @author benaadams / https://twitter.com/ben_a_adams
     */

    function InstancedBufferGeometry() {

    	BufferGeometry.call( this );

    	this.type = 'InstancedBufferGeometry';
    	this.maxInstancedCount = undefined;

    }

    InstancedBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
    InstancedBufferGeometry.prototype.constructor = InstancedBufferGeometry;

    InstancedBufferGeometry.prototype.isInstancedBufferGeometry = true;

    InstancedBufferGeometry.prototype.addGroup = function ( start, count, instances ) {

    	this.groups.push( {

    		start: start,
    		count: count,
    		instances: instances

    	} );

    };

    InstancedBufferGeometry.prototype.copy = function ( source ) {

    	var index = source.index;

    	if ( index !== null ) {

    		this.setIndex( index.clone() );

    	}

    	var attributes = source.attributes;

    	for ( var name in attributes ) {

    		var attribute = attributes[ name ];
    		this.addAttribute( name, attribute.clone() );

    	}

    	var groups = source.groups;

    	for ( var i = 0, l = groups.length; i < l; i ++ ) {

    		var group = groups[ i ];
    		this.addGroup( group.start, group.count, group.instances );

    	}

    	return this;

    };

    /**
     * @author benaadams / https://twitter.com/ben_a_adams
     */

    function InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, normalized ) {

    	this.uuid = exports.Math.generateUUID();

    	this.data = interleavedBuffer;
    	this.itemSize = itemSize;
    	this.offset = offset;

    	this.normalized = normalized === true;

    }


    InterleavedBufferAttribute.prototype = {

    	constructor: InterleavedBufferAttribute,

    	isInterleavedBufferAttribute: true,

    	get count() {

    		return this.data.count;

    	},

    	get array() {

    		return this.data.array;

    	},

    	setX: function ( index, x ) {

    		this.data.array[ index * this.data.stride + this.offset ] = x;

    		return this;

    	},

    	setY: function ( index, y ) {

    		this.data.array[ index * this.data.stride + this.offset + 1 ] = y;

    		return this;

    	},

    	setZ: function ( index, z ) {

    		this.data.array[ index * this.data.stride + this.offset + 2 ] = z;

    		return this;

    	},

    	setW: function ( index, w ) {

    		this.data.array[ index * this.data.stride + this.offset + 3 ] = w;

    		return this;

    	},

    	getX: function ( index ) {

    		return this.data.array[ index * this.data.stride + this.offset ];

    	},

    	getY: function ( index ) {

    		return this.data.array[ index * this.data.stride + this.offset + 1 ];

    	},

    	getZ: function ( index ) {

    		return this.data.array[ index * this.data.stride + this.offset + 2 ];

    	},

    	getW: function ( index ) {

    		return this.data.array[ index * this.data.stride + this.offset + 3 ];

    	},

    	setXY: function ( index, x, y ) {

    		index = index * this.data.stride + this.offset;

    		this.data.array[ index + 0 ] = x;
    		this.data.array[ index + 1 ] = y;

    		return this;

    	},

    	setXYZ: function ( index, x, y, z ) {

    		index = index * this.data.stride + this.offset;

    		this.data.array[ index + 0 ] = x;
    		this.data.array[ index + 1 ] = y;
    		this.data.array[ index + 2 ] = z;

    		return this;

    	},

    	setXYZW: function ( index, x, y, z, w ) {

    		index = index * this.data.stride + this.offset;

    		this.data.array[ index + 0 ] = x;
    		this.data.array[ index + 1 ] = y;
    		this.data.array[ index + 2 ] = z;
    		this.data.array[ index + 3 ] = w;

    		return this;

    	}

    };

    /**
     * @author benaadams / https://twitter.com/ben_a_adams
     */

    function InterleavedBuffer( array, stride ) {

    	this.uuid = exports.Math.generateUUID();

    	this.array = array;
    	this.stride = stride;
    	this.count = array !== undefined ? array.length / stride : 0;

    	this.dynamic = false;
    	this.updateRange = { offset: 0, count: - 1 };

    	this.version = 0;

    }

    InterleavedBuffer.prototype = {

    	constructor: InterleavedBuffer,

    	isInterleavedBuffer: true,

    	set needsUpdate( value ) {

    		if ( value === true ) this.version ++;

    	},

    	setDynamic: function ( value ) {

    		this.dynamic = value;

    		return this;

    	},

    	copy: function ( source ) {

    		this.array = new source.array.constructor( source.array );
    		this.count = source.count;
    		this.stride = source.stride;
    		this.dynamic = source.dynamic;

    		return this;

    	},

    	copyAt: function ( index1, attribute, index2 ) {

    		index1 *= this.stride;
    		index2 *= attribute.stride;

    		for ( var i = 0, l = this.stride; i < l; i ++ ) {

    			this.array[ index1 + i ] = attribute.array[ index2 + i ];

    		}

    		return this;

    	},

    	set: function ( value, offset ) {

    		if ( offset === undefined ) offset = 0;

    		this.array.set( value, offset );

    		return this;

    	},

    	clone: function () {

    		return new this.constructor().copy( this );

    	}

    };

    /**
     * @author benaadams / https://twitter.com/ben_a_adams
     */

    function InstancedInterleavedBuffer( array, stride, meshPerAttribute ) {

    	InterleavedBuffer.call( this, array, stride );

    	this.meshPerAttribute = meshPerAttribute || 1;

    }

    InstancedInterleavedBuffer.prototype = Object.create( InterleavedBuffer.prototype );
    InstancedInterleavedBuffer.prototype.constructor = InstancedInterleavedBuffer;

    InstancedInterleavedBuffer.prototype.isInstancedInterleavedBuffer = true;

    InstancedInterleavedBuffer.prototype.copy = function ( source ) {

    	InterleavedBuffer.prototype.copy.call( this, source );

    	this.meshPerAttribute = source.meshPerAttribute;

    	return this;

    };

    /**
     * @author benaadams / https://twitter.com/ben_a_adams
     */

    function InstancedBufferAttribute( array, itemSize, meshPerAttribute ) {

    	BufferAttribute.call( this, array, itemSize );

    	this.meshPerAttribute = meshPerAttribute || 1;

    }

    InstancedBufferAttribute.prototype = Object.create( BufferAttribute.prototype );
    InstancedBufferAttribute.prototype.constructor = InstancedBufferAttribute;

    InstancedBufferAttribute.prototype.isInstancedBufferAttribute = true;

    InstancedBufferAttribute.prototype.copy = function ( source ) {

    	BufferAttribute.prototype.copy.call( this, source );

    	this.meshPerAttribute = source.meshPerAttribute;

    	return this;

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author bhouston / http://clara.io/
     * @author stephomi / http://stephaneginier.com/
     */

    function Raycaster( origin, direction, near, far ) {

    	this.ray = new Ray( origin, direction );
    	// direction is assumed to be normalized (for accurate distance calculations)

    	this.near = near || 0;
    	this.far = far || Infinity;

    	this.params = {
    		Mesh: {},
    		Line: {},
    		LOD: {},
    		Points: { threshold: 1 },
    		Sprite: {}
    	};

    	Object.defineProperties( this.params, {
    		PointCloud: {
    			get: function () {
    				console.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );
    				return this.Points;
    			}
    		}
    	} );

    }

    function ascSort( a, b ) {

    	return a.distance - b.distance;

    }

    function intersectObject( object, raycaster, intersects, recursive ) {

    	if ( object.visible === false ) return;

    	object.raycast( raycaster, intersects );

    	if ( recursive === true ) {

    		var children = object.children;

    		for ( var i = 0, l = children.length; i < l; i ++ ) {

    			intersectObject( children[ i ], raycaster, intersects, true );

    		}

    	}

    }

    //

    Raycaster.prototype = {

    	constructor: Raycaster,

    	linePrecision: 1,

    	set: function ( origin, direction ) {

    		// direction is assumed to be normalized (for accurate distance calculations)

    		this.ray.set( origin, direction );

    	},

    	setFromCamera: function ( coords, camera ) {

    		if ( (camera && camera.isPerspectiveCamera) ) {

    			this.ray.origin.setFromMatrixPosition( camera.matrixWorld );
    			this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();

    		} else if ( (camera && camera.isOrthographicCamera) ) {

    			this.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera
    			this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );

    		} else {

    			console.error( 'THREE.Raycaster: Unsupported camera type.' );

    		}

    	},

    	intersectObject: function ( object, recursive ) {

    		var intersects = [];

    		intersectObject( object, this, intersects, recursive );

    		intersects.sort( ascSort );

    		return intersects;

    	},

    	intersectObjects: function ( objects, recursive ) {

    		var intersects = [];

    		if ( Array.isArray( objects ) === false ) {

    			console.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );
    			return intersects;

    		}

    		for ( var i = 0, l = objects.length; i < l; i ++ ) {

    			intersectObject( objects[ i ], this, intersects, recursive );

    		}

    		intersects.sort( ascSort );

    		return intersects;

    	}

    };

    /**
     * @author alteredq / http://alteredqualia.com/
     */

    function Clock( autoStart ) {

    	this.autoStart = ( autoStart !== undefined ) ? autoStart : true;

    	this.startTime = 0;
    	this.oldTime = 0;
    	this.elapsedTime = 0;

    	this.running = false;

    }

    Clock.prototype = {

    	constructor: Clock,

    	start: function () {

    		this.startTime = ( performance || Date ).now();

    		this.oldTime = this.startTime;
    		this.running = true;

    	},

    	stop: function () {

    		this.getElapsedTime();
    		this.running = false;

    	},

    	getElapsedTime: function () {

    		this.getDelta();
    		return this.elapsedTime;

    	},

    	getDelta: function () {

    		var diff = 0;

    		if ( this.autoStart && ! this.running ) {

    			this.start();

    		}

    		if ( this.running ) {

    			var newTime = ( performance || Date ).now();

    			diff = ( newTime - this.oldTime ) / 1000;
    			this.oldTime = newTime;

    			this.elapsedTime += diff;

    		}

    		return diff;

    	}

    };

    /**
     * Spline from Tween.js, slightly optimized (and trashed)
     * http://sole.github.com/tween.js/examples/05_spline.html
     *
     * @author mrdoob / http://mrdoob.com/
     * @author alteredq / http://alteredqualia.com/
     */

    function Spline( points ) {

    	this.points = points;

    	var c = [], v3 = { x: 0, y: 0, z: 0 },
    	point, intPoint, weight, w2, w3,
    	pa, pb, pc, pd;

    	this.initFromArray = function ( a ) {

    		this.points = [];

    		for ( var i = 0; i < a.length; i ++ ) {

    			this.points[ i ] = { x: a[ i ][ 0 ], y: a[ i ][ 1 ], z: a[ i ][ 2 ] };

    		}

    	};

    	this.getPoint = function ( k ) {

    		point = ( this.points.length - 1 ) * k;
    		intPoint = Math.floor( point );
    		weight = point - intPoint;

    		c[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;
    		c[ 1 ] = intPoint;
    		c[ 2 ] = intPoint  > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;
    		c[ 3 ] = intPoint  > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;

    		pa = this.points[ c[ 0 ] ];
    		pb = this.points[ c[ 1 ] ];
    		pc = this.points[ c[ 2 ] ];
    		pd = this.points[ c[ 3 ] ];

    		w2 = weight * weight;
    		w3 = weight * w2;

    		v3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );
    		v3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );
    		v3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );

    		return v3;

    	};

    	this.getControlPointsArray = function () {

    		var i, p, l = this.points.length,
    			coords = [];

    		for ( i = 0; i < l; i ++ ) {

    			p = this.points[ i ];
    			coords[ i ] = [ p.x, p.y, p.z ];

    		}

    		return coords;

    	};

    	// approximate length by summing linear segments

    	this.getLength = function ( nSubDivisions ) {

    		var i, index, nSamples, position,
    			point = 0, intPoint = 0, oldIntPoint = 0,
    			oldPosition = new Vector3(),
    			tmpVec = new Vector3(),
    			chunkLengths = [],
    			totalLength = 0;

    		// first point has 0 length

    		chunkLengths[ 0 ] = 0;

    		if ( ! nSubDivisions ) nSubDivisions = 100;

    		nSamples = this.points.length * nSubDivisions;

    		oldPosition.copy( this.points[ 0 ] );

    		for ( i = 1; i < nSamples; i ++ ) {

    			index = i / nSamples;

    			position = this.getPoint( index );
    			tmpVec.copy( position );

    			totalLength += tmpVec.distanceTo( oldPosition );

    			oldPosition.copy( position );

    			point = ( this.points.length - 1 ) * index;
    			intPoint = Math.floor( point );

    			if ( intPoint !== oldIntPoint ) {

    				chunkLengths[ intPoint ] = totalLength;
    				oldIntPoint = intPoint;

    			}

    		}

    		// last point ends with total length

    		chunkLengths[ chunkLengths.length ] = totalLength;

    		return { chunks: chunkLengths, total: totalLength };

    	};

    	this.reparametrizeByArcLength = function ( samplingCoef ) {

    		var i, j,
    			index, indexCurrent, indexNext,
    			realDistance,
    			sampling, position,
    			newpoints = [],
    			tmpVec = new Vector3(),
    			sl = this.getLength();

    		newpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );

    		for ( i = 1; i < this.points.length; i ++ ) {

    			//tmpVec.copy( this.points[ i - 1 ] );
    			//linearDistance = tmpVec.distanceTo( this.points[ i ] );

    			realDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];

    			sampling = Math.ceil( samplingCoef * realDistance / sl.total );

    			indexCurrent = ( i - 1 ) / ( this.points.length - 1 );
    			indexNext = i / ( this.points.length - 1 );

    			for ( j = 1; j < sampling - 1; j ++ ) {

    				index = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );

    				position = this.getPoint( index );
    				newpoints.push( tmpVec.copy( position ).clone() );

    			}

    			newpoints.push( tmpVec.copy( this.points[ i ] ).clone() );

    		}

    		this.points = newpoints;

    	};

    	// Catmull-Rom

    	function interpolate( p0, p1, p2, p3, t, t2, t3 ) {

    		var v0 = ( p2 - p0 ) * 0.5,
    			v1 = ( p3 - p1 ) * 0.5;

    		return ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;

    	}

    }

    /**
     * @author bhouston / http://clara.io
     * @author WestLangley / http://github.com/WestLangley
     *
     * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
     *
     * The poles (phi) are at the positive and negative y axis.
     * The equator starts at positive z.
     */

    function Spherical( radius, phi, theta ) {

    	this.radius = ( radius !== undefined ) ? radius : 1.0;
    	this.phi = ( phi !== undefined ) ? phi : 0; // up / down towards top and bottom pole
    	this.theta = ( theta !== undefined ) ? theta : 0; // around the equator of the sphere

    	return this;

    }

    Spherical.prototype = {

    	constructor: Spherical,

    	set: function ( radius, phi, theta ) {

    		this.radius = radius;
    		this.phi = phi;
    		this.theta = theta;

    		return this;

    	},

    	clone: function () {

    		return new this.constructor().copy( this );

    	},

    	copy: function ( other ) {

    		this.radius.copy( other.radius );
    		this.phi.copy( other.phi );
    		this.theta.copy( other.theta );

    		return this;

    	},

    	// restrict phi to be betwee EPS and PI-EPS
    	makeSafe: function() {

    		var EPS = 0.000001;
    		this.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );

    		return this;

    	},

    	setFromVector3: function( vec3 ) {

    		this.radius = vec3.length();

    		if ( this.radius === 0 ) {

    			this.theta = 0;
    			this.phi = 0;

    		} else {

    			this.theta = Math.atan2( vec3.x, vec3.z ); // equator angle around y-up axis
    			this.phi = Math.acos( exports.Math.clamp( vec3.y / this.radius, - 1, 1 ) ); // polar angle

    		}

    		return this;

    	},

    };

    /**
     * @author alteredq / http://alteredqualia.com/
     */

    function MorphBlendMesh( geometry, material ) {

    	Mesh.call( this, geometry, material );

    	this.animationsMap = {};
    	this.animationsList = [];

    	// prepare default animation
    	// (all frames played together in 1 second)

    	var numFrames = this.geometry.morphTargets.length;

    	var name = "__default";

    	var startFrame = 0;
    	var endFrame = numFrames - 1;

    	var fps = numFrames / 1;

    	this.createAnimation( name, startFrame, endFrame, fps );
    	this.setAnimationWeight( name, 1 );

    }

    MorphBlendMesh.prototype = Object.create( Mesh.prototype );
    MorphBlendMesh.prototype.constructor = MorphBlendMesh;

    MorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {

    	var animation = {

    		start: start,
    		end: end,

    		length: end - start + 1,

    		fps: fps,
    		duration: ( end - start ) / fps,

    		lastFrame: 0,
    		currentFrame: 0,

    		active: false,

    		time: 0,
    		direction: 1,
    		weight: 1,

    		directionBackwards: false,
    		mirroredLoop: false

    	};

    	this.animationsMap[ name ] = animation;
    	this.animationsList.push( animation );

    };

    MorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {

    	var pattern = /([a-z]+)_?(\d+)/i;

    	var firstAnimation, frameRanges = {};

    	var geometry = this.geometry;

    	for ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {

    		var morph = geometry.morphTargets[ i ];
    		var chunks = morph.name.match( pattern );

    		if ( chunks && chunks.length > 1 ) {

    			var name = chunks[ 1 ];

    			if ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: - Infinity };

    			var range = frameRanges[ name ];

    			if ( i < range.start ) range.start = i;
    			if ( i > range.end ) range.end = i;

    			if ( ! firstAnimation ) firstAnimation = name;

    		}

    	}

    	for ( var name in frameRanges ) {

    		var range = frameRanges[ name ];
    		this.createAnimation( name, range.start, range.end, fps );

    	}

    	this.firstAnimation = firstAnimation;

    };

    MorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {

    	var animation = this.animationsMap[ name ];

    	if ( animation ) {

    		animation.direction = 1;
    		animation.directionBackwards = false;

    	}

    };

    MorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {

    	var animation = this.animationsMap[ name ];

    	if ( animation ) {

    		animation.direction = - 1;
    		animation.directionBackwards = true;

    	}

    };

    MorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {

    	var animation = this.animationsMap[ name ];

    	if ( animation ) {

    		animation.fps = fps;
    		animation.duration = ( animation.end - animation.start ) / animation.fps;

    	}

    };

    MorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {

    	var animation = this.animationsMap[ name ];

    	if ( animation ) {

    		animation.duration = duration;
    		animation.fps = ( animation.end - animation.start ) / animation.duration;

    	}

    };

    MorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {

    	var animation = this.animationsMap[ name ];

    	if ( animation ) {

    		animation.weight = weight;

    	}

    };

    MorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {

    	var animation = this.animationsMap[ name ];

    	if ( animation ) {

    		animation.time = time;

    	}

    };

    MorphBlendMesh.prototype.getAnimationTime = function ( name ) {

    	var time = 0;

    	var animation = this.animationsMap[ name ];

    	if ( animation ) {

    		time = animation.time;

    	}

    	return time;

    };

    MorphBlendMesh.prototype.getAnimationDuration = function ( name ) {

    	var duration = - 1;

    	var animation = this.animationsMap[ name ];

    	if ( animation ) {

    		duration = animation.duration;

    	}

    	return duration;

    };

    MorphBlendMesh.prototype.playAnimation = function ( name ) {

    	var animation = this.animationsMap[ name ];

    	if ( animation ) {

    		animation.time = 0;
    		animation.active = true;

    	} else {

    		console.warn( "THREE.MorphBlendMesh: animation[" + name + "] undefined in .playAnimation()" );

    	}

    };

    MorphBlendMesh.prototype.stopAnimation = function ( name ) {

    	var animation = this.animationsMap[ name ];

    	if ( animation ) {

    		animation.active = false;

    	}

    };

    MorphBlendMesh.prototype.update = function ( delta ) {

    	for ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {

    		var animation = this.animationsList[ i ];

    		if ( ! animation.active ) continue;

    		var frameTime = animation.duration / animation.length;

    		animation.time += animation.direction * delta;

    		if ( animation.mirroredLoop ) {

    			if ( animation.time > animation.duration || animation.time < 0 ) {

    				animation.direction *= - 1;

    				if ( animation.time > animation.duration ) {

    					animation.time = animation.duration;
    					animation.directionBackwards = true;

    				}

    				if ( animation.time < 0 ) {

    					animation.time = 0;
    					animation.directionBackwards = false;

    				}

    			}

    		} else {

    			animation.time = animation.time % animation.duration;

    			if ( animation.time < 0 ) animation.time += animation.duration;

    		}

    		var keyframe = animation.start + exports.Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );
    		var weight = animation.weight;

    		if ( keyframe !== animation.currentFrame ) {

    			this.morphTargetInfluences[ animation.lastFrame ] = 0;
    			this.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;

    			this.morphTargetInfluences[ keyframe ] = 0;

    			animation.lastFrame = animation.currentFrame;
    			animation.currentFrame = keyframe;

    		}

    		var mix = ( animation.time % frameTime ) / frameTime;

    		if ( animation.directionBackwards ) mix = 1 - mix;

    		if ( animation.currentFrame !== animation.lastFrame ) {

    			this.morphTargetInfluences[ animation.currentFrame ] = mix * weight;
    			this.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;

    		} else {

    			this.morphTargetInfluences[ animation.currentFrame ] = weight;

    		}

    	}

    };

    /**
     * @author alteredq / http://alteredqualia.com/
     */

    function ImmediateRenderObject( material ) {

    	Object3D.call( this );

    	this.material = material;
    	this.render = function ( renderCallback ) {};

    }

    ImmediateRenderObject.prototype = Object.create( Object3D.prototype );
    ImmediateRenderObject.prototype.constructor = ImmediateRenderObject;

    ImmediateRenderObject.prototype.isImmediateRenderObject = true;

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author WestLangley / http://github.com/WestLangley
    */

    function VertexNormalsHelper( object, size, hex, linewidth ) {

    	this.object = object;

    	this.size = ( size !== undefined ) ? size : 1;

    	var color = ( hex !== undefined ) ? hex : 0xff0000;

    	var width = ( linewidth !== undefined ) ? linewidth : 1;

    	//

    	var nNormals = 0;

    	var objGeometry = this.object.geometry;

    	if ( (objGeometry && objGeometry.isGeometry) ) {

    		nNormals = objGeometry.faces.length * 3;

    	} else if ( (objGeometry && objGeometry.isBufferGeometry) ) {

    		nNormals = objGeometry.attributes.normal.count;

    	}

    	//

    	var geometry = new BufferGeometry();

    	var positions = new Float32Attribute( nNormals * 2 * 3, 3 );

    	geometry.addAttribute( 'position', positions );

    	LineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );

    	//

    	this.matrixAutoUpdate = false;

    	this.update();

    }

    VertexNormalsHelper.prototype = Object.create( LineSegments.prototype );
    VertexNormalsHelper.prototype.constructor = VertexNormalsHelper;

    VertexNormalsHelper.prototype.update = ( function () {

    	var v1 = new Vector3();
    	var v2 = new Vector3();
    	var normalMatrix = new Matrix3();

    	return function update() {

    		var keys = [ 'a', 'b', 'c' ];

    		this.object.updateMatrixWorld( true );

    		normalMatrix.getNormalMatrix( this.object.matrixWorld );

    		var matrixWorld = this.object.matrixWorld;

    		var position = this.geometry.attributes.position;

    		//

    		var objGeometry = this.object.geometry;

    		if ( (objGeometry && objGeometry.isGeometry) ) {

    			var vertices = objGeometry.vertices;

    			var faces = objGeometry.faces;

    			var idx = 0;

    			for ( var i = 0, l = faces.length; i < l; i ++ ) {

    				var face = faces[ i ];

    				for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

    					var vertex = vertices[ face[ keys[ j ] ] ];

    					var normal = face.vertexNormals[ j ];

    					v1.copy( vertex ).applyMatrix4( matrixWorld );

    					v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

    					position.setXYZ( idx, v1.x, v1.y, v1.z );

    					idx = idx + 1;

    					position.setXYZ( idx, v2.x, v2.y, v2.z );

    					idx = idx + 1;

    				}

    			}

    		} else if ( (objGeometry && objGeometry.isBufferGeometry) ) {

    			var objPos = objGeometry.attributes.position;

    			var objNorm = objGeometry.attributes.normal;

    			var idx = 0;

    			// for simplicity, ignore index and drawcalls, and render every normal

    			for ( var j = 0, jl = objPos.count; j < jl; j ++ ) {

    				v1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );

    				v2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) );

    				v2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

    				position.setXYZ( idx, v1.x, v1.y, v1.z );

    				idx = idx + 1;

    				position.setXYZ( idx, v2.x, v2.y, v2.z );

    				idx = idx + 1;

    			}

    		}

    		position.needsUpdate = true;

    		return this;

    	};

    }() );

    /**
     * @author alteredq / http://alteredqualia.com/
     * @author mrdoob / http://mrdoob.com/
     * @author WestLangley / http://github.com/WestLangley
    */

    function SpotLightHelper( light ) {

    	Object3D.call( this );

    	this.light = light;
    	this.light.updateMatrixWorld();

    	this.matrix = light.matrixWorld;
    	this.matrixAutoUpdate = false;

    	var geometry = new BufferGeometry();

    	var positions = [
    		0, 0, 0,   0,   0,   1,
    		0, 0, 0,   1,   0,   1,
    		0, 0, 0, - 1,   0,   1,
    		0, 0, 0,   0,   1,   1,
    		0, 0, 0,   0, - 1,   1
    	];

    	for ( var i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {

    		var p1 = ( i / l ) * Math.PI * 2;
    		var p2 = ( j / l ) * Math.PI * 2;

    		positions.push(
    			Math.cos( p1 ), Math.sin( p1 ), 1,
    			Math.cos( p2 ), Math.sin( p2 ), 1
    		);

    	}

    	geometry.addAttribute( 'position', new Float32Attribute( positions, 3 ) );

    	var material = new LineBasicMaterial( { fog: false } );

    	this.cone = new LineSegments( geometry, material );
    	this.add( this.cone );

    	this.update();

    }

    SpotLightHelper.prototype = Object.create( Object3D.prototype );
    SpotLightHelper.prototype.constructor = SpotLightHelper;

    SpotLightHelper.prototype.dispose = function () {

    	this.cone.geometry.dispose();
    	this.cone.material.dispose();

    };

    SpotLightHelper.prototype.update = function () {

    	var vector = new Vector3();
    	var vector2 = new Vector3();

    	return function update() {

    		var coneLength = this.light.distance ? this.light.distance : 1000;
    		var coneWidth = coneLength * Math.tan( this.light.angle );

    		this.cone.scale.set( coneWidth, coneWidth, coneLength );

    		vector.setFromMatrixPosition( this.light.matrixWorld );
    		vector2.setFromMatrixPosition( this.light.target.matrixWorld );

    		this.cone.lookAt( vector2.sub( vector ) );

    		this.cone.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

    	};

    }();

    /**
     * @author Sean Griffin / http://twitter.com/sgrif
     * @author Michael Guerrero / http://realitymeltdown.com
     * @author mrdoob / http://mrdoob.com/
     * @author ikerr / http://verold.com
     */

    function SkeletonHelper( object ) {

    	this.bones = this.getBoneList( object );

    	var geometry = new Geometry();

    	for ( var i = 0; i < this.bones.length; i ++ ) {

    		var bone = this.bones[ i ];

    		if ( (bone.parent && bone.parent.isBone) ) {

    			geometry.vertices.push( new Vector3() );
    			geometry.vertices.push( new Vector3() );
    			geometry.colors.push( new Color( 0, 0, 1 ) );
    			geometry.colors.push( new Color( 0, 1, 0 ) );

    		}

    	}

    	geometry.dynamic = true;

    	var material = new LineBasicMaterial( { vertexColors: VertexColors, depthTest: false, depthWrite: false, transparent: true } );

    	LineSegments.call( this, geometry, material );

    	this.root = object;

    	this.matrix = object.matrixWorld;
    	this.matrixAutoUpdate = false;

    	this.update();

    }


    SkeletonHelper.prototype = Object.create( LineSegments.prototype );
    SkeletonHelper.prototype.constructor = SkeletonHelper;

    SkeletonHelper.prototype.getBoneList = function( object ) {

    	var boneList = [];

    	if ( (object && object.isBone) ) {

    		boneList.push( object );

    	}

    	for ( var i = 0; i < object.children.length; i ++ ) {

    		boneList.push.apply( boneList, this.getBoneList( object.children[ i ] ) );

    	}

    	return boneList;

    };

    SkeletonHelper.prototype.update = function () {

    	var geometry = this.geometry;

    	var matrixWorldInv = new Matrix4().getInverse( this.root.matrixWorld );

    	var boneMatrix = new Matrix4();

    	var j = 0;

    	for ( var i = 0; i < this.bones.length; i ++ ) {

    		var bone = this.bones[ i ];

    		if ( (bone.parent && bone.parent.isBone) ) {

    			boneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );
    			geometry.vertices[ j ].setFromMatrixPosition( boneMatrix );

    			boneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );
    			geometry.vertices[ j + 1 ].setFromMatrixPosition( boneMatrix );

    			j += 2;

    		}

    	}

    	geometry.verticesNeedUpdate = true;

    	geometry.computeBoundingSphere();

    };

    /**
     * @author alteredq / http://alteredqualia.com/
     * @author mrdoob / http://mrdoob.com/
     */

    function PointLightHelper( light, sphereSize ) {

    	this.light = light;
    	this.light.updateMatrixWorld();

    	var geometry = new SphereBufferGeometry( sphereSize, 4, 2 );
    	var material = new MeshBasicMaterial( { wireframe: true, fog: false } );
    	material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

    	Mesh.call( this, geometry, material );

    	this.matrix = this.light.matrixWorld;
    	this.matrixAutoUpdate = false;

    	/*
    	var distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );
    	var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

    	this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
    	this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

    	var d = light.distance;

    	if ( d === 0.0 ) {

    		this.lightDistance.visible = false;

    	} else {

    		this.lightDistance.scale.set( d, d, d );

    	}

    	this.add( this.lightDistance );
    	*/

    }

    PointLightHelper.prototype = Object.create( Mesh.prototype );
    PointLightHelper.prototype.constructor = PointLightHelper;

    PointLightHelper.prototype.dispose = function () {

    	this.geometry.dispose();
    	this.material.dispose();

    };

    PointLightHelper.prototype.update = function () {

    	this.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

    	/*
    	var d = this.light.distance;

    	if ( d === 0.0 ) {

    		this.lightDistance.visible = false;

    	} else {

    		this.lightDistance.visible = true;
    		this.lightDistance.scale.set( d, d, d );

    	}
    	*/

    };

    /**
     * @author alteredq / http://alteredqualia.com/
     * @author mrdoob / http://mrdoob.com/
     */

    function HemisphereLightHelper( light, sphereSize ) {

    	Object3D.call( this );

    	this.light = light;
    	this.light.updateMatrixWorld();

    	this.matrix = light.matrixWorld;
    	this.matrixAutoUpdate = false;

    	this.colors = [ new Color(), new Color() ];

    	var geometry = new SphereGeometry( sphereSize, 4, 2 );
    	geometry.rotateX( - Math.PI / 2 );

    	for ( var i = 0, il = 8; i < il; i ++ ) {

    		geometry.faces[ i ].color = this.colors[ i < 4 ? 0 : 1 ];

    	}

    	var material = new MeshBasicMaterial( { vertexColors: FaceColors, wireframe: true } );

    	this.lightSphere = new Mesh( geometry, material );
    	this.add( this.lightSphere );

    	this.update();

    }

    HemisphereLightHelper.prototype = Object.create( Object3D.prototype );
    HemisphereLightHelper.prototype.constructor = HemisphereLightHelper;

    HemisphereLightHelper.prototype.dispose = function () {

    	this.lightSphere.geometry.dispose();
    	this.lightSphere.material.dispose();

    };

    HemisphereLightHelper.prototype.update = function () {

    	var vector = new Vector3();

    	return function update() {

    		this.colors[ 0 ].copy( this.light.color ).multiplyScalar( this.light.intensity );
    		this.colors[ 1 ].copy( this.light.groundColor ).multiplyScalar( this.light.intensity );

    		this.lightSphere.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );
    		this.lightSphere.geometry.colorsNeedUpdate = true;

    	};

    }();

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function GridHelper( size, divisions, color1, color2 ) {

    	divisions = divisions || 1;
    	color1 = new Color( color1 !== undefined ? color1 : 0x444444 );
    	color2 = new Color( color2 !== undefined ? color2 : 0x888888 );

    	var center = divisions / 2;
    	var step = ( size * 2 ) / divisions;
    	var vertices = [], colors = [];

    	for ( var i = 0, j = 0, k = - size; i <= divisions; i ++, k += step ) {

    		vertices.push( - size, 0, k, size, 0, k );
    		vertices.push( k, 0, - size, k, 0, size );

    		var color = i === center ? color1 : color2;

    		color.toArray( colors, j ); j += 3;
    		color.toArray( colors, j ); j += 3;
    		color.toArray( colors, j ); j += 3;
    		color.toArray( colors, j ); j += 3;

    	}

    	var geometry = new BufferGeometry();
    	geometry.addAttribute( 'position', new Float32Attribute( vertices, 3 ) );
    	geometry.addAttribute( 'color', new Float32Attribute( colors, 3 ) );

    	var material = new LineBasicMaterial( { vertexColors: VertexColors } );

    	LineSegments.call( this, geometry, material );

    }

    GridHelper.prototype = Object.create( LineSegments.prototype );
    GridHelper.prototype.constructor = GridHelper;

    GridHelper.prototype.setColors = function () {

    	console.error( 'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.' );

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     * @author WestLangley / http://github.com/WestLangley
    */

    function FaceNormalsHelper( object, size, hex, linewidth ) {

    	// FaceNormalsHelper only supports THREE.Geometry

    	this.object = object;

    	this.size = ( size !== undefined ) ? size : 1;

    	var color = ( hex !== undefined ) ? hex : 0xffff00;

    	var width = ( linewidth !== undefined ) ? linewidth : 1;

    	//

    	var nNormals = 0;

    	var objGeometry = this.object.geometry;

    	if ( (objGeometry && objGeometry.isGeometry) ) {

    		nNormals = objGeometry.faces.length;

    	} else {

    		console.warn( 'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.' );

    	}

    	//

    	var geometry = new BufferGeometry();

    	var positions = new Float32Attribute( nNormals * 2 * 3, 3 );

    	geometry.addAttribute( 'position', positions );

    	LineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );

    	//

    	this.matrixAutoUpdate = false;
    	this.update();

    }

    FaceNormalsHelper.prototype = Object.create( LineSegments.prototype );
    FaceNormalsHelper.prototype.constructor = FaceNormalsHelper;

    FaceNormalsHelper.prototype.update = ( function () {

    	var v1 = new Vector3();
    	var v2 = new Vector3();
    	var normalMatrix = new Matrix3();

    	return function update() {

    		this.object.updateMatrixWorld( true );

    		normalMatrix.getNormalMatrix( this.object.matrixWorld );

    		var matrixWorld = this.object.matrixWorld;

    		var position = this.geometry.attributes.position;

    		//

    		var objGeometry = this.object.geometry;

    		var vertices = objGeometry.vertices;

    		var faces = objGeometry.faces;

    		var idx = 0;

    		for ( var i = 0, l = faces.length; i < l; i ++ ) {

    			var face = faces[ i ];

    			var normal = face.normal;

    			v1.copy( vertices[ face.a ] )
    				.add( vertices[ face.b ] )
    				.add( vertices[ face.c ] )
    				.divideScalar( 3 )
    				.applyMatrix4( matrixWorld );

    			v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

    			position.setXYZ( idx, v1.x, v1.y, v1.z );

    			idx = idx + 1;

    			position.setXYZ( idx, v2.x, v2.y, v2.z );

    			idx = idx + 1;

    		}

    		position.needsUpdate = true;

    		return this;

    	};

    }() );

    /**
     * @author alteredq / http://alteredqualia.com/
     * @author mrdoob / http://mrdoob.com/
     * @author WestLangley / http://github.com/WestLangley
     */

    function DirectionalLightHelper( light, size ) {

    	Object3D.call( this );

    	this.light = light;
    	this.light.updateMatrixWorld();

    	this.matrix = light.matrixWorld;
    	this.matrixAutoUpdate = false;

    	if ( size === undefined ) size = 1;

    	var geometry = new BufferGeometry();
    	geometry.addAttribute( 'position', new Float32Attribute( [
    		- size,   size, 0,
    		  size,   size, 0,
    		  size, - size, 0,
    		- size, - size, 0,
    		- size,   size, 0
    	], 3 ) );

    	var material = new LineBasicMaterial( { fog: false } );

    	this.add( new Line( geometry, material ) );

    	geometry = new BufferGeometry();
    	geometry.addAttribute( 'position', new Float32Attribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );

    	this.add( new Line( geometry, material ));

    	this.update();

    }

    DirectionalLightHelper.prototype = Object.create( Object3D.prototype );
    DirectionalLightHelper.prototype.constructor = DirectionalLightHelper;

    DirectionalLightHelper.prototype.dispose = function () {

    	var lightPlane = this.children[ 0 ];
    	var targetLine = this.children[ 1 ];

    	lightPlane.geometry.dispose();
    	lightPlane.material.dispose();
    	targetLine.geometry.dispose();
    	targetLine.material.dispose();

    };

    DirectionalLightHelper.prototype.update = function () {

    	var v1 = new Vector3();
    	var v2 = new Vector3();
    	var v3 = new Vector3();

    	return function update() {

    		v1.setFromMatrixPosition( this.light.matrixWorld );
    		v2.setFromMatrixPosition( this.light.target.matrixWorld );
    		v3.subVectors( v2, v1 );

    		var lightPlane = this.children[ 0 ];
    		var targetLine = this.children[ 1 ];

    		lightPlane.lookAt( v3 );
    		lightPlane.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

    		targetLine.lookAt( v3 );
    		targetLine.scale.z = v3.length();

    	};

    }();

    /**
     * @author alteredq / http://alteredqualia.com/
     *
     *	- shows frustum, line of sight and up of the camera
     *	- suitable for fast updates
     * 	- based on frustum visualization in lightgl.js shadowmap example
     *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
     */

    function CameraHelper( camera ) {

    	var geometry = new Geometry();
    	var material = new LineBasicMaterial( { color: 0xffffff, vertexColors: FaceColors } );

    	var pointMap = {};

    	// colors

    	var hexFrustum = 0xffaa00;
    	var hexCone = 0xff0000;
    	var hexUp = 0x00aaff;
    	var hexTarget = 0xffffff;
    	var hexCross = 0x333333;

    	// near

    	addLine( "n1", "n2", hexFrustum );
    	addLine( "n2", "n4", hexFrustum );
    	addLine( "n4", "n3", hexFrustum );
    	addLine( "n3", "n1", hexFrustum );

    	// far

    	addLine( "f1", "f2", hexFrustum );
    	addLine( "f2", "f4", hexFrustum );
    	addLine( "f4", "f3", hexFrustum );
    	addLine( "f3", "f1", hexFrustum );

    	// sides

    	addLine( "n1", "f1", hexFrustum );
    	addLine( "n2", "f2", hexFrustum );
    	addLine( "n3", "f3", hexFrustum );
    	addLine( "n4", "f4", hexFrustum );

    	// cone

    	addLine( "p", "n1", hexCone );
    	addLine( "p", "n2", hexCone );
    	addLine( "p", "n3", hexCone );
    	addLine( "p", "n4", hexCone );

    	// up

    	addLine( "u1", "u2", hexUp );
    	addLine( "u2", "u3", hexUp );
    	addLine( "u3", "u1", hexUp );

    	// target

    	addLine( "c", "t", hexTarget );
    	addLine( "p", "c", hexCross );

    	// cross

    	addLine( "cn1", "cn2", hexCross );
    	addLine( "cn3", "cn4", hexCross );

    	addLine( "cf1", "cf2", hexCross );
    	addLine( "cf3", "cf4", hexCross );

    	function addLine( a, b, hex ) {

    		addPoint( a, hex );
    		addPoint( b, hex );

    	}

    	function addPoint( id, hex ) {

    		geometry.vertices.push( new Vector3() );
    		geometry.colors.push( new Color( hex ) );

    		if ( pointMap[ id ] === undefined ) {

    			pointMap[ id ] = [];

    		}

    		pointMap[ id ].push( geometry.vertices.length - 1 );

    	}

    	LineSegments.call( this, geometry, material );

    	this.camera = camera;
    	if( this.camera.updateProjectionMatrix ) this.camera.updateProjectionMatrix();

    	this.matrix = camera.matrixWorld;
    	this.matrixAutoUpdate = false;

    	this.pointMap = pointMap;

    	this.update();

    }

    CameraHelper.prototype = Object.create( LineSegments.prototype );
    CameraHelper.prototype.constructor = CameraHelper;

    CameraHelper.prototype.update = function () {

    	var geometry, pointMap;

    	var vector = new Vector3();
    	var camera = new Camera();

    	function setPoint( point, x, y, z ) {

    		vector.set( x, y, z ).unproject( camera );

    		var points = pointMap[ point ];

    		if ( points !== undefined ) {

    			for ( var i = 0, il = points.length; i < il; i ++ ) {

    				geometry.vertices[ points[ i ] ].copy( vector );

    			}

    		}

    	}

    	return function update() {

    		geometry = this.geometry;
    		pointMap = this.pointMap;

    		var w = 1, h = 1;

    		// we need just camera projection matrix
    		// world matrix must be identity

    		camera.projectionMatrix.copy( this.camera.projectionMatrix );

    		// center / target

    		setPoint( "c", 0, 0, - 1 );
    		setPoint( "t", 0, 0,  1 );

    		// near

    		setPoint( "n1", - w, - h, - 1 );
    		setPoint( "n2",   w, - h, - 1 );
    		setPoint( "n3", - w,   h, - 1 );
    		setPoint( "n4",   w,   h, - 1 );

    		// far

    		setPoint( "f1", - w, - h, 1 );
    		setPoint( "f2",   w, - h, 1 );
    		setPoint( "f3", - w,   h, 1 );
    		setPoint( "f4",   w,   h, 1 );

    		// up

    		setPoint( "u1",   w * 0.7, h * 1.1, - 1 );
    		setPoint( "u2", - w * 0.7, h * 1.1, - 1 );
    		setPoint( "u3",         0, h * 2,   - 1 );

    		// cross

    		setPoint( "cf1", - w,   0, 1 );
    		setPoint( "cf2",   w,   0, 1 );
    		setPoint( "cf3",   0, - h, 1 );
    		setPoint( "cf4",   0,   h, 1 );

    		setPoint( "cn1", - w,   0, - 1 );
    		setPoint( "cn2",   w,   0, - 1 );
    		setPoint( "cn3",   0, - h, - 1 );
    		setPoint( "cn4",   0,   h, - 1 );

    		geometry.verticesNeedUpdate = true;

    	};

    }();

    /**
     * @author WestLangley / http://github.com/WestLangley
     */

    // a helper to show the world-axis-aligned bounding box for an object

    function BoundingBoxHelper( object, hex ) {

    	var color = ( hex !== undefined ) ? hex : 0x888888;

    	this.object = object;

    	this.box = new Box3();

    	Mesh.call( this, new BoxGeometry( 1, 1, 1 ), new MeshBasicMaterial( { color: color, wireframe: true } ) );

    }

    BoundingBoxHelper.prototype = Object.create( Mesh.prototype );
    BoundingBoxHelper.prototype.constructor = BoundingBoxHelper;

    BoundingBoxHelper.prototype.update = function () {

    	this.box.setFromObject( this.object );

    	this.box.size( this.scale );

    	this.box.getCenter( this.position );

    };

    /**
     * @author mrdoob / http://mrdoob.com/
     */

    function BoxHelper( object, color ) {

    	if ( color === undefined ) color = 0xffff00;

    	var indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );
    	var positions = new Float32Array( 8 * 3 );

    	var geometry = new BufferGeometry();
    	geometry.setIndex( new BufferAttribute( indices, 1 ) );
    	geometry.addAttribute( 'position', new BufferAttribute( positions, 3 ) );

    	LineSegments.call( this, geometry, new LineBasicMaterial( { color: color } ) );

    	if ( object !== undefined ) {

    		this.update( object );

    	}

    }

    BoxHelper.prototype = Object.create( LineSegments.prototype );
    BoxHelper.prototype.constructor = BoxHelper;

    BoxHelper.prototype.update = ( function () {

    	var box = new Box3();

    	return function update( object ) {

    		if ( (object && object.isBox3) ) {

    			box.copy( object );

    		} else {

    			box.setFromObject( object );

    		}

    		if ( box.isEmpty() ) return;

    		var min = box.min;
    		var max = box.max;

    		/*
    		  5____4
    		1/___0/|
    		| 6__|_7
    		2/___3/

    		0: max.x, max.y, max.z
    		1: min.x, max.y, max.z
    		2: min.x, min.y, max.z
    		3: max.x, min.y, max.z
    		4: max.x, max.y, min.z
    		5: min.x, max.y, min.z
    		6: min.x, min.y, min.z
    		7: max.x, min.y, min.z
    		*/

    		var position = this.geometry.attributes.position;
    		var array = position.array;

    		array[  0 ] = max.x; array[  1 ] = max.y; array[  2 ] = max.z;
    		array[  3 ] = min.x; array[  4 ] = max.y; array[  5 ] = max.z;
    		array[  6 ] = min.x; array[  7 ] = min.y; array[  8 ] = max.z;
    		array[  9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;
    		array[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;
    		array[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;
    		array[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;
    		array[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;

    		position.needsUpdate = true;

    		this.geometry.computeBoundingSphere();

    	};

    } )();

    var lineGeometry = new BufferGeometry();
    lineGeometry.addAttribute( 'position', new Float32Attribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) );

    var coneGeometry = new CylinderBufferGeometry( 0, 0.5, 1, 5, 1 );
    coneGeometry.translate( 0, - 0.5, 0 );

    function ArrowHelper( dir, origin, length, color, headLength, headWidth ) {

    	// dir is assumed to be normalized

    	Object3D.call( this );

    	if ( color === undefined ) color = 0xffff00;
    	if ( length === undefined ) length = 1;
    	if ( headLength === undefined ) headLength = 0.2 * length;
    	if ( headWidth === undefined ) headWidth = 0.2 * headLength;

    	this.position.copy( origin );

    	this.line = new Line( lineGeometry, new LineBasicMaterial( { color: color } ) );
    	this.line.matrixAutoUpdate = false;
    	this.add( this.line );

    	this.cone = new Mesh( coneGeometry, new MeshBasicMaterial( { color: color } ) );
    	this.cone.matrixAutoUpdate = false;
    	this.add( this.cone );

    	this.setDirection( dir );
    	this.setLength( length, headLength, headWidth );

    }

    ArrowHelper.prototype = Object.create( Object3D.prototype );
    ArrowHelper.prototype.constructor = ArrowHelper;

    ArrowHelper.prototype.setDirection = ( function () {

    	var axis = new Vector3();
    	var radians;

    	return function setDirection( dir ) {

    		// dir is assumed to be normalized

    		if ( dir.y > 0.99999 ) {

    			this.quaternion.set( 0, 0, 0, 1 );

    		} else if ( dir.y < - 0.99999 ) {

    			this.quaternion.set( 1, 0, 0, 0 );

    		} else {

    			axis.set( dir.z, 0, - dir.x ).normalize();

    			radians = Math.acos( dir.y );

    			this.quaternion.setFromAxisAngle( axis, radians );

    		}

    	};

    }() );

    ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {

    	if ( headLength === undefined ) headLength = 0.2 * length;
    	if ( headWidth === undefined ) headWidth = 0.2 * headLength;

    	this.line.scale.set( 1, Math.max( 0, length - headLength ), 1 );
    	this.line.updateMatrix();

    	this.cone.scale.set( headWidth, headLength, headWidth );
    	this.cone.position.y = length;
    	this.cone.updateMatrix();

    };

    ArrowHelper.prototype.setColor = function ( color ) {

    	this.line.material.color.copy( color );
    	this.cone.material.color.copy( color );

    };

    /**
     * @author sroucheray / http://sroucheray.org/
     * @author mrdoob / http://mrdoob.com/
     */

    function AxisHelper( size ) {

    	size = size || 1;

    	var vertices = new Float32Array( [
    		0, 0, 0,  size, 0, 0,
    		0, 0, 0,  0, size, 0,
    		0, 0, 0,  0, 0, size
    	] );

    	var colors = new Float32Array( [
    		1, 0, 0,  1, 0.6, 0,
    		0, 1, 0,  0.6, 1, 0,
    		0, 0, 1,  0, 0.6, 1
    	] );

    	var geometry = new BufferGeometry();
    	geometry.addAttribute( 'position', new BufferAttribute( vertices, 3 ) );
    	geometry.addAttribute( 'color', new BufferAttribute( colors, 3 ) );

    	var material = new LineBasicMaterial( { vertexColors: VertexColors } );

    	LineSegments.call( this, geometry, material );

    }

    AxisHelper.prototype = Object.create( LineSegments.prototype );
    AxisHelper.prototype.constructor = AxisHelper;

    /**
     * @author zz85 https://github.com/zz85
     *
     * Centripetal CatmullRom Curve - which is useful for avoiding
     * cusps and self-intersections in non-uniform catmull rom curves.
     * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
     *
     * curve.type accepts centripetal(default), chordal and catmullrom
     * curve.tension is used for catmullrom which defaults to 0.5
     */

    exports.CatmullRomCurve3 = ( function() {

    	var
    		tmp = new Vector3(),
    		px = new CubicPoly(),
    		py = new CubicPoly(),
    		pz = new CubicPoly();

    	/*
    	Based on an optimized c++ solution in
    	 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
    	 - http://ideone.com/NoEbVM

    	This CubicPoly class could be used for reusing some variables and calculations,
    	but for three.js curve use, it could be possible inlined and flatten into a single function call
    	which can be placed in CurveUtils.
    	*/

    	function CubicPoly() {

    	}

    	/*
    	 * Compute coefficients for a cubic polynomial
    	 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
    	 * such that
    	 *   p(0) = x0, p(1) = x1
    	 *  and
    	 *   p'(0) = t0, p'(1) = t1.
    	 */
    	CubicPoly.prototype.init = function( x0, x1, t0, t1 ) {

    		this.c0 = x0;
    		this.c1 = t0;
    		this.c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;
    		this.c3 = 2 * x0 - 2 * x1 + t0 + t1;

    	};

    	CubicPoly.prototype.initNonuniformCatmullRom = function( x0, x1, x2, x3, dt0, dt1, dt2 ) {

    		// compute tangents when parameterized in [t1,t2]
    		var t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;
    		var t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;

    		// rescale tangents for parametrization in [0,1]
    		t1 *= dt1;
    		t2 *= dt1;

    		// initCubicPoly
    		this.init( x1, x2, t1, t2 );

    	};

    	// standard Catmull-Rom spline: interpolate between x1 and x2 with previous/following points x1/x4
    	CubicPoly.prototype.initCatmullRom = function( x0, x1, x2, x3, tension ) {

    		this.init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );

    	};

    	CubicPoly.prototype.calc = function( t ) {

    		var t2 = t * t;
    		var t3 = t2 * t;
    		return this.c0 + this.c1 * t + this.c2 * t2 + this.c3 * t3;

    	};

    	// Subclass Three.js curve
    	return Curve.create(

    		function ( p /* array of Vector3 */ ) {

    			this.points = p || [];
    			this.closed = false;

    		},

    		function ( t ) {

    			var points = this.points,
    				point, intPoint, weight, l;

    			l = points.length;

    			if ( l < 2 ) console.log( 'duh, you need at least 2 points' );

    			point = ( l - ( this.closed ? 0 : 1 ) ) * t;
    			intPoint = Math.floor( point );
    			weight = point - intPoint;

    			if ( this.closed ) {

    				intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;

    			} else if ( weight === 0 && intPoint === l - 1 ) {

    				intPoint = l - 2;
    				weight = 1;

    			}

    			var p0, p1, p2, p3; // 4 points

    			if ( this.closed || intPoint > 0 ) {

    				p0 = points[ ( intPoint - 1 ) % l ];

    			} else {

    				// extrapolate first point
    				tmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );
    				p0 = tmp;

    			}

    			p1 = points[ intPoint % l ];
    			p2 = points[ ( intPoint + 1 ) % l ];

    			if ( this.closed || intPoint + 2 < l ) {

    				p3 = points[ ( intPoint + 2 ) % l ];

    			} else {

    				// extrapolate last point
    				tmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );
    				p3 = tmp;

    			}

    			if ( this.type === undefined || this.type === 'centripetal' || this.type === 'chordal' ) {

    				// init Centripetal / Chordal Catmull-Rom
    				var pow = this.type === 'chordal' ? 0.5 : 0.25;
    				var dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );
    				var dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );
    				var dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );

    				// safety check for repeated points
    				if ( dt1 < 1e-4 ) dt1 = 1.0;
    				if ( dt0 < 1e-4 ) dt0 = dt1;
    				if ( dt2 < 1e-4 ) dt2 = dt1;

    				px.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );
    				py.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );
    				pz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );

    			} else if ( this.type === 'catmullrom' ) {

    				var tension = this.tension !== undefined ? this.tension : 0.5;
    				px.initCatmullRom( p0.x, p1.x, p2.x, p3.x, tension );
    				py.initCatmullRom( p0.y, p1.y, p2.y, p3.y, tension );
    				pz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, tension );

    			}

    			var v = new Vector3(
    				px.calc( weight ),
    				py.calc( weight ),
    				pz.calc( weight )
    			);

    			return v;

    		}

    	);

    } )();

    /**************************************************************
     *	Closed Spline 3D curve
     **************************************************************/


    function ClosedSplineCurve3( points ) {

    	console.warn( 'THREE.ClosedSplineCurve3 has been deprecated. Please use THREE.CatmullRomCurve3.' );

    	exports.CatmullRomCurve3.call( this, points );
    	this.type = 'catmullrom';
    	this.closed = true;

    }

    ClosedSplineCurve3.prototype = Object.create( exports.CatmullRomCurve3.prototype );

    /**************************************************************
     *	Spline 3D curve
     **************************************************************/


    var SplineCurve3 = Curve.create(

    	function ( points /* array of Vector3 */ ) {

    		console.warn( 'THREE.SplineCurve3 will be deprecated. Please use THREE.CatmullRomCurve3' );
    		this.points = ( points === undefined ) ? [] : points;

    	},

    	function ( t ) {

    		var points = this.points;
    		var point = ( points.length - 1 ) * t;

    		var intPoint = Math.floor( point );
    		var weight = point - intPoint;

    		var point0 = points[ intPoint == 0 ? intPoint : intPoint - 1 ];
    		var point1 = points[ intPoint ];
    		var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
    		var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

    		var interpolate = exports.CurveUtils.interpolate;

    		return new Vector3(
    			interpolate( point0.x, point1.x, point2.x, point3.x, weight ),
    			interpolate( point0.y, point1.y, point2.y, point3.y, weight ),
    			interpolate( point0.z, point1.z, point2.z, point3.z, weight )
    		);

    	}

    );

    /**************************************************************
     *	Cubic Bezier 3D curve
     **************************************************************/

    exports.CubicBezierCurve3 = Curve.create(

    	function ( v0, v1, v2, v3 ) {

    		this.v0 = v0;
    		this.v1 = v1;
    		this.v2 = v2;
    		this.v3 = v3;

    	},

    	function ( t ) {

    		var b3 = exports.ShapeUtils.b3;

    		return new Vector3(
    			b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),
    			b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y ),
    			b3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z )
    		);

    	}

    );

    /**************************************************************
     *	Quadratic Bezier 3D curve
     **************************************************************/

    exports.QuadraticBezierCurve3 = Curve.create(

    	function ( v0, v1, v2 ) {

    		this.v0 = v0;
    		this.v1 = v1;
    		this.v2 = v2;

    	},

    	function ( t ) {

    		var b2 = exports.ShapeUtils.b2;		

    		return new Vector3(
    			b2( t, this.v0.x, this.v1.x, this.v2.x ),
    			b2( t, this.v0.y, this.v1.y, this.v2.y ),
    			b2( t, this.v0.z, this.v1.z, this.v2.z )
    		);

    	}

    );

    /**************************************************************
     *	Line3D
     **************************************************************/

    exports.LineCurve3 = Curve.create(

    	function ( v1, v2 ) {

    		this.v1 = v1;
    		this.v2 = v2;

    	},

    	function ( t ) {

    		if ( t === 1 ) {

    			return this.v2.clone();

    		}

    		var vector = new Vector3();

    		vector.subVectors( this.v2, this.v1 ); // diff
    		vector.multiplyScalar( t );
    		vector.add( this.v1 );

    		return vector;

    	}

    );

    /**************************************************************
     *	Arc curve
     **************************************************************/

    function ArcCurve( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

    	EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

    }

    ArcCurve.prototype = Object.create( EllipseCurve.prototype );
    ArcCurve.prototype.constructor = ArcCurve;

    /**
     * @author alteredq / http://alteredqualia.com/
     */

    exports.SceneUtils = {

    	createMultiMaterialObject: function ( geometry, materials ) {

    		var group = new Group();

    		for ( var i = 0, l = materials.length; i < l; i ++ ) {

    			group.add( new Mesh( geometry, materials[ i ] ) );

    		}

    		return group;

    	},

    	detach: function ( child, parent, scene ) {

    		child.applyMatrix( parent.matrixWorld );
    		parent.remove( child );
    		scene.add( child );

    	},

    	attach: function ( child, scene, parent ) {

    		var matrixWorldInverse = new Matrix4();
    		matrixWorldInverse.getInverse( parent.matrixWorld );
    		child.applyMatrix( matrixWorldInverse );

    		scene.remove( child );
    		parent.add( child );

    	}

    };

    function Face4 ( a, b, c, d, normal, color, materialIndex ) {
    	console.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );
    	return new Face3( a, b, c, normal, color, materialIndex );
    }

    var LineStrip = 0;

    var LinePieces = 1;

    function PointCloud ( geometry, material ) {
    	console.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );
    	return new Points( geometry, material );
    }

    function ParticleSystem ( geometry, material ) {
    	console.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );
    	return new Points( geometry, material );
    }

    function PointCloudMaterial ( parameters ) {
    	console.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );
    	return new PointsMaterial( parameters );
    }

    function ParticleBasicMaterial ( parameters ) {
    	console.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );
    	return new PointsMaterial( parameters );
    }

    function ParticleSystemMaterial ( parameters ) {
    	console.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );
    	return new PointsMaterial( parameters );
    }

    function Vertex ( x, y, z ) {
    	console.warn( 'THREE.Vertex has been removed. Use THREE.Vector3 instead.' );
    	return new Vector3( x, y, z );
    }

    //

    function EdgesHelper( object, hex ) {
    	console.warn( 'THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.' );
    	return new LineSegments( new EdgesGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );
    }

    function WireframeHelper( object, hex ) {
    	console.warn( 'THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.' );
    	return new LineSegments( new WireframeGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );
    }

    //

    Object.assign( Box2.prototype, {
    	center: function ( optionalTarget ) {
    		console.warn( 'THREE.Box2: .center() has been renamed to .getCenter().' );
    		return this.getCenter( optionalTarget );
    	},
    	empty: function () {
    		console.warn( 'THREE.Box2: .empty() has been renamed to .isEmpty().' );
    		return this.isEmpty();
    	},
    	isIntersectionBox: function ( box ) {
    		console.warn( 'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().' );
    		return this.intersectsBox( box );
    	},
    	size: function ( optionalTarget ) {
    		console.warn( 'THREE.Box2: .size() has been renamed to .getSize().' );
    		return this.getSize( optionalTarget );
    	}
    } );

    Object.assign( Box3.prototype, {
    	center: function ( optionalTarget ) {
    		console.warn( 'THREE.Box3: .center() has been renamed to .getCenter().' );
    		return this.getCenter( optionalTarget );
    	},
    	empty: function () {
    		console.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );
    		return this.isEmpty();
    	},
    	isIntersectionBox: function ( box ) {
    		console.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );
    		return this.intersectsBox( box );
    	},
    	isIntersectionSphere: function ( sphere ) {
    		console.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
    		return this.intersectsSphere( sphere );
    	},
    	size: function ( optionalTarget ) {
    		console.warn( 'THREE.Box3: .size() has been renamed to .getSize().' );
    		return this.getSize( optionalTarget );
    	}
    } );

    Object.assign( Line3.prototype, {
    	center: function ( optionalTarget ) {
    		console.warn( 'THREE.Line3: .center() has been renamed to .getCenter().' );
    		return this.getCenter( optionalTarget );
    	}
    } );

    Object.assign( Matrix3.prototype, {
    	multiplyVector3: function ( vector ) {
    		console.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );
    		return vector.applyMatrix3( this );
    	},
    	multiplyVector3Array: function ( a ) {
    		console.warn( 'THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
    		return this.applyToVector3Array( a );
    	}
    } );

    Object.assign( Matrix4.prototype, {
    	extractPosition: function ( m ) {
    		console.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );
    		return this.copyPosition( m );
    	},
    	setRotationFromQuaternion: function ( q ) {
    		console.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );
    		return this.makeRotationFromQuaternion( q );
    	},
    	multiplyVector3: function ( vector ) {
    		console.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.' );
    		return vector.applyProjection( this );
    	},
    	multiplyVector4: function ( vector ) {
    		console.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
    		return vector.applyMatrix4( this );
    	},
    	multiplyVector3Array: function ( a ) {
    		console.warn( 'THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
    		return this.applyToVector3Array( a );
    	},
    	rotateAxis: function ( v ) {
    		console.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );
    		v.transformDirection( this );
    	},
    	crossVector: function ( vector ) {
    		console.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
    		return vector.applyMatrix4( this );
    	},
    	translate: function ( v ) {
    		console.error( 'THREE.Matrix4: .translate() has been removed.' );
    	},
    	rotateX: function ( angle ) {
    		console.error( 'THREE.Matrix4: .rotateX() has been removed.' );
    	},
    	rotateY: function ( angle ) {
    		console.error( 'THREE.Matrix4: .rotateY() has been removed.' );
    	},
    	rotateZ: function ( angle ) {
    		console.error( 'THREE.Matrix4: .rotateZ() has been removed.' );
    	},
    	rotateByAxis: function ( axis, angle ) {
    		console.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );
    	}
    } );

    Object.assign( Plane.prototype, {
    	isIntersectionLine: function ( line ) {
    		console.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );
    		return this.intersectsLine( line );
    	}
    } );

    Object.assign( Quaternion.prototype, {
    	multiplyVector3: function ( vector ) {
    		console.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
    		return vector.applyQuaternion( this );
    	}
    } );

    Object.assign( Ray.prototype, {
    	isIntersectionBox: function ( box ) {
    		console.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );
    		return this.intersectsBox( box );
    	},
    	isIntersectionPlane: function ( plane ) {
    		console.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );
    		return this.intersectsPlane( plane );
    	},
    	isIntersectionSphere: function ( sphere ) {
    		console.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
    		return this.intersectsSphere( sphere );
    	}
    } );

    Object.assign( Shape.prototype, {
    	extrude: function ( options ) {
    		console.warn( 'THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.' );
    		return new ExtrudeGeometry( this, options );
    	},
    	makeGeometry: function ( options ) {
    		console.warn( 'THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.' );
    		return new ShapeGeometry( this, options );
    	}
    } );

    Object.assign( Vector3.prototype, {
    	setEulerFromRotationMatrix: function () {
    		console.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );
    	},
    	setEulerFromQuaternion: function () {
    		console.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );
    	},
    	getPositionFromMatrix: function ( m ) {
    		console.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );
    		return this.setFromMatrixPosition( m );
    	},
    	getScaleFromMatrix: function ( m ) {
    		console.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );
    		return this.setFromMatrixScale( m );
    	},
    	getColumnFromMatrix: function ( index, matrix ) {
    		console.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );
    		return this.setFromMatrixColumn( matrix, index );
    	}
    } );

    //

    Object.assign( Object3D.prototype, {
    	getChildByName: function ( name ) {
    		console.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );
    		return this.getObjectByName( name );
    	},
    	renderDepth: function ( value ) {
    		console.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );
    	},
    	translate: function ( distance, axis ) {
    		console.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );
    		return this.translateOnAxis( axis, distance );
    	}
    } );

    Object.defineProperties( Object3D.prototype, {
    	eulerOrder: {
    		get: function () {
    			console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
    			return this.rotation.order;
    		},
    		set: function ( value ) {
    			console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
    			this.rotation.order = value;
    		}
    	},
    	useQuaternion: {
    		get: function () {
    			console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );
    		},
    		set: function ( value ) {
    			console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );
    		}
    	}
    } );

    Object.defineProperties( LOD.prototype, {
    	objects: {
    		get: function () {
    			console.warn( 'THREE.LOD: .objects has been renamed to .levels.' );
    			return this.levels;
    		}
    	}
    } );

    //

    PerspectiveCamera.prototype.setLens = function ( focalLength, filmGauge ) {

    	console.warn( "THREE.PerspectiveCamera.setLens is deprecated. " +
    			"Use .setFocalLength and .filmGauge for a photographic setup." );

    	if ( filmGauge !== undefined ) this.filmGauge = filmGauge;
    	this.setFocalLength( focalLength );

    };

    //

    Object.defineProperties( Light.prototype, {
    	onlyShadow: {
    		set: function ( value ) {
    			console.warn( 'THREE.Light: .onlyShadow has been removed.' );
    		}
    	},
    	shadowCameraFov: {
    		set: function ( value ) {
    			console.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );
    			this.shadow.camera.fov = value;
    		}
    	},
    	shadowCameraLeft: {
    		set: function ( value ) {
    			console.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );
    			this.shadow.camera.left = value;
    		}
    	},
    	shadowCameraRight: {
    		set: function ( value ) {
    			console.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );
    			this.shadow.camera.right = value;
    		}
    	},
    	shadowCameraTop: {
    		set: function ( value ) {
    			console.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );
    			this.shadow.camera.top = value;
    		}
    	},
    	shadowCameraBottom: {
    		set: function ( value ) {
    			console.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );
    			this.shadow.camera.bottom = value;
    		}
    	},
    	shadowCameraNear: {
    		set: function ( value ) {
    			console.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );
    			this.shadow.camera.near = value;
    		}
    	},
    	shadowCameraFar: {
    		set: function ( value ) {
    			console.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );
    			this.shadow.camera.far = value;
    		}
    	},
    	shadowCameraVisible: {
    		set: function ( value ) {
    			console.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );
    		}
    	},
    	shadowBias: {
    		set: function ( value ) {
    			console.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );
    			this.shadow.bias = value;
    		}
    	},
    	shadowDarkness: {
    		set: function ( value ) {
    			console.warn( 'THREE.Light: .shadowDarkness has been removed.' );
    		}
    	},
    	shadowMapWidth: {
    		set: function ( value ) {
    			console.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );
    			this.shadow.mapSize.width = value;
    		}
    	},
    	shadowMapHeight: {
    		set: function ( value ) {
    			console.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );
    			this.shadow.mapSize.height = value;
    		}
    	}
    } );

    //

    Object.defineProperties( BufferAttribute.prototype, {
    	length: {
    		get: function () {
    			console.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );
    			return this.array.length;
    		}
    	}
    } );

    Object.assign( BufferGeometry.prototype, {
    	addIndex: function ( index ) {
    		console.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );
    		this.setIndex( index );
    	},
    	addDrawCall: function ( start, count, indexOffset ) {
    		if ( indexOffset !== undefined ) {
    			console.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );
    		}
    		console.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );
    		this.addGroup( start, count );
    	},
    	clearDrawCalls: function () {
    		console.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );
    		this.clearGroups();
    	},
    	computeTangents: function () {
    		console.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );
    	},
    	computeOffsets: function () {
    		console.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );
    	}
    } );

    Object.defineProperties( BufferGeometry.prototype, {
    	drawcalls: {
    		get: function () {
    			console.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );
    			return this.groups;
    		}
    	},
    	offsets: {
    		get: function () {
    			console.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );
    			return this.groups;
    		}
    	}
    } );

    //

    Object.defineProperties( Material.prototype, {
    	wrapAround: {
    		get: function () {
    			console.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );
    		},
    		set: function ( value ) {
    			console.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );
    		}
    	},
    	wrapRGB: {
    		get: function () {
    			console.warn( 'THREE.' + this.type + ': .wrapRGB has been removed.' );
    			return new Color();
    		}
    	}
    } );

    Object.defineProperties( MeshPhongMaterial.prototype, {
    	metal: {
    		get: function () {
    			console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.' );
    			return false;
    		},
    		set: function ( value ) {
    			console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead' );
    		}
    	}
    } );

    Object.defineProperties( ShaderMaterial.prototype, {
    	derivatives: {
    		get: function () {
    			console.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
    			return this.extensions.derivatives;
    		},
    		set: function ( value ) {
    			console.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
    			this.extensions.derivatives = value;
    		}
    	}
    } );

    //

    EventDispatcher.prototype = Object.assign( Object.create( {

    	// Note: Extra base ensures these properties are not 'assign'ed.

    	constructor: EventDispatcher,

    	apply: function ( target ) {

    		console.warn( "THREE.EventDispatcher: .apply is deprecated, " +
    				"just inherit or Object.assign the prototype to mix-in." );

    		Object.assign( target, this );

    	}

    } ), EventDispatcher.prototype );

    //

    Object.assign( WebGLRenderer.prototype, {
    	supportsFloatTextures: function () {
    		console.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).' );
    		return this.extensions.get( 'OES_texture_float' );
    	},
    	supportsHalfFloatTextures: function () {
    		console.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).' );
    		return this.extensions.get( 'OES_texture_half_float' );
    	},
    	supportsStandardDerivatives: function () {
    		console.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).' );
    		return this.extensions.get( 'OES_standard_derivatives' );
    	},
    	supportsCompressedTextureS3TC: function () {
    		console.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).' );
    		return this.extensions.get( 'WEBGL_compressed_texture_s3tc' );
    	},
    	supportsCompressedTexturePVRTC: function () {
    		console.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).' );
    		return this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );
    	},
    	supportsBlendMinMax: function () {
    		console.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).' );
    		return this.extensions.get( 'EXT_blend_minmax' );
    	},
    	supportsVertexTextures: function () {
    		return this.capabilities.vertexTextures;
    	},
    	supportsInstancedArrays: function () {
    		console.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).' );
    		return this.extensions.get( 'ANGLE_instanced_arrays' );
    	},
    	enableScissorTest: function ( boolean ) {
    		console.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );
    		this.setScissorTest( boolean );
    	},
    	initMaterial: function () {
    		console.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );
    	},
    	addPrePlugin: function () {
    		console.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );
    	},
    	addPostPlugin: function () {
    		console.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );
    	},
    	updateShadowMap: function () {
    		console.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );
    	}
    } );

    Object.defineProperties( WebGLRenderer.prototype, {
    	shadowMapEnabled: {
    		get: function () {
    			return this.shadowMap.enabled;
    		},
    		set: function ( value ) {
    			console.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );
    			this.shadowMap.enabled = value;
    		}
    	},
    	shadowMapType: {
    		get: function () {
    			return this.shadowMap.type;
    		},
    		set: function ( value ) {
    			console.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );
    			this.shadowMap.type = value;
    		}
    	},
    	shadowMapCullFace: {
    		get: function () {
    			return this.shadowMap.cullFace;
    		},
    		set: function ( value ) {
    			console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.' );
    			this.shadowMap.cullFace = value;
    		}
    	}
    } );

    Object.defineProperties( WebGLShadowMap.prototype, {
    	cullFace: {
    		get: function () {
    			return this.renderReverseSided ? CullFaceFront : CullFaceBack;
    		},
    		set: function ( cullFace ) {
    			var value = ( cullFace !== CullFaceBack );
    			console.warn( "WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to " + value + "." );
    			this.renderReverseSided = value;
    		}
    	}
    } );

    //

    Object.defineProperties( WebGLRenderTarget.prototype, {
    	wrapS: {
    		get: function () {
    			console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
    			return this.texture.wrapS;
    		},
    		set: function ( value ) {
    			console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
    			this.texture.wrapS = value;
    		}
    	},
    	wrapT: {
    		get: function () {
    			console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
    			return this.texture.wrapT;
    		},
    		set: function ( value ) {
    			console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
    			this.texture.wrapT = value;
    		}
    	},
    	magFilter: {
    		get: function () {
    			console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
    			return this.texture.magFilter;
    		},
    		set: function ( value ) {
    			console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
    			this.texture.magFilter = value;
    		}
    	},
    	minFilter: {
    		get: function () {
    			console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
    			return this.texture.minFilter;
    		},
    		set: function ( value ) {
    			console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
    			this.texture.minFilter = value;
    		}
    	},
    	anisotropy: {
    		get: function () {
    			console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
    			return this.texture.anisotropy;
    		},
    		set: function ( value ) {
    			console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
    			this.texture.anisotropy = value;
    		}
    	},
    	offset: {
    		get: function () {
    			console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
    			return this.texture.offset;
    		},
    		set: function ( value ) {
    			console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
    			this.texture.offset = value;
    		}
    	},
    	repeat: {
    		get: function () {
    			console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
    			return this.texture.repeat;
    		},
    		set: function ( value ) {
    			console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
    			this.texture.repeat = value;
    		}
    	},
    	format: {
    		get: function () {
    			console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
    			return this.texture.format;
    		},
    		set: function ( value ) {
    			console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
    			this.texture.format = value;
    		}
    	},
    	type: {
    		get: function () {
    			console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
    			return this.texture.type;
    		},
    		set: function ( value ) {
    			console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
    			this.texture.type = value;
    		}
    	},
    	generateMipmaps: {
    		get: function () {
    			console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
    			return this.texture.generateMipmaps;
    		},
    		set: function ( value ) {
    			console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
    			this.texture.generateMipmaps = value;
    		}
    	}
    } );

    //

    Object.assign( Audio.prototype, {
    	load: function ( file ) {
    		console.warn( 'THREE.Audio: .load has been deprecated. Please use THREE.AudioLoader.' );
    		var scope = this;
    		var audioLoader = new AudioLoader();
    		audioLoader.load( file, function ( buffer ) {
    			scope.setBuffer( buffer );
    		} );
    		return this;
    	}
    } );

    Object.assign( AudioAnalyser.prototype, {
    	getData: function ( file ) {
    		console.warn( 'THREE.AudioAnalyser: .getData() is now .getFrequencyData().' );
    		return this.getFrequencyData();
    	}
    } );

    //

    var GeometryUtils = {

    	merge: function ( geometry1, geometry2, materialIndexOffset ) {

    		console.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );

    		var matrix;

    		if ( geometry2.isMesh ) {

    			geometry2.matrixAutoUpdate && geometry2.updateMatrix();

    			matrix = geometry2.matrix;
    			geometry2 = geometry2.geometry;

    		}

    		geometry1.merge( geometry2, matrix, materialIndexOffset );

    	},

    	center: function ( geometry ) {

    		console.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );
    		return geometry.center();

    	}

    };

    var ImageUtils = {

    	crossOrigin: undefined,

    	loadTexture: function ( url, mapping, onLoad, onError ) {

    		console.warn( 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' );

    		var loader = new TextureLoader();
    		loader.setCrossOrigin( this.crossOrigin );

    		var texture = loader.load( url, onLoad, undefined, onError );

    		if ( mapping ) texture.mapping = mapping;

    		return texture;

    	},

    	loadTextureCube: function ( urls, mapping, onLoad, onError ) {

    		console.warn( 'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.' );

    		var loader = new CubeTextureLoader();
    		loader.setCrossOrigin( this.crossOrigin );

    		var texture = loader.load( urls, onLoad, undefined, onError );

    		if ( mapping ) texture.mapping = mapping;

    		return texture;

    	},

    	loadCompressedTexture: function () {

    		console.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' );

    	},

    	loadCompressedTextureCube: function () {

    		console.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' );

    	}

    };

    //

    function Projector () {

    	console.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );

    	this.projectVector = function ( vector, camera ) {

    		console.warn( 'THREE.Projector: .projectVector() is now vector.project().' );
    		vector.project( camera );

    	};

    	this.unprojectVector = function ( vector, camera ) {

    		console.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );
    		vector.unproject( camera );

    	};

    	this.pickingRay = function ( vector, camera ) {

    		console.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );

    	};

    }

    //

    function CanvasRenderer () {

    	console.error( 'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' );

    	this.domElement = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
    	this.clear = function () {};
    	this.render = function () {};
    	this.setClearColor = function () {};
    	this.setSize = function () {};

    }

    Object.defineProperty( exports, 'AudioContext', {
    	get: function () {
    		return exports.getAudioContext();
    	}
    });

    exports.WebGLRenderTargetCube = WebGLRenderTargetCube;
    exports.WebGLRenderTarget = WebGLRenderTarget;
    exports.WebGLRenderer = WebGLRenderer;
    exports.ShaderLib = ShaderLib;
    exports.UniformsLib = UniformsLib;
    exports.ShaderChunk = ShaderChunk;
    exports.FogExp2 = FogExp2;
    exports.Fog = Fog;
    exports.Scene = Scene;
    exports.LensFlare = LensFlare;
    exports.Sprite = Sprite;
    exports.LOD = LOD;
    exports.SkinnedMesh = SkinnedMesh;
    exports.Skeleton = Skeleton;
    exports.Bone = Bone;
    exports.Mesh = Mesh;
    exports.LineSegments = LineSegments;
    exports.Line = Line;
    exports.Points = Points;
    exports.Group = Group;
    exports.VideoTexture = VideoTexture;
    exports.DataTexture = DataTexture;
    exports.CompressedTexture = CompressedTexture;
    exports.CubeTexture = CubeTexture;
    exports.CanvasTexture = CanvasTexture;
    exports.DepthTexture = DepthTexture;
    exports.TextureIdCount = TextureIdCount;
    exports.Texture = Texture;
    exports.MaterialIdCount = MaterialIdCount;
    exports.CompressedTextureLoader = CompressedTextureLoader;
    exports.BinaryTextureLoader = BinaryTextureLoader;
    exports.DataTextureLoader = DataTextureLoader;
    exports.CubeTextureLoader = CubeTextureLoader;
    exports.TextureLoader = TextureLoader;
    exports.ObjectLoader = ObjectLoader;
    exports.MaterialLoader = MaterialLoader;
    exports.BufferGeometryLoader = BufferGeometryLoader;
    exports.LoadingManager = LoadingManager;
    exports.JSONLoader = JSONLoader;
    exports.ImageLoader = ImageLoader;
    exports.FontLoader = FontLoader;
    exports.XHRLoader = XHRLoader;
    exports.Loader = Loader;
    exports.AudioLoader = AudioLoader;
    exports.SpotLightShadow = SpotLightShadow;
    exports.SpotLight = SpotLight;
    exports.PointLight = PointLight;
    exports.HemisphereLight = HemisphereLight;
    exports.DirectionalLightShadow = DirectionalLightShadow;
    exports.DirectionalLight = DirectionalLight;
    exports.AmbientLight = AmbientLight;
    exports.LightShadow = LightShadow;
    exports.Light = Light;
    exports.StereoCamera = StereoCamera;
    exports.PerspectiveCamera = PerspectiveCamera;
    exports.OrthographicCamera = OrthographicCamera;
    exports.CubeCamera = CubeCamera;
    exports.Camera = Camera;
    exports.AudioListener = AudioListener;
    exports.PositionalAudio = PositionalAudio;
    exports.getAudioContext = getAudioContext;
    exports.AudioAnalyser = AudioAnalyser;
    exports.Audio = Audio;
    exports.VectorKeyframeTrack = VectorKeyframeTrack;
    exports.StringKeyframeTrack = StringKeyframeTrack;
    exports.QuaternionKeyframeTrack = QuaternionKeyframeTrack;
    exports.NumberKeyframeTrack = NumberKeyframeTrack;
    exports.ColorKeyframeTrack = ColorKeyframeTrack;
    exports.BooleanKeyframeTrack = BooleanKeyframeTrack;
    exports.PropertyMixer = PropertyMixer;
    exports.PropertyBinding = PropertyBinding;
    exports.KeyframeTrack = KeyframeTrack;
    exports.AnimationObjectGroup = AnimationObjectGroup;
    exports.AnimationMixer = AnimationMixer;
    exports.AnimationClip = AnimationClip;
    exports.Uniform = Uniform;
    exports.InstancedBufferGeometry = InstancedBufferGeometry;
    exports.BufferGeometry = BufferGeometry;
    exports.GeometryIdCount = GeometryIdCount;
    exports.Geometry = Geometry;
    exports.InterleavedBufferAttribute = InterleavedBufferAttribute;
    exports.InstancedInterleavedBuffer = InstancedInterleavedBuffer;
    exports.InterleavedBuffer = InterleavedBuffer;
    exports.InstancedBufferAttribute = InstancedBufferAttribute;
    exports.DynamicBufferAttribute = DynamicBufferAttribute;
    exports.Float64Attribute = Float64Attribute;
    exports.Float32Attribute = Float32Attribute;
    exports.Uint32Attribute = Uint32Attribute;
    exports.Int32Attribute = Int32Attribute;
    exports.Uint16Attribute = Uint16Attribute;
    exports.Int16Attribute = Int16Attribute;
    exports.Uint8ClampedAttribute = Uint8ClampedAttribute;
    exports.Uint8Attribute = Uint8Attribute;
    exports.Int8Attribute = Int8Attribute;
    exports.BufferAttribute = BufferAttribute;
    exports.Face3 = Face3;
    exports.Object3DIdCount = Object3DIdCount;
    exports.Object3D = Object3D;
    exports.Raycaster = Raycaster;
    exports.Layers = Layers;
    exports.EventDispatcher = EventDispatcher;
    exports.Clock = Clock;
    exports.QuaternionLinearInterpolant = QuaternionLinearInterpolant;
    exports.LinearInterpolant = LinearInterpolant;
    exports.DiscreteInterpolant = DiscreteInterpolant;
    exports.CubicInterpolant = CubicInterpolant;
    exports.Interpolant = Interpolant;
    exports.Triangle = Triangle;
    exports.Spline = Spline;
    exports.Spherical = Spherical;
    exports.Plane = Plane;
    exports.Frustum = Frustum;
    exports.Sphere = Sphere;
    exports.Ray = Ray;
    exports.Matrix4 = Matrix4;
    exports.Matrix3 = Matrix3;
    exports.Box3 = Box3;
    exports.Box2 = Box2;
    exports.Line3 = Line3;
    exports.Euler = Euler;
    exports.Vector4 = Vector4;
    exports.Vector3 = Vector3;
    exports.Vector2 = Vector2;
    exports.Quaternion = Quaternion;
    exports.Color = Color;
    exports.MorphBlendMesh = MorphBlendMesh;
    exports.ImmediateRenderObject = ImmediateRenderObject;
    exports.VertexNormalsHelper = VertexNormalsHelper;
    exports.SpotLightHelper = SpotLightHelper;
    exports.SkeletonHelper = SkeletonHelper;
    exports.PointLightHelper = PointLightHelper;
    exports.HemisphereLightHelper = HemisphereLightHelper;
    exports.GridHelper = GridHelper;
    exports.FaceNormalsHelper = FaceNormalsHelper;
    exports.DirectionalLightHelper = DirectionalLightHelper;
    exports.CameraHelper = CameraHelper;
    exports.BoundingBoxHelper = BoundingBoxHelper;
    exports.BoxHelper = BoxHelper;
    exports.ArrowHelper = ArrowHelper;
    exports.AxisHelper = AxisHelper;
    exports.ClosedSplineCurve3 = ClosedSplineCurve3;
    exports.SplineCurve3 = SplineCurve3;
    exports.ArcCurve = ArcCurve;
    exports.EllipseCurve = EllipseCurve;
    exports.SplineCurve = SplineCurve;
    exports.CubicBezierCurve = CubicBezierCurve;
    exports.QuadraticBezierCurve = QuadraticBezierCurve;
    exports.LineCurve = LineCurve;
    exports.Shape = Shape;
    exports.ShapePath = ShapePath;
    exports.Path = Path;
    exports.Font = Font;
    exports.CurvePath = CurvePath;
    exports.Curve = Curve;
    exports.WireframeGeometry = WireframeGeometry;
    exports.ParametricGeometry = ParametricGeometry;
    exports.TetrahedronGeometry = TetrahedronGeometry;
    exports.OctahedronGeometry = OctahedronGeometry;
    exports.IcosahedronGeometry = IcosahedronGeometry;
    exports.DodecahedronGeometry = DodecahedronGeometry;
    exports.PolyhedronGeometry = PolyhedronGeometry;
    exports.TubeGeometry = TubeGeometry;
    exports.TorusKnotGeometry = TorusKnotGeometry;
    exports.TorusKnotBufferGeometry = TorusKnotBufferGeometry;
    exports.TorusGeometry = TorusGeometry;
    exports.TorusBufferGeometry = TorusBufferGeometry;
    exports.TextGeometry = TextGeometry;
    exports.SphereBufferGeometry = SphereBufferGeometry;
    exports.SphereGeometry = SphereGeometry;
    exports.RingGeometry = RingGeometry;
    exports.RingBufferGeometry = RingBufferGeometry;
    exports.PlaneBufferGeometry = PlaneBufferGeometry;
    exports.PlaneGeometry = PlaneGeometry;
    exports.LatheGeometry = LatheGeometry;
    exports.LatheBufferGeometry = LatheBufferGeometry;
    exports.ShapeGeometry = ShapeGeometry;
    exports.ExtrudeGeometry = ExtrudeGeometry;
    exports.EdgesGeometry = EdgesGeometry;
    exports.ConeGeometry = ConeGeometry;
    exports.ConeBufferGeometry = ConeBufferGeometry;
    exports.CylinderGeometry = CylinderGeometry;
    exports.CylinderBufferGeometry = CylinderBufferGeometry;
    exports.CircleBufferGeometry = CircleBufferGeometry;
    exports.CircleGeometry = CircleGeometry;
    exports.BoxBufferGeometry = BoxBufferGeometry;
    exports.BoxGeometry = BoxGeometry;
    exports.ShadowMaterial = ShadowMaterial;
    exports.SpriteMaterial = SpriteMaterial;
    exports.RawShaderMaterial = RawShaderMaterial;
    exports.ShaderMaterial = ShaderMaterial;
    exports.PointsMaterial = PointsMaterial;
    exports.MultiMaterial = MultiMaterial;
    exports.MeshPhysicalMaterial = MeshPhysicalMaterial;
    exports.MeshStandardMaterial = MeshStandardMaterial;
    exports.MeshPhongMaterial = MeshPhongMaterial;
    exports.MeshNormalMaterial = MeshNormalMaterial;
    exports.MeshLambertMaterial = MeshLambertMaterial;
    exports.MeshDepthMaterial = MeshDepthMaterial;
    exports.MeshBasicMaterial = MeshBasicMaterial;
    exports.LineDashedMaterial = LineDashedMaterial;
    exports.LineBasicMaterial = LineBasicMaterial;
    exports.Material = Material;
    exports.REVISION = REVISION;
    exports.MOUSE = MOUSE;
    exports.CullFaceNone = CullFaceNone;
    exports.CullFaceBack = CullFaceBack;
    exports.CullFaceFront = CullFaceFront;
    exports.CullFaceFrontBack = CullFaceFrontBack;
    exports.FrontFaceDirectionCW = FrontFaceDirectionCW;
    exports.FrontFaceDirectionCCW = FrontFaceDirectionCCW;
    exports.BasicShadowMap = BasicShadowMap;
    exports.PCFShadowMap = PCFShadowMap;
    exports.PCFSoftShadowMap = PCFSoftShadowMap;
    exports.FrontSide = FrontSide;
    exports.BackSide = BackSide;
    exports.DoubleSide = DoubleSide;
    exports.FlatShading = FlatShading;
    exports.SmoothShading = SmoothShading;
    exports.NoColors = NoColors;
    exports.FaceColors = FaceColors;
    exports.VertexColors = VertexColors;
    exports.NoBlending = NoBlending;
    exports.NormalBlending = NormalBlending;
    exports.AdditiveBlending = AdditiveBlending;
    exports.SubtractiveBlending = SubtractiveBlending;
    exports.MultiplyBlending = MultiplyBlending;
    exports.CustomBlending = CustomBlending;
    exports.BlendingMode = BlendingMode;
    exports.AddEquation = AddEquation;
    exports.SubtractEquation = SubtractEquation;
    exports.ReverseSubtractEquation = ReverseSubtractEquation;
    exports.MinEquation = MinEquation;
    exports.MaxEquation = MaxEquation;
    exports.ZeroFactor = ZeroFactor;
    exports.OneFactor = OneFactor;
    exports.SrcColorFactor = SrcColorFactor;
    exports.OneMinusSrcColorFactor = OneMinusSrcColorFactor;
    exports.SrcAlphaFactor = SrcAlphaFactor;
    exports.OneMinusSrcAlphaFactor = OneMinusSrcAlphaFactor;
    exports.DstAlphaFactor = DstAlphaFactor;
    exports.OneMinusDstAlphaFactor = OneMinusDstAlphaFactor;
    exports.DstColorFactor = DstColorFactor;
    exports.OneMinusDstColorFactor = OneMinusDstColorFactor;
    exports.SrcAlphaSaturateFactor = SrcAlphaSaturateFactor;
    exports.NeverDepth = NeverDepth;
    exports.AlwaysDepth = AlwaysDepth;
    exports.LessDepth = LessDepth;
    exports.LessEqualDepth = LessEqualDepth;
    exports.EqualDepth = EqualDepth;
    exports.GreaterEqualDepth = GreaterEqualDepth;
    exports.GreaterDepth = GreaterDepth;
    exports.NotEqualDepth = NotEqualDepth;
    exports.MultiplyOperation = MultiplyOperation;
    exports.MixOperation = MixOperation;
    exports.AddOperation = AddOperation;
    exports.NoToneMapping = NoToneMapping;
    exports.LinearToneMapping = LinearToneMapping;
    exports.ReinhardToneMapping = ReinhardToneMapping;
    exports.Uncharted2ToneMapping = Uncharted2ToneMapping;
    exports.CineonToneMapping = CineonToneMapping;
    exports.UVMapping = UVMapping;
    exports.CubeReflectionMapping = CubeReflectionMapping;
    exports.CubeRefractionMapping = CubeRefractionMapping;
    exports.EquirectangularReflectionMapping = EquirectangularReflectionMapping;
    exports.EquirectangularRefractionMapping = EquirectangularRefractionMapping;
    exports.SphericalReflectionMapping = SphericalReflectionMapping;
    exports.CubeUVReflectionMapping = CubeUVReflectionMapping;
    exports.CubeUVRefractionMapping = CubeUVRefractionMapping;
    exports.TextureMapping = TextureMapping;
    exports.RepeatWrapping = RepeatWrapping;
    exports.ClampToEdgeWrapping = ClampToEdgeWrapping;
    exports.MirroredRepeatWrapping = MirroredRepeatWrapping;
    exports.TextureWrapping = TextureWrapping;
    exports.NearestFilter = NearestFilter;
    exports.NearestMipMapNearestFilter = NearestMipMapNearestFilter;
    exports.NearestMipMapLinearFilter = NearestMipMapLinearFilter;
    exports.LinearFilter = LinearFilter;
    exports.LinearMipMapNearestFilter = LinearMipMapNearestFilter;
    exports.LinearMipMapLinearFilter = LinearMipMapLinearFilter;
    exports.TextureFilter = TextureFilter;
    exports.UnsignedByteType = UnsignedByteType;
    exports.ByteType = ByteType;
    exports.ShortType = ShortType;
    exports.UnsignedShortType = UnsignedShortType;
    exports.IntType = IntType;
    exports.UnsignedIntType = UnsignedIntType;
    exports.FloatType = FloatType;
    exports.HalfFloatType = HalfFloatType;
    exports.UnsignedShort4444Type = UnsignedShort4444Type;
    exports.UnsignedShort5551Type = UnsignedShort5551Type;
    exports.UnsignedShort565Type = UnsignedShort565Type;
    exports.UnsignedInt248Type = UnsignedInt248Type;
    exports.AlphaFormat = AlphaFormat;
    exports.RGBFormat = RGBFormat;
    exports.RGBAFormat = RGBAFormat;
    exports.LuminanceFormat = LuminanceFormat;
    exports.LuminanceAlphaFormat = LuminanceAlphaFormat;
    exports.RGBEFormat = RGBEFormat;
    exports.DepthFormat = DepthFormat;
    exports.DepthStencilFormat = DepthStencilFormat;
    exports.RGB_S3TC_DXT1_Format = RGB_S3TC_DXT1_Format;
    exports.RGBA_S3TC_DXT1_Format = RGBA_S3TC_DXT1_Format;
    exports.RGBA_S3TC_DXT3_Format = RGBA_S3TC_DXT3_Format;
    exports.RGBA_S3TC_DXT5_Format = RGBA_S3TC_DXT5_Format;
    exports.RGB_PVRTC_4BPPV1_Format = RGB_PVRTC_4BPPV1_Format;
    exports.RGB_PVRTC_2BPPV1_Format = RGB_PVRTC_2BPPV1_Format;
    exports.RGBA_PVRTC_4BPPV1_Format = RGBA_PVRTC_4BPPV1_Format;
    exports.RGBA_PVRTC_2BPPV1_Format = RGBA_PVRTC_2BPPV1_Format;
    exports.RGB_ETC1_Format = RGB_ETC1_Format;
    exports.LoopOnce = LoopOnce;
    exports.LoopRepeat = LoopRepeat;
    exports.LoopPingPong = LoopPingPong;
    exports.InterpolateDiscrete = InterpolateDiscrete;
    exports.InterpolateLinear = InterpolateLinear;
    exports.InterpolateSmooth = InterpolateSmooth;
    exports.ZeroCurvatureEnding = ZeroCurvatureEnding;
    exports.ZeroSlopeEnding = ZeroSlopeEnding;
    exports.WrapAroundEnding = WrapAroundEnding;
    exports.TrianglesDrawMode = TrianglesDrawMode;
    exports.TriangleStripDrawMode = TriangleStripDrawMode;
    exports.TriangleFanDrawMode = TriangleFanDrawMode;
    exports.LinearEncoding = LinearEncoding;
    exports.sRGBEncoding = sRGBEncoding;
    exports.GammaEncoding = GammaEncoding;
    exports.RGBEEncoding = RGBEEncoding;
    exports.LogLuvEncoding = LogLuvEncoding;
    exports.RGBM7Encoding = RGBM7Encoding;
    exports.RGBM16Encoding = RGBM16Encoding;
    exports.RGBDEncoding = RGBDEncoding;
    exports.BasicDepthPacking = BasicDepthPacking;
    exports.RGBADepthPacking = RGBADepthPacking;
    exports.CubeGeometry = BoxGeometry;
    exports.Face4 = Face4;
    exports.LineStrip = LineStrip;
    exports.LinePieces = LinePieces;
    exports.MeshFaceMaterial = MultiMaterial;
    exports.PointCloud = PointCloud;
    exports.Particle = Sprite;
    exports.ParticleSystem = ParticleSystem;
    exports.PointCloudMaterial = PointCloudMaterial;
    exports.ParticleBasicMaterial = ParticleBasicMaterial;
    exports.ParticleSystemMaterial = ParticleSystemMaterial;
    exports.Vertex = Vertex;
    exports.EdgesHelper = EdgesHelper;
    exports.WireframeHelper = WireframeHelper;
    exports.GeometryUtils = GeometryUtils;
    exports.ImageUtils = ImageUtils;
    exports.Projector = Projector;
    exports.CanvasRenderer = CanvasRenderer;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
},{}],2:[function(require,module,exports){
'use strict';

var _three = require('three');

var THREE = _interopRequireWildcard(_three);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

// import anime from 'animejs'


var camera = void 0,
    scene = void 0,
    renderer = void 0,
    mesh = void 0;

var init = function init() {
	camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 1000);
	camera.position.z = 400;

	scene = new THREE.Scene();

	var geometry = new THREE.BoxBufferGeometry(100, 100, 100);
	var material = new THREE.MeshBasicMaterial();

	mesh = new THREE.Mesh(geometry, material);
	scene.add(mesh);

	renderer = new THREE.WebGLRenderer();
	renderer.setPixelRatio(window.devicePixelRatio);
	renderer.setSize(window.innerWidth, window.innerHeight);

	document.body.appendChild(renderer.domElement);

	window.addEventListener('resize', onWindowResize, false);
};

var onWindowResize = function onWindowResize() {
	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();
	renderer.setSize(window.innerWidth, window.innerHeight);
};

var animate = function animate() {
	requestAnimationFrame(animate);
	mesh.rotation.x += 0.001;
	mesh.rotation.y += 0.002;
	renderer.render(scene, camera);
};

init();
animate();

},{"three":1}]},{},[2])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvdGhyZWUvYnVpbGQvdGhyZWUuanMiLCJzcmMvanMvbWFpbi5qc3giXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDL3p4Q0E7O0lBQVksSzs7OztBQUNaOzs7QUFHQSxJQUFJLGVBQUo7QUFBQSxJQUFZLGNBQVo7QUFBQSxJQUFtQixpQkFBbkI7QUFBQSxJQUE2QixhQUE3Qjs7QUFFQSxJQUFNLE9BQU8sU0FBUCxJQUFPLEdBQU07QUFDbEIsVUFBUyxJQUFJLE1BQU0saUJBQVYsQ0FBNkIsRUFBN0IsRUFBaUMsT0FBTyxVQUFQLEdBQW9CLE9BQU8sV0FBNUQsRUFBeUUsQ0FBekUsRUFBNEUsSUFBNUUsQ0FBVDtBQUNBLFFBQU8sUUFBUCxDQUFnQixDQUFoQixHQUFvQixHQUFwQjs7QUFFQSxTQUFRLElBQUksTUFBTSxLQUFWLEVBQVI7O0FBRUEsS0FBTSxXQUFXLElBQUksTUFBTSxpQkFBVixDQUE2QixHQUE3QixFQUFrQyxHQUFsQyxFQUF1QyxHQUF2QyxDQUFqQjtBQUNBLEtBQU0sV0FBVyxJQUFJLE1BQU0saUJBQVYsRUFBakI7O0FBRUEsUUFBTyxJQUFJLE1BQU0sSUFBVixDQUFnQixRQUFoQixFQUEwQixRQUExQixDQUFQO0FBQ0EsT0FBTSxHQUFOLENBQVUsSUFBVjs7QUFFQSxZQUFXLElBQUksTUFBTSxhQUFWLEVBQVg7QUFDQSxVQUFTLGFBQVQsQ0FBd0IsT0FBTyxnQkFBL0I7QUFDQSxVQUFTLE9BQVQsQ0FBa0IsT0FBTyxVQUF6QixFQUFxQyxPQUFPLFdBQTVDOztBQUVBLFVBQVMsSUFBVCxDQUFjLFdBQWQsQ0FBMkIsU0FBUyxVQUFwQzs7QUFFQSxRQUFPLGdCQUFQLENBQXlCLFFBQXpCLEVBQW1DLGNBQW5DLEVBQW1ELEtBQW5EO0FBQ0EsQ0FuQkQ7O0FBc0JBLElBQU0saUJBQWlCLFNBQWpCLGNBQWlCLEdBQU07QUFDNUIsUUFBTyxNQUFQLEdBQWdCLE9BQU8sVUFBUCxHQUFvQixPQUFPLFdBQTNDO0FBQ0EsUUFBTyxzQkFBUDtBQUNBLFVBQVMsT0FBVCxDQUFrQixPQUFPLFVBQXpCLEVBQXFDLE9BQU8sV0FBNUM7QUFDQSxDQUpEOztBQU9BLElBQU0sVUFBVSxTQUFWLE9BQVUsR0FBTTtBQUNyQix1QkFBdUIsT0FBdkI7QUFDQSxNQUFLLFFBQUwsQ0FBYyxDQUFkLElBQW1CLEtBQW5CO0FBQ0EsTUFBSyxRQUFMLENBQWMsQ0FBZCxJQUFtQixLQUFuQjtBQUNBLFVBQVMsTUFBVCxDQUFpQixLQUFqQixFQUF3QixNQUF4QjtBQUNBLENBTEQ7O0FBT0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuICAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuICAgIChmYWN0b3J5KChnbG9iYWwuVEhSRUUgPSBnbG9iYWwuVEhSRUUgfHwge30pKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbiAgICAvLyBQb2x5ZmlsbHNcblxuICAgIGlmICggTnVtYmVyLkVQU0lMT04gPT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0TnVtYmVyLkVQU0lMT04gPSBNYXRoLnBvdyggMiwgLSA1MiApO1xuXG4gICAgfVxuXG4gICAgLy9cblxuICAgIGlmICggTWF0aC5zaWduID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvc2lnblxuXG4gICAgXHRNYXRoLnNpZ24gPSBmdW5jdGlvbiAoIHggKSB7XG5cbiAgICBcdFx0cmV0dXJuICggeCA8IDAgKSA/IC0gMSA6ICggeCA+IDAgKSA/IDEgOiArIHg7XG5cbiAgICBcdH07XG5cbiAgICB9XG5cbiAgICBpZiAoIEZ1bmN0aW9uLnByb3RvdHlwZS5uYW1lID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdC8vIE1pc3NpbmcgaW4gSUU5LTExLlxuICAgIFx0Ly8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRnVuY3Rpb24vbmFtZVxuXG4gICAgXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIEZ1bmN0aW9uLnByb3RvdHlwZSwgJ25hbWUnLCB7XG5cbiAgICBcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0XHRyZXR1cm4gdGhpcy50b1N0cmluZygpLm1hdGNoKCAvXlxccypmdW5jdGlvblxccyooXFxTKilcXHMqXFwoLyApWyAxIF07XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9ICk7XG5cbiAgICB9XG5cbiAgICBpZiAoIE9iamVjdC5hc3NpZ24gPT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0Ly8gTWlzc2luZyBpbiBJRS5cbiAgICBcdC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9hc3NpZ25cblxuICAgIFx0KCBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0T2JqZWN0LmFzc2lnbiA9IGZ1bmN0aW9uICggdGFyZ2V0ICkge1xuXG4gICAgXHRcdFx0J3VzZSBzdHJpY3QnO1xuXG4gICAgXHRcdFx0aWYgKCB0YXJnZXQgPT09IHVuZGVmaW5lZCB8fCB0YXJnZXQgPT09IG51bGwgKSB7XG5cbiAgICBcdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoICdDYW5ub3QgY29udmVydCB1bmRlZmluZWQgb3IgbnVsbCB0byBvYmplY3QnICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHR2YXIgb3V0cHV0ID0gT2JqZWN0KCB0YXJnZXQgKTtcblxuICAgIFx0XHRcdGZvciAoIHZhciBpbmRleCA9IDE7IGluZGV4IDwgYXJndW1lbnRzLmxlbmd0aDsgaW5kZXggKysgKSB7XG5cbiAgICBcdFx0XHRcdHZhciBzb3VyY2UgPSBhcmd1bWVudHNbIGluZGV4IF07XG5cbiAgICBcdFx0XHRcdGlmICggc291cmNlICE9PSB1bmRlZmluZWQgJiYgc291cmNlICE9PSBudWxsICkge1xuXG4gICAgXHRcdFx0XHRcdGZvciAoIHZhciBuZXh0S2V5IGluIHNvdXJjZSApIHtcblxuICAgIFx0XHRcdFx0XHRcdGlmICggT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKCBzb3VyY2UsIG5leHRLZXkgKSApIHtcblxuICAgIFx0XHRcdFx0XHRcdFx0b3V0cHV0WyBuZXh0S2V5IF0gPSBzb3VyY2VbIG5leHRLZXkgXTtcblxuICAgIFx0XHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdHJldHVybiBvdXRwdXQ7XG5cbiAgICBcdFx0fTtcblxuICAgIFx0fSApKCk7XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL2V2ZW50ZGlzcGF0Y2hlci5qcy9cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIEV2ZW50RGlzcGF0Y2hlcigpIHt9XG5cbiAgICBPYmplY3QuYXNzaWduKCBFdmVudERpc3BhdGNoZXIucHJvdG90eXBlLCB7XG5cbiAgICBcdGFkZEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uICggdHlwZSwgbGlzdGVuZXIgKSB7XG5cbiAgICBcdFx0aWYgKCB0aGlzLl9saXN0ZW5lcnMgPT09IHVuZGVmaW5lZCApIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xuXG4gICAgXHRcdHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG5cbiAgICBcdFx0aWYgKCBsaXN0ZW5lcnNbIHR5cGUgXSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0bGlzdGVuZXJzWyB0eXBlIF0gPSBbXTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0aWYgKCBsaXN0ZW5lcnNbIHR5cGUgXS5pbmRleE9mKCBsaXN0ZW5lciApID09PSAtIDEgKSB7XG5cbiAgICBcdFx0XHRsaXN0ZW5lcnNbIHR5cGUgXS5wdXNoKCBsaXN0ZW5lciApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0fSxcblxuICAgIFx0aGFzRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gKCB0eXBlLCBsaXN0ZW5lciApIHtcblxuICAgIFx0XHRpZiAoIHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkICkgcmV0dXJuIGZhbHNlO1xuXG4gICAgXHRcdHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG5cbiAgICBcdFx0aWYgKCBsaXN0ZW5lcnNbIHR5cGUgXSAhPT0gdW5kZWZpbmVkICYmIGxpc3RlbmVyc1sgdHlwZSBdLmluZGV4T2YoIGxpc3RlbmVyICkgIT09IC0gMSApIHtcblxuICAgIFx0XHRcdHJldHVybiB0cnVlO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gZmFsc2U7XG5cbiAgICBcdH0sXG5cbiAgICBcdHJlbW92ZUV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uICggdHlwZSwgbGlzdGVuZXIgKSB7XG5cbiAgICBcdFx0aWYgKCB0aGlzLl9saXN0ZW5lcnMgPT09IHVuZGVmaW5lZCApIHJldHVybjtcblxuICAgIFx0XHR2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xuICAgIFx0XHR2YXIgbGlzdGVuZXJBcnJheSA9IGxpc3RlbmVyc1sgdHlwZSBdO1xuXG4gICAgXHRcdGlmICggbGlzdGVuZXJBcnJheSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0dmFyIGluZGV4ID0gbGlzdGVuZXJBcnJheS5pbmRleE9mKCBsaXN0ZW5lciApO1xuXG4gICAgXHRcdFx0aWYgKCBpbmRleCAhPT0gLSAxICkge1xuXG4gICAgXHRcdFx0XHRsaXN0ZW5lckFycmF5LnNwbGljZSggaW5kZXgsIDEgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdH0sXG5cbiAgICBcdGRpc3BhdGNoRXZlbnQ6IGZ1bmN0aW9uICggZXZlbnQgKSB7XG5cbiAgICBcdFx0aWYgKCB0aGlzLl9saXN0ZW5lcnMgPT09IHVuZGVmaW5lZCApIHJldHVybjtcblxuICAgIFx0XHR2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xuICAgIFx0XHR2YXIgbGlzdGVuZXJBcnJheSA9IGxpc3RlbmVyc1sgZXZlbnQudHlwZSBdO1xuXG4gICAgXHRcdGlmICggbGlzdGVuZXJBcnJheSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0ZXZlbnQudGFyZ2V0ID0gdGhpcztcblxuICAgIFx0XHRcdHZhciBhcnJheSA9IFtdLCBpID0gMDtcbiAgICBcdFx0XHR2YXIgbGVuZ3RoID0gbGlzdGVuZXJBcnJheS5sZW5ndGg7XG5cbiAgICBcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbmd0aDsgaSArKyApIHtcblxuICAgIFx0XHRcdFx0YXJyYXlbIGkgXSA9IGxpc3RlbmVyQXJyYXlbIGkgXTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICsrICkge1xuXG4gICAgXHRcdFx0XHRhcnJheVsgaSBdLmNhbGwoIHRoaXMsIGV2ZW50ICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9XG5cbiAgICB9ICk7XG5cbiAgICB2YXIgUkVWSVNJT04gPSAnODEnO1xuICAgIHZhciBNT1VTRSA9IHsgTEVGVDogMCwgTUlERExFOiAxLCBSSUdIVDogMiB9O1xuICAgIHZhciBDdWxsRmFjZU5vbmUgPSAwO1xuICAgIHZhciBDdWxsRmFjZUJhY2sgPSAxO1xuICAgIHZhciBDdWxsRmFjZUZyb250ID0gMjtcbiAgICB2YXIgQ3VsbEZhY2VGcm9udEJhY2sgPSAzO1xuICAgIHZhciBGcm9udEZhY2VEaXJlY3Rpb25DVyA9IDA7XG4gICAgdmFyIEZyb250RmFjZURpcmVjdGlvbkNDVyA9IDE7XG4gICAgdmFyIEJhc2ljU2hhZG93TWFwID0gMDtcbiAgICB2YXIgUENGU2hhZG93TWFwID0gMTtcbiAgICB2YXIgUENGU29mdFNoYWRvd01hcCA9IDI7XG4gICAgdmFyIEZyb250U2lkZSA9IDA7XG4gICAgdmFyIEJhY2tTaWRlID0gMTtcbiAgICB2YXIgRG91YmxlU2lkZSA9IDI7XG4gICAgdmFyIEZsYXRTaGFkaW5nID0gMTtcbiAgICB2YXIgU21vb3RoU2hhZGluZyA9IDI7XG4gICAgdmFyIE5vQ29sb3JzID0gMDtcbiAgICB2YXIgRmFjZUNvbG9ycyA9IDE7XG4gICAgdmFyIFZlcnRleENvbG9ycyA9IDI7XG4gICAgdmFyIE5vQmxlbmRpbmcgPSAwO1xuICAgIHZhciBOb3JtYWxCbGVuZGluZyA9IDE7XG4gICAgdmFyIEFkZGl0aXZlQmxlbmRpbmcgPSAyO1xuICAgIHZhciBTdWJ0cmFjdGl2ZUJsZW5kaW5nID0gMztcbiAgICB2YXIgTXVsdGlwbHlCbGVuZGluZyA9IDQ7XG4gICAgdmFyIEN1c3RvbUJsZW5kaW5nID0gNTtcbiAgICB2YXIgQmxlbmRpbmdNb2RlID0ge1xuICAgICAgICBOb0JsZW5kaW5nOiBOb0JsZW5kaW5nLFxuICAgICAgICBOb3JtYWxCbGVuZGluZzogTm9ybWFsQmxlbmRpbmcsXG4gICAgICAgIEFkZGl0aXZlQmxlbmRpbmc6IEFkZGl0aXZlQmxlbmRpbmcsXG4gICAgICAgIFN1YnRyYWN0aXZlQmxlbmRpbmc6IFN1YnRyYWN0aXZlQmxlbmRpbmcsXG4gICAgICAgIE11bHRpcGx5QmxlbmRpbmc6IE11bHRpcGx5QmxlbmRpbmcsXG4gICAgICAgIEN1c3RvbUJsZW5kaW5nOiBDdXN0b21CbGVuZGluZ1xuICAgIH07XG4gICAgdmFyIEFkZEVxdWF0aW9uID0gMTAwO1xuICAgIHZhciBTdWJ0cmFjdEVxdWF0aW9uID0gMTAxO1xuICAgIHZhciBSZXZlcnNlU3VidHJhY3RFcXVhdGlvbiA9IDEwMjtcbiAgICB2YXIgTWluRXF1YXRpb24gPSAxMDM7XG4gICAgdmFyIE1heEVxdWF0aW9uID0gMTA0O1xuICAgIHZhciBaZXJvRmFjdG9yID0gMjAwO1xuICAgIHZhciBPbmVGYWN0b3IgPSAyMDE7XG4gICAgdmFyIFNyY0NvbG9yRmFjdG9yID0gMjAyO1xuICAgIHZhciBPbmVNaW51c1NyY0NvbG9yRmFjdG9yID0gMjAzO1xuICAgIHZhciBTcmNBbHBoYUZhY3RvciA9IDIwNDtcbiAgICB2YXIgT25lTWludXNTcmNBbHBoYUZhY3RvciA9IDIwNTtcbiAgICB2YXIgRHN0QWxwaGFGYWN0b3IgPSAyMDY7XG4gICAgdmFyIE9uZU1pbnVzRHN0QWxwaGFGYWN0b3IgPSAyMDc7XG4gICAgdmFyIERzdENvbG9yRmFjdG9yID0gMjA4O1xuICAgIHZhciBPbmVNaW51c0RzdENvbG9yRmFjdG9yID0gMjA5O1xuICAgIHZhciBTcmNBbHBoYVNhdHVyYXRlRmFjdG9yID0gMjEwO1xuICAgIHZhciBOZXZlckRlcHRoID0gMDtcbiAgICB2YXIgQWx3YXlzRGVwdGggPSAxO1xuICAgIHZhciBMZXNzRGVwdGggPSAyO1xuICAgIHZhciBMZXNzRXF1YWxEZXB0aCA9IDM7XG4gICAgdmFyIEVxdWFsRGVwdGggPSA0O1xuICAgIHZhciBHcmVhdGVyRXF1YWxEZXB0aCA9IDU7XG4gICAgdmFyIEdyZWF0ZXJEZXB0aCA9IDY7XG4gICAgdmFyIE5vdEVxdWFsRGVwdGggPSA3O1xuICAgIHZhciBNdWx0aXBseU9wZXJhdGlvbiA9IDA7XG4gICAgdmFyIE1peE9wZXJhdGlvbiA9IDE7XG4gICAgdmFyIEFkZE9wZXJhdGlvbiA9IDI7XG4gICAgdmFyIE5vVG9uZU1hcHBpbmcgPSAwO1xuICAgIHZhciBMaW5lYXJUb25lTWFwcGluZyA9IDE7XG4gICAgdmFyIFJlaW5oYXJkVG9uZU1hcHBpbmcgPSAyO1xuICAgIHZhciBVbmNoYXJ0ZWQyVG9uZU1hcHBpbmcgPSAzO1xuICAgIHZhciBDaW5lb25Ub25lTWFwcGluZyA9IDQ7XG4gICAgdmFyIFVWTWFwcGluZyA9IDMwMDtcbiAgICB2YXIgQ3ViZVJlZmxlY3Rpb25NYXBwaW5nID0gMzAxO1xuICAgIHZhciBDdWJlUmVmcmFjdGlvbk1hcHBpbmcgPSAzMDI7XG4gICAgdmFyIEVxdWlyZWN0YW5ndWxhclJlZmxlY3Rpb25NYXBwaW5nID0gMzAzO1xuICAgIHZhciBFcXVpcmVjdGFuZ3VsYXJSZWZyYWN0aW9uTWFwcGluZyA9IDMwNDtcbiAgICB2YXIgU3BoZXJpY2FsUmVmbGVjdGlvbk1hcHBpbmcgPSAzMDU7XG4gICAgdmFyIEN1YmVVVlJlZmxlY3Rpb25NYXBwaW5nID0gMzA2O1xuICAgIHZhciBDdWJlVVZSZWZyYWN0aW9uTWFwcGluZyA9IDMwNztcbiAgICB2YXIgVGV4dHVyZU1hcHBpbmcgPSB7XG4gICAgICAgIFVWTWFwcGluZzogVVZNYXBwaW5nLFxuICAgICAgICBDdWJlUmVmbGVjdGlvbk1hcHBpbmc6IEN1YmVSZWZsZWN0aW9uTWFwcGluZyxcbiAgICAgICAgQ3ViZVJlZnJhY3Rpb25NYXBwaW5nOiBDdWJlUmVmcmFjdGlvbk1hcHBpbmcsXG4gICAgICAgIEVxdWlyZWN0YW5ndWxhclJlZmxlY3Rpb25NYXBwaW5nOiBFcXVpcmVjdGFuZ3VsYXJSZWZsZWN0aW9uTWFwcGluZyxcbiAgICAgICAgRXF1aXJlY3Rhbmd1bGFyUmVmcmFjdGlvbk1hcHBpbmc6IEVxdWlyZWN0YW5ndWxhclJlZnJhY3Rpb25NYXBwaW5nLFxuICAgICAgICBTcGhlcmljYWxSZWZsZWN0aW9uTWFwcGluZzogU3BoZXJpY2FsUmVmbGVjdGlvbk1hcHBpbmcsXG4gICAgICAgIEN1YmVVVlJlZmxlY3Rpb25NYXBwaW5nOiBDdWJlVVZSZWZsZWN0aW9uTWFwcGluZyxcbiAgICAgICAgQ3ViZVVWUmVmcmFjdGlvbk1hcHBpbmc6IEN1YmVVVlJlZnJhY3Rpb25NYXBwaW5nXG4gICAgfTtcbiAgICB2YXIgUmVwZWF0V3JhcHBpbmcgPSAxMDAwO1xuICAgIHZhciBDbGFtcFRvRWRnZVdyYXBwaW5nID0gMTAwMTtcbiAgICB2YXIgTWlycm9yZWRSZXBlYXRXcmFwcGluZyA9IDEwMDI7XG4gICAgdmFyIFRleHR1cmVXcmFwcGluZyA9IHtcbiAgICAgICAgUmVwZWF0V3JhcHBpbmc6IFJlcGVhdFdyYXBwaW5nLFxuICAgICAgICBDbGFtcFRvRWRnZVdyYXBwaW5nOiBDbGFtcFRvRWRnZVdyYXBwaW5nLFxuICAgICAgICBNaXJyb3JlZFJlcGVhdFdyYXBwaW5nOiBNaXJyb3JlZFJlcGVhdFdyYXBwaW5nXG4gICAgfTtcbiAgICB2YXIgTmVhcmVzdEZpbHRlciA9IDEwMDM7XG4gICAgdmFyIE5lYXJlc3RNaXBNYXBOZWFyZXN0RmlsdGVyID0gMTAwNDtcbiAgICB2YXIgTmVhcmVzdE1pcE1hcExpbmVhckZpbHRlciA9IDEwMDU7XG4gICAgdmFyIExpbmVhckZpbHRlciA9IDEwMDY7XG4gICAgdmFyIExpbmVhck1pcE1hcE5lYXJlc3RGaWx0ZXIgPSAxMDA3O1xuICAgIHZhciBMaW5lYXJNaXBNYXBMaW5lYXJGaWx0ZXIgPSAxMDA4O1xuICAgIHZhciBUZXh0dXJlRmlsdGVyID0ge1xuICAgICAgICBOZWFyZXN0RmlsdGVyOiBOZWFyZXN0RmlsdGVyLFxuICAgICAgICBOZWFyZXN0TWlwTWFwTmVhcmVzdEZpbHRlcjogTmVhcmVzdE1pcE1hcE5lYXJlc3RGaWx0ZXIsXG4gICAgICAgIE5lYXJlc3RNaXBNYXBMaW5lYXJGaWx0ZXI6IE5lYXJlc3RNaXBNYXBMaW5lYXJGaWx0ZXIsXG4gICAgICAgIExpbmVhckZpbHRlcjogTGluZWFyRmlsdGVyLFxuICAgICAgICBMaW5lYXJNaXBNYXBOZWFyZXN0RmlsdGVyOiBMaW5lYXJNaXBNYXBOZWFyZXN0RmlsdGVyLFxuICAgICAgICBMaW5lYXJNaXBNYXBMaW5lYXJGaWx0ZXI6IExpbmVhck1pcE1hcExpbmVhckZpbHRlclxuICAgIH07XG4gICAgdmFyIFVuc2lnbmVkQnl0ZVR5cGUgPSAxMDA5O1xuICAgIHZhciBCeXRlVHlwZSA9IDEwMTA7XG4gICAgdmFyIFNob3J0VHlwZSA9IDEwMTE7XG4gICAgdmFyIFVuc2lnbmVkU2hvcnRUeXBlID0gMTAxMjtcbiAgICB2YXIgSW50VHlwZSA9IDEwMTM7XG4gICAgdmFyIFVuc2lnbmVkSW50VHlwZSA9IDEwMTQ7XG4gICAgdmFyIEZsb2F0VHlwZSA9IDEwMTU7XG4gICAgdmFyIEhhbGZGbG9hdFR5cGUgPSAxMDE2O1xuICAgIHZhciBVbnNpZ25lZFNob3J0NDQ0NFR5cGUgPSAxMDE3O1xuICAgIHZhciBVbnNpZ25lZFNob3J0NTU1MVR5cGUgPSAxMDE4O1xuICAgIHZhciBVbnNpZ25lZFNob3J0NTY1VHlwZSA9IDEwMTk7XG4gICAgdmFyIFVuc2lnbmVkSW50MjQ4VHlwZSA9IDEwMjA7XG4gICAgdmFyIEFscGhhRm9ybWF0ID0gMTAyMTtcbiAgICB2YXIgUkdCRm9ybWF0ID0gMTAyMjtcbiAgICB2YXIgUkdCQUZvcm1hdCA9IDEwMjM7XG4gICAgdmFyIEx1bWluYW5jZUZvcm1hdCA9IDEwMjQ7XG4gICAgdmFyIEx1bWluYW5jZUFscGhhRm9ybWF0ID0gMTAyNTtcbiAgICB2YXIgUkdCRUZvcm1hdCA9IFJHQkFGb3JtYXQ7XG4gICAgdmFyIERlcHRoRm9ybWF0ID0gMTAyNjtcbiAgICB2YXIgRGVwdGhTdGVuY2lsRm9ybWF0ID0gMTAyNztcbiAgICB2YXIgUkdCX1MzVENfRFhUMV9Gb3JtYXQgPSAyMDAxO1xuICAgIHZhciBSR0JBX1MzVENfRFhUMV9Gb3JtYXQgPSAyMDAyO1xuICAgIHZhciBSR0JBX1MzVENfRFhUM19Gb3JtYXQgPSAyMDAzO1xuICAgIHZhciBSR0JBX1MzVENfRFhUNV9Gb3JtYXQgPSAyMDA0O1xuICAgIHZhciBSR0JfUFZSVENfNEJQUFYxX0Zvcm1hdCA9IDIxMDA7XG4gICAgdmFyIFJHQl9QVlJUQ18yQlBQVjFfRm9ybWF0ID0gMjEwMTtcbiAgICB2YXIgUkdCQV9QVlJUQ180QlBQVjFfRm9ybWF0ID0gMjEwMjtcbiAgICB2YXIgUkdCQV9QVlJUQ18yQlBQVjFfRm9ybWF0ID0gMjEwMztcbiAgICB2YXIgUkdCX0VUQzFfRm9ybWF0ID0gMjE1MTtcbiAgICB2YXIgTG9vcE9uY2UgPSAyMjAwO1xuICAgIHZhciBMb29wUmVwZWF0ID0gMjIwMTtcbiAgICB2YXIgTG9vcFBpbmdQb25nID0gMjIwMjtcbiAgICB2YXIgSW50ZXJwb2xhdGVEaXNjcmV0ZSA9IDIzMDA7XG4gICAgdmFyIEludGVycG9sYXRlTGluZWFyID0gMjMwMTtcbiAgICB2YXIgSW50ZXJwb2xhdGVTbW9vdGggPSAyMzAyO1xuICAgIHZhciBaZXJvQ3VydmF0dXJlRW5kaW5nID0gMjQwMDtcbiAgICB2YXIgWmVyb1Nsb3BlRW5kaW5nID0gMjQwMTtcbiAgICB2YXIgV3JhcEFyb3VuZEVuZGluZyA9IDI0MDI7XG4gICAgdmFyIFRyaWFuZ2xlc0RyYXdNb2RlID0gMDtcbiAgICB2YXIgVHJpYW5nbGVTdHJpcERyYXdNb2RlID0gMTtcbiAgICB2YXIgVHJpYW5nbGVGYW5EcmF3TW9kZSA9IDI7XG4gICAgdmFyIExpbmVhckVuY29kaW5nID0gMzAwMDtcbiAgICB2YXIgc1JHQkVuY29kaW5nID0gMzAwMTtcbiAgICB2YXIgR2FtbWFFbmNvZGluZyA9IDMwMDc7XG4gICAgdmFyIFJHQkVFbmNvZGluZyA9IDMwMDI7XG4gICAgdmFyIExvZ0x1dkVuY29kaW5nID0gMzAwMztcbiAgICB2YXIgUkdCTTdFbmNvZGluZyA9IDMwMDQ7XG4gICAgdmFyIFJHQk0xNkVuY29kaW5nID0gMzAwNTtcbiAgICB2YXIgUkdCREVuY29kaW5nID0gMzAwNjtcbiAgICB2YXIgQmFzaWNEZXB0aFBhY2tpbmcgPSAzMjAwO1xuICAgIHZhciBSR0JBRGVwdGhQYWNraW5nID0gMzIwMTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gICAgICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAgICAgKi9cblxuICAgIGV4cG9ydHMuTWF0aCA9IHtcblxuICAgIFx0REVHMlJBRDogTWF0aC5QSSAvIDE4MCxcbiAgICBcdFJBRDJERUc6IDE4MCAvIE1hdGguUEksXG5cbiAgICBcdGdlbmVyYXRlVVVJRDogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdC8vIGh0dHA6Ly93d3cuYnJvb2ZhLmNvbS9Ub29scy9NYXRoLnV1aWQuaHRtXG5cbiAgICBcdFx0dmFyIGNoYXJzID0gJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6Jy5zcGxpdCggJycgKTtcbiAgICBcdFx0dmFyIHV1aWQgPSBuZXcgQXJyYXkoIDM2ICk7XG4gICAgXHRcdHZhciBybmQgPSAwLCByO1xuXG4gICAgXHRcdHJldHVybiBmdW5jdGlvbiBnZW5lcmF0ZVVVSUQoKSB7XG5cbiAgICBcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCAzNjsgaSArKyApIHtcblxuICAgIFx0XHRcdFx0aWYgKCBpID09PSA4IHx8IGkgPT09IDEzIHx8IGkgPT09IDE4IHx8IGkgPT09IDIzICkge1xuXG4gICAgXHRcdFx0XHRcdHV1aWRbIGkgXSA9ICctJztcblxuICAgIFx0XHRcdFx0fSBlbHNlIGlmICggaSA9PT0gMTQgKSB7XG5cbiAgICBcdFx0XHRcdFx0dXVpZFsgaSBdID0gJzQnO1xuXG4gICAgXHRcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHRcdGlmICggcm5kIDw9IDB4MDIgKSBybmQgPSAweDIwMDAwMDAgKyAoIE1hdGgucmFuZG9tKCkgKiAweDEwMDAwMDAgKSB8IDA7XG4gICAgXHRcdFx0XHRcdHIgPSBybmQgJiAweGY7XG4gICAgXHRcdFx0XHRcdHJuZCA9IHJuZCA+PiA0O1xuICAgIFx0XHRcdFx0XHR1dWlkWyBpIF0gPSBjaGFyc1sgKCBpID09PSAxOSApID8gKCByICYgMHgzICkgfCAweDggOiByIF07XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdHJldHVybiB1dWlkLmpvaW4oICcnICk7XG5cbiAgICBcdFx0fTtcblxuICAgIFx0fSgpLFxuXG4gICAgXHRjbGFtcDogZnVuY3Rpb24gKCB2YWx1ZSwgbWluLCBtYXggKSB7XG5cbiAgICBcdFx0cmV0dXJuIE1hdGgubWF4KCBtaW4sIE1hdGgubWluKCBtYXgsIHZhbHVlICkgKTtcblxuICAgIFx0fSxcblxuICAgIFx0Ly8gY29tcHV0ZSBldWNsaWRpYW4gbW9kdWxvIG9mIG0gJSBuXG4gICAgXHQvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Nb2R1bG9fb3BlcmF0aW9uXG5cbiAgICBcdGV1Y2xpZGVhbk1vZHVsbzogZnVuY3Rpb24gKCBuLCBtICkge1xuXG4gICAgXHRcdHJldHVybiAoICggbiAlIG0gKSArIG0gKSAlIG07XG5cbiAgICBcdH0sXG5cbiAgICBcdC8vIExpbmVhciBtYXBwaW5nIGZyb20gcmFuZ2UgPGExLCBhMj4gdG8gcmFuZ2UgPGIxLCBiMj5cblxuICAgIFx0bWFwTGluZWFyOiBmdW5jdGlvbiAoIHgsIGExLCBhMiwgYjEsIGIyICkge1xuXG4gICAgXHRcdHJldHVybiBiMSArICggeCAtIGExICkgKiAoIGIyIC0gYjEgKSAvICggYTIgLSBhMSApO1xuXG4gICAgXHR9LFxuXG4gICAgXHQvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1Ntb290aHN0ZXBcblxuICAgIFx0c21vb3Roc3RlcDogZnVuY3Rpb24gKCB4LCBtaW4sIG1heCApIHtcblxuICAgIFx0XHRpZiAoIHggPD0gbWluICkgcmV0dXJuIDA7XG4gICAgXHRcdGlmICggeCA+PSBtYXggKSByZXR1cm4gMTtcblxuICAgIFx0XHR4ID0gKCB4IC0gbWluICkgLyAoIG1heCAtIG1pbiApO1xuXG4gICAgXHRcdHJldHVybiB4ICogeCAqICggMyAtIDIgKiB4ICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNtb290aGVyc3RlcDogZnVuY3Rpb24gKCB4LCBtaW4sIG1heCApIHtcblxuICAgIFx0XHRpZiAoIHggPD0gbWluICkgcmV0dXJuIDA7XG4gICAgXHRcdGlmICggeCA+PSBtYXggKSByZXR1cm4gMTtcblxuICAgIFx0XHR4ID0gKCB4IC0gbWluICkgLyAoIG1heCAtIG1pbiApO1xuXG4gICAgXHRcdHJldHVybiB4ICogeCAqIHggKiAoIHggKiAoIHggKiA2IC0gMTUgKSArIDEwICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdHJhbmRvbTE2OiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0aC5yYW5kb20xNigpIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSBNYXRoLnJhbmRvbSgpIGluc3RlYWQuJyApO1xuICAgIFx0XHRyZXR1cm4gTWF0aC5yYW5kb20oKTtcblxuICAgIFx0fSxcblxuICAgIFx0Ly8gUmFuZG9tIGludGVnZXIgZnJvbSA8bG93LCBoaWdoPiBpbnRlcnZhbFxuXG4gICAgXHRyYW5kSW50OiBmdW5jdGlvbiAoIGxvdywgaGlnaCApIHtcblxuICAgIFx0XHRyZXR1cm4gbG93ICsgTWF0aC5mbG9vciggTWF0aC5yYW5kb20oKSAqICggaGlnaCAtIGxvdyArIDEgKSApO1xuXG4gICAgXHR9LFxuXG4gICAgXHQvLyBSYW5kb20gZmxvYXQgZnJvbSA8bG93LCBoaWdoPiBpbnRlcnZhbFxuXG4gICAgXHRyYW5kRmxvYXQ6IGZ1bmN0aW9uICggbG93LCBoaWdoICkge1xuXG4gICAgXHRcdHJldHVybiBsb3cgKyBNYXRoLnJhbmRvbSgpICogKCBoaWdoIC0gbG93ICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdC8vIFJhbmRvbSBmbG9hdCBmcm9tIDwtcmFuZ2UvMiwgcmFuZ2UvMj4gaW50ZXJ2YWxcblxuICAgIFx0cmFuZEZsb2F0U3ByZWFkOiBmdW5jdGlvbiAoIHJhbmdlICkge1xuXG4gICAgXHRcdHJldHVybiByYW5nZSAqICggMC41IC0gTWF0aC5yYW5kb20oKSApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRkZWdUb1JhZDogZnVuY3Rpb24gKCBkZWdyZWVzICkge1xuXG4gICAgXHRcdHJldHVybiBkZWdyZWVzICogZXhwb3J0cy5NYXRoLkRFRzJSQUQ7XG5cbiAgICBcdH0sXG5cbiAgICBcdHJhZFRvRGVnOiBmdW5jdGlvbiAoIHJhZGlhbnMgKSB7XG5cbiAgICBcdFx0cmV0dXJuIHJhZGlhbnMgKiBleHBvcnRzLk1hdGguUkFEMkRFRztcblxuICAgIFx0fSxcblxuICAgIFx0aXNQb3dlck9mVHdvOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG4gICAgXHRcdHJldHVybiAoIHZhbHVlICYgKCB2YWx1ZSAtIDEgKSApID09PSAwICYmIHZhbHVlICE9PSAwO1xuXG4gICAgXHR9LFxuXG4gICAgXHRuZWFyZXN0UG93ZXJPZlR3bzogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuICAgIFx0XHRyZXR1cm4gTWF0aC5wb3coIDIsIE1hdGgucm91bmQoIE1hdGgubG9nKCB2YWx1ZSApIC8gTWF0aC5MTjIgKSApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRuZXh0UG93ZXJPZlR3bzogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuICAgIFx0XHR2YWx1ZSAtLTtcbiAgICBcdFx0dmFsdWUgfD0gdmFsdWUgPj4gMTtcbiAgICBcdFx0dmFsdWUgfD0gdmFsdWUgPj4gMjtcbiAgICBcdFx0dmFsdWUgfD0gdmFsdWUgPj4gNDtcbiAgICBcdFx0dmFsdWUgfD0gdmFsdWUgPj4gODtcbiAgICBcdFx0dmFsdWUgfD0gdmFsdWUgPj4gMTY7XG4gICAgXHRcdHZhbHVlICsrO1xuXG4gICAgXHRcdHJldHVybiB2YWx1ZTtcblxuICAgIFx0fVxuXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gICAgICogQGF1dGhvciBwaGlsb2diIC8gaHR0cDovL2Jsb2cudGhlaml0Lm9yZy9cbiAgICAgKiBAYXV0aG9yIGVncmFldGhlciAvIGh0dHA6Ly9lZ3JhZXRoZXIuY29tL1xuICAgICAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIFZlY3RvcjIoIHgsIHkgKSB7XG5cbiAgICBcdHRoaXMueCA9IHggfHwgMDtcbiAgICBcdHRoaXMueSA9IHkgfHwgMDtcblxuICAgIH1cblxuICAgIFZlY3RvcjIucHJvdG90eXBlID0ge1xuXG4gICAgXHRjb25zdHJ1Y3RvcjogVmVjdG9yMixcblxuICAgIFx0aXNWZWN0b3IyOiB0cnVlLFxuXG4gICAgXHRnZXQgd2lkdGgoKSB7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMueDtcblxuICAgIFx0fSxcblxuICAgIFx0c2V0IHdpZHRoKCB2YWx1ZSApIHtcblxuICAgIFx0XHR0aGlzLnggPSB2YWx1ZTtcblxuICAgIFx0fSxcblxuICAgIFx0Z2V0IGhlaWdodCgpIHtcblxuICAgIFx0XHRyZXR1cm4gdGhpcy55O1xuXG4gICAgXHR9LFxuXG4gICAgXHRzZXQgaGVpZ2h0KCB2YWx1ZSApIHtcblxuICAgIFx0XHR0aGlzLnkgPSB2YWx1ZTtcblxuICAgIFx0fSxcblxuICAgIFx0Ly9cblxuICAgIFx0c2V0OiBmdW5jdGlvbiAoIHgsIHkgKSB7XG5cbiAgICBcdFx0dGhpcy54ID0geDtcbiAgICBcdFx0dGhpcy55ID0geTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0c2V0U2NhbGFyOiBmdW5jdGlvbiAoIHNjYWxhciApIHtcblxuICAgIFx0XHR0aGlzLnggPSBzY2FsYXI7XG4gICAgXHRcdHRoaXMueSA9IHNjYWxhcjtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0c2V0WDogZnVuY3Rpb24gKCB4ICkge1xuXG4gICAgXHRcdHRoaXMueCA9IHg7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldFk6IGZ1bmN0aW9uICggeSApIHtcblxuICAgIFx0XHR0aGlzLnkgPSB5O1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRzZXRDb21wb25lbnQ6IGZ1bmN0aW9uICggaW5kZXgsIHZhbHVlICkge1xuXG4gICAgXHRcdHN3aXRjaCAoIGluZGV4ICkge1xuXG4gICAgXHRcdFx0Y2FzZSAwOiB0aGlzLnggPSB2YWx1ZTsgYnJlYWs7XG4gICAgXHRcdFx0Y2FzZSAxOiB0aGlzLnkgPSB2YWx1ZTsgYnJlYWs7XG4gICAgXHRcdFx0ZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCAnaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAnICsgaW5kZXggKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdH0sXG5cbiAgICBcdGdldENvbXBvbmVudDogZnVuY3Rpb24gKCBpbmRleCApIHtcblxuICAgIFx0XHRzd2l0Y2ggKCBpbmRleCApIHtcblxuICAgIFx0XHRcdGNhc2UgMDogcmV0dXJuIHRoaXMueDtcbiAgICBcdFx0XHRjYXNlIDE6IHJldHVybiB0aGlzLnk7XG4gICAgXHRcdFx0ZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCAnaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAnICsgaW5kZXggKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdH0sXG5cbiAgICBcdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLngsIHRoaXMueSApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRjb3B5OiBmdW5jdGlvbiAoIHYgKSB7XG5cbiAgICBcdFx0dGhpcy54ID0gdi54O1xuICAgIFx0XHR0aGlzLnkgPSB2Lnk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGFkZDogZnVuY3Rpb24gKCB2LCB3ICkge1xuXG4gICAgXHRcdGlmICggdyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMjogLmFkZCgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLmFkZFZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcbiAgICBcdFx0XHRyZXR1cm4gdGhpcy5hZGRWZWN0b3JzKCB2LCB3ICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHRoaXMueCArPSB2Lng7XG4gICAgXHRcdHRoaXMueSArPSB2Lnk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGFkZFNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xuXG4gICAgXHRcdHRoaXMueCArPSBzO1xuICAgIFx0XHR0aGlzLnkgKz0gcztcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0YWRkVmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xuXG4gICAgXHRcdHRoaXMueCA9IGEueCArIGIueDtcbiAgICBcdFx0dGhpcy55ID0gYS55ICsgYi55O1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRhZGRTY2FsZWRWZWN0b3I6IGZ1bmN0aW9uICggdiwgcyApIHtcblxuICAgIFx0XHR0aGlzLnggKz0gdi54ICogcztcbiAgICBcdFx0dGhpcy55ICs9IHYueSAqIHM7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdHN1YjogZnVuY3Rpb24gKCB2LCB3ICkge1xuXG4gICAgXHRcdGlmICggdyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMjogLnN1YigpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLnN1YlZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcbiAgICBcdFx0XHRyZXR1cm4gdGhpcy5zdWJWZWN0b3JzKCB2LCB3ICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHRoaXMueCAtPSB2Lng7XG4gICAgXHRcdHRoaXMueSAtPSB2Lnk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdHN1YlNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xuXG4gICAgXHRcdHRoaXMueCAtPSBzO1xuICAgIFx0XHR0aGlzLnkgLT0gcztcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0c3ViVmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xuXG4gICAgXHRcdHRoaXMueCA9IGEueCAtIGIueDtcbiAgICBcdFx0dGhpcy55ID0gYS55IC0gYi55O1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRtdWx0aXBseTogZnVuY3Rpb24gKCB2ICkge1xuXG4gICAgXHRcdHRoaXMueCAqPSB2Lng7XG4gICAgXHRcdHRoaXMueSAqPSB2Lnk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdG11bHRpcGx5U2NhbGFyOiBmdW5jdGlvbiAoIHNjYWxhciApIHtcblxuICAgIFx0XHRpZiAoIGlzRmluaXRlKCBzY2FsYXIgKSApIHtcblxuICAgIFx0XHRcdHRoaXMueCAqPSBzY2FsYXI7XG4gICAgXHRcdFx0dGhpcy55ICo9IHNjYWxhcjtcblxuICAgIFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0dGhpcy54ID0gMDtcbiAgICBcdFx0XHR0aGlzLnkgPSAwO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0ZGl2aWRlOiBmdW5jdGlvbiAoIHYgKSB7XG5cbiAgICBcdFx0dGhpcy54IC89IHYueDtcbiAgICBcdFx0dGhpcy55IC89IHYueTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0ZGl2aWRlU2NhbGFyOiBmdW5jdGlvbiAoIHNjYWxhciApIHtcblxuICAgIFx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseVNjYWxhciggMSAvIHNjYWxhciApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRtaW46IGZ1bmN0aW9uICggdiApIHtcblxuICAgIFx0XHR0aGlzLnggPSBNYXRoLm1pbiggdGhpcy54LCB2LnggKTtcbiAgICBcdFx0dGhpcy55ID0gTWF0aC5taW4oIHRoaXMueSwgdi55ICk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdG1heDogZnVuY3Rpb24gKCB2ICkge1xuXG4gICAgXHRcdHRoaXMueCA9IE1hdGgubWF4KCB0aGlzLngsIHYueCApO1xuICAgIFx0XHR0aGlzLnkgPSBNYXRoLm1heCggdGhpcy55LCB2LnkgKTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0Y2xhbXA6IGZ1bmN0aW9uICggbWluLCBtYXggKSB7XG5cbiAgICBcdFx0Ly8gVGhpcyBmdW5jdGlvbiBhc3N1bWVzIG1pbiA8IG1heCwgaWYgdGhpcyBhc3N1bXB0aW9uIGlzbid0IHRydWUgaXQgd2lsbCBub3Qgb3BlcmF0ZSBjb3JyZWN0bHlcblxuICAgIFx0XHR0aGlzLnggPSBNYXRoLm1heCggbWluLngsIE1hdGgubWluKCBtYXgueCwgdGhpcy54ICkgKTtcbiAgICBcdFx0dGhpcy55ID0gTWF0aC5tYXgoIG1pbi55LCBNYXRoLm1pbiggbWF4LnksIHRoaXMueSApICk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGNsYW1wU2NhbGFyOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dmFyIG1pbiwgbWF4O1xuXG4gICAgXHRcdHJldHVybiBmdW5jdGlvbiBjbGFtcFNjYWxhciggbWluVmFsLCBtYXhWYWwgKSB7XG5cbiAgICBcdFx0XHRpZiAoIG1pbiA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0XHRtaW4gPSBuZXcgVmVjdG9yMigpO1xuICAgIFx0XHRcdFx0bWF4ID0gbmV3IFZlY3RvcjIoKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdG1pbi5zZXQoIG1pblZhbCwgbWluVmFsICk7XG4gICAgXHRcdFx0bWF4LnNldCggbWF4VmFsLCBtYXhWYWwgKTtcblxuICAgIFx0XHRcdHJldHVybiB0aGlzLmNsYW1wKCBtaW4sIG1heCApO1xuXG4gICAgXHRcdH07XG5cbiAgICBcdH0oKSxcblxuICAgIFx0Y2xhbXBMZW5ndGg6IGZ1bmN0aW9uICggbWluLCBtYXggKSB7XG5cbiAgICBcdFx0dmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoKCk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIoIE1hdGgubWF4KCBtaW4sIE1hdGgubWluKCBtYXgsIGxlbmd0aCApICkgLyBsZW5ndGggKTtcblxuICAgIFx0fSxcblxuICAgIFx0Zmxvb3I6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR0aGlzLnggPSBNYXRoLmZsb29yKCB0aGlzLnggKTtcbiAgICBcdFx0dGhpcy55ID0gTWF0aC5mbG9vciggdGhpcy55ICk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGNlaWw6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR0aGlzLnggPSBNYXRoLmNlaWwoIHRoaXMueCApO1xuICAgIFx0XHR0aGlzLnkgPSBNYXRoLmNlaWwoIHRoaXMueSApO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRyb3VuZDogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHRoaXMueCA9IE1hdGgucm91bmQoIHRoaXMueCApO1xuICAgIFx0XHR0aGlzLnkgPSBNYXRoLnJvdW5kKCB0aGlzLnkgKTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0cm91bmRUb1plcm86IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR0aGlzLnggPSAoIHRoaXMueCA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy54ICkgOiBNYXRoLmZsb29yKCB0aGlzLnggKTtcbiAgICBcdFx0dGhpcy55ID0gKCB0aGlzLnkgPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMueSApIDogTWF0aC5mbG9vciggdGhpcy55ICk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdG5lZ2F0ZTogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHRoaXMueCA9IC0gdGhpcy54O1xuICAgIFx0XHR0aGlzLnkgPSAtIHRoaXMueTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0ZG90OiBmdW5jdGlvbiAoIHYgKSB7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMueCAqIHYueCArIHRoaXMueSAqIHYueTtcblxuICAgIFx0fSxcblxuICAgIFx0bGVuZ3RoU3E6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHRyZXR1cm4gdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55O1xuXG4gICAgXHR9LFxuXG4gICAgXHRsZW5ndGg6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHRyZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKTtcblxuICAgIFx0fSxcblxuICAgIFx0bGVuZ3RoTWFuaGF0dGFuOiBmdW5jdGlvbigpIHtcblxuICAgIFx0XHRyZXR1cm4gTWF0aC5hYnMoIHRoaXMueCApICsgTWF0aC5hYnMoIHRoaXMueSApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRub3JtYWxpemU6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHRyZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIoIHRoaXMubGVuZ3RoKCkgKTtcblxuICAgIFx0fSxcblxuICAgIFx0YW5nbGU6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHQvLyBjb21wdXRlcyB0aGUgYW5nbGUgaW4gcmFkaWFucyB3aXRoIHJlc3BlY3QgdG8gdGhlIHBvc2l0aXZlIHgtYXhpc1xuXG4gICAgXHRcdHZhciBhbmdsZSA9IE1hdGguYXRhbjIoIHRoaXMueSwgdGhpcy54ICk7XG5cbiAgICBcdFx0aWYgKCBhbmdsZSA8IDAgKSBhbmdsZSArPSAyICogTWF0aC5QSTtcblxuICAgIFx0XHRyZXR1cm4gYW5nbGU7XG5cbiAgICBcdH0sXG5cbiAgICBcdGRpc3RhbmNlVG86IGZ1bmN0aW9uICggdiApIHtcblxuICAgIFx0XHRyZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLmRpc3RhbmNlVG9TcXVhcmVkKCB2ICkgKTtcblxuICAgIFx0fSxcblxuICAgIFx0ZGlzdGFuY2VUb1NxdWFyZWQ6IGZ1bmN0aW9uICggdiApIHtcblxuICAgIFx0XHR2YXIgZHggPSB0aGlzLnggLSB2LngsIGR5ID0gdGhpcy55IC0gdi55O1xuICAgIFx0XHRyZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGRpc3RhbmNlVG9NYW5oYXR0YW46IGZ1bmN0aW9uICggdiApIHtcblxuICAgIFx0XHRyZXR1cm4gTWF0aC5hYnMoIHRoaXMueCAtIHYueCApICsgTWF0aC5hYnMoIHRoaXMueSAtIHYueSApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRzZXRMZW5ndGg6IGZ1bmN0aW9uICggbGVuZ3RoICkge1xuXG4gICAgXHRcdHJldHVybiB0aGlzLm11bHRpcGx5U2NhbGFyKCBsZW5ndGggLyB0aGlzLmxlbmd0aCgpICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGxlcnA6IGZ1bmN0aW9uICggdiwgYWxwaGEgKSB7XG5cbiAgICBcdFx0dGhpcy54ICs9ICggdi54IC0gdGhpcy54ICkgKiBhbHBoYTtcbiAgICBcdFx0dGhpcy55ICs9ICggdi55IC0gdGhpcy55ICkgKiBhbHBoYTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0bGVycFZlY3RvcnM6IGZ1bmN0aW9uICggdjEsIHYyLCBhbHBoYSApIHtcblxuICAgIFx0XHRyZXR1cm4gdGhpcy5zdWJWZWN0b3JzKCB2MiwgdjEgKS5tdWx0aXBseVNjYWxhciggYWxwaGEgKS5hZGQoIHYxICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGVxdWFsczogZnVuY3Rpb24gKCB2ICkge1xuXG4gICAgXHRcdHJldHVybiAoICggdi54ID09PSB0aGlzLnggKSAmJiAoIHYueSA9PT0gdGhpcy55ICkgKTtcblxuICAgIFx0fSxcblxuICAgIFx0ZnJvbUFycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XG5cbiAgICBcdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cbiAgICBcdFx0dGhpcy54ID0gYXJyYXlbIG9mZnNldCBdO1xuICAgIFx0XHR0aGlzLnkgPSBhcnJheVsgb2Zmc2V0ICsgMSBdO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHR0b0FycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XG5cbiAgICBcdFx0aWYgKCBhcnJheSA9PT0gdW5kZWZpbmVkICkgYXJyYXkgPSBbXTtcbiAgICBcdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cbiAgICBcdFx0YXJyYXlbIG9mZnNldCBdID0gdGhpcy54O1xuICAgIFx0XHRhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGhpcy55O1xuXG4gICAgXHRcdHJldHVybiBhcnJheTtcblxuICAgIFx0fSxcblxuICAgIFx0ZnJvbUF0dHJpYnV0ZTogZnVuY3Rpb24gKCBhdHRyaWJ1dGUsIGluZGV4LCBvZmZzZXQgKSB7XG5cbiAgICBcdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cbiAgICBcdFx0aW5kZXggPSBpbmRleCAqIGF0dHJpYnV0ZS5pdGVtU2l6ZSArIG9mZnNldDtcblxuICAgIFx0XHR0aGlzLnggPSBhdHRyaWJ1dGUuYXJyYXlbIGluZGV4IF07XG4gICAgXHRcdHRoaXMueSA9IGF0dHJpYnV0ZS5hcnJheVsgaW5kZXggKyAxIF07XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdHJvdGF0ZUFyb3VuZDogZnVuY3Rpb24gKCBjZW50ZXIsIGFuZ2xlICkge1xuXG4gICAgXHRcdHZhciBjID0gTWF0aC5jb3MoIGFuZ2xlICksIHMgPSBNYXRoLnNpbiggYW5nbGUgKTtcblxuICAgIFx0XHR2YXIgeCA9IHRoaXMueCAtIGNlbnRlci54O1xuICAgIFx0XHR2YXIgeSA9IHRoaXMueSAtIGNlbnRlci55O1xuXG4gICAgXHRcdHRoaXMueCA9IHggKiBjIC0geSAqIHMgKyBjZW50ZXIueDtcbiAgICBcdFx0dGhpcy55ID0geCAqIHMgKyB5ICogYyArIGNlbnRlci55O1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9XG5cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAgICAgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICAgICAqIEBhdXRob3Igc3ppbWVrIC8gaHR0cHM6Ly9naXRodWIuY29tL3N6aW1lay9cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIFRleHR1cmUoIGltYWdlLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHksIGVuY29kaW5nICkge1xuXG4gICAgXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsICdpZCcsIHsgdmFsdWU6IFRleHR1cmVJZENvdW50KCkgfSApO1xuXG4gICAgXHR0aGlzLnV1aWQgPSBleHBvcnRzLk1hdGguZ2VuZXJhdGVVVUlEKCk7XG5cbiAgICBcdHRoaXMubmFtZSA9ICcnO1xuICAgIFx0dGhpcy5zb3VyY2VGaWxlID0gJyc7XG5cbiAgICBcdHRoaXMuaW1hZ2UgPSBpbWFnZSAhPT0gdW5kZWZpbmVkID8gaW1hZ2UgOiBUZXh0dXJlLkRFRkFVTFRfSU1BR0U7XG4gICAgXHR0aGlzLm1pcG1hcHMgPSBbXTtcblxuICAgIFx0dGhpcy5tYXBwaW5nID0gbWFwcGluZyAhPT0gdW5kZWZpbmVkID8gbWFwcGluZyA6IFRleHR1cmUuREVGQVVMVF9NQVBQSU5HO1xuXG4gICAgXHR0aGlzLndyYXBTID0gd3JhcFMgIT09IHVuZGVmaW5lZCA/IHdyYXBTIDogQ2xhbXBUb0VkZ2VXcmFwcGluZztcbiAgICBcdHRoaXMud3JhcFQgPSB3cmFwVCAhPT0gdW5kZWZpbmVkID8gd3JhcFQgOiBDbGFtcFRvRWRnZVdyYXBwaW5nO1xuXG4gICAgXHR0aGlzLm1hZ0ZpbHRlciA9IG1hZ0ZpbHRlciAhPT0gdW5kZWZpbmVkID8gbWFnRmlsdGVyIDogTGluZWFyRmlsdGVyO1xuICAgIFx0dGhpcy5taW5GaWx0ZXIgPSBtaW5GaWx0ZXIgIT09IHVuZGVmaW5lZCA/IG1pbkZpbHRlciA6IExpbmVhck1pcE1hcExpbmVhckZpbHRlcjtcblxuICAgIFx0dGhpcy5hbmlzb3Ryb3B5ID0gYW5pc290cm9weSAhPT0gdW5kZWZpbmVkID8gYW5pc290cm9weSA6IDE7XG5cbiAgICBcdHRoaXMuZm9ybWF0ID0gZm9ybWF0ICE9PSB1bmRlZmluZWQgPyBmb3JtYXQgOiBSR0JBRm9ybWF0O1xuICAgIFx0dGhpcy50eXBlID0gdHlwZSAhPT0gdW5kZWZpbmVkID8gdHlwZSA6IFVuc2lnbmVkQnl0ZVR5cGU7XG5cbiAgICBcdHRoaXMub2Zmc2V0ID0gbmV3IFZlY3RvcjIoIDAsIDAgKTtcbiAgICBcdHRoaXMucmVwZWF0ID0gbmV3IFZlY3RvcjIoIDEsIDEgKTtcblxuICAgIFx0dGhpcy5nZW5lcmF0ZU1pcG1hcHMgPSB0cnVlO1xuICAgIFx0dGhpcy5wcmVtdWx0aXBseUFscGhhID0gZmFsc2U7XG4gICAgXHR0aGlzLmZsaXBZID0gdHJ1ZTtcbiAgICBcdHRoaXMudW5wYWNrQWxpZ25tZW50ID0gNDtcdC8vIHZhbGlkIHZhbHVlczogMSwgMiwgNCwgOCAoc2VlIGh0dHA6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsZXMvc2RrL2RvY3MvbWFuL3hodG1sL2dsUGl4ZWxTdG9yZWkueG1sKVxuXG5cbiAgICBcdC8vIFZhbHVlcyBvZiBlbmNvZGluZyAhPT0gVEhSRUUuTGluZWFyRW5jb2Rpbmcgb25seSBzdXBwb3J0ZWQgb24gbWFwLCBlbnZNYXAgYW5kIGVtaXNzaXZlTWFwLlxuICAgIFx0Ly9cbiAgICBcdC8vIEFsc28gY2hhbmdpbmcgdGhlIGVuY29kaW5nIGFmdGVyIGFscmVhZHkgdXNlZCBieSBhIE1hdGVyaWFsIHdpbGwgbm90IGF1dG9tYXRpY2FsbHkgbWFrZSB0aGUgTWF0ZXJpYWxcbiAgICBcdC8vIHVwZGF0ZS4gIFlvdSBuZWVkIHRvIGV4cGxpY2l0bHkgY2FsbCBNYXRlcmlhbC5uZWVkc1VwZGF0ZSB0byB0cmlnZ2VyIGl0IHRvIHJlY29tcGlsZS5cbiAgICBcdHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZyAhPT0gdW5kZWZpbmVkID8gZW5jb2RpbmcgOiAgTGluZWFyRW5jb2Rpbmc7XG5cbiAgICBcdHRoaXMudmVyc2lvbiA9IDA7XG4gICAgXHR0aGlzLm9uVXBkYXRlID0gbnVsbDtcblxuICAgIH1cblxuICAgIFRleHR1cmUuREVGQVVMVF9JTUFHRSA9IHVuZGVmaW5lZDtcbiAgICBUZXh0dXJlLkRFRkFVTFRfTUFQUElORyA9IFVWTWFwcGluZztcblxuICAgIFRleHR1cmUucHJvdG90eXBlID0ge1xuXG4gICAgXHRjb25zdHJ1Y3RvcjogVGV4dHVyZSxcblxuICAgIFx0aXNUZXh0dXJlOiB0cnVlLFxuXG4gICAgXHRzZXQgbmVlZHNVcGRhdGUoIHZhbHVlICkge1xuXG4gICAgXHRcdGlmICggdmFsdWUgPT09IHRydWUgKSB0aGlzLnZlcnNpb24gKys7XG5cbiAgICBcdH0sXG5cbiAgICBcdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuICAgIFx0XHR0aGlzLmltYWdlID0gc291cmNlLmltYWdlO1xuICAgIFx0XHR0aGlzLm1pcG1hcHMgPSBzb3VyY2UubWlwbWFwcy5zbGljZSggMCApO1xuXG4gICAgXHRcdHRoaXMubWFwcGluZyA9IHNvdXJjZS5tYXBwaW5nO1xuXG4gICAgXHRcdHRoaXMud3JhcFMgPSBzb3VyY2Uud3JhcFM7XG4gICAgXHRcdHRoaXMud3JhcFQgPSBzb3VyY2Uud3JhcFQ7XG5cbiAgICBcdFx0dGhpcy5tYWdGaWx0ZXIgPSBzb3VyY2UubWFnRmlsdGVyO1xuICAgIFx0XHR0aGlzLm1pbkZpbHRlciA9IHNvdXJjZS5taW5GaWx0ZXI7XG5cbiAgICBcdFx0dGhpcy5hbmlzb3Ryb3B5ID0gc291cmNlLmFuaXNvdHJvcHk7XG5cbiAgICBcdFx0dGhpcy5mb3JtYXQgPSBzb3VyY2UuZm9ybWF0O1xuICAgIFx0XHR0aGlzLnR5cGUgPSBzb3VyY2UudHlwZTtcblxuICAgIFx0XHR0aGlzLm9mZnNldC5jb3B5KCBzb3VyY2Uub2Zmc2V0ICk7XG4gICAgXHRcdHRoaXMucmVwZWF0LmNvcHkoIHNvdXJjZS5yZXBlYXQgKTtcblxuICAgIFx0XHR0aGlzLmdlbmVyYXRlTWlwbWFwcyA9IHNvdXJjZS5nZW5lcmF0ZU1pcG1hcHM7XG4gICAgXHRcdHRoaXMucHJlbXVsdGlwbHlBbHBoYSA9IHNvdXJjZS5wcmVtdWx0aXBseUFscGhhO1xuICAgIFx0XHR0aGlzLmZsaXBZID0gc291cmNlLmZsaXBZO1xuICAgIFx0XHR0aGlzLnVucGFja0FsaWdubWVudCA9IHNvdXJjZS51bnBhY2tBbGlnbm1lbnQ7XG4gICAgXHRcdHRoaXMuZW5jb2RpbmcgPSBzb3VyY2UuZW5jb2Rpbmc7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdHRvSlNPTjogZnVuY3Rpb24gKCBtZXRhICkge1xuXG4gICAgXHRcdGlmICggbWV0YS50ZXh0dXJlc1sgdGhpcy51dWlkIF0gIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdHJldHVybiBtZXRhLnRleHR1cmVzWyB0aGlzLnV1aWQgXTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0ZnVuY3Rpb24gZ2V0RGF0YVVSTCggaW1hZ2UgKSB7XG5cbiAgICBcdFx0XHR2YXIgY2FudmFzO1xuXG4gICAgXHRcdFx0aWYgKCBpbWFnZS50b0RhdGFVUkwgIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0Y2FudmFzID0gaW1hZ2U7XG5cbiAgICBcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHRjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJywgJ2NhbnZhcycgKTtcbiAgICBcdFx0XHRcdGNhbnZhcy53aWR0aCA9IGltYWdlLndpZHRoO1xuICAgIFx0XHRcdFx0Y2FudmFzLmhlaWdodCA9IGltYWdlLmhlaWdodDtcblxuICAgIFx0XHRcdFx0Y2FudmFzLmdldENvbnRleHQoICcyZCcgKS5kcmF3SW1hZ2UoIGltYWdlLCAwLCAwLCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0ICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRpZiAoIGNhbnZhcy53aWR0aCA+IDIwNDggfHwgY2FudmFzLmhlaWdodCA+IDIwNDggKSB7XG5cbiAgICBcdFx0XHRcdHJldHVybiBjYW52YXMudG9EYXRhVVJMKCAnaW1hZ2UvanBlZycsIDAuNiApO1xuXG4gICAgXHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0cmV0dXJuIGNhbnZhcy50b0RhdGFVUkwoICdpbWFnZS9wbmcnICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHZhciBvdXRwdXQgPSB7XG4gICAgXHRcdFx0bWV0YWRhdGE6IHtcbiAgICBcdFx0XHRcdHZlcnNpb246IDQuNCxcbiAgICBcdFx0XHRcdHR5cGU6ICdUZXh0dXJlJyxcbiAgICBcdFx0XHRcdGdlbmVyYXRvcjogJ1RleHR1cmUudG9KU09OJ1xuICAgIFx0XHRcdH0sXG5cbiAgICBcdFx0XHR1dWlkOiB0aGlzLnV1aWQsXG4gICAgXHRcdFx0bmFtZTogdGhpcy5uYW1lLFxuXG4gICAgXHRcdFx0bWFwcGluZzogdGhpcy5tYXBwaW5nLFxuXG4gICAgXHRcdFx0cmVwZWF0OiBbIHRoaXMucmVwZWF0LngsIHRoaXMucmVwZWF0LnkgXSxcbiAgICBcdFx0XHRvZmZzZXQ6IFsgdGhpcy5vZmZzZXQueCwgdGhpcy5vZmZzZXQueSBdLFxuICAgIFx0XHRcdHdyYXA6IFsgdGhpcy53cmFwUywgdGhpcy53cmFwVCBdLFxuXG4gICAgXHRcdFx0bWluRmlsdGVyOiB0aGlzLm1pbkZpbHRlcixcbiAgICBcdFx0XHRtYWdGaWx0ZXI6IHRoaXMubWFnRmlsdGVyLFxuICAgIFx0XHRcdGFuaXNvdHJvcHk6IHRoaXMuYW5pc290cm9weSxcblxuICAgIFx0XHRcdGZsaXBZOiB0aGlzLmZsaXBZXG4gICAgXHRcdH07XG5cbiAgICBcdFx0aWYgKCB0aGlzLmltYWdlICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHQvLyBUT0RPOiBNb3ZlIHRvIFRIUkVFLkltYWdlXG5cbiAgICBcdFx0XHR2YXIgaW1hZ2UgPSB0aGlzLmltYWdlO1xuXG4gICAgXHRcdFx0aWYgKCBpbWFnZS51dWlkID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRcdGltYWdlLnV1aWQgPSBleHBvcnRzLk1hdGguZ2VuZXJhdGVVVUlEKCk7IC8vIFVHSFxuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0aWYgKCBtZXRhLmltYWdlc1sgaW1hZ2UudXVpZCBdID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRcdG1ldGEuaW1hZ2VzWyBpbWFnZS51dWlkIF0gPSB7XG4gICAgXHRcdFx0XHRcdHV1aWQ6IGltYWdlLnV1aWQsXG4gICAgXHRcdFx0XHRcdHVybDogZ2V0RGF0YVVSTCggaW1hZ2UgKVxuICAgIFx0XHRcdFx0fTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdG91dHB1dC5pbWFnZSA9IGltYWdlLnV1aWQ7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdG1ldGEudGV4dHVyZXNbIHRoaXMudXVpZCBdID0gb3V0cHV0O1xuXG4gICAgXHRcdHJldHVybiBvdXRwdXQ7XG5cbiAgICBcdH0sXG5cbiAgICBcdGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2Rpc3Bvc2UnIH0gKTtcblxuICAgIFx0fSxcblxuICAgIFx0dHJhbnNmb3JtVXY6IGZ1bmN0aW9uICggdXYgKSB7XG5cbiAgICBcdFx0aWYgKCB0aGlzLm1hcHBpbmcgIT09IFVWTWFwcGluZyApICByZXR1cm47XG5cbiAgICBcdFx0dXYubXVsdGlwbHkoIHRoaXMucmVwZWF0ICk7XG4gICAgXHRcdHV2LmFkZCggdGhpcy5vZmZzZXQgKTtcblxuICAgIFx0XHRpZiAoIHV2LnggPCAwIHx8IHV2LnggPiAxICkge1xuXG4gICAgXHRcdFx0c3dpdGNoICggdGhpcy53cmFwUyApIHtcblxuICAgIFx0XHRcdFx0Y2FzZSBSZXBlYXRXcmFwcGluZzpcblxuICAgIFx0XHRcdFx0XHR1di54ID0gdXYueCAtIE1hdGguZmxvb3IoIHV2LnggKTtcbiAgICBcdFx0XHRcdFx0YnJlYWs7XG5cbiAgICBcdFx0XHRcdGNhc2UgQ2xhbXBUb0VkZ2VXcmFwcGluZzpcblxuICAgIFx0XHRcdFx0XHR1di54ID0gdXYueCA8IDAgPyAwIDogMTtcbiAgICBcdFx0XHRcdFx0YnJlYWs7XG5cbiAgICBcdFx0XHRcdGNhc2UgTWlycm9yZWRSZXBlYXRXcmFwcGluZzpcblxuICAgIFx0XHRcdFx0XHRpZiAoIE1hdGguYWJzKCBNYXRoLmZsb29yKCB1di54ICkgJSAyICkgPT09IDEgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHR1di54ID0gTWF0aC5jZWlsKCB1di54ICkgLSB1di54O1xuXG4gICAgXHRcdFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdFx0XHR1di54ID0gdXYueCAtIE1hdGguZmxvb3IoIHV2LnggKTtcblxuICAgIFx0XHRcdFx0XHR9XG4gICAgXHRcdFx0XHRcdGJyZWFrO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHRpZiAoIHV2LnkgPCAwIHx8IHV2LnkgPiAxICkge1xuXG4gICAgXHRcdFx0c3dpdGNoICggdGhpcy53cmFwVCApIHtcblxuICAgIFx0XHRcdFx0Y2FzZSBSZXBlYXRXcmFwcGluZzpcblxuICAgIFx0XHRcdFx0XHR1di55ID0gdXYueSAtIE1hdGguZmxvb3IoIHV2LnkgKTtcbiAgICBcdFx0XHRcdFx0YnJlYWs7XG5cbiAgICBcdFx0XHRcdGNhc2UgQ2xhbXBUb0VkZ2VXcmFwcGluZzpcblxuICAgIFx0XHRcdFx0XHR1di55ID0gdXYueSA8IDAgPyAwIDogMTtcbiAgICBcdFx0XHRcdFx0YnJlYWs7XG5cbiAgICBcdFx0XHRcdGNhc2UgTWlycm9yZWRSZXBlYXRXcmFwcGluZzpcblxuICAgIFx0XHRcdFx0XHRpZiAoIE1hdGguYWJzKCBNYXRoLmZsb29yKCB1di55ICkgJSAyICkgPT09IDEgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHR1di55ID0gTWF0aC5jZWlsKCB1di55ICkgLSB1di55O1xuXG4gICAgXHRcdFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdFx0XHR1di55ID0gdXYueSAtIE1hdGguZmxvb3IoIHV2LnkgKTtcblxuICAgIFx0XHRcdFx0XHR9XG4gICAgXHRcdFx0XHRcdGJyZWFrO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHRpZiAoIHRoaXMuZmxpcFkgKSB7XG5cbiAgICBcdFx0XHR1di55ID0gMSAtIHV2Lnk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9XG5cbiAgICB9O1xuXG4gICAgT2JqZWN0LmFzc2lnbiggVGV4dHVyZS5wcm90b3R5cGUsIEV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUgKTtcblxuICAgIHZhciBjb3VudCA9IDA7XG4gICAgZnVuY3Rpb24gVGV4dHVyZUlkQ291bnQoKSB7IHJldHVybiBjb3VudCsrOyB9O1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBzdXBlcmVnZ2JlcnQgLyBodHRwOi8vd3d3LnBhdWxicnVudC5jby51ay9cbiAgICAgKiBAYXV0aG9yIHBoaWxvZ2IgLyBodHRwOi8vYmxvZy50aGVqaXQub3JnL1xuICAgICAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG4gICAgICogQGF1dGhvciBlZ3JhZXRoZXIgLyBodHRwOi8vZWdyYWV0aGVyLmNvbS9cbiAgICAgKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIFZlY3RvcjQoIHgsIHksIHosIHcgKSB7XG5cbiAgICBcdHRoaXMueCA9IHggfHwgMDtcbiAgICBcdHRoaXMueSA9IHkgfHwgMDtcbiAgICBcdHRoaXMueiA9IHogfHwgMDtcbiAgICBcdHRoaXMudyA9ICggdyAhPT0gdW5kZWZpbmVkICkgPyB3IDogMTtcblxuICAgIH1cblxuICAgIFZlY3RvcjQucHJvdG90eXBlID0ge1xuXG4gICAgXHRjb25zdHJ1Y3RvcjogVmVjdG9yNCxcblxuICAgIFx0aXNWZWN0b3I0OiB0cnVlLFxuXG4gICAgXHRzZXQ6IGZ1bmN0aW9uICggeCwgeSwgeiwgdyApIHtcblxuICAgIFx0XHR0aGlzLnggPSB4O1xuICAgIFx0XHR0aGlzLnkgPSB5O1xuICAgIFx0XHR0aGlzLnogPSB6O1xuICAgIFx0XHR0aGlzLncgPSB3O1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRzZXRTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xuXG4gICAgXHRcdHRoaXMueCA9IHNjYWxhcjtcbiAgICBcdFx0dGhpcy55ID0gc2NhbGFyO1xuICAgIFx0XHR0aGlzLnogPSBzY2FsYXI7XG4gICAgXHRcdHRoaXMudyA9IHNjYWxhcjtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0c2V0WDogZnVuY3Rpb24gKCB4ICkge1xuXG4gICAgXHRcdHRoaXMueCA9IHg7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldFk6IGZ1bmN0aW9uICggeSApIHtcblxuICAgIFx0XHR0aGlzLnkgPSB5O1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRzZXRaOiBmdW5jdGlvbiAoIHogKSB7XG5cbiAgICBcdFx0dGhpcy56ID0gejtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0c2V0VzogZnVuY3Rpb24gKCB3ICkge1xuXG4gICAgXHRcdHRoaXMudyA9IHc7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldENvbXBvbmVudDogZnVuY3Rpb24gKCBpbmRleCwgdmFsdWUgKSB7XG5cbiAgICBcdFx0c3dpdGNoICggaW5kZXggKSB7XG5cbiAgICBcdFx0XHRjYXNlIDA6IHRoaXMueCA9IHZhbHVlOyBicmVhaztcbiAgICBcdFx0XHRjYXNlIDE6IHRoaXMueSA9IHZhbHVlOyBicmVhaztcbiAgICBcdFx0XHRjYXNlIDI6IHRoaXMueiA9IHZhbHVlOyBicmVhaztcbiAgICBcdFx0XHRjYXNlIDM6IHRoaXMudyA9IHZhbHVlOyBicmVhaztcbiAgICBcdFx0XHRkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoICdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0fSxcblxuICAgIFx0Z2V0Q29tcG9uZW50OiBmdW5jdGlvbiAoIGluZGV4ICkge1xuXG4gICAgXHRcdHN3aXRjaCAoIGluZGV4ICkge1xuXG4gICAgXHRcdFx0Y2FzZSAwOiByZXR1cm4gdGhpcy54O1xuICAgIFx0XHRcdGNhc2UgMTogcmV0dXJuIHRoaXMueTtcbiAgICBcdFx0XHRjYXNlIDI6IHJldHVybiB0aGlzLno7XG4gICAgXHRcdFx0Y2FzZSAzOiByZXR1cm4gdGhpcy53O1xuICAgIFx0XHRcdGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvciggJ2luZGV4IGlzIG91dCBvZiByYW5nZTogJyArIGluZGV4ICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9LFxuXG4gICAgXHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy54LCB0aGlzLnksIHRoaXMueiwgdGhpcy53ICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGNvcHk6IGZ1bmN0aW9uICggdiApIHtcblxuICAgIFx0XHR0aGlzLnggPSB2Lng7XG4gICAgXHRcdHRoaXMueSA9IHYueTtcbiAgICBcdFx0dGhpcy56ID0gdi56O1xuICAgIFx0XHR0aGlzLncgPSAoIHYudyAhPT0gdW5kZWZpbmVkICkgPyB2LncgOiAxO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRhZGQ6IGZ1bmN0aW9uICggdiwgdyApIHtcblxuICAgIFx0XHRpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjQ6IC5hZGQoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5hZGRWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nICk7XG4gICAgXHRcdFx0cmV0dXJuIHRoaXMuYWRkVmVjdG9ycyggdiwgdyApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHR0aGlzLnggKz0gdi54O1xuICAgIFx0XHR0aGlzLnkgKz0gdi55O1xuICAgIFx0XHR0aGlzLnogKz0gdi56O1xuICAgIFx0XHR0aGlzLncgKz0gdi53O1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRhZGRTY2FsYXI6IGZ1bmN0aW9uICggcyApIHtcblxuICAgIFx0XHR0aGlzLnggKz0gcztcbiAgICBcdFx0dGhpcy55ICs9IHM7XG4gICAgXHRcdHRoaXMueiArPSBzO1xuICAgIFx0XHR0aGlzLncgKz0gcztcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0YWRkVmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xuXG4gICAgXHRcdHRoaXMueCA9IGEueCArIGIueDtcbiAgICBcdFx0dGhpcy55ID0gYS55ICsgYi55O1xuICAgIFx0XHR0aGlzLnogPSBhLnogKyBiLno7XG4gICAgXHRcdHRoaXMudyA9IGEudyArIGIudztcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0YWRkU2NhbGVkVmVjdG9yOiBmdW5jdGlvbiAoIHYsIHMgKSB7XG5cbiAgICBcdFx0dGhpcy54ICs9IHYueCAqIHM7XG4gICAgXHRcdHRoaXMueSArPSB2LnkgKiBzO1xuICAgIFx0XHR0aGlzLnogKz0gdi56ICogcztcbiAgICBcdFx0dGhpcy53ICs9IHYudyAqIHM7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdHN1YjogZnVuY3Rpb24gKCB2LCB3ICkge1xuXG4gICAgXHRcdGlmICggdyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yNDogLnN1YigpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLnN1YlZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcbiAgICBcdFx0XHRyZXR1cm4gdGhpcy5zdWJWZWN0b3JzKCB2LCB3ICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHRoaXMueCAtPSB2Lng7XG4gICAgXHRcdHRoaXMueSAtPSB2Lnk7XG4gICAgXHRcdHRoaXMueiAtPSB2Lno7XG4gICAgXHRcdHRoaXMudyAtPSB2Lnc7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdHN1YlNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xuXG4gICAgXHRcdHRoaXMueCAtPSBzO1xuICAgIFx0XHR0aGlzLnkgLT0gcztcbiAgICBcdFx0dGhpcy56IC09IHM7XG4gICAgXHRcdHRoaXMudyAtPSBzO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRzdWJWZWN0b3JzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XG5cbiAgICBcdFx0dGhpcy54ID0gYS54IC0gYi54O1xuICAgIFx0XHR0aGlzLnkgPSBhLnkgLSBiLnk7XG4gICAgXHRcdHRoaXMueiA9IGEueiAtIGIuejtcbiAgICBcdFx0dGhpcy53ID0gYS53IC0gYi53O1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRtdWx0aXBseVNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XG5cbiAgICBcdFx0aWYgKCBpc0Zpbml0ZSggc2NhbGFyICkgKSB7XG5cbiAgICBcdFx0XHR0aGlzLnggKj0gc2NhbGFyO1xuICAgIFx0XHRcdHRoaXMueSAqPSBzY2FsYXI7XG4gICAgXHRcdFx0dGhpcy56ICo9IHNjYWxhcjtcbiAgICBcdFx0XHR0aGlzLncgKj0gc2NhbGFyO1xuXG4gICAgXHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHR0aGlzLnggPSAwO1xuICAgIFx0XHRcdHRoaXMueSA9IDA7XG4gICAgXHRcdFx0dGhpcy56ID0gMDtcbiAgICBcdFx0XHR0aGlzLncgPSAwO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0YXBwbHlNYXRyaXg0OiBmdW5jdGlvbiAoIG0gKSB7XG5cbiAgICBcdFx0dmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLnosIHcgPSB0aGlzLnc7XG4gICAgXHRcdHZhciBlID0gbS5lbGVtZW50cztcblxuICAgIFx0XHR0aGlzLnggPSBlWyAwIF0gKiB4ICsgZVsgNCBdICogeSArIGVbIDggXSAqIHogKyBlWyAxMiBdICogdztcbiAgICBcdFx0dGhpcy55ID0gZVsgMSBdICogeCArIGVbIDUgXSAqIHkgKyBlWyA5IF0gKiB6ICsgZVsgMTMgXSAqIHc7XG4gICAgXHRcdHRoaXMueiA9IGVbIDIgXSAqIHggKyBlWyA2IF0gKiB5ICsgZVsgMTAgXSAqIHogKyBlWyAxNCBdICogdztcbiAgICBcdFx0dGhpcy53ID0gZVsgMyBdICogeCArIGVbIDcgXSAqIHkgKyBlWyAxMSBdICogeiArIGVbIDE1IF0gKiB3O1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRkaXZpZGVTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xuXG4gICAgXHRcdHJldHVybiB0aGlzLm11bHRpcGx5U2NhbGFyKCAxIC8gc2NhbGFyICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldEF4aXNBbmdsZUZyb21RdWF0ZXJuaW9uOiBmdW5jdGlvbiAoIHEgKSB7XG5cbiAgICBcdFx0Ly8gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvZ2VvbWV0cnkvcm90YXRpb25zL2NvbnZlcnNpb25zL3F1YXRlcm5pb25Ub0FuZ2xlL2luZGV4Lmh0bVxuXG4gICAgXHRcdC8vIHEgaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkXG5cbiAgICBcdFx0dGhpcy53ID0gMiAqIE1hdGguYWNvcyggcS53ICk7XG5cbiAgICBcdFx0dmFyIHMgPSBNYXRoLnNxcnQoIDEgLSBxLncgKiBxLncgKTtcblxuICAgIFx0XHRpZiAoIHMgPCAwLjAwMDEgKSB7XG5cbiAgICBcdFx0XHQgdGhpcy54ID0gMTtcbiAgICBcdFx0XHQgdGhpcy55ID0gMDtcbiAgICBcdFx0XHQgdGhpcy56ID0gMDtcblxuICAgIFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0IHRoaXMueCA9IHEueCAvIHM7XG4gICAgXHRcdFx0IHRoaXMueSA9IHEueSAvIHM7XG4gICAgXHRcdFx0IHRoaXMueiA9IHEueiAvIHM7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRzZXRBeGlzQW5nbGVGcm9tUm90YXRpb25NYXRyaXg6IGZ1bmN0aW9uICggbSApIHtcblxuICAgIFx0XHQvLyBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9nZW9tZXRyeS9yb3RhdGlvbnMvY29udmVyc2lvbnMvbWF0cml4VG9BbmdsZS9pbmRleC5odG1cblxuICAgIFx0XHQvLyBhc3N1bWVzIHRoZSB1cHBlciAzeDMgb2YgbSBpcyBhIHB1cmUgcm90YXRpb24gbWF0cml4IChpLmUsIHVuc2NhbGVkKVxuXG4gICAgXHRcdHZhciBhbmdsZSwgeCwgeSwgeixcdFx0Ly8gdmFyaWFibGVzIGZvciByZXN1bHRcbiAgICBcdFx0XHRlcHNpbG9uID0gMC4wMSxcdFx0Ly8gbWFyZ2luIHRvIGFsbG93IGZvciByb3VuZGluZyBlcnJvcnNcbiAgICBcdFx0XHRlcHNpbG9uMiA9IDAuMSxcdFx0Ly8gbWFyZ2luIHRvIGRpc3Rpbmd1aXNoIGJldHdlZW4gMCBhbmQgMTgwIGRlZ3JlZXNcblxuICAgIFx0XHRcdHRlID0gbS5lbGVtZW50cyxcblxuICAgIFx0XHRcdG0xMSA9IHRlWyAwIF0sIG0xMiA9IHRlWyA0IF0sIG0xMyA9IHRlWyA4IF0sXG4gICAgXHRcdFx0bTIxID0gdGVbIDEgXSwgbTIyID0gdGVbIDUgXSwgbTIzID0gdGVbIDkgXSxcbiAgICBcdFx0XHRtMzEgPSB0ZVsgMiBdLCBtMzIgPSB0ZVsgNiBdLCBtMzMgPSB0ZVsgMTAgXTtcblxuICAgIFx0XHRpZiAoICggTWF0aC5hYnMoIG0xMiAtIG0yMSApIDwgZXBzaWxvbiApICYmXG4gICAgXHRcdCAgICAgKCBNYXRoLmFicyggbTEzIC0gbTMxICkgPCBlcHNpbG9uICkgJiZcbiAgICBcdFx0ICAgICAoIE1hdGguYWJzKCBtMjMgLSBtMzIgKSA8IGVwc2lsb24gKSApIHtcblxuICAgIFx0XHRcdC8vIHNpbmd1bGFyaXR5IGZvdW5kXG4gICAgXHRcdFx0Ly8gZmlyc3QgY2hlY2sgZm9yIGlkZW50aXR5IG1hdHJpeCB3aGljaCBtdXN0IGhhdmUgKzEgZm9yIGFsbCB0ZXJtc1xuICAgIFx0XHRcdC8vIGluIGxlYWRpbmcgZGlhZ29uYWwgYW5kIHplcm8gaW4gb3RoZXIgdGVybXNcblxuICAgIFx0XHRcdGlmICggKCBNYXRoLmFicyggbTEyICsgbTIxICkgPCBlcHNpbG9uMiApICYmXG4gICAgXHRcdFx0ICAgICAoIE1hdGguYWJzKCBtMTMgKyBtMzEgKSA8IGVwc2lsb24yICkgJiZcbiAgICBcdFx0XHQgICAgICggTWF0aC5hYnMoIG0yMyArIG0zMiApIDwgZXBzaWxvbjIgKSAmJlxuICAgIFx0XHRcdCAgICAgKCBNYXRoLmFicyggbTExICsgbTIyICsgbTMzIC0gMyApIDwgZXBzaWxvbjIgKSApIHtcblxuICAgIFx0XHRcdFx0Ly8gdGhpcyBzaW5ndWxhcml0eSBpcyBpZGVudGl0eSBtYXRyaXggc28gYW5nbGUgPSAwXG5cbiAgICBcdFx0XHRcdHRoaXMuc2V0KCAxLCAwLCAwLCAwICk7XG5cbiAgICBcdFx0XHRcdHJldHVybiB0aGlzOyAvLyB6ZXJvIGFuZ2xlLCBhcmJpdHJhcnkgYXhpc1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0Ly8gb3RoZXJ3aXNlIHRoaXMgc2luZ3VsYXJpdHkgaXMgYW5nbGUgPSAxODBcblxuICAgIFx0XHRcdGFuZ2xlID0gTWF0aC5QSTtcblxuICAgIFx0XHRcdHZhciB4eCA9ICggbTExICsgMSApIC8gMjtcbiAgICBcdFx0XHR2YXIgeXkgPSAoIG0yMiArIDEgKSAvIDI7XG4gICAgXHRcdFx0dmFyIHp6ID0gKCBtMzMgKyAxICkgLyAyO1xuICAgIFx0XHRcdHZhciB4eSA9ICggbTEyICsgbTIxICkgLyA0O1xuICAgIFx0XHRcdHZhciB4eiA9ICggbTEzICsgbTMxICkgLyA0O1xuICAgIFx0XHRcdHZhciB5eiA9ICggbTIzICsgbTMyICkgLyA0O1xuXG4gICAgXHRcdFx0aWYgKCAoIHh4ID4geXkgKSAmJiAoIHh4ID4genogKSApIHtcblxuICAgIFx0XHRcdFx0Ly8gbTExIGlzIHRoZSBsYXJnZXN0IGRpYWdvbmFsIHRlcm1cblxuICAgIFx0XHRcdFx0aWYgKCB4eCA8IGVwc2lsb24gKSB7XG5cbiAgICBcdFx0XHRcdFx0eCA9IDA7XG4gICAgXHRcdFx0XHRcdHkgPSAwLjcwNzEwNjc4MTtcbiAgICBcdFx0XHRcdFx0eiA9IDAuNzA3MTA2NzgxO1xuXG4gICAgXHRcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHRcdHggPSBNYXRoLnNxcnQoIHh4ICk7XG4gICAgXHRcdFx0XHRcdHkgPSB4eSAvIHg7XG4gICAgXHRcdFx0XHRcdHogPSB4eiAvIHg7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdH0gZWxzZSBpZiAoIHl5ID4genogKSB7XG5cbiAgICBcdFx0XHRcdC8vIG0yMiBpcyB0aGUgbGFyZ2VzdCBkaWFnb25hbCB0ZXJtXG5cbiAgICBcdFx0XHRcdGlmICggeXkgPCBlcHNpbG9uICkge1xuXG4gICAgXHRcdFx0XHRcdHggPSAwLjcwNzEwNjc4MTtcbiAgICBcdFx0XHRcdFx0eSA9IDA7XG4gICAgXHRcdFx0XHRcdHogPSAwLjcwNzEwNjc4MTtcblxuICAgIFx0XHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0XHR5ID0gTWF0aC5zcXJ0KCB5eSApO1xuICAgIFx0XHRcdFx0XHR4ID0geHkgLyB5O1xuICAgIFx0XHRcdFx0XHR6ID0geXogLyB5O1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHQvLyBtMzMgaXMgdGhlIGxhcmdlc3QgZGlhZ29uYWwgdGVybSBzbyBiYXNlIHJlc3VsdCBvbiB0aGlzXG5cbiAgICBcdFx0XHRcdGlmICggenogPCBlcHNpbG9uICkge1xuXG4gICAgXHRcdFx0XHRcdHggPSAwLjcwNzEwNjc4MTtcbiAgICBcdFx0XHRcdFx0eSA9IDAuNzA3MTA2NzgxO1xuICAgIFx0XHRcdFx0XHR6ID0gMDtcblxuICAgIFx0XHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0XHR6ID0gTWF0aC5zcXJ0KCB6eiApO1xuICAgIFx0XHRcdFx0XHR4ID0geHogLyB6O1xuICAgIFx0XHRcdFx0XHR5ID0geXogLyB6O1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHR0aGlzLnNldCggeCwgeSwgeiwgYW5nbGUgKTtcblxuICAgIFx0XHRcdHJldHVybiB0aGlzOyAvLyByZXR1cm4gMTgwIGRlZyByb3RhdGlvblxuXG4gICAgXHRcdH1cblxuICAgIFx0XHQvLyBhcyB3ZSBoYXZlIHJlYWNoZWQgaGVyZSB0aGVyZSBhcmUgbm8gc2luZ3VsYXJpdGllcyBzbyB3ZSBjYW4gaGFuZGxlIG5vcm1hbGx5XG5cbiAgICBcdFx0dmFyIHMgPSBNYXRoLnNxcnQoICggbTMyIC0gbTIzICkgKiAoIG0zMiAtIG0yMyApICtcbiAgICBcdFx0ICAgICAgICAgICAgICAgICAgICggbTEzIC0gbTMxICkgKiAoIG0xMyAtIG0zMSApICtcbiAgICBcdFx0ICAgICAgICAgICAgICAgICAgICggbTIxIC0gbTEyICkgKiAoIG0yMSAtIG0xMiApICk7IC8vIHVzZWQgdG8gbm9ybWFsaXplXG5cbiAgICBcdFx0aWYgKCBNYXRoLmFicyggcyApIDwgMC4wMDEgKSBzID0gMTtcblxuICAgIFx0XHQvLyBwcmV2ZW50IGRpdmlkZSBieSB6ZXJvLCBzaG91bGQgbm90IGhhcHBlbiBpZiBtYXRyaXggaXMgb3J0aG9nb25hbCBhbmQgc2hvdWxkIGJlXG4gICAgXHRcdC8vIGNhdWdodCBieSBzaW5ndWxhcml0eSB0ZXN0IGFib3ZlLCBidXQgSSd2ZSBsZWZ0IGl0IGluIGp1c3QgaW4gY2FzZVxuXG4gICAgXHRcdHRoaXMueCA9ICggbTMyIC0gbTIzICkgLyBzO1xuICAgIFx0XHR0aGlzLnkgPSAoIG0xMyAtIG0zMSApIC8gcztcbiAgICBcdFx0dGhpcy56ID0gKCBtMjEgLSBtMTIgKSAvIHM7XG4gICAgXHRcdHRoaXMudyA9IE1hdGguYWNvcyggKCBtMTEgKyBtMjIgKyBtMzMgLSAxICkgLyAyICk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdG1pbjogZnVuY3Rpb24gKCB2ICkge1xuXG4gICAgXHRcdHRoaXMueCA9IE1hdGgubWluKCB0aGlzLngsIHYueCApO1xuICAgIFx0XHR0aGlzLnkgPSBNYXRoLm1pbiggdGhpcy55LCB2LnkgKTtcbiAgICBcdFx0dGhpcy56ID0gTWF0aC5taW4oIHRoaXMueiwgdi56ICk7XG4gICAgXHRcdHRoaXMudyA9IE1hdGgubWluKCB0aGlzLncsIHYudyApO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRtYXg6IGZ1bmN0aW9uICggdiApIHtcblxuICAgIFx0XHR0aGlzLnggPSBNYXRoLm1heCggdGhpcy54LCB2LnggKTtcbiAgICBcdFx0dGhpcy55ID0gTWF0aC5tYXgoIHRoaXMueSwgdi55ICk7XG4gICAgXHRcdHRoaXMueiA9IE1hdGgubWF4KCB0aGlzLnosIHYueiApO1xuICAgIFx0XHR0aGlzLncgPSBNYXRoLm1heCggdGhpcy53LCB2LncgKTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0Y2xhbXA6IGZ1bmN0aW9uICggbWluLCBtYXggKSB7XG5cbiAgICBcdFx0Ly8gVGhpcyBmdW5jdGlvbiBhc3N1bWVzIG1pbiA8IG1heCwgaWYgdGhpcyBhc3N1bXB0aW9uIGlzbid0IHRydWUgaXQgd2lsbCBub3Qgb3BlcmF0ZSBjb3JyZWN0bHlcblxuICAgIFx0XHR0aGlzLnggPSBNYXRoLm1heCggbWluLngsIE1hdGgubWluKCBtYXgueCwgdGhpcy54ICkgKTtcbiAgICBcdFx0dGhpcy55ID0gTWF0aC5tYXgoIG1pbi55LCBNYXRoLm1pbiggbWF4LnksIHRoaXMueSApICk7XG4gICAgXHRcdHRoaXMueiA9IE1hdGgubWF4KCBtaW4ueiwgTWF0aC5taW4oIG1heC56LCB0aGlzLnogKSApO1xuICAgIFx0XHR0aGlzLncgPSBNYXRoLm1heCggbWluLncsIE1hdGgubWluKCBtYXgudywgdGhpcy53ICkgKTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0Y2xhbXBTY2FsYXI6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR2YXIgbWluLCBtYXg7XG5cbiAgICBcdFx0cmV0dXJuIGZ1bmN0aW9uIGNsYW1wU2NhbGFyKCBtaW5WYWwsIG1heFZhbCApIHtcblxuICAgIFx0XHRcdGlmICggbWluID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRcdG1pbiA9IG5ldyBWZWN0b3I0KCk7XG4gICAgXHRcdFx0XHRtYXggPSBuZXcgVmVjdG9yNCgpO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0bWluLnNldCggbWluVmFsLCBtaW5WYWwsIG1pblZhbCwgbWluVmFsICk7XG4gICAgXHRcdFx0bWF4LnNldCggbWF4VmFsLCBtYXhWYWwsIG1heFZhbCwgbWF4VmFsICk7XG5cbiAgICBcdFx0XHRyZXR1cm4gdGhpcy5jbGFtcCggbWluLCBtYXggKTtcblxuICAgIFx0XHR9O1xuXG4gICAgXHR9KCksXG5cbiAgICBcdGZsb29yOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dGhpcy54ID0gTWF0aC5mbG9vciggdGhpcy54ICk7XG4gICAgXHRcdHRoaXMueSA9IE1hdGguZmxvb3IoIHRoaXMueSApO1xuICAgIFx0XHR0aGlzLnogPSBNYXRoLmZsb29yKCB0aGlzLnogKTtcbiAgICBcdFx0dGhpcy53ID0gTWF0aC5mbG9vciggdGhpcy53ICk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGNlaWw6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR0aGlzLnggPSBNYXRoLmNlaWwoIHRoaXMueCApO1xuICAgIFx0XHR0aGlzLnkgPSBNYXRoLmNlaWwoIHRoaXMueSApO1xuICAgIFx0XHR0aGlzLnogPSBNYXRoLmNlaWwoIHRoaXMueiApO1xuICAgIFx0XHR0aGlzLncgPSBNYXRoLmNlaWwoIHRoaXMudyApO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRyb3VuZDogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHRoaXMueCA9IE1hdGgucm91bmQoIHRoaXMueCApO1xuICAgIFx0XHR0aGlzLnkgPSBNYXRoLnJvdW5kKCB0aGlzLnkgKTtcbiAgICBcdFx0dGhpcy56ID0gTWF0aC5yb3VuZCggdGhpcy56ICk7XG4gICAgXHRcdHRoaXMudyA9IE1hdGgucm91bmQoIHRoaXMudyApO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRyb3VuZFRvWmVybzogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHRoaXMueCA9ICggdGhpcy54IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLnggKSA6IE1hdGguZmxvb3IoIHRoaXMueCApO1xuICAgIFx0XHR0aGlzLnkgPSAoIHRoaXMueSA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy55ICkgOiBNYXRoLmZsb29yKCB0aGlzLnkgKTtcbiAgICBcdFx0dGhpcy56ID0gKCB0aGlzLnogPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMueiApIDogTWF0aC5mbG9vciggdGhpcy56ICk7XG4gICAgXHRcdHRoaXMudyA9ICggdGhpcy53IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLncgKSA6IE1hdGguZmxvb3IoIHRoaXMudyApO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRuZWdhdGU6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR0aGlzLnggPSAtIHRoaXMueDtcbiAgICBcdFx0dGhpcy55ID0gLSB0aGlzLnk7XG4gICAgXHRcdHRoaXMueiA9IC0gdGhpcy56O1xuICAgIFx0XHR0aGlzLncgPSAtIHRoaXMudztcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0ZG90OiBmdW5jdGlvbiAoIHYgKSB7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMueCAqIHYueCArIHRoaXMueSAqIHYueSArIHRoaXMueiAqIHYueiArIHRoaXMudyAqIHYudztcblxuICAgIFx0fSxcblxuICAgIFx0bGVuZ3RoU3E6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHRyZXR1cm4gdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICsgdGhpcy56ICogdGhpcy56ICsgdGhpcy53ICogdGhpcy53O1xuXG4gICAgXHR9LFxuXG4gICAgXHRsZW5ndGg6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHRyZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLnogKyB0aGlzLncgKiB0aGlzLncgKTtcblxuICAgIFx0fSxcblxuICAgIFx0bGVuZ3RoTWFuaGF0dGFuOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0cmV0dXJuIE1hdGguYWJzKCB0aGlzLnggKSArIE1hdGguYWJzKCB0aGlzLnkgKSArIE1hdGguYWJzKCB0aGlzLnogKSArIE1hdGguYWJzKCB0aGlzLncgKTtcblxuICAgIFx0fSxcblxuICAgIFx0bm9ybWFsaXplOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKCB0aGlzLmxlbmd0aCgpICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldExlbmd0aDogZnVuY3Rpb24gKCBsZW5ndGggKSB7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIoIGxlbmd0aCAvIHRoaXMubGVuZ3RoKCkgKTtcblxuICAgIFx0fSxcblxuICAgIFx0bGVycDogZnVuY3Rpb24gKCB2LCBhbHBoYSApIHtcblxuICAgIFx0XHR0aGlzLnggKz0gKCB2LnggLSB0aGlzLnggKSAqIGFscGhhO1xuICAgIFx0XHR0aGlzLnkgKz0gKCB2LnkgLSB0aGlzLnkgKSAqIGFscGhhO1xuICAgIFx0XHR0aGlzLnogKz0gKCB2LnogLSB0aGlzLnogKSAqIGFscGhhO1xuICAgIFx0XHR0aGlzLncgKz0gKCB2LncgLSB0aGlzLncgKSAqIGFscGhhO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRsZXJwVmVjdG9yczogZnVuY3Rpb24gKCB2MSwgdjIsIGFscGhhICkge1xuXG4gICAgXHRcdHJldHVybiB0aGlzLnN1YlZlY3RvcnMoIHYyLCB2MSApLm11bHRpcGx5U2NhbGFyKCBhbHBoYSApLmFkZCggdjEgKTtcblxuICAgIFx0fSxcblxuICAgIFx0ZXF1YWxzOiBmdW5jdGlvbiAoIHYgKSB7XG5cbiAgICBcdFx0cmV0dXJuICggKCB2LnggPT09IHRoaXMueCApICYmICggdi55ID09PSB0aGlzLnkgKSAmJiAoIHYueiA9PT0gdGhpcy56ICkgJiYgKCB2LncgPT09IHRoaXMudyApICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGZyb21BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xuXG4gICAgXHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG4gICAgXHRcdHRoaXMueCA9IGFycmF5WyBvZmZzZXQgXTtcbiAgICBcdFx0dGhpcy55ID0gYXJyYXlbIG9mZnNldCArIDEgXTtcbiAgICBcdFx0dGhpcy56ID0gYXJyYXlbIG9mZnNldCArIDIgXTtcbiAgICBcdFx0dGhpcy53ID0gYXJyYXlbIG9mZnNldCArIDMgXTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0dG9BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xuXG4gICAgXHRcdGlmICggYXJyYXkgPT09IHVuZGVmaW5lZCApIGFycmF5ID0gW107XG4gICAgXHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG4gICAgXHRcdGFycmF5WyBvZmZzZXQgXSA9IHRoaXMueDtcbiAgICBcdFx0YXJyYXlbIG9mZnNldCArIDEgXSA9IHRoaXMueTtcbiAgICBcdFx0YXJyYXlbIG9mZnNldCArIDIgXSA9IHRoaXMuejtcbiAgICBcdFx0YXJyYXlbIG9mZnNldCArIDMgXSA9IHRoaXMudztcblxuICAgIFx0XHRyZXR1cm4gYXJyYXk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGZyb21BdHRyaWJ1dGU6IGZ1bmN0aW9uICggYXR0cmlidXRlLCBpbmRleCwgb2Zmc2V0ICkge1xuXG4gICAgXHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG4gICAgXHRcdGluZGV4ID0gaW5kZXggKiBhdHRyaWJ1dGUuaXRlbVNpemUgKyBvZmZzZXQ7XG5cbiAgICBcdFx0dGhpcy54ID0gYXR0cmlidXRlLmFycmF5WyBpbmRleCBdO1xuICAgIFx0XHR0aGlzLnkgPSBhdHRyaWJ1dGUuYXJyYXlbIGluZGV4ICsgMSBdO1xuICAgIFx0XHR0aGlzLnogPSBhdHRyaWJ1dGUuYXJyYXlbIGluZGV4ICsgMiBdO1xuICAgIFx0XHR0aGlzLncgPSBhdHRyaWJ1dGUuYXJyYXlbIGluZGV4ICsgMyBdO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9XG5cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBzemltZWsgLyBodHRwczovL2dpdGh1Yi5jb20vc3ppbWVrL1xuICAgICAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gICAgICogQGF1dGhvciBNYXJpdXMgS2ludGVsIC8gaHR0cHM6Ly9naXRodWIuY29tL2tpbnRlbFxuICAgICAqL1xuXG4gICAgLypcbiAgICAgSW4gb3B0aW9ucywgd2UgY2FuIHNwZWNpZnk6XG4gICAgICogVGV4dHVyZSBwYXJhbWV0ZXJzIGZvciBhbiBhdXRvLWdlbmVyYXRlZCB0YXJnZXQgdGV4dHVyZVxuICAgICAqIGRlcHRoQnVmZmVyL3N0ZW5jaWxCdWZmZXI6IEJvb2xlYW5zIHRvIGluZGljYXRlIGlmIHdlIHNob3VsZCBnZW5lcmF0ZSB0aGVzZSBidWZmZXJzXG4gICAgKi9cbiAgICBmdW5jdGlvbiBXZWJHTFJlbmRlclRhcmdldCggd2lkdGgsIGhlaWdodCwgb3B0aW9ucyApIHtcblxuICAgIFx0dGhpcy51dWlkID0gZXhwb3J0cy5NYXRoLmdlbmVyYXRlVVVJRCgpO1xuXG4gICAgXHR0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgXHR0aGlzLmhlaWdodCA9IGhlaWdodDtcblxuICAgIFx0dGhpcy5zY2lzc29yID0gbmV3IFZlY3RvcjQoIDAsIDAsIHdpZHRoLCBoZWlnaHQgKTtcbiAgICBcdHRoaXMuc2Npc3NvclRlc3QgPSBmYWxzZTtcblxuICAgIFx0dGhpcy52aWV3cG9ydCA9IG5ldyBWZWN0b3I0KCAwLCAwLCB3aWR0aCwgaGVpZ2h0ICk7XG5cbiAgICBcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgXHRpZiAoIG9wdGlvbnMubWluRmlsdGVyID09PSB1bmRlZmluZWQgKSBvcHRpb25zLm1pbkZpbHRlciA9IExpbmVhckZpbHRlcjtcblxuICAgIFx0dGhpcy50ZXh0dXJlID0gbmV3IFRleHR1cmUoIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBvcHRpb25zLndyYXBTLCBvcHRpb25zLndyYXBULCBvcHRpb25zLm1hZ0ZpbHRlciwgb3B0aW9ucy5taW5GaWx0ZXIsIG9wdGlvbnMuZm9ybWF0LCBvcHRpb25zLnR5cGUsIG9wdGlvbnMuYW5pc290cm9weSwgb3B0aW9ucy5lbmNvZGluZyApO1xuXG4gICAgXHR0aGlzLmRlcHRoQnVmZmVyID0gb3B0aW9ucy5kZXB0aEJ1ZmZlciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5kZXB0aEJ1ZmZlciA6IHRydWU7XG4gICAgXHR0aGlzLnN0ZW5jaWxCdWZmZXIgPSBvcHRpb25zLnN0ZW5jaWxCdWZmZXIgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuc3RlbmNpbEJ1ZmZlciA6IHRydWU7XG4gICAgXHR0aGlzLmRlcHRoVGV4dHVyZSA9IG9wdGlvbnMuZGVwdGhUZXh0dXJlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmRlcHRoVGV4dHVyZSA6IG51bGw7XG5cbiAgICB9XG5cbiAgICBPYmplY3QuYXNzaWduKCBXZWJHTFJlbmRlclRhcmdldC5wcm90b3R5cGUsIEV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUsIHtcblxuICAgIFx0aXNXZWJHTFJlbmRlclRhcmdldDogdHJ1ZSxcblxuICAgIFx0c2V0U2l6ZTogZnVuY3Rpb24gKCB3aWR0aCwgaGVpZ2h0ICkge1xuXG4gICAgXHRcdGlmICggdGhpcy53aWR0aCAhPT0gd2lkdGggfHwgdGhpcy5oZWlnaHQgIT09IGhlaWdodCApIHtcblxuICAgIFx0XHRcdHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICBcdFx0XHR0aGlzLmhlaWdodCA9IGhlaWdodDtcblxuICAgIFx0XHRcdHRoaXMuZGlzcG9zZSgpO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHR0aGlzLnZpZXdwb3J0LnNldCggMCwgMCwgd2lkdGgsIGhlaWdodCApO1xuICAgIFx0XHR0aGlzLnNjaXNzb3Iuc2V0KCAwLCAwLCB3aWR0aCwgaGVpZ2h0ICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuICAgIFx0XHR0aGlzLndpZHRoID0gc291cmNlLndpZHRoO1xuICAgIFx0XHR0aGlzLmhlaWdodCA9IHNvdXJjZS5oZWlnaHQ7XG5cbiAgICBcdFx0dGhpcy52aWV3cG9ydC5jb3B5KCBzb3VyY2Uudmlld3BvcnQgKTtcblxuICAgIFx0XHR0aGlzLnRleHR1cmUgPSBzb3VyY2UudGV4dHVyZS5jbG9uZSgpO1xuXG4gICAgXHRcdHRoaXMuZGVwdGhCdWZmZXIgPSBzb3VyY2UuZGVwdGhCdWZmZXI7XG4gICAgXHRcdHRoaXMuc3RlbmNpbEJ1ZmZlciA9IHNvdXJjZS5zdGVuY2lsQnVmZmVyO1xuICAgIFx0XHR0aGlzLmRlcHRoVGV4dHVyZSA9IHNvdXJjZS5kZXB0aFRleHR1cmU7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2Rpc3Bvc2UnIH0gKTtcblxuICAgIFx0fVxuXG4gICAgfSApO1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbVxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gV2ViR0xSZW5kZXJUYXJnZXRDdWJlKCB3aWR0aCwgaGVpZ2h0LCBvcHRpb25zICkge1xuXG4gICAgXHRXZWJHTFJlbmRlclRhcmdldC5jYWxsKCB0aGlzLCB3aWR0aCwgaGVpZ2h0LCBvcHRpb25zICk7XG5cbiAgICBcdHRoaXMuYWN0aXZlQ3ViZUZhY2UgPSAwOyAvLyBQWCAwLCBOWCAxLCBQWSAyLCBOWSAzLCBQWiA0LCBOWiA1XG4gICAgXHR0aGlzLmFjdGl2ZU1pcE1hcExldmVsID0gMDtcblxuICAgIH1cblxuICAgIFdlYkdMUmVuZGVyVGFyZ2V0Q3ViZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBXZWJHTFJlbmRlclRhcmdldC5wcm90b3R5cGUgKTtcbiAgICBXZWJHTFJlbmRlclRhcmdldEN1YmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gV2ViR0xSZW5kZXJUYXJnZXRDdWJlO1xuXG4gICAgV2ViR0xSZW5kZXJUYXJnZXRDdWJlLnByb3RvdHlwZS5pc1dlYkdMUmVuZGVyVGFyZ2V0Q3ViZSA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICAgICAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gICAgICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG4gICAgICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pb1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gUXVhdGVybmlvbiggeCwgeSwgeiwgdyApIHtcblxuICAgIFx0dGhpcy5feCA9IHggfHwgMDtcbiAgICBcdHRoaXMuX3kgPSB5IHx8IDA7XG4gICAgXHR0aGlzLl96ID0geiB8fCAwO1xuICAgIFx0dGhpcy5fdyA9ICggdyAhPT0gdW5kZWZpbmVkICkgPyB3IDogMTtcblxuICAgIH1cblxuICAgIFF1YXRlcm5pb24ucHJvdG90eXBlID0ge1xuXG4gICAgXHRjb25zdHJ1Y3RvcjogUXVhdGVybmlvbixcblxuICAgIFx0Z2V0IHggKCkge1xuXG4gICAgXHRcdHJldHVybiB0aGlzLl94O1xuXG4gICAgXHR9LFxuXG4gICAgXHRzZXQgeCAoIHZhbHVlICkge1xuXG4gICAgXHRcdHRoaXMuX3ggPSB2YWx1ZTtcbiAgICBcdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGdldCB5ICgpIHtcblxuICAgIFx0XHRyZXR1cm4gdGhpcy5feTtcblxuICAgIFx0fSxcblxuICAgIFx0c2V0IHkgKCB2YWx1ZSApIHtcblxuICAgIFx0XHR0aGlzLl95ID0gdmFsdWU7XG4gICAgXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG4gICAgXHR9LFxuXG4gICAgXHRnZXQgeiAoKSB7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMuX3o7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldCB6ICggdmFsdWUgKSB7XG5cbiAgICBcdFx0dGhpcy5feiA9IHZhbHVlO1xuICAgIFx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuICAgIFx0fSxcblxuICAgIFx0Z2V0IHcgKCkge1xuXG4gICAgXHRcdHJldHVybiB0aGlzLl93O1xuXG4gICAgXHR9LFxuXG4gICAgXHRzZXQgdyAoIHZhbHVlICkge1xuXG4gICAgXHRcdHRoaXMuX3cgPSB2YWx1ZTtcbiAgICBcdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldDogZnVuY3Rpb24gKCB4LCB5LCB6LCB3ICkge1xuXG4gICAgXHRcdHRoaXMuX3ggPSB4O1xuICAgIFx0XHR0aGlzLl95ID0geTtcbiAgICBcdFx0dGhpcy5feiA9IHo7XG4gICAgXHRcdHRoaXMuX3cgPSB3O1xuXG4gICAgXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy5feCwgdGhpcy5feSwgdGhpcy5feiwgdGhpcy5fdyApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRjb3B5OiBmdW5jdGlvbiAoIHF1YXRlcm5pb24gKSB7XG5cbiAgICBcdFx0dGhpcy5feCA9IHF1YXRlcm5pb24ueDtcbiAgICBcdFx0dGhpcy5feSA9IHF1YXRlcm5pb24ueTtcbiAgICBcdFx0dGhpcy5feiA9IHF1YXRlcm5pb24uejtcbiAgICBcdFx0dGhpcy5fdyA9IHF1YXRlcm5pb24udztcblxuICAgIFx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0c2V0RnJvbUV1bGVyOiBmdW5jdGlvbiAoIGV1bGVyLCB1cGRhdGUgKSB7XG5cbiAgICBcdFx0aWYgKCAoZXVsZXIgJiYgZXVsZXIuaXNFdWxlcikgPT09IGZhbHNlICkge1xuXG4gICAgXHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuUXVhdGVybmlvbjogLnNldEZyb21FdWxlcigpIG5vdyBleHBlY3RzIGEgRXVsZXIgcm90YXRpb24gcmF0aGVyIHRoYW4gYSBWZWN0b3IzIGFuZCBvcmRlci4nICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdC8vIGh0dHA6Ly93d3cubWF0aHdvcmtzLmNvbS9tYXRsYWJjZW50cmFsL2ZpbGVleGNoYW5nZS9cbiAgICBcdFx0Ly8gXHQyMDY5Ni1mdW5jdGlvbi10by1jb252ZXJ0LWJldHdlZW4tZGNtLWV1bGVyLWFuZ2xlcy1xdWF0ZXJuaW9ucy1hbmQtZXVsZXItdmVjdG9ycy9cbiAgICBcdFx0Ly9cdGNvbnRlbnQvU3BpbkNhbGMubVxuXG4gICAgXHRcdHZhciBjMSA9IE1hdGguY29zKCBldWxlci5feCAvIDIgKTtcbiAgICBcdFx0dmFyIGMyID0gTWF0aC5jb3MoIGV1bGVyLl95IC8gMiApO1xuICAgIFx0XHR2YXIgYzMgPSBNYXRoLmNvcyggZXVsZXIuX3ogLyAyICk7XG4gICAgXHRcdHZhciBzMSA9IE1hdGguc2luKCBldWxlci5feCAvIDIgKTtcbiAgICBcdFx0dmFyIHMyID0gTWF0aC5zaW4oIGV1bGVyLl95IC8gMiApO1xuICAgIFx0XHR2YXIgczMgPSBNYXRoLnNpbiggZXVsZXIuX3ogLyAyICk7XG5cbiAgICBcdFx0dmFyIG9yZGVyID0gZXVsZXIub3JkZXI7XG5cbiAgICBcdFx0aWYgKCBvcmRlciA9PT0gJ1hZWicgKSB7XG5cbiAgICBcdFx0XHR0aGlzLl94ID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzO1xuICAgIFx0XHRcdHRoaXMuX3kgPSBjMSAqIHMyICogYzMgLSBzMSAqIGMyICogczM7XG4gICAgXHRcdFx0dGhpcy5feiA9IGMxICogYzIgKiBzMyArIHMxICogczIgKiBjMztcbiAgICBcdFx0XHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzIC0gczEgKiBzMiAqIHMzO1xuXG4gICAgXHRcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWVhaJyApIHtcblxuICAgIFx0XHRcdHRoaXMuX3ggPSBzMSAqIGMyICogYzMgKyBjMSAqIHMyICogczM7XG4gICAgXHRcdFx0dGhpcy5feSA9IGMxICogczIgKiBjMyAtIHMxICogYzIgKiBzMztcbiAgICBcdFx0XHR0aGlzLl96ID0gYzEgKiBjMiAqIHMzIC0gczEgKiBzMiAqIGMzO1xuICAgIFx0XHRcdHRoaXMuX3cgPSBjMSAqIGMyICogYzMgKyBzMSAqIHMyICogczM7XG5cbiAgICBcdFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdaWFknICkge1xuXG4gICAgXHRcdFx0dGhpcy5feCA9IHMxICogYzIgKiBjMyAtIGMxICogczIgKiBzMztcbiAgICBcdFx0XHR0aGlzLl95ID0gYzEgKiBzMiAqIGMzICsgczEgKiBjMiAqIHMzO1xuICAgIFx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgKyBzMSAqIHMyICogYzM7XG4gICAgXHRcdFx0dGhpcy5fdyA9IGMxICogYzIgKiBjMyAtIHMxICogczIgKiBzMztcblxuICAgIFx0XHR9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1pZWCcgKSB7XG5cbiAgICBcdFx0XHR0aGlzLl94ID0gczEgKiBjMiAqIGMzIC0gYzEgKiBzMiAqIHMzO1xuICAgIFx0XHRcdHRoaXMuX3kgPSBjMSAqIHMyICogYzMgKyBzMSAqIGMyICogczM7XG4gICAgXHRcdFx0dGhpcy5feiA9IGMxICogYzIgKiBzMyAtIHMxICogczIgKiBjMztcbiAgICBcdFx0XHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzICsgczEgKiBzMiAqIHMzO1xuXG4gICAgXHRcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWVpYJyApIHtcblxuICAgIFx0XHRcdHRoaXMuX3ggPSBzMSAqIGMyICogYzMgKyBjMSAqIHMyICogczM7XG4gICAgXHRcdFx0dGhpcy5feSA9IGMxICogczIgKiBjMyArIHMxICogYzIgKiBzMztcbiAgICBcdFx0XHR0aGlzLl96ID0gYzEgKiBjMiAqIHMzIC0gczEgKiBzMiAqIGMzO1xuICAgIFx0XHRcdHRoaXMuX3cgPSBjMSAqIGMyICogYzMgLSBzMSAqIHMyICogczM7XG5cbiAgICBcdFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdYWlknICkge1xuXG4gICAgXHRcdFx0dGhpcy5feCA9IHMxICogYzIgKiBjMyAtIGMxICogczIgKiBzMztcbiAgICBcdFx0XHR0aGlzLl95ID0gYzEgKiBzMiAqIGMzIC0gczEgKiBjMiAqIHMzO1xuICAgIFx0XHRcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgKyBzMSAqIHMyICogYzM7XG4gICAgXHRcdFx0dGhpcy5fdyA9IGMxICogYzIgKiBjMyArIHMxICogczIgKiBzMztcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0aWYgKCB1cGRhdGUgIT09IGZhbHNlICkgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldEZyb21BeGlzQW5nbGU6IGZ1bmN0aW9uICggYXhpcywgYW5nbGUgKSB7XG5cbiAgICBcdFx0Ly8gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvZ2VvbWV0cnkvcm90YXRpb25zL2NvbnZlcnNpb25zL2FuZ2xlVG9RdWF0ZXJuaW9uL2luZGV4Lmh0bVxuXG4gICAgXHRcdC8vIGFzc3VtZXMgYXhpcyBpcyBub3JtYWxpemVkXG5cbiAgICBcdFx0dmFyIGhhbGZBbmdsZSA9IGFuZ2xlIC8gMiwgcyA9IE1hdGguc2luKCBoYWxmQW5nbGUgKTtcblxuICAgIFx0XHR0aGlzLl94ID0gYXhpcy54ICogcztcbiAgICBcdFx0dGhpcy5feSA9IGF4aXMueSAqIHM7XG4gICAgXHRcdHRoaXMuX3ogPSBheGlzLnogKiBzO1xuICAgIFx0XHR0aGlzLl93ID0gTWF0aC5jb3MoIGhhbGZBbmdsZSApO1xuXG4gICAgXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRzZXRGcm9tUm90YXRpb25NYXRyaXg6IGZ1bmN0aW9uICggbSApIHtcblxuICAgIFx0XHQvLyBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9nZW9tZXRyeS9yb3RhdGlvbnMvY29udmVyc2lvbnMvbWF0cml4VG9RdWF0ZXJuaW9uL2luZGV4Lmh0bVxuXG4gICAgXHRcdC8vIGFzc3VtZXMgdGhlIHVwcGVyIDN4MyBvZiBtIGlzIGEgcHVyZSByb3RhdGlvbiBtYXRyaXggKGkuZSwgdW5zY2FsZWQpXG5cbiAgICBcdFx0dmFyIHRlID0gbS5lbGVtZW50cyxcblxuICAgIFx0XHRcdG0xMSA9IHRlWyAwIF0sIG0xMiA9IHRlWyA0IF0sIG0xMyA9IHRlWyA4IF0sXG4gICAgXHRcdFx0bTIxID0gdGVbIDEgXSwgbTIyID0gdGVbIDUgXSwgbTIzID0gdGVbIDkgXSxcbiAgICBcdFx0XHRtMzEgPSB0ZVsgMiBdLCBtMzIgPSB0ZVsgNiBdLCBtMzMgPSB0ZVsgMTAgXSxcblxuICAgIFx0XHRcdHRyYWNlID0gbTExICsgbTIyICsgbTMzLFxuICAgIFx0XHRcdHM7XG5cbiAgICBcdFx0aWYgKCB0cmFjZSA+IDAgKSB7XG5cbiAgICBcdFx0XHRzID0gMC41IC8gTWF0aC5zcXJ0KCB0cmFjZSArIDEuMCApO1xuXG4gICAgXHRcdFx0dGhpcy5fdyA9IDAuMjUgLyBzO1xuICAgIFx0XHRcdHRoaXMuX3ggPSAoIG0zMiAtIG0yMyApICogcztcbiAgICBcdFx0XHR0aGlzLl95ID0gKCBtMTMgLSBtMzEgKSAqIHM7XG4gICAgXHRcdFx0dGhpcy5feiA9ICggbTIxIC0gbTEyICkgKiBzO1xuXG4gICAgXHRcdH0gZWxzZSBpZiAoIG0xMSA+IG0yMiAmJiBtMTEgPiBtMzMgKSB7XG5cbiAgICBcdFx0XHRzID0gMi4wICogTWF0aC5zcXJ0KCAxLjAgKyBtMTEgLSBtMjIgLSBtMzMgKTtcblxuICAgIFx0XHRcdHRoaXMuX3cgPSAoIG0zMiAtIG0yMyApIC8gcztcbiAgICBcdFx0XHR0aGlzLl94ID0gMC4yNSAqIHM7XG4gICAgXHRcdFx0dGhpcy5feSA9ICggbTEyICsgbTIxICkgLyBzO1xuICAgIFx0XHRcdHRoaXMuX3ogPSAoIG0xMyArIG0zMSApIC8gcztcblxuICAgIFx0XHR9IGVsc2UgaWYgKCBtMjIgPiBtMzMgKSB7XG5cbiAgICBcdFx0XHRzID0gMi4wICogTWF0aC5zcXJ0KCAxLjAgKyBtMjIgLSBtMTEgLSBtMzMgKTtcblxuICAgIFx0XHRcdHRoaXMuX3cgPSAoIG0xMyAtIG0zMSApIC8gcztcbiAgICBcdFx0XHR0aGlzLl94ID0gKCBtMTIgKyBtMjEgKSAvIHM7XG4gICAgXHRcdFx0dGhpcy5feSA9IDAuMjUgKiBzO1xuICAgIFx0XHRcdHRoaXMuX3ogPSAoIG0yMyArIG0zMiApIC8gcztcblxuICAgIFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0cyA9IDIuMCAqIE1hdGguc3FydCggMS4wICsgbTMzIC0gbTExIC0gbTIyICk7XG5cbiAgICBcdFx0XHR0aGlzLl93ID0gKCBtMjEgLSBtMTIgKSAvIHM7XG4gICAgXHRcdFx0dGhpcy5feCA9ICggbTEzICsgbTMxICkgLyBzO1xuICAgIFx0XHRcdHRoaXMuX3kgPSAoIG0yMyArIG0zMiApIC8gcztcbiAgICBcdFx0XHR0aGlzLl96ID0gMC4yNSAqIHM7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRzZXRGcm9tVW5pdFZlY3RvcnM6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHQvLyBodHRwOi8vbG9sZW5naW5lLm5ldC9ibG9nLzIwMTQvMDIvMjQvcXVhdGVybmlvbi1mcm9tLXR3by12ZWN0b3JzLWZpbmFsXG5cbiAgICBcdFx0Ly8gYXNzdW1lcyBkaXJlY3Rpb24gdmVjdG9ycyB2RnJvbSBhbmQgdlRvIGFyZSBub3JtYWxpemVkXG5cbiAgICBcdFx0dmFyIHYxLCByO1xuXG4gICAgXHRcdHZhciBFUFMgPSAwLjAwMDAwMTtcblxuICAgIFx0XHRyZXR1cm4gZnVuY3Rpb24gc2V0RnJvbVVuaXRWZWN0b3JzKCB2RnJvbSwgdlRvICkge1xuXG4gICAgXHRcdFx0aWYgKCB2MSA9PT0gdW5kZWZpbmVkICkgdjEgPSBuZXcgVmVjdG9yMygpO1xuXG4gICAgXHRcdFx0ciA9IHZGcm9tLmRvdCggdlRvICkgKyAxO1xuXG4gICAgXHRcdFx0aWYgKCByIDwgRVBTICkge1xuXG4gICAgXHRcdFx0XHRyID0gMDtcblxuICAgIFx0XHRcdFx0aWYgKCBNYXRoLmFicyggdkZyb20ueCApID4gTWF0aC5hYnMoIHZGcm9tLnogKSApIHtcblxuICAgIFx0XHRcdFx0XHR2MS5zZXQoIC0gdkZyb20ueSwgdkZyb20ueCwgMCApO1xuXG4gICAgXHRcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHRcdHYxLnNldCggMCwgLSB2RnJvbS56LCB2RnJvbS55ICk7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdHYxLmNyb3NzVmVjdG9ycyggdkZyb20sIHZUbyApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0dGhpcy5feCA9IHYxLng7XG4gICAgXHRcdFx0dGhpcy5feSA9IHYxLnk7XG4gICAgXHRcdFx0dGhpcy5feiA9IHYxLno7XG4gICAgXHRcdFx0dGhpcy5fdyA9IHI7XG5cbiAgICBcdFx0XHRyZXR1cm4gdGhpcy5ub3JtYWxpemUoKTtcblxuICAgIFx0XHR9O1xuXG4gICAgXHR9KCksXG5cbiAgICBcdGludmVyc2U6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHRyZXR1cm4gdGhpcy5jb25qdWdhdGUoKS5ub3JtYWxpemUoKTtcblxuICAgIFx0fSxcblxuICAgIFx0Y29uanVnYXRlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dGhpcy5feCAqPSAtIDE7XG4gICAgXHRcdHRoaXMuX3kgKj0gLSAxO1xuICAgIFx0XHR0aGlzLl96ICo9IC0gMTtcblxuICAgIFx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0ZG90OiBmdW5jdGlvbiAoIHYgKSB7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMuX3ggKiB2Ll94ICsgdGhpcy5feSAqIHYuX3kgKyB0aGlzLl96ICogdi5feiArIHRoaXMuX3cgKiB2Ll93O1xuXG4gICAgXHR9LFxuXG4gICAgXHRsZW5ndGhTcTogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHJldHVybiB0aGlzLl94ICogdGhpcy5feCArIHRoaXMuX3kgKiB0aGlzLl95ICsgdGhpcy5feiAqIHRoaXMuX3ogKyB0aGlzLl93ICogdGhpcy5fdztcblxuICAgIFx0fSxcblxuICAgIFx0bGVuZ3RoOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0cmV0dXJuIE1hdGguc3FydCggdGhpcy5feCAqIHRoaXMuX3ggKyB0aGlzLl95ICogdGhpcy5feSArIHRoaXMuX3ogKiB0aGlzLl96ICsgdGhpcy5fdyAqIHRoaXMuX3cgKTtcblxuICAgIFx0fSxcblxuICAgIFx0bm9ybWFsaXplOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dmFyIGwgPSB0aGlzLmxlbmd0aCgpO1xuXG4gICAgXHRcdGlmICggbCA9PT0gMCApIHtcblxuICAgIFx0XHRcdHRoaXMuX3ggPSAwO1xuICAgIFx0XHRcdHRoaXMuX3kgPSAwO1xuICAgIFx0XHRcdHRoaXMuX3ogPSAwO1xuICAgIFx0XHRcdHRoaXMuX3cgPSAxO1xuXG4gICAgXHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRsID0gMSAvIGw7XG5cbiAgICBcdFx0XHR0aGlzLl94ID0gdGhpcy5feCAqIGw7XG4gICAgXHRcdFx0dGhpcy5feSA9IHRoaXMuX3kgKiBsO1xuICAgIFx0XHRcdHRoaXMuX3ogPSB0aGlzLl96ICogbDtcbiAgICBcdFx0XHR0aGlzLl93ID0gdGhpcy5fdyAqIGw7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRtdWx0aXBseTogZnVuY3Rpb24gKCBxLCBwICkge1xuXG4gICAgXHRcdGlmICggcCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuUXVhdGVybmlvbjogLm11bHRpcGx5KCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAubXVsdGlwbHlRdWF0ZXJuaW9ucyggYSwgYiApIGluc3RlYWQuJyApO1xuICAgIFx0XHRcdHJldHVybiB0aGlzLm11bHRpcGx5UXVhdGVybmlvbnMoIHEsIHAgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlRdWF0ZXJuaW9ucyggdGhpcywgcSApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRwcmVtdWx0aXBseTogZnVuY3Rpb24gKCBxICkge1xuXG4gICAgXHRcdHJldHVybiB0aGlzLm11bHRpcGx5UXVhdGVybmlvbnMoIHEsIHRoaXMgKTtcblxuICAgIFx0fSxcblxuICAgIFx0bXVsdGlwbHlRdWF0ZXJuaW9uczogZnVuY3Rpb24gKCBhLCBiICkge1xuXG4gICAgXHRcdC8vIGZyb20gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvYWxnZWJyYS9yZWFsTm9ybWVkQWxnZWJyYS9xdWF0ZXJuaW9ucy9jb2RlL2luZGV4Lmh0bVxuXG4gICAgXHRcdHZhciBxYXggPSBhLl94LCBxYXkgPSBhLl95LCBxYXogPSBhLl96LCBxYXcgPSBhLl93O1xuICAgIFx0XHR2YXIgcWJ4ID0gYi5feCwgcWJ5ID0gYi5feSwgcWJ6ID0gYi5feiwgcWJ3ID0gYi5fdztcblxuICAgIFx0XHR0aGlzLl94ID0gcWF4ICogcWJ3ICsgcWF3ICogcWJ4ICsgcWF5ICogcWJ6IC0gcWF6ICogcWJ5O1xuICAgIFx0XHR0aGlzLl95ID0gcWF5ICogcWJ3ICsgcWF3ICogcWJ5ICsgcWF6ICogcWJ4IC0gcWF4ICogcWJ6O1xuICAgIFx0XHR0aGlzLl96ID0gcWF6ICogcWJ3ICsgcWF3ICogcWJ6ICsgcWF4ICogcWJ5IC0gcWF5ICogcWJ4O1xuICAgIFx0XHR0aGlzLl93ID0gcWF3ICogcWJ3IC0gcWF4ICogcWJ4IC0gcWF5ICogcWJ5IC0gcWF6ICogcWJ6O1xuXG4gICAgXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRzbGVycDogZnVuY3Rpb24gKCBxYiwgdCApIHtcblxuICAgIFx0XHRpZiAoIHQgPT09IDAgKSByZXR1cm4gdGhpcztcbiAgICBcdFx0aWYgKCB0ID09PSAxICkgcmV0dXJuIHRoaXMuY29weSggcWIgKTtcblxuICAgIFx0XHR2YXIgeCA9IHRoaXMuX3gsIHkgPSB0aGlzLl95LCB6ID0gdGhpcy5feiwgdyA9IHRoaXMuX3c7XG5cbiAgICBcdFx0Ly8gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvYWxnZWJyYS9yZWFsTm9ybWVkQWxnZWJyYS9xdWF0ZXJuaW9ucy9zbGVycC9cblxuICAgIFx0XHR2YXIgY29zSGFsZlRoZXRhID0gdyAqIHFiLl93ICsgeCAqIHFiLl94ICsgeSAqIHFiLl95ICsgeiAqIHFiLl96O1xuXG4gICAgXHRcdGlmICggY29zSGFsZlRoZXRhIDwgMCApIHtcblxuICAgIFx0XHRcdHRoaXMuX3cgPSAtIHFiLl93O1xuICAgIFx0XHRcdHRoaXMuX3ggPSAtIHFiLl94O1xuICAgIFx0XHRcdHRoaXMuX3kgPSAtIHFiLl95O1xuICAgIFx0XHRcdHRoaXMuX3ogPSAtIHFiLl96O1xuXG4gICAgXHRcdFx0Y29zSGFsZlRoZXRhID0gLSBjb3NIYWxmVGhldGE7XG5cbiAgICBcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdHRoaXMuY29weSggcWIgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0aWYgKCBjb3NIYWxmVGhldGEgPj0gMS4wICkge1xuXG4gICAgXHRcdFx0dGhpcy5fdyA9IHc7XG4gICAgXHRcdFx0dGhpcy5feCA9IHg7XG4gICAgXHRcdFx0dGhpcy5feSA9IHk7XG4gICAgXHRcdFx0dGhpcy5feiA9IHo7XG5cbiAgICBcdFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0dmFyIHNpbkhhbGZUaGV0YSA9IE1hdGguc3FydCggMS4wIC0gY29zSGFsZlRoZXRhICogY29zSGFsZlRoZXRhICk7XG5cbiAgICBcdFx0aWYgKCBNYXRoLmFicyggc2luSGFsZlRoZXRhICkgPCAwLjAwMSApIHtcblxuICAgIFx0XHRcdHRoaXMuX3cgPSAwLjUgKiAoIHcgKyB0aGlzLl93ICk7XG4gICAgXHRcdFx0dGhpcy5feCA9IDAuNSAqICggeCArIHRoaXMuX3ggKTtcbiAgICBcdFx0XHR0aGlzLl95ID0gMC41ICogKCB5ICsgdGhpcy5feSApO1xuICAgIFx0XHRcdHRoaXMuX3ogPSAwLjUgKiAoIHogKyB0aGlzLl96ICk7XG5cbiAgICBcdFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0dmFyIGhhbGZUaGV0YSA9IE1hdGguYXRhbjIoIHNpbkhhbGZUaGV0YSwgY29zSGFsZlRoZXRhICk7XG4gICAgXHRcdHZhciByYXRpb0EgPSBNYXRoLnNpbiggKCAxIC0gdCApICogaGFsZlRoZXRhICkgLyBzaW5IYWxmVGhldGEsXG4gICAgXHRcdHJhdGlvQiA9IE1hdGguc2luKCB0ICogaGFsZlRoZXRhICkgLyBzaW5IYWxmVGhldGE7XG5cbiAgICBcdFx0dGhpcy5fdyA9ICggdyAqIHJhdGlvQSArIHRoaXMuX3cgKiByYXRpb0IgKTtcbiAgICBcdFx0dGhpcy5feCA9ICggeCAqIHJhdGlvQSArIHRoaXMuX3ggKiByYXRpb0IgKTtcbiAgICBcdFx0dGhpcy5feSA9ICggeSAqIHJhdGlvQSArIHRoaXMuX3kgKiByYXRpb0IgKTtcbiAgICBcdFx0dGhpcy5feiA9ICggeiAqIHJhdGlvQSArIHRoaXMuX3ogKiByYXRpb0IgKTtcblxuICAgIFx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0ZXF1YWxzOiBmdW5jdGlvbiAoIHF1YXRlcm5pb24gKSB7XG5cbiAgICBcdFx0cmV0dXJuICggcXVhdGVybmlvbi5feCA9PT0gdGhpcy5feCApICYmICggcXVhdGVybmlvbi5feSA9PT0gdGhpcy5feSApICYmICggcXVhdGVybmlvbi5feiA9PT0gdGhpcy5feiApICYmICggcXVhdGVybmlvbi5fdyA9PT0gdGhpcy5fdyApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRmcm9tQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcblxuICAgIFx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuICAgIFx0XHR0aGlzLl94ID0gYXJyYXlbIG9mZnNldCBdO1xuICAgIFx0XHR0aGlzLl95ID0gYXJyYXlbIG9mZnNldCArIDEgXTtcbiAgICBcdFx0dGhpcy5feiA9IGFycmF5WyBvZmZzZXQgKyAyIF07XG4gICAgXHRcdHRoaXMuX3cgPSBhcnJheVsgb2Zmc2V0ICsgMyBdO1xuXG4gICAgXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHR0b0FycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XG5cbiAgICBcdFx0aWYgKCBhcnJheSA9PT0gdW5kZWZpbmVkICkgYXJyYXkgPSBbXTtcbiAgICBcdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cbiAgICBcdFx0YXJyYXlbIG9mZnNldCBdID0gdGhpcy5feDtcbiAgICBcdFx0YXJyYXlbIG9mZnNldCArIDEgXSA9IHRoaXMuX3k7XG4gICAgXHRcdGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0aGlzLl96O1xuICAgIFx0XHRhcnJheVsgb2Zmc2V0ICsgMyBdID0gdGhpcy5fdztcblxuICAgIFx0XHRyZXR1cm4gYXJyYXk7XG5cbiAgICBcdH0sXG5cbiAgICBcdG9uQ2hhbmdlOiBmdW5jdGlvbiAoIGNhbGxiYWNrICkge1xuXG4gICAgXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjayA9IGNhbGxiYWNrO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRvbkNoYW5nZUNhbGxiYWNrOiBmdW5jdGlvbiAoKSB7fVxuXG4gICAgfTtcblxuICAgIE9iamVjdC5hc3NpZ24oIFF1YXRlcm5pb24sIHtcblxuICAgIFx0c2xlcnA6IGZ1bmN0aW9uKCBxYSwgcWIsIHFtLCB0ICkge1xuXG4gICAgXHRcdHJldHVybiBxbS5jb3B5KCBxYSApLnNsZXJwKCBxYiwgdCApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRzbGVycEZsYXQ6IGZ1bmN0aW9uKFxuICAgIFx0XHRcdGRzdCwgZHN0T2Zmc2V0LCBzcmMwLCBzcmNPZmZzZXQwLCBzcmMxLCBzcmNPZmZzZXQxLCB0ICkge1xuXG4gICAgXHRcdC8vIGZ1enotZnJlZSwgYXJyYXktYmFzZWQgUXVhdGVybmlvbiBTTEVSUCBvcGVyYXRpb25cblxuICAgIFx0XHR2YXIgeDAgPSBzcmMwWyBzcmNPZmZzZXQwICsgMCBdLFxuICAgIFx0XHRcdHkwID0gc3JjMFsgc3JjT2Zmc2V0MCArIDEgXSxcbiAgICBcdFx0XHR6MCA9IHNyYzBbIHNyY09mZnNldDAgKyAyIF0sXG4gICAgXHRcdFx0dzAgPSBzcmMwWyBzcmNPZmZzZXQwICsgMyBdLFxuXG4gICAgXHRcdFx0eDEgPSBzcmMxWyBzcmNPZmZzZXQxICsgMCBdLFxuICAgIFx0XHRcdHkxID0gc3JjMVsgc3JjT2Zmc2V0MSArIDEgXSxcbiAgICBcdFx0XHR6MSA9IHNyYzFbIHNyY09mZnNldDEgKyAyIF0sXG4gICAgXHRcdFx0dzEgPSBzcmMxWyBzcmNPZmZzZXQxICsgMyBdO1xuXG4gICAgXHRcdGlmICggdzAgIT09IHcxIHx8IHgwICE9PSB4MSB8fCB5MCAhPT0geTEgfHwgejAgIT09IHoxICkge1xuXG4gICAgXHRcdFx0dmFyIHMgPSAxIC0gdCxcblxuICAgIFx0XHRcdFx0Y29zID0geDAgKiB4MSArIHkwICogeTEgKyB6MCAqIHoxICsgdzAgKiB3MSxcblxuICAgIFx0XHRcdFx0ZGlyID0gKCBjb3MgPj0gMCA/IDEgOiAtIDEgKSxcbiAgICBcdFx0XHRcdHNxclNpbiA9IDEgLSBjb3MgKiBjb3M7XG5cbiAgICBcdFx0XHQvLyBTa2lwIHRoZSBTbGVycCBmb3IgdGlueSBzdGVwcyB0byBhdm9pZCBudW1lcmljIHByb2JsZW1zOlxuICAgIFx0XHRcdGlmICggc3FyU2luID4gTnVtYmVyLkVQU0lMT04gKSB7XG5cbiAgICBcdFx0XHRcdHZhciBzaW4gPSBNYXRoLnNxcnQoIHNxclNpbiApLFxuICAgIFx0XHRcdFx0XHRsZW4gPSBNYXRoLmF0YW4yKCBzaW4sIGNvcyAqIGRpciApO1xuXG4gICAgXHRcdFx0XHRzID0gTWF0aC5zaW4oIHMgKiBsZW4gKSAvIHNpbjtcbiAgICBcdFx0XHRcdHQgPSBNYXRoLnNpbiggdCAqIGxlbiApIC8gc2luO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0dmFyIHREaXIgPSB0ICogZGlyO1xuXG4gICAgXHRcdFx0eDAgPSB4MCAqIHMgKyB4MSAqIHREaXI7XG4gICAgXHRcdFx0eTAgPSB5MCAqIHMgKyB5MSAqIHREaXI7XG4gICAgXHRcdFx0ejAgPSB6MCAqIHMgKyB6MSAqIHREaXI7XG4gICAgXHRcdFx0dzAgPSB3MCAqIHMgKyB3MSAqIHREaXI7XG5cbiAgICBcdFx0XHQvLyBOb3JtYWxpemUgaW4gY2FzZSB3ZSBqdXN0IGRpZCBhIGxlcnA6XG4gICAgXHRcdFx0aWYgKCBzID09PSAxIC0gdCApIHtcblxuICAgIFx0XHRcdFx0dmFyIGYgPSAxIC8gTWF0aC5zcXJ0KCB4MCAqIHgwICsgeTAgKiB5MCArIHowICogejAgKyB3MCAqIHcwICk7XG5cbiAgICBcdFx0XHRcdHgwICo9IGY7XG4gICAgXHRcdFx0XHR5MCAqPSBmO1xuICAgIFx0XHRcdFx0ejAgKj0gZjtcbiAgICBcdFx0XHRcdHcwICo9IGY7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGRzdFsgZHN0T2Zmc2V0IF0gPSB4MDtcbiAgICBcdFx0ZHN0WyBkc3RPZmZzZXQgKyAxIF0gPSB5MDtcbiAgICBcdFx0ZHN0WyBkc3RPZmZzZXQgKyAyIF0gPSB6MDtcbiAgICBcdFx0ZHN0WyBkc3RPZmZzZXQgKyAzIF0gPSB3MDtcblxuICAgIFx0fVxuXG4gICAgfSApO1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAgICAgKiBAYXV0aG9yICpraWxlIC8gaHR0cDovL2tpbGUuc3RyYXZhZ2FuemEub3JnL1xuICAgICAqIEBhdXRob3IgcGhpbG9nYiAvIGh0dHA6Ly9ibG9nLnRoZWppdC5vcmcvXG4gICAgICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAgICAgKiBAYXV0aG9yIGVncmFldGhlciAvIGh0dHA6Ly9lZ3JhZXRoZXIuY29tL1xuICAgICAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gVmVjdG9yMyggeCwgeSwgeiApIHtcblxuICAgIFx0dGhpcy54ID0geCB8fCAwO1xuICAgIFx0dGhpcy55ID0geSB8fCAwO1xuICAgIFx0dGhpcy56ID0geiB8fCAwO1xuXG4gICAgfVxuXG4gICAgVmVjdG9yMy5wcm90b3R5cGUgPSB7XG5cbiAgICBcdGNvbnN0cnVjdG9yOiBWZWN0b3IzLFxuXG4gICAgXHRpc1ZlY3RvcjM6IHRydWUsXG5cbiAgICBcdHNldDogZnVuY3Rpb24gKCB4LCB5LCB6ICkge1xuXG4gICAgXHRcdHRoaXMueCA9IHg7XG4gICAgXHRcdHRoaXMueSA9IHk7XG4gICAgXHRcdHRoaXMueiA9IHo7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldFNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XG5cbiAgICBcdFx0dGhpcy54ID0gc2NhbGFyO1xuICAgIFx0XHR0aGlzLnkgPSBzY2FsYXI7XG4gICAgXHRcdHRoaXMueiA9IHNjYWxhcjtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0c2V0WDogZnVuY3Rpb24gKCB4ICkge1xuXG4gICAgXHRcdHRoaXMueCA9IHg7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldFk6IGZ1bmN0aW9uICggeSApIHtcblxuICAgIFx0XHR0aGlzLnkgPSB5O1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRzZXRaOiBmdW5jdGlvbiAoIHogKSB7XG5cbiAgICBcdFx0dGhpcy56ID0gejtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0c2V0Q29tcG9uZW50OiBmdW5jdGlvbiAoIGluZGV4LCB2YWx1ZSApIHtcblxuICAgIFx0XHRzd2l0Y2ggKCBpbmRleCApIHtcblxuICAgIFx0XHRcdGNhc2UgMDogdGhpcy54ID0gdmFsdWU7IGJyZWFrO1xuICAgIFx0XHRcdGNhc2UgMTogdGhpcy55ID0gdmFsdWU7IGJyZWFrO1xuICAgIFx0XHRcdGNhc2UgMjogdGhpcy56ID0gdmFsdWU7IGJyZWFrO1xuICAgIFx0XHRcdGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvciggJ2luZGV4IGlzIG91dCBvZiByYW5nZTogJyArIGluZGV4ICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9LFxuXG4gICAgXHRnZXRDb21wb25lbnQ6IGZ1bmN0aW9uICggaW5kZXggKSB7XG5cbiAgICBcdFx0c3dpdGNoICggaW5kZXggKSB7XG5cbiAgICBcdFx0XHRjYXNlIDA6IHJldHVybiB0aGlzLng7XG4gICAgXHRcdFx0Y2FzZSAxOiByZXR1cm4gdGhpcy55O1xuICAgIFx0XHRcdGNhc2UgMjogcmV0dXJuIHRoaXMuejtcbiAgICBcdFx0XHRkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoICdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0fSxcblxuICAgIFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMueCwgdGhpcy55LCB0aGlzLnogKTtcblxuICAgIFx0fSxcblxuICAgIFx0Y29weTogZnVuY3Rpb24gKCB2ICkge1xuXG4gICAgXHRcdHRoaXMueCA9IHYueDtcbiAgICBcdFx0dGhpcy55ID0gdi55O1xuICAgIFx0XHR0aGlzLnogPSB2Lno7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGFkZDogZnVuY3Rpb24gKCB2LCB3ICkge1xuXG4gICAgXHRcdGlmICggdyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogLmFkZCgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLmFkZFZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcbiAgICBcdFx0XHRyZXR1cm4gdGhpcy5hZGRWZWN0b3JzKCB2LCB3ICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHRoaXMueCArPSB2Lng7XG4gICAgXHRcdHRoaXMueSArPSB2Lnk7XG4gICAgXHRcdHRoaXMueiArPSB2Lno7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGFkZFNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xuXG4gICAgXHRcdHRoaXMueCArPSBzO1xuICAgIFx0XHR0aGlzLnkgKz0gcztcbiAgICBcdFx0dGhpcy56ICs9IHM7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGFkZFZlY3RvcnM6IGZ1bmN0aW9uICggYSwgYiApIHtcblxuICAgIFx0XHR0aGlzLnggPSBhLnggKyBiLng7XG4gICAgXHRcdHRoaXMueSA9IGEueSArIGIueTtcbiAgICBcdFx0dGhpcy56ID0gYS56ICsgYi56O1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRhZGRTY2FsZWRWZWN0b3I6IGZ1bmN0aW9uICggdiwgcyApIHtcblxuICAgIFx0XHR0aGlzLnggKz0gdi54ICogcztcbiAgICBcdFx0dGhpcy55ICs9IHYueSAqIHM7XG4gICAgXHRcdHRoaXMueiArPSB2LnogKiBzO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRzdWI6IGZ1bmN0aW9uICggdiwgdyApIHtcblxuICAgIFx0XHRpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjM6IC5zdWIoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5zdWJWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nICk7XG4gICAgXHRcdFx0cmV0dXJuIHRoaXMuc3ViVmVjdG9ycyggdiwgdyApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHR0aGlzLnggLT0gdi54O1xuICAgIFx0XHR0aGlzLnkgLT0gdi55O1xuICAgIFx0XHR0aGlzLnogLT0gdi56O1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRzdWJTY2FsYXI6IGZ1bmN0aW9uICggcyApIHtcblxuICAgIFx0XHR0aGlzLnggLT0gcztcbiAgICBcdFx0dGhpcy55IC09IHM7XG4gICAgXHRcdHRoaXMueiAtPSBzO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRzdWJWZWN0b3JzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XG5cbiAgICBcdFx0dGhpcy54ID0gYS54IC0gYi54O1xuICAgIFx0XHR0aGlzLnkgPSBhLnkgLSBiLnk7XG4gICAgXHRcdHRoaXMueiA9IGEueiAtIGIuejtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0bXVsdGlwbHk6IGZ1bmN0aW9uICggdiwgdyApIHtcblxuICAgIFx0XHRpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjM6IC5tdWx0aXBseSgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLm11bHRpcGx5VmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyApO1xuICAgIFx0XHRcdHJldHVybiB0aGlzLm11bHRpcGx5VmVjdG9ycyggdiwgdyApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHR0aGlzLnggKj0gdi54O1xuICAgIFx0XHR0aGlzLnkgKj0gdi55O1xuICAgIFx0XHR0aGlzLnogKj0gdi56O1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRtdWx0aXBseVNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XG5cbiAgICBcdFx0aWYgKCBpc0Zpbml0ZSggc2NhbGFyICkgKSB7XG5cbiAgICBcdFx0XHR0aGlzLnggKj0gc2NhbGFyO1xuICAgIFx0XHRcdHRoaXMueSAqPSBzY2FsYXI7XG4gICAgXHRcdFx0dGhpcy56ICo9IHNjYWxhcjtcblxuICAgIFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0dGhpcy54ID0gMDtcbiAgICBcdFx0XHR0aGlzLnkgPSAwO1xuICAgIFx0XHRcdHRoaXMueiA9IDA7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRtdWx0aXBseVZlY3RvcnM6IGZ1bmN0aW9uICggYSwgYiApIHtcblxuICAgIFx0XHR0aGlzLnggPSBhLnggKiBiLng7XG4gICAgXHRcdHRoaXMueSA9IGEueSAqIGIueTtcbiAgICBcdFx0dGhpcy56ID0gYS56ICogYi56O1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRhcHBseUV1bGVyOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dmFyIHF1YXRlcm5pb247XG5cbiAgICBcdFx0cmV0dXJuIGZ1bmN0aW9uIGFwcGx5RXVsZXIoIGV1bGVyICkge1xuXG4gICAgXHRcdFx0aWYgKCAoZXVsZXIgJiYgZXVsZXIuaXNFdWxlcikgPT09IGZhbHNlICkge1xuXG4gICAgXHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuVmVjdG9yMzogLmFwcGx5RXVsZXIoKSBub3cgZXhwZWN0cyBhbiBFdWxlciByb3RhdGlvbiByYXRoZXIgdGhhbiBhIFZlY3RvcjMgYW5kIG9yZGVyLicgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdGlmICggcXVhdGVybmlvbiA9PT0gdW5kZWZpbmVkICkgcXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XG5cbiAgICBcdFx0XHRyZXR1cm4gdGhpcy5hcHBseVF1YXRlcm5pb24oIHF1YXRlcm5pb24uc2V0RnJvbUV1bGVyKCBldWxlciApICk7XG5cbiAgICBcdFx0fTtcblxuICAgIFx0fSgpLFxuXG4gICAgXHRhcHBseUF4aXNBbmdsZTogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHZhciBxdWF0ZXJuaW9uO1xuXG4gICAgXHRcdHJldHVybiBmdW5jdGlvbiBhcHBseUF4aXNBbmdsZSggYXhpcywgYW5nbGUgKSB7XG5cbiAgICBcdFx0XHRpZiAoIHF1YXRlcm5pb24gPT09IHVuZGVmaW5lZCApIHF1YXRlcm5pb24gPSBuZXcgUXVhdGVybmlvbigpO1xuXG4gICAgXHRcdFx0cmV0dXJuIHRoaXMuYXBwbHlRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uLnNldEZyb21BeGlzQW5nbGUoIGF4aXMsIGFuZ2xlICkgKTtcblxuICAgIFx0XHR9O1xuXG4gICAgXHR9KCksXG5cbiAgICBcdGFwcGx5TWF0cml4MzogZnVuY3Rpb24gKCBtICkge1xuXG4gICAgXHRcdHZhciB4ID0gdGhpcy54LCB5ID0gdGhpcy55LCB6ID0gdGhpcy56O1xuICAgIFx0XHR2YXIgZSA9IG0uZWxlbWVudHM7XG5cbiAgICBcdFx0dGhpcy54ID0gZVsgMCBdICogeCArIGVbIDMgXSAqIHkgKyBlWyA2IF0gKiB6O1xuICAgIFx0XHR0aGlzLnkgPSBlWyAxIF0gKiB4ICsgZVsgNCBdICogeSArIGVbIDcgXSAqIHo7XG4gICAgXHRcdHRoaXMueiA9IGVbIDIgXSAqIHggKyBlWyA1IF0gKiB5ICsgZVsgOCBdICogejtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0YXBwbHlNYXRyaXg0OiBmdW5jdGlvbiAoIG0gKSB7XG5cbiAgICBcdFx0Ly8gaW5wdXQ6IFRIUkVFLk1hdHJpeDQgYWZmaW5lIG1hdHJpeFxuXG4gICAgXHRcdHZhciB4ID0gdGhpcy54LCB5ID0gdGhpcy55LCB6ID0gdGhpcy56O1xuICAgIFx0XHR2YXIgZSA9IG0uZWxlbWVudHM7XG5cbiAgICBcdFx0dGhpcy54ID0gZVsgMCBdICogeCArIGVbIDQgXSAqIHkgKyBlWyA4IF0gICogeiArIGVbIDEyIF07XG4gICAgXHRcdHRoaXMueSA9IGVbIDEgXSAqIHggKyBlWyA1IF0gKiB5ICsgZVsgOSBdICAqIHogKyBlWyAxMyBdO1xuICAgIFx0XHR0aGlzLnogPSBlWyAyIF0gKiB4ICsgZVsgNiBdICogeSArIGVbIDEwIF0gKiB6ICsgZVsgMTQgXTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0YXBwbHlQcm9qZWN0aW9uOiBmdW5jdGlvbiAoIG0gKSB7XG5cbiAgICBcdFx0Ly8gaW5wdXQ6IFRIUkVFLk1hdHJpeDQgcHJvamVjdGlvbiBtYXRyaXhcblxuICAgIFx0XHR2YXIgeCA9IHRoaXMueCwgeSA9IHRoaXMueSwgeiA9IHRoaXMuejtcbiAgICBcdFx0dmFyIGUgPSBtLmVsZW1lbnRzO1xuICAgIFx0XHR2YXIgZCA9IDEgLyAoIGVbIDMgXSAqIHggKyBlWyA3IF0gKiB5ICsgZVsgMTEgXSAqIHogKyBlWyAxNSBdICk7IC8vIHBlcnNwZWN0aXZlIGRpdmlkZVxuXG4gICAgXHRcdHRoaXMueCA9ICggZVsgMCBdICogeCArIGVbIDQgXSAqIHkgKyBlWyA4IF0gICogeiArIGVbIDEyIF0gKSAqIGQ7XG4gICAgXHRcdHRoaXMueSA9ICggZVsgMSBdICogeCArIGVbIDUgXSAqIHkgKyBlWyA5IF0gICogeiArIGVbIDEzIF0gKSAqIGQ7XG4gICAgXHRcdHRoaXMueiA9ICggZVsgMiBdICogeCArIGVbIDYgXSAqIHkgKyBlWyAxMCBdICogeiArIGVbIDE0IF0gKSAqIGQ7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGFwcGx5UXVhdGVybmlvbjogZnVuY3Rpb24gKCBxICkge1xuXG4gICAgXHRcdHZhciB4ID0gdGhpcy54LCB5ID0gdGhpcy55LCB6ID0gdGhpcy56O1xuICAgIFx0XHR2YXIgcXggPSBxLngsIHF5ID0gcS55LCBxeiA9IHEueiwgcXcgPSBxLnc7XG5cbiAgICBcdFx0Ly8gY2FsY3VsYXRlIHF1YXQgKiB2ZWN0b3JcblxuICAgIFx0XHR2YXIgaXggPSAgcXcgKiB4ICsgcXkgKiB6IC0gcXogKiB5O1xuICAgIFx0XHR2YXIgaXkgPSAgcXcgKiB5ICsgcXogKiB4IC0gcXggKiB6O1xuICAgIFx0XHR2YXIgaXogPSAgcXcgKiB6ICsgcXggKiB5IC0gcXkgKiB4O1xuICAgIFx0XHR2YXIgaXcgPSAtIHF4ICogeCAtIHF5ICogeSAtIHF6ICogejtcblxuICAgIFx0XHQvLyBjYWxjdWxhdGUgcmVzdWx0ICogaW52ZXJzZSBxdWF0XG5cbiAgICBcdFx0dGhpcy54ID0gaXggKiBxdyArIGl3ICogLSBxeCArIGl5ICogLSBxeiAtIGl6ICogLSBxeTtcbiAgICBcdFx0dGhpcy55ID0gaXkgKiBxdyArIGl3ICogLSBxeSArIGl6ICogLSBxeCAtIGl4ICogLSBxejtcbiAgICBcdFx0dGhpcy56ID0gaXogKiBxdyArIGl3ICogLSBxeiArIGl4ICogLSBxeSAtIGl5ICogLSBxeDtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0cHJvamVjdDogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHZhciBtYXRyaXg7XG5cbiAgICBcdFx0cmV0dXJuIGZ1bmN0aW9uIHByb2plY3QoIGNhbWVyYSApIHtcblxuICAgIFx0XHRcdGlmICggbWF0cml4ID09PSB1bmRlZmluZWQgKSBtYXRyaXggPSBuZXcgTWF0cml4NCgpO1xuXG4gICAgXHRcdFx0bWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4LCBtYXRyaXguZ2V0SW52ZXJzZSggY2FtZXJhLm1hdHJpeFdvcmxkICkgKTtcbiAgICBcdFx0XHRyZXR1cm4gdGhpcy5hcHBseVByb2plY3Rpb24oIG1hdHJpeCApO1xuXG4gICAgXHRcdH07XG5cbiAgICBcdH0oKSxcblxuICAgIFx0dW5wcm9qZWN0OiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dmFyIG1hdHJpeDtcblxuICAgIFx0XHRyZXR1cm4gZnVuY3Rpb24gdW5wcm9qZWN0KCBjYW1lcmEgKSB7XG5cbiAgICBcdFx0XHRpZiAoIG1hdHJpeCA9PT0gdW5kZWZpbmVkICkgbWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcblxuICAgIFx0XHRcdG1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBjYW1lcmEubWF0cml4V29ybGQsIG1hdHJpeC5nZXRJbnZlcnNlKCBjYW1lcmEucHJvamVjdGlvbk1hdHJpeCApICk7XG4gICAgXHRcdFx0cmV0dXJuIHRoaXMuYXBwbHlQcm9qZWN0aW9uKCBtYXRyaXggKTtcblxuICAgIFx0XHR9O1xuXG4gICAgXHR9KCksXG5cbiAgICBcdHRyYW5zZm9ybURpcmVjdGlvbjogZnVuY3Rpb24gKCBtICkge1xuXG4gICAgXHRcdC8vIGlucHV0OiBUSFJFRS5NYXRyaXg0IGFmZmluZSBtYXRyaXhcbiAgICBcdFx0Ly8gdmVjdG9yIGludGVycHJldGVkIGFzIGEgZGlyZWN0aW9uXG5cbiAgICBcdFx0dmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLno7XG4gICAgXHRcdHZhciBlID0gbS5lbGVtZW50cztcblxuICAgIFx0XHR0aGlzLnggPSBlWyAwIF0gKiB4ICsgZVsgNCBdICogeSArIGVbIDggXSAgKiB6O1xuICAgIFx0XHR0aGlzLnkgPSBlWyAxIF0gKiB4ICsgZVsgNSBdICogeSArIGVbIDkgXSAgKiB6O1xuICAgIFx0XHR0aGlzLnogPSBlWyAyIF0gKiB4ICsgZVsgNiBdICogeSArIGVbIDEwIF0gKiB6O1xuXG4gICAgXHRcdHJldHVybiB0aGlzLm5vcm1hbGl6ZSgpO1xuXG4gICAgXHR9LFxuXG4gICAgXHRkaXZpZGU6IGZ1bmN0aW9uICggdiApIHtcblxuICAgIFx0XHR0aGlzLnggLz0gdi54O1xuICAgIFx0XHR0aGlzLnkgLz0gdi55O1xuICAgIFx0XHR0aGlzLnogLz0gdi56O1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRkaXZpZGVTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xuXG4gICAgXHRcdHJldHVybiB0aGlzLm11bHRpcGx5U2NhbGFyKCAxIC8gc2NhbGFyICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdG1pbjogZnVuY3Rpb24gKCB2ICkge1xuXG4gICAgXHRcdHRoaXMueCA9IE1hdGgubWluKCB0aGlzLngsIHYueCApO1xuICAgIFx0XHR0aGlzLnkgPSBNYXRoLm1pbiggdGhpcy55LCB2LnkgKTtcbiAgICBcdFx0dGhpcy56ID0gTWF0aC5taW4oIHRoaXMueiwgdi56ICk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdG1heDogZnVuY3Rpb24gKCB2ICkge1xuXG4gICAgXHRcdHRoaXMueCA9IE1hdGgubWF4KCB0aGlzLngsIHYueCApO1xuICAgIFx0XHR0aGlzLnkgPSBNYXRoLm1heCggdGhpcy55LCB2LnkgKTtcbiAgICBcdFx0dGhpcy56ID0gTWF0aC5tYXgoIHRoaXMueiwgdi56ICk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGNsYW1wOiBmdW5jdGlvbiAoIG1pbiwgbWF4ICkge1xuXG4gICAgXHRcdC8vIFRoaXMgZnVuY3Rpb24gYXNzdW1lcyBtaW4gPCBtYXgsIGlmIHRoaXMgYXNzdW1wdGlvbiBpc24ndCB0cnVlIGl0IHdpbGwgbm90IG9wZXJhdGUgY29ycmVjdGx5XG5cbiAgICBcdFx0dGhpcy54ID0gTWF0aC5tYXgoIG1pbi54LCBNYXRoLm1pbiggbWF4LngsIHRoaXMueCApICk7XG4gICAgXHRcdHRoaXMueSA9IE1hdGgubWF4KCBtaW4ueSwgTWF0aC5taW4oIG1heC55LCB0aGlzLnkgKSApO1xuICAgIFx0XHR0aGlzLnogPSBNYXRoLm1heCggbWluLnosIE1hdGgubWluKCBtYXgueiwgdGhpcy56ICkgKTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0Y2xhbXBTY2FsYXI6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR2YXIgbWluLCBtYXg7XG5cbiAgICBcdFx0cmV0dXJuIGZ1bmN0aW9uIGNsYW1wU2NhbGFyKCBtaW5WYWwsIG1heFZhbCApIHtcblxuICAgIFx0XHRcdGlmICggbWluID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRcdG1pbiA9IG5ldyBWZWN0b3IzKCk7XG4gICAgXHRcdFx0XHRtYXggPSBuZXcgVmVjdG9yMygpO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0bWluLnNldCggbWluVmFsLCBtaW5WYWwsIG1pblZhbCApO1xuICAgIFx0XHRcdG1heC5zZXQoIG1heFZhbCwgbWF4VmFsLCBtYXhWYWwgKTtcblxuICAgIFx0XHRcdHJldHVybiB0aGlzLmNsYW1wKCBtaW4sIG1heCApO1xuXG4gICAgXHRcdH07XG5cbiAgICBcdH0oKSxcblxuICAgIFx0Y2xhbXBMZW5ndGg6IGZ1bmN0aW9uICggbWluLCBtYXggKSB7XG5cbiAgICBcdFx0dmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoKCk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIoIE1hdGgubWF4KCBtaW4sIE1hdGgubWluKCBtYXgsIGxlbmd0aCApICkgLyBsZW5ndGggKTtcblxuICAgIFx0fSxcblxuICAgIFx0Zmxvb3I6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR0aGlzLnggPSBNYXRoLmZsb29yKCB0aGlzLnggKTtcbiAgICBcdFx0dGhpcy55ID0gTWF0aC5mbG9vciggdGhpcy55ICk7XG4gICAgXHRcdHRoaXMueiA9IE1hdGguZmxvb3IoIHRoaXMueiApO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRjZWlsOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dGhpcy54ID0gTWF0aC5jZWlsKCB0aGlzLnggKTtcbiAgICBcdFx0dGhpcy55ID0gTWF0aC5jZWlsKCB0aGlzLnkgKTtcbiAgICBcdFx0dGhpcy56ID0gTWF0aC5jZWlsKCB0aGlzLnogKTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0cm91bmQ6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR0aGlzLnggPSBNYXRoLnJvdW5kKCB0aGlzLnggKTtcbiAgICBcdFx0dGhpcy55ID0gTWF0aC5yb3VuZCggdGhpcy55ICk7XG4gICAgXHRcdHRoaXMueiA9IE1hdGgucm91bmQoIHRoaXMueiApO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRyb3VuZFRvWmVybzogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHRoaXMueCA9ICggdGhpcy54IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLnggKSA6IE1hdGguZmxvb3IoIHRoaXMueCApO1xuICAgIFx0XHR0aGlzLnkgPSAoIHRoaXMueSA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy55ICkgOiBNYXRoLmZsb29yKCB0aGlzLnkgKTtcbiAgICBcdFx0dGhpcy56ID0gKCB0aGlzLnogPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMueiApIDogTWF0aC5mbG9vciggdGhpcy56ICk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdG5lZ2F0ZTogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHRoaXMueCA9IC0gdGhpcy54O1xuICAgIFx0XHR0aGlzLnkgPSAtIHRoaXMueTtcbiAgICBcdFx0dGhpcy56ID0gLSB0aGlzLno7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGRvdDogZnVuY3Rpb24gKCB2ICkge1xuXG4gICAgXHRcdHJldHVybiB0aGlzLnggKiB2LnggKyB0aGlzLnkgKiB2LnkgKyB0aGlzLnogKiB2Lno7XG5cbiAgICBcdH0sXG5cbiAgICBcdGxlbmd0aFNxOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSArIHRoaXMueiAqIHRoaXMuejtcblxuICAgIFx0fSxcblxuICAgIFx0bGVuZ3RoOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0cmV0dXJuIE1hdGguc3FydCggdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICsgdGhpcy56ICogdGhpcy56ICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGxlbmd0aE1hbmhhdHRhbjogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHJldHVybiBNYXRoLmFicyggdGhpcy54ICkgKyBNYXRoLmFicyggdGhpcy55ICkgKyBNYXRoLmFicyggdGhpcy56ICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdG5vcm1hbGl6ZTogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHJldHVybiB0aGlzLmRpdmlkZVNjYWxhciggdGhpcy5sZW5ndGgoKSApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRzZXRMZW5ndGg6IGZ1bmN0aW9uICggbGVuZ3RoICkge1xuXG4gICAgXHRcdHJldHVybiB0aGlzLm11bHRpcGx5U2NhbGFyKCBsZW5ndGggLyB0aGlzLmxlbmd0aCgpICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGxlcnA6IGZ1bmN0aW9uICggdiwgYWxwaGEgKSB7XG5cbiAgICBcdFx0dGhpcy54ICs9ICggdi54IC0gdGhpcy54ICkgKiBhbHBoYTtcbiAgICBcdFx0dGhpcy55ICs9ICggdi55IC0gdGhpcy55ICkgKiBhbHBoYTtcbiAgICBcdFx0dGhpcy56ICs9ICggdi56IC0gdGhpcy56ICkgKiBhbHBoYTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0bGVycFZlY3RvcnM6IGZ1bmN0aW9uICggdjEsIHYyLCBhbHBoYSApIHtcblxuICAgIFx0XHRyZXR1cm4gdGhpcy5zdWJWZWN0b3JzKCB2MiwgdjEgKS5tdWx0aXBseVNjYWxhciggYWxwaGEgKS5hZGQoIHYxICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGNyb3NzOiBmdW5jdGlvbiAoIHYsIHcgKSB7XG5cbiAgICBcdFx0aWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IzOiAuY3Jvc3MoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5jcm9zc1ZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcbiAgICBcdFx0XHRyZXR1cm4gdGhpcy5jcm9zc1ZlY3RvcnMoIHYsIHcgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0dmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLno7XG5cbiAgICBcdFx0dGhpcy54ID0geSAqIHYueiAtIHogKiB2Lnk7XG4gICAgXHRcdHRoaXMueSA9IHogKiB2LnggLSB4ICogdi56O1xuICAgIFx0XHR0aGlzLnogPSB4ICogdi55IC0geSAqIHYueDtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0Y3Jvc3NWZWN0b3JzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XG5cbiAgICBcdFx0dmFyIGF4ID0gYS54LCBheSA9IGEueSwgYXogPSBhLno7XG4gICAgXHRcdHZhciBieCA9IGIueCwgYnkgPSBiLnksIGJ6ID0gYi56O1xuXG4gICAgXHRcdHRoaXMueCA9IGF5ICogYnogLSBheiAqIGJ5O1xuICAgIFx0XHR0aGlzLnkgPSBheiAqIGJ4IC0gYXggKiBiejtcbiAgICBcdFx0dGhpcy56ID0gYXggKiBieSAtIGF5ICogYng7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdHByb2plY3RPblZlY3RvcjogZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XG5cbiAgICBcdFx0dmFyIHNjYWxhciA9IHZlY3Rvci5kb3QoIHRoaXMgKSAvIHZlY3Rvci5sZW5ndGhTcSgpO1xuXG4gICAgXHRcdHJldHVybiB0aGlzLmNvcHkoIHZlY3RvciApLm11bHRpcGx5U2NhbGFyKCBzY2FsYXIgKTtcblxuICAgIFx0fSxcblxuICAgIFx0cHJvamVjdE9uUGxhbmU6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR2YXIgdjE7XG5cbiAgICBcdFx0cmV0dXJuIGZ1bmN0aW9uIHByb2plY3RPblBsYW5lKCBwbGFuZU5vcm1hbCApIHtcblxuICAgIFx0XHRcdGlmICggdjEgPT09IHVuZGVmaW5lZCApIHYxID0gbmV3IFZlY3RvcjMoKTtcblxuICAgIFx0XHRcdHYxLmNvcHkoIHRoaXMgKS5wcm9qZWN0T25WZWN0b3IoIHBsYW5lTm9ybWFsICk7XG5cbiAgICBcdFx0XHRyZXR1cm4gdGhpcy5zdWIoIHYxICk7XG5cbiAgICBcdFx0fTtcblxuICAgIFx0fSgpLFxuXG4gICAgXHRyZWZsZWN0OiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0Ly8gcmVmbGVjdCBpbmNpZGVudCB2ZWN0b3Igb2ZmIHBsYW5lIG9ydGhvZ29uYWwgdG8gbm9ybWFsXG4gICAgXHRcdC8vIG5vcm1hbCBpcyBhc3N1bWVkIHRvIGhhdmUgdW5pdCBsZW5ndGhcblxuICAgIFx0XHR2YXIgdjE7XG5cbiAgICBcdFx0cmV0dXJuIGZ1bmN0aW9uIHJlZmxlY3QoIG5vcm1hbCApIHtcblxuICAgIFx0XHRcdGlmICggdjEgPT09IHVuZGVmaW5lZCApIHYxID0gbmV3IFZlY3RvcjMoKTtcblxuICAgIFx0XHRcdHJldHVybiB0aGlzLnN1YiggdjEuY29weSggbm9ybWFsICkubXVsdGlwbHlTY2FsYXIoIDIgKiB0aGlzLmRvdCggbm9ybWFsICkgKSApO1xuXG4gICAgXHRcdH07XG5cbiAgICBcdH0oKSxcblxuICAgIFx0YW5nbGVUbzogZnVuY3Rpb24gKCB2ICkge1xuXG4gICAgXHRcdHZhciB0aGV0YSA9IHRoaXMuZG90KCB2ICkgLyAoIE1hdGguc3FydCggdGhpcy5sZW5ndGhTcSgpICogdi5sZW5ndGhTcSgpICkgKTtcblxuICAgIFx0XHQvLyBjbGFtcCwgdG8gaGFuZGxlIG51bWVyaWNhbCBwcm9ibGVtc1xuXG4gICAgXHRcdHJldHVybiBNYXRoLmFjb3MoIGV4cG9ydHMuTWF0aC5jbGFtcCggdGhldGEsIC0gMSwgMSApICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGRpc3RhbmNlVG86IGZ1bmN0aW9uICggdiApIHtcblxuICAgIFx0XHRyZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLmRpc3RhbmNlVG9TcXVhcmVkKCB2ICkgKTtcblxuICAgIFx0fSxcblxuICAgIFx0ZGlzdGFuY2VUb1NxdWFyZWQ6IGZ1bmN0aW9uICggdiApIHtcblxuICAgIFx0XHR2YXIgZHggPSB0aGlzLnggLSB2LngsIGR5ID0gdGhpcy55IC0gdi55LCBkeiA9IHRoaXMueiAtIHYuejtcblxuICAgIFx0XHRyZXR1cm4gZHggKiBkeCArIGR5ICogZHkgKyBkeiAqIGR6O1xuXG4gICAgXHR9LFxuXG4gICAgXHRkaXN0YW5jZVRvTWFuaGF0dGFuOiBmdW5jdGlvbiAoIHYgKSB7XG5cbiAgICBcdFx0cmV0dXJuIE1hdGguYWJzKCB0aGlzLnggLSB2LnggKSArIE1hdGguYWJzKCB0aGlzLnkgLSB2LnkgKSArIE1hdGguYWJzKCB0aGlzLnogLSB2LnogKTtcblxuICAgIFx0fSxcblxuICAgIFx0c2V0RnJvbVNwaGVyaWNhbDogZnVuY3Rpb24oIHMgKSB7XG5cbiAgICBcdFx0dmFyIHNpblBoaVJhZGl1cyA9IE1hdGguc2luKCBzLnBoaSApICogcy5yYWRpdXM7XG5cbiAgICBcdFx0dGhpcy54ID0gc2luUGhpUmFkaXVzICogTWF0aC5zaW4oIHMudGhldGEgKTtcbiAgICBcdFx0dGhpcy55ID0gTWF0aC5jb3MoIHMucGhpICkgKiBzLnJhZGl1cztcbiAgICBcdFx0dGhpcy56ID0gc2luUGhpUmFkaXVzICogTWF0aC5jb3MoIHMudGhldGEgKTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0c2V0RnJvbU1hdHJpeFBvc2l0aW9uOiBmdW5jdGlvbiAoIG0gKSB7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMuc2V0RnJvbU1hdHJpeENvbHVtbiggbSwgMyApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRzZXRGcm9tTWF0cml4U2NhbGU6IGZ1bmN0aW9uICggbSApIHtcblxuICAgIFx0XHR2YXIgc3ggPSB0aGlzLnNldEZyb21NYXRyaXhDb2x1bW4oIG0sIDAgKS5sZW5ndGgoKTtcbiAgICBcdFx0dmFyIHN5ID0gdGhpcy5zZXRGcm9tTWF0cml4Q29sdW1uKCBtLCAxICkubGVuZ3RoKCk7XG4gICAgXHRcdHZhciBzeiA9IHRoaXMuc2V0RnJvbU1hdHJpeENvbHVtbiggbSwgMiApLmxlbmd0aCgpO1xuXG4gICAgXHRcdHRoaXMueCA9IHN4O1xuICAgIFx0XHR0aGlzLnkgPSBzeTtcbiAgICBcdFx0dGhpcy56ID0gc3o7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldEZyb21NYXRyaXhDb2x1bW46IGZ1bmN0aW9uICggbSwgaW5kZXggKSB7XG5cbiAgICBcdFx0aWYgKCB0eXBlb2YgbSA9PT0gJ251bWJlcicgKSB7XG5cbiAgICBcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IzOiBzZXRGcm9tTWF0cml4Q29sdW1uIG5vdyBleHBlY3RzICggbWF0cml4LCBpbmRleCApLicgKTtcbiAgICBcdFx0XHR2YXIgdGVtcCA9IG1cbiAgICBcdFx0XHRtID0gaW5kZXg7XG4gICAgXHRcdFx0aW5kZXggPSB0ZW1wO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gdGhpcy5mcm9tQXJyYXkoIG0uZWxlbWVudHMsIGluZGV4ICogNCApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRlcXVhbHM6IGZ1bmN0aW9uICggdiApIHtcblxuICAgIFx0XHRyZXR1cm4gKCAoIHYueCA9PT0gdGhpcy54ICkgJiYgKCB2LnkgPT09IHRoaXMueSApICYmICggdi56ID09PSB0aGlzLnogKSApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRmcm9tQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcblxuICAgIFx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuICAgIFx0XHR0aGlzLnggPSBhcnJheVsgb2Zmc2V0IF07XG4gICAgXHRcdHRoaXMueSA9IGFycmF5WyBvZmZzZXQgKyAxIF07XG4gICAgXHRcdHRoaXMueiA9IGFycmF5WyBvZmZzZXQgKyAyIF07XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdHRvQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcblxuICAgIFx0XHRpZiAoIGFycmF5ID09PSB1bmRlZmluZWQgKSBhcnJheSA9IFtdO1xuICAgIFx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuICAgIFx0XHRhcnJheVsgb2Zmc2V0IF0gPSB0aGlzLng7XG4gICAgXHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0aGlzLnk7XG4gICAgXHRcdGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0aGlzLno7XG5cbiAgICBcdFx0cmV0dXJuIGFycmF5O1xuXG4gICAgXHR9LFxuXG4gICAgXHRmcm9tQXR0cmlidXRlOiBmdW5jdGlvbiAoIGF0dHJpYnV0ZSwgaW5kZXgsIG9mZnNldCApIHtcblxuICAgIFx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuICAgIFx0XHRpbmRleCA9IGluZGV4ICogYXR0cmlidXRlLml0ZW1TaXplICsgb2Zmc2V0O1xuXG4gICAgXHRcdHRoaXMueCA9IGF0dHJpYnV0ZS5hcnJheVsgaW5kZXggXTtcbiAgICBcdFx0dGhpcy55ID0gYXR0cmlidXRlLmFycmF5WyBpbmRleCArIDEgXTtcbiAgICBcdFx0dGhpcy56ID0gYXR0cmlidXRlLmFycmF5WyBpbmRleCArIDIgXTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fVxuXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gICAgICogQGF1dGhvciBzdXBlcmVnZ2JlcnQgLyBodHRwOi8vd3d3LnBhdWxicnVudC5jby51ay9cbiAgICAgKiBAYXV0aG9yIHBoaWxvZ2IgLyBodHRwOi8vYmxvZy50aGVqaXQub3JnL1xuICAgICAqIEBhdXRob3Igam9yZGlfcm9zIC8gaHR0cDovL3BsYXR0c29mdC5jb21cbiAgICAgKiBAYXV0aG9yIEQxcGxvMWQgLyBodHRwOi8vZ2l0aHViLmNvbS9EMXBsbzFkXG4gICAgICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAgICAgKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICAgICAqIEBhdXRob3IgdGlta25pcCAvIGh0dHA6Ly93d3cuZmxvb3JwbGFubmVyLmNvbS9cbiAgICAgKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXG4gICAgICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBNYXRyaXg0KCkge1xuXG4gICAgXHR0aGlzLmVsZW1lbnRzID0gbmV3IEZsb2F0MzJBcnJheSggW1xuXG4gICAgXHRcdDEsIDAsIDAsIDAsXG4gICAgXHRcdDAsIDEsIDAsIDAsXG4gICAgXHRcdDAsIDAsIDEsIDAsXG4gICAgXHRcdDAsIDAsIDAsIDFcblxuICAgIFx0XSApO1xuXG4gICAgXHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPiAwICkge1xuXG4gICAgXHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5NYXRyaXg0OiB0aGUgY29uc3RydWN0b3Igbm8gbG9uZ2VyIHJlYWRzIGFyZ3VtZW50cy4gdXNlIC5zZXQoKSBpbnN0ZWFkLicgKTtcblxuICAgIFx0fVxuXG4gICAgfVxuXG4gICAgTWF0cml4NC5wcm90b3R5cGUgPSB7XG5cbiAgICBcdGNvbnN0cnVjdG9yOiBNYXRyaXg0LFxuXG4gICAgXHRpc01hdHJpeDQ6IHRydWUsXG5cbiAgICBcdHNldDogZnVuY3Rpb24gKCBuMTEsIG4xMiwgbjEzLCBuMTQsIG4yMSwgbjIyLCBuMjMsIG4yNCwgbjMxLCBuMzIsIG4zMywgbjM0LCBuNDEsIG40MiwgbjQzLCBuNDQgKSB7XG5cbiAgICBcdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuICAgIFx0XHR0ZVsgMCBdID0gbjExOyB0ZVsgNCBdID0gbjEyOyB0ZVsgOCBdID0gbjEzOyB0ZVsgMTIgXSA9IG4xNDtcbiAgICBcdFx0dGVbIDEgXSA9IG4yMTsgdGVbIDUgXSA9IG4yMjsgdGVbIDkgXSA9IG4yMzsgdGVbIDEzIF0gPSBuMjQ7XG4gICAgXHRcdHRlWyAyIF0gPSBuMzE7IHRlWyA2IF0gPSBuMzI7IHRlWyAxMCBdID0gbjMzOyB0ZVsgMTQgXSA9IG4zNDtcbiAgICBcdFx0dGVbIDMgXSA9IG40MTsgdGVbIDcgXSA9IG40MjsgdGVbIDExIF0gPSBuNDM7IHRlWyAxNSBdID0gbjQ0O1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRpZGVudGl0eTogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHRoaXMuc2V0KFxuXG4gICAgXHRcdFx0MSwgMCwgMCwgMCxcbiAgICBcdFx0XHQwLCAxLCAwLCAwLFxuICAgIFx0XHRcdDAsIDAsIDEsIDAsXG4gICAgXHRcdFx0MCwgMCwgMCwgMVxuXG4gICAgXHRcdCk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0cmV0dXJuIG5ldyBNYXRyaXg0KCkuZnJvbUFycmF5KCB0aGlzLmVsZW1lbnRzICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGNvcHk6IGZ1bmN0aW9uICggbSApIHtcblxuICAgIFx0XHR0aGlzLmVsZW1lbnRzLnNldCggbS5lbGVtZW50cyApO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRjb3B5UG9zaXRpb246IGZ1bmN0aW9uICggbSApIHtcblxuICAgIFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuICAgIFx0XHR2YXIgbWUgPSBtLmVsZW1lbnRzO1xuXG4gICAgXHRcdHRlWyAxMiBdID0gbWVbIDEyIF07XG4gICAgXHRcdHRlWyAxMyBdID0gbWVbIDEzIF07XG4gICAgXHRcdHRlWyAxNCBdID0gbWVbIDE0IF07XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGV4dHJhY3RCYXNpczogZnVuY3Rpb24gKCB4QXhpcywgeUF4aXMsIHpBeGlzICkge1xuXG4gICAgXHRcdHhBeGlzLnNldEZyb21NYXRyaXhDb2x1bW4oIHRoaXMsIDAgKTtcbiAgICBcdFx0eUF4aXMuc2V0RnJvbU1hdHJpeENvbHVtbiggdGhpcywgMSApO1xuICAgIFx0XHR6QXhpcy5zZXRGcm9tTWF0cml4Q29sdW1uKCB0aGlzLCAyICk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdG1ha2VCYXNpczogZnVuY3Rpb24gKCB4QXhpcywgeUF4aXMsIHpBeGlzICkge1xuXG4gICAgXHRcdHRoaXMuc2V0KFxuICAgIFx0XHRcdHhBeGlzLngsIHlBeGlzLngsIHpBeGlzLngsIDAsXG4gICAgXHRcdFx0eEF4aXMueSwgeUF4aXMueSwgekF4aXMueSwgMCxcbiAgICBcdFx0XHR4QXhpcy56LCB5QXhpcy56LCB6QXhpcy56LCAwLFxuICAgIFx0XHRcdDAsICAgICAgIDAsICAgICAgIDAsICAgICAgIDFcbiAgICBcdFx0KTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0ZXh0cmFjdFJvdGF0aW9uOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dmFyIHYxO1xuXG4gICAgXHRcdHJldHVybiBmdW5jdGlvbiBleHRyYWN0Um90YXRpb24oIG0gKSB7XG5cbiAgICBcdFx0XHRpZiAoIHYxID09PSB1bmRlZmluZWQgKSB2MSA9IG5ldyBWZWN0b3IzKCk7XG5cbiAgICBcdFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuICAgIFx0XHRcdHZhciBtZSA9IG0uZWxlbWVudHM7XG5cbiAgICBcdFx0XHR2YXIgc2NhbGVYID0gMSAvIHYxLnNldEZyb21NYXRyaXhDb2x1bW4oIG0sIDAgKS5sZW5ndGgoKTtcbiAgICBcdFx0XHR2YXIgc2NhbGVZID0gMSAvIHYxLnNldEZyb21NYXRyaXhDb2x1bW4oIG0sIDEgKS5sZW5ndGgoKTtcbiAgICBcdFx0XHR2YXIgc2NhbGVaID0gMSAvIHYxLnNldEZyb21NYXRyaXhDb2x1bW4oIG0sIDIgKS5sZW5ndGgoKTtcblxuICAgIFx0XHRcdHRlWyAwIF0gPSBtZVsgMCBdICogc2NhbGVYO1xuICAgIFx0XHRcdHRlWyAxIF0gPSBtZVsgMSBdICogc2NhbGVYO1xuICAgIFx0XHRcdHRlWyAyIF0gPSBtZVsgMiBdICogc2NhbGVYO1xuXG4gICAgXHRcdFx0dGVbIDQgXSA9IG1lWyA0IF0gKiBzY2FsZVk7XG4gICAgXHRcdFx0dGVbIDUgXSA9IG1lWyA1IF0gKiBzY2FsZVk7XG4gICAgXHRcdFx0dGVbIDYgXSA9IG1lWyA2IF0gKiBzY2FsZVk7XG5cbiAgICBcdFx0XHR0ZVsgOCBdID0gbWVbIDggXSAqIHNjYWxlWjtcbiAgICBcdFx0XHR0ZVsgOSBdID0gbWVbIDkgXSAqIHNjYWxlWjtcbiAgICBcdFx0XHR0ZVsgMTAgXSA9IG1lWyAxMCBdICogc2NhbGVaO1xuXG4gICAgXHRcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdFx0fTtcblxuICAgIFx0fSgpLFxuXG4gICAgXHRtYWtlUm90YXRpb25Gcm9tRXVsZXI6IGZ1bmN0aW9uICggZXVsZXIgKSB7XG5cbiAgICBcdFx0aWYgKCAoZXVsZXIgJiYgZXVsZXIuaXNFdWxlcikgPT09IGZhbHNlICkge1xuXG4gICAgXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLk1hdHJpeDogLm1ha2VSb3RhdGlvbkZyb21FdWxlcigpIG5vdyBleHBlY3RzIGEgRXVsZXIgcm90YXRpb24gcmF0aGVyIHRoYW4gYSBWZWN0b3IzIGFuZCBvcmRlci4nICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cbiAgICBcdFx0dmFyIHggPSBldWxlci54LCB5ID0gZXVsZXIueSwgeiA9IGV1bGVyLno7XG4gICAgXHRcdHZhciBhID0gTWF0aC5jb3MoIHggKSwgYiA9IE1hdGguc2luKCB4ICk7XG4gICAgXHRcdHZhciBjID0gTWF0aC5jb3MoIHkgKSwgZCA9IE1hdGguc2luKCB5ICk7XG4gICAgXHRcdHZhciBlID0gTWF0aC5jb3MoIHogKSwgZiA9IE1hdGguc2luKCB6ICk7XG5cbiAgICBcdFx0aWYgKCBldWxlci5vcmRlciA9PT0gJ1hZWicgKSB7XG5cbiAgICBcdFx0XHR2YXIgYWUgPSBhICogZSwgYWYgPSBhICogZiwgYmUgPSBiICogZSwgYmYgPSBiICogZjtcblxuICAgIFx0XHRcdHRlWyAwIF0gPSBjICogZTtcbiAgICBcdFx0XHR0ZVsgNCBdID0gLSBjICogZjtcbiAgICBcdFx0XHR0ZVsgOCBdID0gZDtcblxuICAgIFx0XHRcdHRlWyAxIF0gPSBhZiArIGJlICogZDtcbiAgICBcdFx0XHR0ZVsgNSBdID0gYWUgLSBiZiAqIGQ7XG4gICAgXHRcdFx0dGVbIDkgXSA9IC0gYiAqIGM7XG5cbiAgICBcdFx0XHR0ZVsgMiBdID0gYmYgLSBhZSAqIGQ7XG4gICAgXHRcdFx0dGVbIDYgXSA9IGJlICsgYWYgKiBkO1xuICAgIFx0XHRcdHRlWyAxMCBdID0gYSAqIGM7XG5cbiAgICBcdFx0fSBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdZWFonICkge1xuXG4gICAgXHRcdFx0dmFyIGNlID0gYyAqIGUsIGNmID0gYyAqIGYsIGRlID0gZCAqIGUsIGRmID0gZCAqIGY7XG5cbiAgICBcdFx0XHR0ZVsgMCBdID0gY2UgKyBkZiAqIGI7XG4gICAgXHRcdFx0dGVbIDQgXSA9IGRlICogYiAtIGNmO1xuICAgIFx0XHRcdHRlWyA4IF0gPSBhICogZDtcblxuICAgIFx0XHRcdHRlWyAxIF0gPSBhICogZjtcbiAgICBcdFx0XHR0ZVsgNSBdID0gYSAqIGU7XG4gICAgXHRcdFx0dGVbIDkgXSA9IC0gYjtcblxuICAgIFx0XHRcdHRlWyAyIF0gPSBjZiAqIGIgLSBkZTtcbiAgICBcdFx0XHR0ZVsgNiBdID0gZGYgKyBjZSAqIGI7XG4gICAgXHRcdFx0dGVbIDEwIF0gPSBhICogYztcblxuICAgIFx0XHR9IGVsc2UgaWYgKCBldWxlci5vcmRlciA9PT0gJ1pYWScgKSB7XG5cbiAgICBcdFx0XHR2YXIgY2UgPSBjICogZSwgY2YgPSBjICogZiwgZGUgPSBkICogZSwgZGYgPSBkICogZjtcblxuICAgIFx0XHRcdHRlWyAwIF0gPSBjZSAtIGRmICogYjtcbiAgICBcdFx0XHR0ZVsgNCBdID0gLSBhICogZjtcbiAgICBcdFx0XHR0ZVsgOCBdID0gZGUgKyBjZiAqIGI7XG5cbiAgICBcdFx0XHR0ZVsgMSBdID0gY2YgKyBkZSAqIGI7XG4gICAgXHRcdFx0dGVbIDUgXSA9IGEgKiBlO1xuICAgIFx0XHRcdHRlWyA5IF0gPSBkZiAtIGNlICogYjtcblxuICAgIFx0XHRcdHRlWyAyIF0gPSAtIGEgKiBkO1xuICAgIFx0XHRcdHRlWyA2IF0gPSBiO1xuICAgIFx0XHRcdHRlWyAxMCBdID0gYSAqIGM7XG5cbiAgICBcdFx0fSBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdaWVgnICkge1xuXG4gICAgXHRcdFx0dmFyIGFlID0gYSAqIGUsIGFmID0gYSAqIGYsIGJlID0gYiAqIGUsIGJmID0gYiAqIGY7XG5cbiAgICBcdFx0XHR0ZVsgMCBdID0gYyAqIGU7XG4gICAgXHRcdFx0dGVbIDQgXSA9IGJlICogZCAtIGFmO1xuICAgIFx0XHRcdHRlWyA4IF0gPSBhZSAqIGQgKyBiZjtcblxuICAgIFx0XHRcdHRlWyAxIF0gPSBjICogZjtcbiAgICBcdFx0XHR0ZVsgNSBdID0gYmYgKiBkICsgYWU7XG4gICAgXHRcdFx0dGVbIDkgXSA9IGFmICogZCAtIGJlO1xuXG4gICAgXHRcdFx0dGVbIDIgXSA9IC0gZDtcbiAgICBcdFx0XHR0ZVsgNiBdID0gYiAqIGM7XG4gICAgXHRcdFx0dGVbIDEwIF0gPSBhICogYztcblxuICAgIFx0XHR9IGVsc2UgaWYgKCBldWxlci5vcmRlciA9PT0gJ1laWCcgKSB7XG5cbiAgICBcdFx0XHR2YXIgYWMgPSBhICogYywgYWQgPSBhICogZCwgYmMgPSBiICogYywgYmQgPSBiICogZDtcblxuICAgIFx0XHRcdHRlWyAwIF0gPSBjICogZTtcbiAgICBcdFx0XHR0ZVsgNCBdID0gYmQgLSBhYyAqIGY7XG4gICAgXHRcdFx0dGVbIDggXSA9IGJjICogZiArIGFkO1xuXG4gICAgXHRcdFx0dGVbIDEgXSA9IGY7XG4gICAgXHRcdFx0dGVbIDUgXSA9IGEgKiBlO1xuICAgIFx0XHRcdHRlWyA5IF0gPSAtIGIgKiBlO1xuXG4gICAgXHRcdFx0dGVbIDIgXSA9IC0gZCAqIGU7XG4gICAgXHRcdFx0dGVbIDYgXSA9IGFkICogZiArIGJjO1xuICAgIFx0XHRcdHRlWyAxMCBdID0gYWMgLSBiZCAqIGY7XG5cbiAgICBcdFx0fSBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdYWlknICkge1xuXG4gICAgXHRcdFx0dmFyIGFjID0gYSAqIGMsIGFkID0gYSAqIGQsIGJjID0gYiAqIGMsIGJkID0gYiAqIGQ7XG5cbiAgICBcdFx0XHR0ZVsgMCBdID0gYyAqIGU7XG4gICAgXHRcdFx0dGVbIDQgXSA9IC0gZjtcbiAgICBcdFx0XHR0ZVsgOCBdID0gZCAqIGU7XG5cbiAgICBcdFx0XHR0ZVsgMSBdID0gYWMgKiBmICsgYmQ7XG4gICAgXHRcdFx0dGVbIDUgXSA9IGEgKiBlO1xuICAgIFx0XHRcdHRlWyA5IF0gPSBhZCAqIGYgLSBiYztcblxuICAgIFx0XHRcdHRlWyAyIF0gPSBiYyAqIGYgLSBhZDtcbiAgICBcdFx0XHR0ZVsgNiBdID0gYiAqIGU7XG4gICAgXHRcdFx0dGVbIDEwIF0gPSBiZCAqIGYgKyBhYztcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0Ly8gbGFzdCBjb2x1bW5cbiAgICBcdFx0dGVbIDMgXSA9IDA7XG4gICAgXHRcdHRlWyA3IF0gPSAwO1xuICAgIFx0XHR0ZVsgMTEgXSA9IDA7XG5cbiAgICBcdFx0Ly8gYm90dG9tIHJvd1xuICAgIFx0XHR0ZVsgMTIgXSA9IDA7XG4gICAgXHRcdHRlWyAxMyBdID0gMDtcbiAgICBcdFx0dGVbIDE0IF0gPSAwO1xuICAgIFx0XHR0ZVsgMTUgXSA9IDE7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdG1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uOiBmdW5jdGlvbiAoIHEgKSB7XG5cbiAgICBcdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuICAgIFx0XHR2YXIgeCA9IHEueCwgeSA9IHEueSwgeiA9IHEueiwgdyA9IHEudztcbiAgICBcdFx0dmFyIHgyID0geCArIHgsIHkyID0geSArIHksIHoyID0geiArIHo7XG4gICAgXHRcdHZhciB4eCA9IHggKiB4MiwgeHkgPSB4ICogeTIsIHh6ID0geCAqIHoyO1xuICAgIFx0XHR2YXIgeXkgPSB5ICogeTIsIHl6ID0geSAqIHoyLCB6eiA9IHogKiB6MjtcbiAgICBcdFx0dmFyIHd4ID0gdyAqIHgyLCB3eSA9IHcgKiB5Miwgd3ogPSB3ICogejI7XG5cbiAgICBcdFx0dGVbIDAgXSA9IDEgLSAoIHl5ICsgenogKTtcbiAgICBcdFx0dGVbIDQgXSA9IHh5IC0gd3o7XG4gICAgXHRcdHRlWyA4IF0gPSB4eiArIHd5O1xuXG4gICAgXHRcdHRlWyAxIF0gPSB4eSArIHd6O1xuICAgIFx0XHR0ZVsgNSBdID0gMSAtICggeHggKyB6eiApO1xuICAgIFx0XHR0ZVsgOSBdID0geXogLSB3eDtcblxuICAgIFx0XHR0ZVsgMiBdID0geHogLSB3eTtcbiAgICBcdFx0dGVbIDYgXSA9IHl6ICsgd3g7XG4gICAgXHRcdHRlWyAxMCBdID0gMSAtICggeHggKyB5eSApO1xuXG4gICAgXHRcdC8vIGxhc3QgY29sdW1uXG4gICAgXHRcdHRlWyAzIF0gPSAwO1xuICAgIFx0XHR0ZVsgNyBdID0gMDtcbiAgICBcdFx0dGVbIDExIF0gPSAwO1xuXG4gICAgXHRcdC8vIGJvdHRvbSByb3dcbiAgICBcdFx0dGVbIDEyIF0gPSAwO1xuICAgIFx0XHR0ZVsgMTMgXSA9IDA7XG4gICAgXHRcdHRlWyAxNCBdID0gMDtcbiAgICBcdFx0dGVbIDE1IF0gPSAxO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRsb29rQXQ6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR2YXIgeCwgeSwgejtcblxuICAgIFx0XHRyZXR1cm4gZnVuY3Rpb24gbG9va0F0KCBleWUsIHRhcmdldCwgdXAgKSB7XG5cbiAgICBcdFx0XHRpZiAoIHggPT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0eCA9IG5ldyBWZWN0b3IzKCk7XG4gICAgXHRcdFx0XHR5ID0gbmV3IFZlY3RvcjMoKTtcbiAgICBcdFx0XHRcdHogPSBuZXcgVmVjdG9yMygpO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuICAgIFx0XHRcdHouc3ViVmVjdG9ycyggZXllLCB0YXJnZXQgKS5ub3JtYWxpemUoKTtcblxuICAgIFx0XHRcdGlmICggei5sZW5ndGhTcSgpID09PSAwICkge1xuXG4gICAgXHRcdFx0XHR6LnogPSAxO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0eC5jcm9zc1ZlY3RvcnMoIHVwLCB6ICkubm9ybWFsaXplKCk7XG5cbiAgICBcdFx0XHRpZiAoIHgubGVuZ3RoU3EoKSA9PT0gMCApIHtcblxuICAgIFx0XHRcdFx0ei56ICs9IDAuMDAwMTtcbiAgICBcdFx0XHRcdHguY3Jvc3NWZWN0b3JzKCB1cCwgeiApLm5vcm1hbGl6ZSgpO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0eS5jcm9zc1ZlY3RvcnMoIHosIHggKTtcblxuXG4gICAgXHRcdFx0dGVbIDAgXSA9IHgueDsgdGVbIDQgXSA9IHkueDsgdGVbIDggXSA9IHoueDtcbiAgICBcdFx0XHR0ZVsgMSBdID0geC55OyB0ZVsgNSBdID0geS55OyB0ZVsgOSBdID0gei55O1xuICAgIFx0XHRcdHRlWyAyIF0gPSB4Lno7IHRlWyA2IF0gPSB5Lno7IHRlWyAxMCBdID0gei56O1xuXG4gICAgXHRcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdFx0fTtcblxuICAgIFx0fSgpLFxuXG4gICAgXHRtdWx0aXBseTogZnVuY3Rpb24gKCBtLCBuICkge1xuXG4gICAgXHRcdGlmICggbiAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLm11bHRpcGx5KCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAubXVsdGlwbHlNYXRyaWNlcyggYSwgYiApIGluc3RlYWQuJyApO1xuICAgIFx0XHRcdHJldHVybiB0aGlzLm11bHRpcGx5TWF0cmljZXMoIG0sIG4gKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlNYXRyaWNlcyggdGhpcywgbSApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRwcmVtdWx0aXBseTogZnVuY3Rpb24gKCBtICkge1xuXG4gICAgXHRcdHJldHVybiB0aGlzLm11bHRpcGx5TWF0cmljZXMoIG0sIHRoaXMgKTtcblxuICAgIFx0fSxcblxuICAgIFx0bXVsdGlwbHlNYXRyaWNlczogZnVuY3Rpb24gKCBhLCBiICkge1xuXG4gICAgXHRcdHZhciBhZSA9IGEuZWxlbWVudHM7XG4gICAgXHRcdHZhciBiZSA9IGIuZWxlbWVudHM7XG4gICAgXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cbiAgICBcdFx0dmFyIGExMSA9IGFlWyAwIF0sIGExMiA9IGFlWyA0IF0sIGExMyA9IGFlWyA4IF0sIGExNCA9IGFlWyAxMiBdO1xuICAgIFx0XHR2YXIgYTIxID0gYWVbIDEgXSwgYTIyID0gYWVbIDUgXSwgYTIzID0gYWVbIDkgXSwgYTI0ID0gYWVbIDEzIF07XG4gICAgXHRcdHZhciBhMzEgPSBhZVsgMiBdLCBhMzIgPSBhZVsgNiBdLCBhMzMgPSBhZVsgMTAgXSwgYTM0ID0gYWVbIDE0IF07XG4gICAgXHRcdHZhciBhNDEgPSBhZVsgMyBdLCBhNDIgPSBhZVsgNyBdLCBhNDMgPSBhZVsgMTEgXSwgYTQ0ID0gYWVbIDE1IF07XG5cbiAgICBcdFx0dmFyIGIxMSA9IGJlWyAwIF0sIGIxMiA9IGJlWyA0IF0sIGIxMyA9IGJlWyA4IF0sIGIxNCA9IGJlWyAxMiBdO1xuICAgIFx0XHR2YXIgYjIxID0gYmVbIDEgXSwgYjIyID0gYmVbIDUgXSwgYjIzID0gYmVbIDkgXSwgYjI0ID0gYmVbIDEzIF07XG4gICAgXHRcdHZhciBiMzEgPSBiZVsgMiBdLCBiMzIgPSBiZVsgNiBdLCBiMzMgPSBiZVsgMTAgXSwgYjM0ID0gYmVbIDE0IF07XG4gICAgXHRcdHZhciBiNDEgPSBiZVsgMyBdLCBiNDIgPSBiZVsgNyBdLCBiNDMgPSBiZVsgMTEgXSwgYjQ0ID0gYmVbIDE1IF07XG5cbiAgICBcdFx0dGVbIDAgXSA9IGExMSAqIGIxMSArIGExMiAqIGIyMSArIGExMyAqIGIzMSArIGExNCAqIGI0MTtcbiAgICBcdFx0dGVbIDQgXSA9IGExMSAqIGIxMiArIGExMiAqIGIyMiArIGExMyAqIGIzMiArIGExNCAqIGI0MjtcbiAgICBcdFx0dGVbIDggXSA9IGExMSAqIGIxMyArIGExMiAqIGIyMyArIGExMyAqIGIzMyArIGExNCAqIGI0MztcbiAgICBcdFx0dGVbIDEyIF0gPSBhMTEgKiBiMTQgKyBhMTIgKiBiMjQgKyBhMTMgKiBiMzQgKyBhMTQgKiBiNDQ7XG5cbiAgICBcdFx0dGVbIDEgXSA9IGEyMSAqIGIxMSArIGEyMiAqIGIyMSArIGEyMyAqIGIzMSArIGEyNCAqIGI0MTtcbiAgICBcdFx0dGVbIDUgXSA9IGEyMSAqIGIxMiArIGEyMiAqIGIyMiArIGEyMyAqIGIzMiArIGEyNCAqIGI0MjtcbiAgICBcdFx0dGVbIDkgXSA9IGEyMSAqIGIxMyArIGEyMiAqIGIyMyArIGEyMyAqIGIzMyArIGEyNCAqIGI0MztcbiAgICBcdFx0dGVbIDEzIF0gPSBhMjEgKiBiMTQgKyBhMjIgKiBiMjQgKyBhMjMgKiBiMzQgKyBhMjQgKiBiNDQ7XG5cbiAgICBcdFx0dGVbIDIgXSA9IGEzMSAqIGIxMSArIGEzMiAqIGIyMSArIGEzMyAqIGIzMSArIGEzNCAqIGI0MTtcbiAgICBcdFx0dGVbIDYgXSA9IGEzMSAqIGIxMiArIGEzMiAqIGIyMiArIGEzMyAqIGIzMiArIGEzNCAqIGI0MjtcbiAgICBcdFx0dGVbIDEwIF0gPSBhMzEgKiBiMTMgKyBhMzIgKiBiMjMgKyBhMzMgKiBiMzMgKyBhMzQgKiBiNDM7XG4gICAgXHRcdHRlWyAxNCBdID0gYTMxICogYjE0ICsgYTMyICogYjI0ICsgYTMzICogYjM0ICsgYTM0ICogYjQ0O1xuXG4gICAgXHRcdHRlWyAzIF0gPSBhNDEgKiBiMTEgKyBhNDIgKiBiMjEgKyBhNDMgKiBiMzEgKyBhNDQgKiBiNDE7XG4gICAgXHRcdHRlWyA3IF0gPSBhNDEgKiBiMTIgKyBhNDIgKiBiMjIgKyBhNDMgKiBiMzIgKyBhNDQgKiBiNDI7XG4gICAgXHRcdHRlWyAxMSBdID0gYTQxICogYjEzICsgYTQyICogYjIzICsgYTQzICogYjMzICsgYTQ0ICogYjQzO1xuICAgIFx0XHR0ZVsgMTUgXSA9IGE0MSAqIGIxNCArIGE0MiAqIGIyNCArIGE0MyAqIGIzNCArIGE0NCAqIGI0NDtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0bXVsdGlwbHlUb0FycmF5OiBmdW5jdGlvbiAoIGEsIGIsIHIgKSB7XG5cbiAgICBcdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuICAgIFx0XHR0aGlzLm11bHRpcGx5TWF0cmljZXMoIGEsIGIgKTtcblxuICAgIFx0XHRyWyAwIF0gPSB0ZVsgMCBdOyByWyAxIF0gPSB0ZVsgMSBdOyByWyAyIF0gPSB0ZVsgMiBdOyByWyAzIF0gPSB0ZVsgMyBdO1xuICAgIFx0XHRyWyA0IF0gPSB0ZVsgNCBdOyByWyA1IF0gPSB0ZVsgNSBdOyByWyA2IF0gPSB0ZVsgNiBdOyByWyA3IF0gPSB0ZVsgNyBdO1xuICAgIFx0XHRyWyA4IF0gID0gdGVbIDggXTsgclsgOSBdICA9IHRlWyA5IF07IHJbIDEwIF0gPSB0ZVsgMTAgXTsgclsgMTEgXSA9IHRlWyAxMSBdO1xuICAgIFx0XHRyWyAxMiBdID0gdGVbIDEyIF07IHJbIDEzIF0gPSB0ZVsgMTMgXTsgclsgMTQgXSA9IHRlWyAxNCBdOyByWyAxNSBdID0gdGVbIDE1IF07XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdG11bHRpcGx5U2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XG5cbiAgICBcdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuICAgIFx0XHR0ZVsgMCBdICo9IHM7IHRlWyA0IF0gKj0gczsgdGVbIDggXSAqPSBzOyB0ZVsgMTIgXSAqPSBzO1xuICAgIFx0XHR0ZVsgMSBdICo9IHM7IHRlWyA1IF0gKj0gczsgdGVbIDkgXSAqPSBzOyB0ZVsgMTMgXSAqPSBzO1xuICAgIFx0XHR0ZVsgMiBdICo9IHM7IHRlWyA2IF0gKj0gczsgdGVbIDEwIF0gKj0gczsgdGVbIDE0IF0gKj0gcztcbiAgICBcdFx0dGVbIDMgXSAqPSBzOyB0ZVsgNyBdICo9IHM7IHRlWyAxMSBdICo9IHM7IHRlWyAxNSBdICo9IHM7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGFwcGx5VG9WZWN0b3IzQXJyYXk6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR2YXIgdjE7XG5cbiAgICBcdFx0cmV0dXJuIGZ1bmN0aW9uIGFwcGx5VG9WZWN0b3IzQXJyYXkoIGFycmF5LCBvZmZzZXQsIGxlbmd0aCApIHtcblxuICAgIFx0XHRcdGlmICggdjEgPT09IHVuZGVmaW5lZCApIHYxID0gbmV3IFZlY3RvcjMoKTtcbiAgICBcdFx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcbiAgICBcdFx0XHRpZiAoIGxlbmd0aCA9PT0gdW5kZWZpbmVkICkgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBqID0gb2Zmc2V0OyBpIDwgbGVuZ3RoOyBpICs9IDMsIGogKz0gMyApIHtcblxuICAgIFx0XHRcdFx0djEuZnJvbUFycmF5KCBhcnJheSwgaiApO1xuICAgIFx0XHRcdFx0djEuYXBwbHlNYXRyaXg0KCB0aGlzICk7XG4gICAgXHRcdFx0XHR2MS50b0FycmF5KCBhcnJheSwgaiApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0cmV0dXJuIGFycmF5O1xuXG4gICAgXHRcdH07XG5cbiAgICBcdH0oKSxcblxuICAgIFx0YXBwbHlUb0J1ZmZlcjogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHZhciB2MTtcblxuICAgIFx0XHRyZXR1cm4gZnVuY3Rpb24gYXBwbHlUb0J1ZmZlciggYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCApIHtcblxuICAgIFx0XHRcdGlmICggdjEgPT09IHVuZGVmaW5lZCApIHYxID0gbmV3IFZlY3RvcjMoKTtcbiAgICBcdFx0XHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcbiAgICBcdFx0XHRpZiAoIGxlbmd0aCA9PT0gdW5kZWZpbmVkICkgbGVuZ3RoID0gYnVmZmVyLmxlbmd0aCAvIGJ1ZmZlci5pdGVtU2l6ZTtcblxuICAgIFx0XHRcdGZvciAoIHZhciBpID0gMCwgaiA9IG9mZnNldDsgaSA8IGxlbmd0aDsgaSArKywgaiArKyApIHtcblxuICAgIFx0XHRcdFx0djEueCA9IGJ1ZmZlci5nZXRYKCBqICk7XG4gICAgXHRcdFx0XHR2MS55ID0gYnVmZmVyLmdldFkoIGogKTtcbiAgICBcdFx0XHRcdHYxLnogPSBidWZmZXIuZ2V0WiggaiApO1xuXG4gICAgXHRcdFx0XHR2MS5hcHBseU1hdHJpeDQoIHRoaXMgKTtcblxuICAgIFx0XHRcdFx0YnVmZmVyLnNldFhZWiggdjEueCwgdjEueSwgdjEueiApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0cmV0dXJuIGJ1ZmZlcjtcblxuICAgIFx0XHR9O1xuXG4gICAgXHR9KCksXG5cbiAgICBcdGRldGVybWluYW50OiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuICAgIFx0XHR2YXIgbjExID0gdGVbIDAgXSwgbjEyID0gdGVbIDQgXSwgbjEzID0gdGVbIDggXSwgbjE0ID0gdGVbIDEyIF07XG4gICAgXHRcdHZhciBuMjEgPSB0ZVsgMSBdLCBuMjIgPSB0ZVsgNSBdLCBuMjMgPSB0ZVsgOSBdLCBuMjQgPSB0ZVsgMTMgXTtcbiAgICBcdFx0dmFyIG4zMSA9IHRlWyAyIF0sIG4zMiA9IHRlWyA2IF0sIG4zMyA9IHRlWyAxMCBdLCBuMzQgPSB0ZVsgMTQgXTtcbiAgICBcdFx0dmFyIG40MSA9IHRlWyAzIF0sIG40MiA9IHRlWyA3IF0sIG40MyA9IHRlWyAxMSBdLCBuNDQgPSB0ZVsgMTUgXTtcblxuICAgIFx0XHQvL1RPRE86IG1ha2UgdGhpcyBtb3JlIGVmZmljaWVudFxuICAgIFx0XHQvLyggYmFzZWQgb24gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvYWxnZWJyYS9tYXRyaXgvZnVuY3Rpb25zL2ludmVyc2UvZm91ckQvaW5kZXguaHRtIClcblxuICAgIFx0XHRyZXR1cm4gKFxuICAgIFx0XHRcdG40MSAqIChcbiAgICBcdFx0XHRcdCsgbjE0ICogbjIzICogbjMyXG4gICAgXHRcdFx0XHQgLSBuMTMgKiBuMjQgKiBuMzJcbiAgICBcdFx0XHRcdCAtIG4xNCAqIG4yMiAqIG4zM1xuICAgIFx0XHRcdFx0ICsgbjEyICogbjI0ICogbjMzXG4gICAgXHRcdFx0XHQgKyBuMTMgKiBuMjIgKiBuMzRcbiAgICBcdFx0XHRcdCAtIG4xMiAqIG4yMyAqIG4zNFxuICAgIFx0XHRcdCkgK1xuICAgIFx0XHRcdG40MiAqIChcbiAgICBcdFx0XHRcdCsgbjExICogbjIzICogbjM0XG4gICAgXHRcdFx0XHQgLSBuMTEgKiBuMjQgKiBuMzNcbiAgICBcdFx0XHRcdCArIG4xNCAqIG4yMSAqIG4zM1xuICAgIFx0XHRcdFx0IC0gbjEzICogbjIxICogbjM0XG4gICAgXHRcdFx0XHQgKyBuMTMgKiBuMjQgKiBuMzFcbiAgICBcdFx0XHRcdCAtIG4xNCAqIG4yMyAqIG4zMVxuICAgIFx0XHRcdCkgK1xuICAgIFx0XHRcdG40MyAqIChcbiAgICBcdFx0XHRcdCsgbjExICogbjI0ICogbjMyXG4gICAgXHRcdFx0XHQgLSBuMTEgKiBuMjIgKiBuMzRcbiAgICBcdFx0XHRcdCAtIG4xNCAqIG4yMSAqIG4zMlxuICAgIFx0XHRcdFx0ICsgbjEyICogbjIxICogbjM0XG4gICAgXHRcdFx0XHQgKyBuMTQgKiBuMjIgKiBuMzFcbiAgICBcdFx0XHRcdCAtIG4xMiAqIG4yNCAqIG4zMVxuICAgIFx0XHRcdCkgK1xuICAgIFx0XHRcdG40NCAqIChcbiAgICBcdFx0XHRcdC0gbjEzICogbjIyICogbjMxXG4gICAgXHRcdFx0XHQgLSBuMTEgKiBuMjMgKiBuMzJcbiAgICBcdFx0XHRcdCArIG4xMSAqIG4yMiAqIG4zM1xuICAgIFx0XHRcdFx0ICsgbjEzICogbjIxICogbjMyXG4gICAgXHRcdFx0XHQgLSBuMTIgKiBuMjEgKiBuMzNcbiAgICBcdFx0XHRcdCArIG4xMiAqIG4yMyAqIG4zMVxuICAgIFx0XHRcdClcblxuICAgIFx0XHQpO1xuXG4gICAgXHR9LFxuXG4gICAgXHR0cmFuc3Bvc2U6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuICAgIFx0XHR2YXIgdG1wO1xuXG4gICAgXHRcdHRtcCA9IHRlWyAxIF07IHRlWyAxIF0gPSB0ZVsgNCBdOyB0ZVsgNCBdID0gdG1wO1xuICAgIFx0XHR0bXAgPSB0ZVsgMiBdOyB0ZVsgMiBdID0gdGVbIDggXTsgdGVbIDggXSA9IHRtcDtcbiAgICBcdFx0dG1wID0gdGVbIDYgXTsgdGVbIDYgXSA9IHRlWyA5IF07IHRlWyA5IF0gPSB0bXA7XG5cbiAgICBcdFx0dG1wID0gdGVbIDMgXTsgdGVbIDMgXSA9IHRlWyAxMiBdOyB0ZVsgMTIgXSA9IHRtcDtcbiAgICBcdFx0dG1wID0gdGVbIDcgXTsgdGVbIDcgXSA9IHRlWyAxMyBdOyB0ZVsgMTMgXSA9IHRtcDtcbiAgICBcdFx0dG1wID0gdGVbIDExIF07IHRlWyAxMSBdID0gdGVbIDE0IF07IHRlWyAxNCBdID0gdG1wO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRmbGF0dGVuVG9BcnJheU9mZnNldDogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xuXG4gICAgXHRcdGNvbnNvbGUud2FybiggXCJUSFJFRS5NYXRyaXgzOiAuZmxhdHRlblRvQXJyYXlPZmZzZXQgaXMgZGVwcmVjYXRlZCBcIiArXG4gICAgXHRcdFx0XHRcIi0ganVzdCB1c2UgLnRvQXJyYXkgaW5zdGVhZC5cIiApO1xuXG4gICAgXHRcdHJldHVybiB0aGlzLnRvQXJyYXkoIGFycmF5LCBvZmZzZXQgKTtcblxuICAgIFx0fSxcblxuICAgIFx0Z2V0UG9zaXRpb246IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR2YXIgdjE7XG5cbiAgICBcdFx0cmV0dXJuIGZ1bmN0aW9uIGdldFBvc2l0aW9uKCkge1xuXG4gICAgXHRcdFx0aWYgKCB2MSA9PT0gdW5kZWZpbmVkICkgdjEgPSBuZXcgVmVjdG9yMygpO1xuICAgIFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDQ6IC5nZXRQb3NpdGlvbigpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBWZWN0b3IzLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbWF0cml4ICkgaW5zdGVhZC4nICk7XG5cbiAgICBcdFx0XHRyZXR1cm4gdjEuc2V0RnJvbU1hdHJpeENvbHVtbiggdGhpcywgMyApO1xuXG4gICAgXHRcdH07XG5cbiAgICBcdH0oKSxcblxuICAgIFx0c2V0UG9zaXRpb246IGZ1bmN0aW9uICggdiApIHtcblxuICAgIFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG4gICAgXHRcdHRlWyAxMiBdID0gdi54O1xuICAgIFx0XHR0ZVsgMTMgXSA9IHYueTtcbiAgICBcdFx0dGVbIDE0IF0gPSB2Lno7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGdldEludmVyc2U6IGZ1bmN0aW9uICggbSwgdGhyb3dPbkRlZ2VuZXJhdGUgKSB7XG5cbiAgICBcdFx0Ly8gYmFzZWQgb24gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvYWxnZWJyYS9tYXRyaXgvZnVuY3Rpb25zL2ludmVyc2UvZm91ckQvaW5kZXguaHRtXG4gICAgXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHMsXG4gICAgXHRcdFx0bWUgPSBtLmVsZW1lbnRzLFxuXG4gICAgXHRcdFx0bjExID0gbWVbIDAgXSwgbjIxID0gbWVbIDEgXSwgbjMxID0gbWVbIDIgXSwgbjQxID0gbWVbIDMgXSxcbiAgICBcdFx0XHRuMTIgPSBtZVsgNCBdLCBuMjIgPSBtZVsgNSBdLCBuMzIgPSBtZVsgNiBdLCBuNDIgPSBtZVsgNyBdLFxuICAgIFx0XHRcdG4xMyA9IG1lWyA4IF0sIG4yMyA9IG1lWyA5IF0sIG4zMyA9IG1lWyAxMCBdLCBuNDMgPSBtZVsgMTEgXSxcbiAgICBcdFx0XHRuMTQgPSBtZVsgMTIgXSwgbjI0ID0gbWVbIDEzIF0sIG4zNCA9IG1lWyAxNCBdLCBuNDQgPSBtZVsgMTUgXSxcblxuICAgIFx0XHRcdHQxMSA9IG4yMyAqIG4zNCAqIG40MiAtIG4yNCAqIG4zMyAqIG40MiArIG4yNCAqIG4zMiAqIG40MyAtIG4yMiAqIG4zNCAqIG40MyAtIG4yMyAqIG4zMiAqIG40NCArIG4yMiAqIG4zMyAqIG40NCxcbiAgICBcdFx0XHR0MTIgPSBuMTQgKiBuMzMgKiBuNDIgLSBuMTMgKiBuMzQgKiBuNDIgLSBuMTQgKiBuMzIgKiBuNDMgKyBuMTIgKiBuMzQgKiBuNDMgKyBuMTMgKiBuMzIgKiBuNDQgLSBuMTIgKiBuMzMgKiBuNDQsXG4gICAgXHRcdFx0dDEzID0gbjEzICogbjI0ICogbjQyIC0gbjE0ICogbjIzICogbjQyICsgbjE0ICogbjIyICogbjQzIC0gbjEyICogbjI0ICogbjQzIC0gbjEzICogbjIyICogbjQ0ICsgbjEyICogbjIzICogbjQ0LFxuICAgIFx0XHRcdHQxNCA9IG4xNCAqIG4yMyAqIG4zMiAtIG4xMyAqIG4yNCAqIG4zMiAtIG4xNCAqIG4yMiAqIG4zMyArIG4xMiAqIG4yNCAqIG4zMyArIG4xMyAqIG4yMiAqIG4zNCAtIG4xMiAqIG4yMyAqIG4zNDtcblxuICAgIFx0XHR2YXIgZGV0ID0gbjExICogdDExICsgbjIxICogdDEyICsgbjMxICogdDEzICsgbjQxICogdDE0O1xuXG4gICAgXHRcdGlmICggZGV0ID09PSAwICkge1xuXG4gICAgXHRcdFx0dmFyIG1zZyA9IFwiVEhSRUUuTWF0cml4NC5nZXRJbnZlcnNlKCk6IGNhbid0IGludmVydCBtYXRyaXgsIGRldGVybWluYW50IGlzIDBcIjtcblxuICAgIFx0XHRcdGlmICggdGhyb3dPbkRlZ2VuZXJhdGUgPT09IHRydWUgKSB7XG5cbiAgICBcdFx0XHRcdHRocm93IG5ldyBFcnJvciggbXNnICk7XG5cbiAgICBcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHRjb25zb2xlLndhcm4oIG1zZyApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0cmV0dXJuIHRoaXMuaWRlbnRpdHkoKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0dmFyIGRldEludiA9IDEgLyBkZXQ7XG5cbiAgICBcdFx0dGVbIDAgXSA9IHQxMSAqIGRldEludjtcbiAgICBcdFx0dGVbIDEgXSA9ICggbjI0ICogbjMzICogbjQxIC0gbjIzICogbjM0ICogbjQxIC0gbjI0ICogbjMxICogbjQzICsgbjIxICogbjM0ICogbjQzICsgbjIzICogbjMxICogbjQ0IC0gbjIxICogbjMzICogbjQ0ICkgKiBkZXRJbnY7XG4gICAgXHRcdHRlWyAyIF0gPSAoIG4yMiAqIG4zNCAqIG40MSAtIG4yNCAqIG4zMiAqIG40MSArIG4yNCAqIG4zMSAqIG40MiAtIG4yMSAqIG4zNCAqIG40MiAtIG4yMiAqIG4zMSAqIG40NCArIG4yMSAqIG4zMiAqIG40NCApICogZGV0SW52O1xuICAgIFx0XHR0ZVsgMyBdID0gKCBuMjMgKiBuMzIgKiBuNDEgLSBuMjIgKiBuMzMgKiBuNDEgLSBuMjMgKiBuMzEgKiBuNDIgKyBuMjEgKiBuMzMgKiBuNDIgKyBuMjIgKiBuMzEgKiBuNDMgLSBuMjEgKiBuMzIgKiBuNDMgKSAqIGRldEludjtcblxuICAgIFx0XHR0ZVsgNCBdID0gdDEyICogZGV0SW52O1xuICAgIFx0XHR0ZVsgNSBdID0gKCBuMTMgKiBuMzQgKiBuNDEgLSBuMTQgKiBuMzMgKiBuNDEgKyBuMTQgKiBuMzEgKiBuNDMgLSBuMTEgKiBuMzQgKiBuNDMgLSBuMTMgKiBuMzEgKiBuNDQgKyBuMTEgKiBuMzMgKiBuNDQgKSAqIGRldEludjtcbiAgICBcdFx0dGVbIDYgXSA9ICggbjE0ICogbjMyICogbjQxIC0gbjEyICogbjM0ICogbjQxIC0gbjE0ICogbjMxICogbjQyICsgbjExICogbjM0ICogbjQyICsgbjEyICogbjMxICogbjQ0IC0gbjExICogbjMyICogbjQ0ICkgKiBkZXRJbnY7XG4gICAgXHRcdHRlWyA3IF0gPSAoIG4xMiAqIG4zMyAqIG40MSAtIG4xMyAqIG4zMiAqIG40MSArIG4xMyAqIG4zMSAqIG40MiAtIG4xMSAqIG4zMyAqIG40MiAtIG4xMiAqIG4zMSAqIG40MyArIG4xMSAqIG4zMiAqIG40MyApICogZGV0SW52O1xuXG4gICAgXHRcdHRlWyA4IF0gPSB0MTMgKiBkZXRJbnY7XG4gICAgXHRcdHRlWyA5IF0gPSAoIG4xNCAqIG4yMyAqIG40MSAtIG4xMyAqIG4yNCAqIG40MSAtIG4xNCAqIG4yMSAqIG40MyArIG4xMSAqIG4yNCAqIG40MyArIG4xMyAqIG4yMSAqIG40NCAtIG4xMSAqIG4yMyAqIG40NCApICogZGV0SW52O1xuICAgIFx0XHR0ZVsgMTAgXSA9ICggbjEyICogbjI0ICogbjQxIC0gbjE0ICogbjIyICogbjQxICsgbjE0ICogbjIxICogbjQyIC0gbjExICogbjI0ICogbjQyIC0gbjEyICogbjIxICogbjQ0ICsgbjExICogbjIyICogbjQ0ICkgKiBkZXRJbnY7XG4gICAgXHRcdHRlWyAxMSBdID0gKCBuMTMgKiBuMjIgKiBuNDEgLSBuMTIgKiBuMjMgKiBuNDEgLSBuMTMgKiBuMjEgKiBuNDIgKyBuMTEgKiBuMjMgKiBuNDIgKyBuMTIgKiBuMjEgKiBuNDMgLSBuMTEgKiBuMjIgKiBuNDMgKSAqIGRldEludjtcblxuICAgIFx0XHR0ZVsgMTIgXSA9IHQxNCAqIGRldEludjtcbiAgICBcdFx0dGVbIDEzIF0gPSAoIG4xMyAqIG4yNCAqIG4zMSAtIG4xNCAqIG4yMyAqIG4zMSArIG4xNCAqIG4yMSAqIG4zMyAtIG4xMSAqIG4yNCAqIG4zMyAtIG4xMyAqIG4yMSAqIG4zNCArIG4xMSAqIG4yMyAqIG4zNCApICogZGV0SW52O1xuICAgIFx0XHR0ZVsgMTQgXSA9ICggbjE0ICogbjIyICogbjMxIC0gbjEyICogbjI0ICogbjMxIC0gbjE0ICogbjIxICogbjMyICsgbjExICogbjI0ICogbjMyICsgbjEyICogbjIxICogbjM0IC0gbjExICogbjIyICogbjM0ICkgKiBkZXRJbnY7XG4gICAgXHRcdHRlWyAxNSBdID0gKCBuMTIgKiBuMjMgKiBuMzEgLSBuMTMgKiBuMjIgKiBuMzEgKyBuMTMgKiBuMjEgKiBuMzIgLSBuMTEgKiBuMjMgKiBuMzIgLSBuMTIgKiBuMjEgKiBuMzMgKyBuMTEgKiBuMjIgKiBuMzMgKSAqIGRldEludjtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0c2NhbGU6IGZ1bmN0aW9uICggdiApIHtcblxuICAgIFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuICAgIFx0XHR2YXIgeCA9IHYueCwgeSA9IHYueSwgeiA9IHYuejtcblxuICAgIFx0XHR0ZVsgMCBdICo9IHg7IHRlWyA0IF0gKj0geTsgdGVbIDggXSAqPSB6O1xuICAgIFx0XHR0ZVsgMSBdICo9IHg7IHRlWyA1IF0gKj0geTsgdGVbIDkgXSAqPSB6O1xuICAgIFx0XHR0ZVsgMiBdICo9IHg7IHRlWyA2IF0gKj0geTsgdGVbIDEwIF0gKj0gejtcbiAgICBcdFx0dGVbIDMgXSAqPSB4OyB0ZVsgNyBdICo9IHk7IHRlWyAxMSBdICo9IHo7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGdldE1heFNjYWxlT25BeGlzOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuICAgIFx0XHR2YXIgc2NhbGVYU3EgPSB0ZVsgMCBdICogdGVbIDAgXSArIHRlWyAxIF0gKiB0ZVsgMSBdICsgdGVbIDIgXSAqIHRlWyAyIF07XG4gICAgXHRcdHZhciBzY2FsZVlTcSA9IHRlWyA0IF0gKiB0ZVsgNCBdICsgdGVbIDUgXSAqIHRlWyA1IF0gKyB0ZVsgNiBdICogdGVbIDYgXTtcbiAgICBcdFx0dmFyIHNjYWxlWlNxID0gdGVbIDggXSAqIHRlWyA4IF0gKyB0ZVsgOSBdICogdGVbIDkgXSArIHRlWyAxMCBdICogdGVbIDEwIF07XG5cbiAgICBcdFx0cmV0dXJuIE1hdGguc3FydCggTWF0aC5tYXgoIHNjYWxlWFNxLCBzY2FsZVlTcSwgc2NhbGVaU3EgKSApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRtYWtlVHJhbnNsYXRpb246IGZ1bmN0aW9uICggeCwgeSwgeiApIHtcblxuICAgIFx0XHR0aGlzLnNldChcblxuICAgIFx0XHRcdDEsIDAsIDAsIHgsXG4gICAgXHRcdFx0MCwgMSwgMCwgeSxcbiAgICBcdFx0XHQwLCAwLCAxLCB6LFxuICAgIFx0XHRcdDAsIDAsIDAsIDFcblxuICAgIFx0XHQpO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRtYWtlUm90YXRpb25YOiBmdW5jdGlvbiAoIHRoZXRhICkge1xuXG4gICAgXHRcdHZhciBjID0gTWF0aC5jb3MoIHRoZXRhICksIHMgPSBNYXRoLnNpbiggdGhldGEgKTtcblxuICAgIFx0XHR0aGlzLnNldChcblxuICAgIFx0XHRcdDEsIDAsICAwLCAwLFxuICAgIFx0XHRcdDAsIGMsIC0gcywgMCxcbiAgICBcdFx0XHQwLCBzLCAgYywgMCxcbiAgICBcdFx0XHQwLCAwLCAgMCwgMVxuXG4gICAgXHRcdCk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdG1ha2VSb3RhdGlvblk6IGZ1bmN0aW9uICggdGhldGEgKSB7XG5cbiAgICBcdFx0dmFyIGMgPSBNYXRoLmNvcyggdGhldGEgKSwgcyA9IE1hdGguc2luKCB0aGV0YSApO1xuXG4gICAgXHRcdHRoaXMuc2V0KFxuXG4gICAgXHRcdFx0IGMsIDAsIHMsIDAsXG4gICAgXHRcdFx0IDAsIDEsIDAsIDAsXG4gICAgXHRcdFx0LSBzLCAwLCBjLCAwLFxuICAgIFx0XHRcdCAwLCAwLCAwLCAxXG5cbiAgICBcdFx0KTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0bWFrZVJvdGF0aW9uWjogZnVuY3Rpb24gKCB0aGV0YSApIHtcblxuICAgIFx0XHR2YXIgYyA9IE1hdGguY29zKCB0aGV0YSApLCBzID0gTWF0aC5zaW4oIHRoZXRhICk7XG5cbiAgICBcdFx0dGhpcy5zZXQoXG5cbiAgICBcdFx0XHRjLCAtIHMsIDAsIDAsXG4gICAgXHRcdFx0cywgIGMsIDAsIDAsXG4gICAgXHRcdFx0MCwgIDAsIDEsIDAsXG4gICAgXHRcdFx0MCwgIDAsIDAsIDFcblxuICAgIFx0XHQpO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRtYWtlUm90YXRpb25BeGlzOiBmdW5jdGlvbiAoIGF4aXMsIGFuZ2xlICkge1xuXG4gICAgXHRcdC8vIEJhc2VkIG9uIGh0dHA6Ly93d3cuZ2FtZWRldi5uZXQvcmVmZXJlbmNlL2FydGljbGVzL2FydGljbGUxMTk5LmFzcFxuXG4gICAgXHRcdHZhciBjID0gTWF0aC5jb3MoIGFuZ2xlICk7XG4gICAgXHRcdHZhciBzID0gTWF0aC5zaW4oIGFuZ2xlICk7XG4gICAgXHRcdHZhciB0ID0gMSAtIGM7XG4gICAgXHRcdHZhciB4ID0gYXhpcy54LCB5ID0gYXhpcy55LCB6ID0gYXhpcy56O1xuICAgIFx0XHR2YXIgdHggPSB0ICogeCwgdHkgPSB0ICogeTtcblxuICAgIFx0XHR0aGlzLnNldChcblxuICAgIFx0XHRcdHR4ICogeCArIGMsIHR4ICogeSAtIHMgKiB6LCB0eCAqIHogKyBzICogeSwgMCxcbiAgICBcdFx0XHR0eCAqIHkgKyBzICogeiwgdHkgKiB5ICsgYywgdHkgKiB6IC0gcyAqIHgsIDAsXG4gICAgXHRcdFx0dHggKiB6IC0gcyAqIHksIHR5ICogeiArIHMgKiB4LCB0ICogeiAqIHogKyBjLCAwLFxuICAgIFx0XHRcdDAsIDAsIDAsIDFcblxuICAgIFx0XHQpO1xuXG4gICAgXHRcdCByZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0bWFrZVNjYWxlOiBmdW5jdGlvbiAoIHgsIHksIHogKSB7XG5cbiAgICBcdFx0dGhpcy5zZXQoXG5cbiAgICBcdFx0XHR4LCAwLCAwLCAwLFxuICAgIFx0XHRcdDAsIHksIDAsIDAsXG4gICAgXHRcdFx0MCwgMCwgeiwgMCxcbiAgICBcdFx0XHQwLCAwLCAwLCAxXG5cbiAgICBcdFx0KTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0Y29tcG9zZTogZnVuY3Rpb24gKCBwb3NpdGlvbiwgcXVhdGVybmlvbiwgc2NhbGUgKSB7XG5cbiAgICBcdFx0dGhpcy5tYWtlUm90YXRpb25Gcm9tUXVhdGVybmlvbiggcXVhdGVybmlvbiApO1xuICAgIFx0XHR0aGlzLnNjYWxlKCBzY2FsZSApO1xuICAgIFx0XHR0aGlzLnNldFBvc2l0aW9uKCBwb3NpdGlvbiApO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRkZWNvbXBvc2U6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR2YXIgdmVjdG9yLCBtYXRyaXg7XG5cbiAgICBcdFx0cmV0dXJuIGZ1bmN0aW9uIGRlY29tcG9zZSggcG9zaXRpb24sIHF1YXRlcm5pb24sIHNjYWxlICkge1xuXG4gICAgXHRcdFx0aWYgKCB2ZWN0b3IgPT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0dmVjdG9yID0gbmV3IFZlY3RvcjMoKTtcbiAgICBcdFx0XHRcdG1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG4gICAgXHRcdFx0dmFyIHN4ID0gdmVjdG9yLnNldCggdGVbIDAgXSwgdGVbIDEgXSwgdGVbIDIgXSApLmxlbmd0aCgpO1xuICAgIFx0XHRcdHZhciBzeSA9IHZlY3Rvci5zZXQoIHRlWyA0IF0sIHRlWyA1IF0sIHRlWyA2IF0gKS5sZW5ndGgoKTtcbiAgICBcdFx0XHR2YXIgc3ogPSB2ZWN0b3Iuc2V0KCB0ZVsgOCBdLCB0ZVsgOSBdLCB0ZVsgMTAgXSApLmxlbmd0aCgpO1xuXG4gICAgXHRcdFx0Ly8gaWYgZGV0ZXJtaW5lIGlzIG5lZ2F0aXZlLCB3ZSBuZWVkIHRvIGludmVydCBvbmUgc2NhbGVcbiAgICBcdFx0XHR2YXIgZGV0ID0gdGhpcy5kZXRlcm1pbmFudCgpO1xuICAgIFx0XHRcdGlmICggZGV0IDwgMCApIHtcblxuICAgIFx0XHRcdFx0c3ggPSAtIHN4O1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0cG9zaXRpb24ueCA9IHRlWyAxMiBdO1xuICAgIFx0XHRcdHBvc2l0aW9uLnkgPSB0ZVsgMTMgXTtcbiAgICBcdFx0XHRwb3NpdGlvbi56ID0gdGVbIDE0IF07XG5cbiAgICBcdFx0XHQvLyBzY2FsZSB0aGUgcm90YXRpb24gcGFydFxuXG4gICAgXHRcdFx0bWF0cml4LmVsZW1lbnRzLnNldCggdGhpcy5lbGVtZW50cyApOyAvLyBhdCB0aGlzIHBvaW50IG1hdHJpeCBpcyBpbmNvbXBsZXRlIHNvIHdlIGNhbid0IHVzZSAuY29weSgpXG5cbiAgICBcdFx0XHR2YXIgaW52U1ggPSAxIC8gc3g7XG4gICAgXHRcdFx0dmFyIGludlNZID0gMSAvIHN5O1xuICAgIFx0XHRcdHZhciBpbnZTWiA9IDEgLyBzejtcblxuICAgIFx0XHRcdG1hdHJpeC5lbGVtZW50c1sgMCBdICo9IGludlNYO1xuICAgIFx0XHRcdG1hdHJpeC5lbGVtZW50c1sgMSBdICo9IGludlNYO1xuICAgIFx0XHRcdG1hdHJpeC5lbGVtZW50c1sgMiBdICo9IGludlNYO1xuXG4gICAgXHRcdFx0bWF0cml4LmVsZW1lbnRzWyA0IF0gKj0gaW52U1k7XG4gICAgXHRcdFx0bWF0cml4LmVsZW1lbnRzWyA1IF0gKj0gaW52U1k7XG4gICAgXHRcdFx0bWF0cml4LmVsZW1lbnRzWyA2IF0gKj0gaW52U1k7XG5cbiAgICBcdFx0XHRtYXRyaXguZWxlbWVudHNbIDggXSAqPSBpbnZTWjtcbiAgICBcdFx0XHRtYXRyaXguZWxlbWVudHNbIDkgXSAqPSBpbnZTWjtcbiAgICBcdFx0XHRtYXRyaXguZWxlbWVudHNbIDEwIF0gKj0gaW52U1o7XG5cbiAgICBcdFx0XHRxdWF0ZXJuaW9uLnNldEZyb21Sb3RhdGlvbk1hdHJpeCggbWF0cml4ICk7XG5cbiAgICBcdFx0XHRzY2FsZS54ID0gc3g7XG4gICAgXHRcdFx0c2NhbGUueSA9IHN5O1xuICAgIFx0XHRcdHNjYWxlLnogPSBzejtcblxuICAgIFx0XHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHRcdH07XG5cbiAgICBcdH0oKSxcblxuICAgIFx0bWFrZUZydXN0dW06IGZ1bmN0aW9uICggbGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBuZWFyLCBmYXIgKSB7XG5cbiAgICBcdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcbiAgICBcdFx0dmFyIHggPSAyICogbmVhciAvICggcmlnaHQgLSBsZWZ0ICk7XG4gICAgXHRcdHZhciB5ID0gMiAqIG5lYXIgLyAoIHRvcCAtIGJvdHRvbSApO1xuXG4gICAgXHRcdHZhciBhID0gKCByaWdodCArIGxlZnQgKSAvICggcmlnaHQgLSBsZWZ0ICk7XG4gICAgXHRcdHZhciBiID0gKCB0b3AgKyBib3R0b20gKSAvICggdG9wIC0gYm90dG9tICk7XG4gICAgXHRcdHZhciBjID0gLSAoIGZhciArIG5lYXIgKSAvICggZmFyIC0gbmVhciApO1xuICAgIFx0XHR2YXIgZCA9IC0gMiAqIGZhciAqIG5lYXIgLyAoIGZhciAtIG5lYXIgKTtcblxuICAgIFx0XHR0ZVsgMCBdID0geDtcdHRlWyA0IF0gPSAwO1x0dGVbIDggXSA9IGE7XHR0ZVsgMTIgXSA9IDA7XG4gICAgXHRcdHRlWyAxIF0gPSAwO1x0dGVbIDUgXSA9IHk7XHR0ZVsgOSBdID0gYjtcdHRlWyAxMyBdID0gMDtcbiAgICBcdFx0dGVbIDIgXSA9IDA7XHR0ZVsgNiBdID0gMDtcdHRlWyAxMCBdID0gYztcdHRlWyAxNCBdID0gZDtcbiAgICBcdFx0dGVbIDMgXSA9IDA7XHR0ZVsgNyBdID0gMDtcdHRlWyAxMSBdID0gLSAxO1x0dGVbIDE1IF0gPSAwO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRtYWtlUGVyc3BlY3RpdmU6IGZ1bmN0aW9uICggZm92LCBhc3BlY3QsIG5lYXIsIGZhciApIHtcblxuICAgIFx0XHR2YXIgeW1heCA9IG5lYXIgKiBNYXRoLnRhbiggZXhwb3J0cy5NYXRoLkRFRzJSQUQgKiBmb3YgKiAwLjUgKTtcbiAgICBcdFx0dmFyIHltaW4gPSAtIHltYXg7XG4gICAgXHRcdHZhciB4bWluID0geW1pbiAqIGFzcGVjdDtcbiAgICBcdFx0dmFyIHhtYXggPSB5bWF4ICogYXNwZWN0O1xuXG4gICAgXHRcdHJldHVybiB0aGlzLm1ha2VGcnVzdHVtKCB4bWluLCB4bWF4LCB5bWluLCB5bWF4LCBuZWFyLCBmYXIgKTtcblxuICAgIFx0fSxcblxuICAgIFx0bWFrZU9ydGhvZ3JhcGhpYzogZnVuY3Rpb24gKCBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20sIG5lYXIsIGZhciApIHtcblxuICAgIFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuICAgIFx0XHR2YXIgdyA9IDEuMCAvICggcmlnaHQgLSBsZWZ0ICk7XG4gICAgXHRcdHZhciBoID0gMS4wIC8gKCB0b3AgLSBib3R0b20gKTtcbiAgICBcdFx0dmFyIHAgPSAxLjAgLyAoIGZhciAtIG5lYXIgKTtcblxuICAgIFx0XHR2YXIgeCA9ICggcmlnaHQgKyBsZWZ0ICkgKiB3O1xuICAgIFx0XHR2YXIgeSA9ICggdG9wICsgYm90dG9tICkgKiBoO1xuICAgIFx0XHR2YXIgeiA9ICggZmFyICsgbmVhciApICogcDtcblxuICAgIFx0XHR0ZVsgMCBdID0gMiAqIHc7XHR0ZVsgNCBdID0gMDtcdHRlWyA4IF0gPSAwO1x0dGVbIDEyIF0gPSAtIHg7XG4gICAgXHRcdHRlWyAxIF0gPSAwO1x0dGVbIDUgXSA9IDIgKiBoO1x0dGVbIDkgXSA9IDA7XHR0ZVsgMTMgXSA9IC0geTtcbiAgICBcdFx0dGVbIDIgXSA9IDA7XHR0ZVsgNiBdID0gMDtcdHRlWyAxMCBdID0gLSAyICogcDtcdHRlWyAxNCBdID0gLSB6O1xuICAgIFx0XHR0ZVsgMyBdID0gMDtcdHRlWyA3IF0gPSAwO1x0dGVbIDExIF0gPSAwO1x0dGVbIDE1IF0gPSAxO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRlcXVhbHM6IGZ1bmN0aW9uICggbWF0cml4ICkge1xuXG4gICAgXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG4gICAgXHRcdHZhciBtZSA9IG1hdHJpeC5lbGVtZW50cztcblxuICAgIFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCAxNjsgaSArKyApIHtcblxuICAgIFx0XHRcdGlmICggdGVbIGkgXSAhPT0gbWVbIGkgXSApIHJldHVybiBmYWxzZTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIHRydWU7XG5cbiAgICBcdH0sXG5cbiAgICBcdGZyb21BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xuXG4gICAgXHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG4gICAgXHRcdGZvciggdmFyIGkgPSAwOyBpIDwgMTY7IGkgKysgKSB7XG5cbiAgICBcdFx0XHR0aGlzLmVsZW1lbnRzWyBpIF0gPSBhcnJheVsgaSArIG9mZnNldCBdO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0dG9BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xuXG4gICAgXHRcdGlmICggYXJyYXkgPT09IHVuZGVmaW5lZCApIGFycmF5ID0gW107XG4gICAgXHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG4gICAgXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cbiAgICBcdFx0YXJyYXlbIG9mZnNldCBdID0gdGVbIDAgXTtcbiAgICBcdFx0YXJyYXlbIG9mZnNldCArIDEgXSA9IHRlWyAxIF07XG4gICAgXHRcdGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0ZVsgMiBdO1xuICAgIFx0XHRhcnJheVsgb2Zmc2V0ICsgMyBdID0gdGVbIDMgXTtcblxuICAgIFx0XHRhcnJheVsgb2Zmc2V0ICsgNCBdID0gdGVbIDQgXTtcbiAgICBcdFx0YXJyYXlbIG9mZnNldCArIDUgXSA9IHRlWyA1IF07XG4gICAgXHRcdGFycmF5WyBvZmZzZXQgKyA2IF0gPSB0ZVsgNiBdO1xuICAgIFx0XHRhcnJheVsgb2Zmc2V0ICsgNyBdID0gdGVbIDcgXTtcblxuICAgIFx0XHRhcnJheVsgb2Zmc2V0ICsgOCBdICA9IHRlWyA4IF07XG4gICAgXHRcdGFycmF5WyBvZmZzZXQgKyA5IF0gID0gdGVbIDkgXTtcbiAgICBcdFx0YXJyYXlbIG9mZnNldCArIDEwIF0gPSB0ZVsgMTAgXTtcbiAgICBcdFx0YXJyYXlbIG9mZnNldCArIDExIF0gPSB0ZVsgMTEgXTtcblxuICAgIFx0XHRhcnJheVsgb2Zmc2V0ICsgMTIgXSA9IHRlWyAxMiBdO1xuICAgIFx0XHRhcnJheVsgb2Zmc2V0ICsgMTMgXSA9IHRlWyAxMyBdO1xuICAgIFx0XHRhcnJheVsgb2Zmc2V0ICsgMTQgXSA9IHRlWyAxNCBdO1xuICAgIFx0XHRhcnJheVsgb2Zmc2V0ICsgMTUgXSA9IHRlWyAxNSBdO1xuXG4gICAgXHRcdHJldHVybiBhcnJheTtcblxuICAgIFx0fVxuXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBDdWJlVGV4dHVyZSggaW1hZ2VzLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHksIGVuY29kaW5nICkge1xuXG4gICAgXHRpbWFnZXMgPSBpbWFnZXMgIT09IHVuZGVmaW5lZCA/IGltYWdlcyA6IFtdO1xuICAgIFx0bWFwcGluZyA9IG1hcHBpbmcgIT09IHVuZGVmaW5lZCA/IG1hcHBpbmcgOiBDdWJlUmVmbGVjdGlvbk1hcHBpbmc7XG5cbiAgICBcdFRleHR1cmUuY2FsbCggdGhpcywgaW1hZ2VzLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHksIGVuY29kaW5nICk7XG5cbiAgICBcdHRoaXMuZmxpcFkgPSBmYWxzZTtcblxuICAgIH1cblxuICAgIEN1YmVUZXh0dXJlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRleHR1cmUucHJvdG90eXBlICk7XG4gICAgQ3ViZVRleHR1cmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ3ViZVRleHR1cmU7XG5cbiAgICBDdWJlVGV4dHVyZS5wcm90b3R5cGUuaXNDdWJlVGV4dHVyZSA9IHRydWU7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIEN1YmVUZXh0dXJlLnByb3RvdHlwZSwgJ2ltYWdlcycsIHtcblxuICAgIFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMuaW1hZ2U7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuICAgIFx0XHR0aGlzLmltYWdlID0gdmFsdWU7XG5cbiAgICBcdH1cblxuICAgIH0gKTtcblxuICAgIHZhciBlbXB0eVRleHR1cmUgPSBuZXcgVGV4dHVyZSgpO1xuICAgIHZhciBlbXB0eUN1YmVUZXh0dXJlID0gbmV3IEN1YmVUZXh0dXJlKCk7XG5cbiAgICAvLyAtLS0gQmFzZSBmb3IgaW5uZXIgbm9kZXMgKGluY2x1ZGluZyB0aGUgcm9vdCkgLS0tXG5cbiAgICBmdW5jdGlvbiBVbmlmb3JtQ29udGFpbmVyKCkge1xuXG4gICAgXHR0aGlzLnNlcSA9IFtdO1xuICAgIFx0dGhpcy5tYXAgPSB7fTtcblxuICAgIH1cblxuICAgIC8vIC0tLSBVdGlsaXRpZXMgLS0tXG5cbiAgICAvLyBBcnJheSBDYWNoZXMgKHByb3ZpZGUgdHlwZWQgYXJyYXlzIGZvciB0ZW1wb3JhcnkgYnkgc2l6ZSlcblxuICAgIHZhciBhcnJheUNhY2hlRjMyID0gW107XG4gICAgdmFyIGFycmF5Q2FjaGVJMzIgPSBbXTtcblxuICAgIC8vIEZsYXR0ZW5pbmcgZm9yIGFycmF5cyBvZiB2ZWN0b3JzIGFuZCBtYXRyaWNlc1xuXG4gICAgZnVuY3Rpb24gZmxhdHRlbiggYXJyYXksIG5CbG9ja3MsIGJsb2NrU2l6ZSApIHtcblxuICAgIFx0dmFyIGZpcnN0RWxlbSA9IGFycmF5WyAwIF07XG5cbiAgICBcdGlmICggZmlyc3RFbGVtIDw9IDAgfHwgZmlyc3RFbGVtID4gMCApIHJldHVybiBhcnJheTtcbiAgICBcdC8vIHVub3B0aW1pemVkOiAhIGlzTmFOKCBmaXJzdEVsZW0gKVxuICAgIFx0Ly8gc2VlIGh0dHA6Ly9qYWNrc29uZHVuc3Rhbi5jb20vYXJ0aWNsZXMvOTgzXG5cbiAgICBcdHZhciBuID0gbkJsb2NrcyAqIGJsb2NrU2l6ZSxcbiAgICBcdFx0ciA9IGFycmF5Q2FjaGVGMzJbIG4gXTtcblxuICAgIFx0aWYgKCByID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0ciA9IG5ldyBGbG9hdDMyQXJyYXkoIG4gKTtcbiAgICBcdFx0YXJyYXlDYWNoZUYzMlsgbiBdID0gcjtcblxuICAgIFx0fVxuXG4gICAgXHRpZiAoIG5CbG9ja3MgIT09IDAgKSB7XG5cbiAgICBcdFx0Zmlyc3RFbGVtLnRvQXJyYXkoIHIsIDAgKTtcblxuICAgIFx0XHRmb3IgKCB2YXIgaSA9IDEsIG9mZnNldCA9IDA7IGkgIT09IG5CbG9ja3M7ICsrIGkgKSB7XG5cbiAgICBcdFx0XHRvZmZzZXQgKz0gYmxvY2tTaXplO1xuICAgIFx0XHRcdGFycmF5WyBpIF0udG9BcnJheSggciwgb2Zmc2V0ICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9XG5cbiAgICBcdHJldHVybiByO1xuXG4gICAgfVxuXG4gICAgLy8gVGV4dHVyZSB1bml0IGFsbG9jYXRpb25cblxuICAgIGZ1bmN0aW9uIGFsbG9jVGV4VW5pdHMoIHJlbmRlcmVyLCBuICkge1xuXG4gICAgXHR2YXIgciA9IGFycmF5Q2FjaGVJMzJbIG4gXTtcblxuICAgIFx0aWYgKCByID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0ciA9IG5ldyBJbnQzMkFycmF5KCBuICk7XG4gICAgXHRcdGFycmF5Q2FjaGVJMzJbIG4gXSA9IHI7XG5cbiAgICBcdH1cblxuICAgIFx0Zm9yICggdmFyIGkgPSAwOyBpICE9PSBuOyArKyBpIClcbiAgICBcdFx0clsgaSBdID0gcmVuZGVyZXIuYWxsb2NUZXh0dXJlVW5pdCgpO1xuXG4gICAgXHRyZXR1cm4gcjtcblxuICAgIH1cblxuICAgIC8vIC0tLSBTZXR0ZXJzIC0tLVxuXG4gICAgLy8gTm90ZTogRGVmaW5pbmcgdGhlc2UgbWV0aG9kcyBleHRlcm5hbGx5LCBiZWNhdXNlIHRoZXkgY29tZSBpbiBhIGJ1bmNoXG4gICAgLy8gYW5kIHRoaXMgd2F5IHRoZWlyIG5hbWVzIG1pbmlmeS5cblxuICAgIC8vIFNpbmdsZSBzY2FsYXJcblxuICAgIGZ1bmN0aW9uIHNldFZhbHVlMWYoIGdsLCB2ICkgeyBnbC51bmlmb3JtMWYoIHRoaXMuYWRkciwgdiApOyB9XG4gICAgZnVuY3Rpb24gc2V0VmFsdWUxaSggZ2wsIHYgKSB7IGdsLnVuaWZvcm0xaSggdGhpcy5hZGRyLCB2ICk7IH1cblxuICAgIC8vIFNpbmdsZSBmbG9hdCB2ZWN0b3IgKGZyb20gZmxhdCBhcnJheSBvciBUSFJFRS5WZWN0b3JOKVxuXG4gICAgZnVuY3Rpb24gc2V0VmFsdWUyZnYoIGdsLCB2ICkge1xuXG4gICAgXHRpZiAoIHYueCA9PT0gdW5kZWZpbmVkICkgZ2wudW5pZm9ybTJmdiggdGhpcy5hZGRyLCB2ICk7XG4gICAgXHRlbHNlIGdsLnVuaWZvcm0yZiggdGhpcy5hZGRyLCB2LngsIHYueSApO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0VmFsdWUzZnYoIGdsLCB2ICkge1xuXG4gICAgXHRpZiAoIHYueCAhPT0gdW5kZWZpbmVkIClcbiAgICBcdFx0Z2wudW5pZm9ybTNmKCB0aGlzLmFkZHIsIHYueCwgdi55LCB2LnogKTtcbiAgICBcdGVsc2UgaWYgKCB2LnIgIT09IHVuZGVmaW5lZCApXG4gICAgXHRcdGdsLnVuaWZvcm0zZiggdGhpcy5hZGRyLCB2LnIsIHYuZywgdi5iICk7XG4gICAgXHRlbHNlXG4gICAgXHRcdGdsLnVuaWZvcm0zZnYoIHRoaXMuYWRkciwgdiApO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0VmFsdWU0ZnYoIGdsLCB2ICkge1xuXG4gICAgXHRpZiAoIHYueCA9PT0gdW5kZWZpbmVkICkgZ2wudW5pZm9ybTRmdiggdGhpcy5hZGRyLCB2ICk7XG4gICAgXHRlbHNlIGdsLnVuaWZvcm00ZiggdGhpcy5hZGRyLCB2LngsIHYueSwgdi56LCB2LncgKTtcblxuICAgIH1cblxuICAgIC8vIFNpbmdsZSBtYXRyaXggKGZyb20gZmxhdCBhcnJheSBvciBNYXRyaXhOKVxuXG4gICAgZnVuY3Rpb24gc2V0VmFsdWUyZm0oIGdsLCB2ICkge1xuXG4gICAgXHRnbC51bmlmb3JtTWF0cml4MmZ2KCB0aGlzLmFkZHIsIGZhbHNlLCB2LmVsZW1lbnRzIHx8IHYgKTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldFZhbHVlM2ZtKCBnbCwgdiApIHtcblxuICAgIFx0Z2wudW5pZm9ybU1hdHJpeDNmdiggdGhpcy5hZGRyLCBmYWxzZSwgdi5lbGVtZW50cyB8fCB2ICk7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRWYWx1ZTRmbSggZ2wsIHYgKSB7XG5cbiAgICBcdGdsLnVuaWZvcm1NYXRyaXg0ZnYoIHRoaXMuYWRkciwgZmFsc2UsIHYuZWxlbWVudHMgfHwgdiApO1xuXG4gICAgfVxuXG4gICAgLy8gU2luZ2xlIHRleHR1cmUgKDJEIC8gQ3ViZSlcblxuICAgIGZ1bmN0aW9uIHNldFZhbHVlVDEoIGdsLCB2LCByZW5kZXJlciApIHtcblxuICAgIFx0dmFyIHVuaXQgPSByZW5kZXJlci5hbGxvY1RleHR1cmVVbml0KCk7XG4gICAgXHRnbC51bmlmb3JtMWkoIHRoaXMuYWRkciwgdW5pdCApO1xuICAgIFx0cmVuZGVyZXIuc2V0VGV4dHVyZTJEKCB2IHx8IGVtcHR5VGV4dHVyZSwgdW5pdCApO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0VmFsdWVUNiggZ2wsIHYsIHJlbmRlcmVyICkge1xuXG4gICAgXHR2YXIgdW5pdCA9IHJlbmRlcmVyLmFsbG9jVGV4dHVyZVVuaXQoKTtcbiAgICBcdGdsLnVuaWZvcm0xaSggdGhpcy5hZGRyLCB1bml0ICk7XG4gICAgXHRyZW5kZXJlci5zZXRUZXh0dXJlQ3ViZSggdiB8fCBlbXB0eUN1YmVUZXh0dXJlLCB1bml0ICk7XG5cbiAgICB9XG5cbiAgICAvLyBJbnRlZ2VyIC8gQm9vbGVhbiB2ZWN0b3JzIG9yIGFycmF5cyB0aGVyZW9mIChhbHdheXMgZmxhdCBhcnJheXMpXG5cbiAgICBmdW5jdGlvbiBzZXRWYWx1ZTJpdiggZ2wsIHYgKSB7IGdsLnVuaWZvcm0yaXYoIHRoaXMuYWRkciwgdiApOyB9XG4gICAgZnVuY3Rpb24gc2V0VmFsdWUzaXYoIGdsLCB2ICkgeyBnbC51bmlmb3JtM2l2KCB0aGlzLmFkZHIsIHYgKTsgfVxuICAgIGZ1bmN0aW9uIHNldFZhbHVlNGl2KCBnbCwgdiApIHsgZ2wudW5pZm9ybTRpdiggdGhpcy5hZGRyLCB2ICk7IH1cblxuICAgIC8vIEhlbHBlciB0byBwaWNrIHRoZSByaWdodCBzZXR0ZXIgZm9yIHRoZSBzaW5ndWxhciBjYXNlXG5cbiAgICBmdW5jdGlvbiBnZXRTaW5ndWxhclNldHRlciggdHlwZSApIHtcblxuICAgIFx0c3dpdGNoICggdHlwZSApIHtcblxuICAgIFx0XHRjYXNlIDB4MTQwNjogcmV0dXJuIHNldFZhbHVlMWY7IC8vIEZMT0FUXG4gICAgXHRcdGNhc2UgMHg4YjUwOiByZXR1cm4gc2V0VmFsdWUyZnY7IC8vIF9WRUMyXG4gICAgXHRcdGNhc2UgMHg4YjUxOiByZXR1cm4gc2V0VmFsdWUzZnY7IC8vIF9WRUMzXG4gICAgXHRcdGNhc2UgMHg4YjUyOiByZXR1cm4gc2V0VmFsdWU0ZnY7IC8vIF9WRUM0XG5cbiAgICBcdFx0Y2FzZSAweDhiNWE6IHJldHVybiBzZXRWYWx1ZTJmbTsgLy8gX01BVDJcbiAgICBcdFx0Y2FzZSAweDhiNWI6IHJldHVybiBzZXRWYWx1ZTNmbTsgLy8gX01BVDNcbiAgICBcdFx0Y2FzZSAweDhiNWM6IHJldHVybiBzZXRWYWx1ZTRmbTsgLy8gX01BVDRcblxuICAgIFx0XHRjYXNlIDB4OGI1ZTogcmV0dXJuIHNldFZhbHVlVDE7IC8vIFNBTVBMRVJfMkRcbiAgICBcdFx0Y2FzZSAweDhiNjA6IHJldHVybiBzZXRWYWx1ZVQ2OyAvLyBTQU1QTEVSX0NVQkVcblxuICAgIFx0XHRjYXNlIDB4MTQwNDogY2FzZSAweDhiNTY6IHJldHVybiBzZXRWYWx1ZTFpOyAvLyBJTlQsIEJPT0xcbiAgICBcdFx0Y2FzZSAweDhiNTM6IGNhc2UgMHg4YjU3OiByZXR1cm4gc2V0VmFsdWUyaXY7IC8vIF9WRUMyXG4gICAgXHRcdGNhc2UgMHg4YjU0OiBjYXNlIDB4OGI1ODogcmV0dXJuIHNldFZhbHVlM2l2OyAvLyBfVkVDM1xuICAgIFx0XHRjYXNlIDB4OGI1NTogY2FzZSAweDhiNTk6IHJldHVybiBzZXRWYWx1ZTRpdjsgLy8gX1ZFQzRcblxuICAgIFx0fVxuXG4gICAgfVxuXG4gICAgLy8gQXJyYXkgb2Ygc2NhbGFyc1xuXG4gICAgZnVuY3Rpb24gc2V0VmFsdWUxZnYoIGdsLCB2ICkgeyBnbC51bmlmb3JtMWZ2KCB0aGlzLmFkZHIsIHYgKTsgfVxuICAgIGZ1bmN0aW9uIHNldFZhbHVlMWl2KCBnbCwgdiApIHsgZ2wudW5pZm9ybTFpdiggdGhpcy5hZGRyLCB2ICk7IH1cblxuICAgIC8vIEFycmF5IG9mIHZlY3RvcnMgKGZsYXQgb3IgZnJvbSBUSFJFRSBjbGFzc2VzKVxuXG4gICAgZnVuY3Rpb24gc2V0VmFsdWVWMmEoIGdsLCB2ICkge1xuXG4gICAgXHRnbC51bmlmb3JtMmZ2KCB0aGlzLmFkZHIsIGZsYXR0ZW4oIHYsIHRoaXMuc2l6ZSwgMiApICk7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRWYWx1ZVYzYSggZ2wsIHYgKSB7XG5cbiAgICBcdGdsLnVuaWZvcm0zZnYoIHRoaXMuYWRkciwgZmxhdHRlbiggdiwgdGhpcy5zaXplLCAzICkgKTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldFZhbHVlVjRhKCBnbCwgdiApIHtcblxuICAgIFx0Z2wudW5pZm9ybTRmdiggdGhpcy5hZGRyLCBmbGF0dGVuKCB2LCB0aGlzLnNpemUsIDQgKSApO1xuXG4gICAgfVxuXG4gICAgLy8gQXJyYXkgb2YgbWF0cmljZXMgKGZsYXQgb3IgZnJvbSBUSFJFRSBjbGFzZXMpXG5cbiAgICBmdW5jdGlvbiBzZXRWYWx1ZU0yYSggZ2wsIHYgKSB7XG5cbiAgICBcdGdsLnVuaWZvcm1NYXRyaXgyZnYoIHRoaXMuYWRkciwgZmFsc2UsIGZsYXR0ZW4oIHYsIHRoaXMuc2l6ZSwgNCApICk7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRWYWx1ZU0zYSggZ2wsIHYgKSB7XG5cbiAgICBcdGdsLnVuaWZvcm1NYXRyaXgzZnYoIHRoaXMuYWRkciwgZmFsc2UsIGZsYXR0ZW4oIHYsIHRoaXMuc2l6ZSwgOSApICk7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRWYWx1ZU00YSggZ2wsIHYgKSB7XG5cbiAgICBcdGdsLnVuaWZvcm1NYXRyaXg0ZnYoIHRoaXMuYWRkciwgZmFsc2UsIGZsYXR0ZW4oIHYsIHRoaXMuc2l6ZSwgMTYgKSApO1xuXG4gICAgfVxuXG4gICAgLy8gQXJyYXkgb2YgdGV4dHVyZXMgKDJEIC8gQ3ViZSlcblxuICAgIGZ1bmN0aW9uIHNldFZhbHVlVDFhKCBnbCwgdiwgcmVuZGVyZXIgKSB7XG5cbiAgICBcdHZhciBuID0gdi5sZW5ndGgsXG4gICAgXHRcdHVuaXRzID0gYWxsb2NUZXhVbml0cyggcmVuZGVyZXIsIG4gKTtcblxuICAgIFx0Z2wudW5pZm9ybTFpdiggdGhpcy5hZGRyLCB1bml0cyApO1xuXG4gICAgXHRmb3IgKCB2YXIgaSA9IDA7IGkgIT09IG47ICsrIGkgKSB7XG5cbiAgICBcdFx0cmVuZGVyZXIuc2V0VGV4dHVyZTJEKCB2WyBpIF0gfHwgZW1wdHlUZXh0dXJlLCB1bml0c1sgaSBdICk7XG5cbiAgICBcdH1cblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldFZhbHVlVDZhKCBnbCwgdiwgcmVuZGVyZXIgKSB7XG5cbiAgICBcdHZhciBuID0gdi5sZW5ndGgsXG4gICAgXHRcdHVuaXRzID0gYWxsb2NUZXhVbml0cyggcmVuZGVyZXIsIG4gKTtcblxuICAgIFx0Z2wudW5pZm9ybTFpdiggdGhpcy5hZGRyLCB1bml0cyApO1xuXG4gICAgXHRmb3IgKCB2YXIgaSA9IDA7IGkgIT09IG47ICsrIGkgKSB7XG5cbiAgICBcdFx0cmVuZGVyZXIuc2V0VGV4dHVyZUN1YmUoIHZbIGkgXSB8fCBlbXB0eUN1YmVUZXh0dXJlLCB1bml0c1sgaSBdICk7XG5cbiAgICBcdH1cblxuICAgIH1cblxuICAgIC8vIEhlbHBlciB0byBwaWNrIHRoZSByaWdodCBzZXR0ZXIgZm9yIGEgcHVyZSAoYm90dG9tLWxldmVsKSBhcnJheVxuXG4gICAgZnVuY3Rpb24gZ2V0UHVyZUFycmF5U2V0dGVyKCB0eXBlICkge1xuXG4gICAgXHRzd2l0Y2ggKCB0eXBlICkge1xuXG4gICAgXHRcdGNhc2UgMHgxNDA2OiByZXR1cm4gc2V0VmFsdWUxZnY7IC8vIEZMT0FUXG4gICAgXHRcdGNhc2UgMHg4YjUwOiByZXR1cm4gc2V0VmFsdWVWMmE7IC8vIF9WRUMyXG4gICAgXHRcdGNhc2UgMHg4YjUxOiByZXR1cm4gc2V0VmFsdWVWM2E7IC8vIF9WRUMzXG4gICAgXHRcdGNhc2UgMHg4YjUyOiByZXR1cm4gc2V0VmFsdWVWNGE7IC8vIF9WRUM0XG5cbiAgICBcdFx0Y2FzZSAweDhiNWE6IHJldHVybiBzZXRWYWx1ZU0yYTsgLy8gX01BVDJcbiAgICBcdFx0Y2FzZSAweDhiNWI6IHJldHVybiBzZXRWYWx1ZU0zYTsgLy8gX01BVDNcbiAgICBcdFx0Y2FzZSAweDhiNWM6IHJldHVybiBzZXRWYWx1ZU00YTsgLy8gX01BVDRcblxuICAgIFx0XHRjYXNlIDB4OGI1ZTogcmV0dXJuIHNldFZhbHVlVDFhOyAvLyBTQU1QTEVSXzJEXG4gICAgXHRcdGNhc2UgMHg4YjYwOiByZXR1cm4gc2V0VmFsdWVUNmE7IC8vIFNBTVBMRVJfQ1VCRVxuXG4gICAgXHRcdGNhc2UgMHgxNDA0OiBjYXNlIDB4OGI1NjogcmV0dXJuIHNldFZhbHVlMWl2OyAvLyBJTlQsIEJPT0xcbiAgICBcdFx0Y2FzZSAweDhiNTM6IGNhc2UgMHg4YjU3OiByZXR1cm4gc2V0VmFsdWUyaXY7IC8vIF9WRUMyXG4gICAgXHRcdGNhc2UgMHg4YjU0OiBjYXNlIDB4OGI1ODogcmV0dXJuIHNldFZhbHVlM2l2OyAvLyBfVkVDM1xuICAgIFx0XHRjYXNlIDB4OGI1NTogY2FzZSAweDhiNTk6IHJldHVybiBzZXRWYWx1ZTRpdjsgLy8gX1ZFQzRcblxuICAgIFx0fVxuXG4gICAgfVxuXG4gICAgLy8gLS0tIFVuaWZvcm0gQ2xhc3NlcyAtLS1cblxuICAgIGZ1bmN0aW9uIFNpbmdsZVVuaWZvcm0oIGlkLCBhY3RpdmVJbmZvLCBhZGRyICkge1xuXG4gICAgXHR0aGlzLmlkID0gaWQ7XG4gICAgXHR0aGlzLmFkZHIgPSBhZGRyO1xuICAgIFx0dGhpcy5zZXRWYWx1ZSA9IGdldFNpbmd1bGFyU2V0dGVyKCBhY3RpdmVJbmZvLnR5cGUgKTtcblxuICAgIFx0Ly8gdGhpcy5wYXRoID0gYWN0aXZlSW5mby5uYW1lOyAvLyBERUJVR1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gUHVyZUFycmF5VW5pZm9ybSggaWQsIGFjdGl2ZUluZm8sIGFkZHIgKSB7XG5cbiAgICBcdHRoaXMuaWQgPSBpZDtcbiAgICBcdHRoaXMuYWRkciA9IGFkZHI7XG4gICAgXHR0aGlzLnNpemUgPSBhY3RpdmVJbmZvLnNpemU7XG4gICAgXHR0aGlzLnNldFZhbHVlID0gZ2V0UHVyZUFycmF5U2V0dGVyKCBhY3RpdmVJbmZvLnR5cGUgKTtcblxuICAgIFx0Ly8gdGhpcy5wYXRoID0gYWN0aXZlSW5mby5uYW1lOyAvLyBERUJVR1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gU3RydWN0dXJlZFVuaWZvcm0oIGlkICkge1xuXG4gICAgXHR0aGlzLmlkID0gaWQ7XG5cbiAgICBcdFVuaWZvcm1Db250YWluZXIuY2FsbCggdGhpcyApOyAvLyBtaXgtaW5cblxuICAgIH1cblxuICAgIFN0cnVjdHVyZWRVbmlmb3JtLnByb3RvdHlwZS5zZXRWYWx1ZSA9IGZ1bmN0aW9uKCBnbCwgdmFsdWUgKSB7XG5cbiAgICBcdC8vIE5vdGU6IERvbid0IG5lZWQgYW4gZXh0cmEgJ3JlbmRlcmVyJyBwYXJhbWV0ZXIsIHNpbmNlIHNhbXBsZXJzXG4gICAgXHQvLyBhcmUgbm90IGFsbG93ZWQgaW4gc3RydWN0dXJlZCB1bmlmb3Jtcy5cblxuICAgIFx0dmFyIHNlcSA9IHRoaXMuc2VxO1xuXG4gICAgXHRmb3IgKCB2YXIgaSA9IDAsIG4gPSBzZXEubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xuXG4gICAgXHRcdHZhciB1ID0gc2VxWyBpIF07XG4gICAgXHRcdHUuc2V0VmFsdWUoIGdsLCB2YWx1ZVsgdS5pZCBdICk7XG5cbiAgICBcdH1cblxuICAgIH07XG5cbiAgICAvLyAtLS0gVG9wLWxldmVsIC0tLVxuXG4gICAgLy8gUGFyc2VyIC0gYnVpbGRzIHVwIHRoZSBwcm9wZXJ0eSB0cmVlIGZyb20gdGhlIHBhdGggc3RyaW5nc1xuXG4gICAgdmFyIFJlUGF0aFBhcnQgPSAvKFtcXHdcXGRfXSspKFxcXSk/KFxcW3xcXC4pPy9nO1xuXG4gICAgLy8gZXh0cmFjdHNcbiAgICAvLyBcdC0gdGhlIGlkZW50aWZpZXIgKG1lbWJlciBuYW1lIG9yIGFycmF5IGluZGV4KVxuICAgIC8vICAtIGZvbGxvd2VkIGJ5IGFuIG9wdGlvbmFsIHJpZ2h0IGJyYWNrZXQgKGZvdW5kIHdoZW4gYXJyYXkgaW5kZXgpXG4gICAgLy8gIC0gZm9sbG93ZWQgYnkgYW4gb3B0aW9uYWwgbGVmdCBicmFja2V0IG9yIGRvdCAodHlwZSBvZiBzdWJzY3JpcHQpXG4gICAgLy9cbiAgICAvLyBOb3RlOiBUaGVzZSBwb3J0aW9ucyBjYW4gYmUgcmVhZCBpbiBhIG5vbi1vdmVybGFwcGluZyBmYXNoaW9uIGFuZFxuICAgIC8vIGFsbG93IHN0cmFpZ2h0Zm9yd2FyZCBwYXJzaW5nIG9mIHRoZSBoaWVyYXJjaHkgdGhhdCBXZWJHTCBlbmNvZGVzXG4gICAgLy8gaW4gdGhlIHVuaWZvcm0gbmFtZXMuXG5cbiAgICBmdW5jdGlvbiBhZGRVbmlmb3JtKCBjb250YWluZXIsIHVuaWZvcm1PYmplY3QgKSB7XG5cbiAgICBcdGNvbnRhaW5lci5zZXEucHVzaCggdW5pZm9ybU9iamVjdCApO1xuICAgIFx0Y29udGFpbmVyLm1hcFsgdW5pZm9ybU9iamVjdC5pZCBdID0gdW5pZm9ybU9iamVjdDtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlVW5pZm9ybSggYWN0aXZlSW5mbywgYWRkciwgY29udGFpbmVyICkge1xuXG4gICAgXHR2YXIgcGF0aCA9IGFjdGl2ZUluZm8ubmFtZSxcbiAgICBcdFx0cGF0aExlbmd0aCA9IHBhdGgubGVuZ3RoO1xuXG4gICAgXHQvLyByZXNldCBSZWdFeHAgb2JqZWN0LCBiZWNhdXNlIG9mIHRoZSBlYXJseSBleGl0IG9mIGEgcHJldmlvdXMgcnVuXG4gICAgXHRSZVBhdGhQYXJ0Lmxhc3RJbmRleCA9IDA7XG5cbiAgICBcdGZvciAoOyA7KSB7XG5cbiAgICBcdFx0dmFyIG1hdGNoID0gUmVQYXRoUGFydC5leGVjKCBwYXRoICksXG4gICAgXHRcdFx0bWF0Y2hFbmQgPSBSZVBhdGhQYXJ0Lmxhc3RJbmRleCxcblxuICAgIFx0XHRcdGlkID0gbWF0Y2hbIDEgXSxcbiAgICBcdFx0XHRpZElzSW5kZXggPSBtYXRjaFsgMiBdID09PSAnXScsXG4gICAgXHRcdFx0c3Vic2NyaXB0ID0gbWF0Y2hbIDMgXTtcblxuICAgIFx0XHRpZiAoIGlkSXNJbmRleCApIGlkID0gaWQgfCAwOyAvLyBjb252ZXJ0IHRvIGludGVnZXJcblxuICAgIFx0XHRpZiAoIHN1YnNjcmlwdCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgXHRcdFx0XHRzdWJzY3JpcHQgPT09ICdbJyAmJiBtYXRjaEVuZCArIDIgPT09IHBhdGhMZW5ndGggKSB7XG4gICAgXHRcdFx0Ly8gYmFyZSBuYW1lIG9yIFwicHVyZVwiIGJvdHRvbS1sZXZlbCBhcnJheSBcIlswXVwiIHN1ZmZpeFxuXG4gICAgXHRcdFx0YWRkVW5pZm9ybSggY29udGFpbmVyLCBzdWJzY3JpcHQgPT09IHVuZGVmaW5lZCA/XG4gICAgXHRcdFx0XHRcdG5ldyBTaW5nbGVVbmlmb3JtKCBpZCwgYWN0aXZlSW5mbywgYWRkciApIDpcbiAgICBcdFx0XHRcdFx0bmV3IFB1cmVBcnJheVVuaWZvcm0oIGlkLCBhY3RpdmVJbmZvLCBhZGRyICkgKTtcblxuICAgIFx0XHRcdGJyZWFrO1xuXG4gICAgXHRcdH0gZWxzZSB7XG4gICAgXHRcdFx0Ly8gc3RlcCBpbnRvIGlubmVyIG5vZGUgLyBjcmVhdGUgaXQgaW4gY2FzZSBpdCBkb2Vzbid0IGV4aXN0XG5cbiAgICBcdFx0XHR2YXIgbWFwID0gY29udGFpbmVyLm1hcCxcbiAgICBcdFx0XHRcdG5leHQgPSBtYXBbIGlkIF07XG5cbiAgICBcdFx0XHRpZiAoIG5leHQgPT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0bmV4dCA9IG5ldyBTdHJ1Y3R1cmVkVW5pZm9ybSggaWQgKTtcbiAgICBcdFx0XHRcdGFkZFVuaWZvcm0oIGNvbnRhaW5lciwgbmV4dCApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0Y29udGFpbmVyID0gbmV4dDtcblxuICAgIFx0XHR9XG5cbiAgICBcdH1cblxuICAgIH1cblxuICAgIC8vIFJvb3QgQ29udGFpbmVyXG5cbiAgICBmdW5jdGlvbiBXZWJHTFVuaWZvcm1zKCBnbCwgcHJvZ3JhbSwgcmVuZGVyZXIgKSB7XG5cbiAgICBcdFVuaWZvcm1Db250YWluZXIuY2FsbCggdGhpcyApO1xuXG4gICAgXHR0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG5cbiAgICBcdHZhciBuID0gZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlciggcHJvZ3JhbSwgZ2wuQUNUSVZFX1VOSUZPUk1TICk7XG5cbiAgICBcdGZvciAoIHZhciBpID0gMDsgaSAhPT0gbjsgKysgaSApIHtcblxuICAgIFx0XHR2YXIgaW5mbyA9IGdsLmdldEFjdGl2ZVVuaWZvcm0oIHByb2dyYW0sIGkgKSxcbiAgICBcdFx0XHRwYXRoID0gaW5mby5uYW1lLFxuICAgIFx0XHRcdGFkZHIgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sIHBhdGggKTtcblxuICAgIFx0XHRwYXJzZVVuaWZvcm0oIGluZm8sIGFkZHIsIHRoaXMgKTtcblxuICAgIFx0fVxuXG4gICAgfVxuXG4gICAgV2ViR0xVbmlmb3Jtcy5wcm90b3R5cGUuc2V0VmFsdWUgPSBmdW5jdGlvbiggZ2wsIG5hbWUsIHZhbHVlICkge1xuXG4gICAgXHR2YXIgdSA9IHRoaXMubWFwWyBuYW1lIF07XG5cbiAgICBcdGlmICggdSAhPT0gdW5kZWZpbmVkICkgdS5zZXRWYWx1ZSggZ2wsIHZhbHVlLCB0aGlzLnJlbmRlcmVyICk7XG5cbiAgICB9O1xuXG4gICAgV2ViR0xVbmlmb3Jtcy5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oIGdsLCBvYmplY3QsIG5hbWUgKSB7XG5cbiAgICBcdHZhciB1ID0gdGhpcy5tYXBbIG5hbWUgXTtcblxuICAgIFx0aWYgKCB1ICE9PSB1bmRlZmluZWQgKSB1LnNldFZhbHVlKCBnbCwgb2JqZWN0WyBuYW1lIF0sIHRoaXMucmVuZGVyZXIgKTtcblxuICAgIH07XG5cbiAgICBXZWJHTFVuaWZvcm1zLnByb3RvdHlwZS5zZXRPcHRpb25hbCA9IGZ1bmN0aW9uKCBnbCwgb2JqZWN0LCBuYW1lICkge1xuXG4gICAgXHR2YXIgdiA9IG9iamVjdFsgbmFtZSBdO1xuXG4gICAgXHRpZiAoIHYgIT09IHVuZGVmaW5lZCApIHRoaXMuc2V0VmFsdWUoIGdsLCBuYW1lLCB2ICk7XG5cbiAgICB9O1xuXG5cbiAgICAvLyBTdGF0aWMgaW50ZXJmYWNlXG5cbiAgICBXZWJHTFVuaWZvcm1zLnVwbG9hZCA9IGZ1bmN0aW9uKCBnbCwgc2VxLCB2YWx1ZXMsIHJlbmRlcmVyICkge1xuXG4gICAgXHRmb3IgKCB2YXIgaSA9IDAsIG4gPSBzZXEubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xuXG4gICAgXHRcdHZhciB1ID0gc2VxWyBpIF0sXG4gICAgXHRcdFx0diA9IHZhbHVlc1sgdS5pZCBdO1xuXG4gICAgXHRcdGlmICggdi5uZWVkc1VwZGF0ZSAhPT0gZmFsc2UgKSB7XG4gICAgXHRcdFx0Ly8gbm90ZTogYWx3YXlzIHVwZGF0aW5nIHdoZW4gLm5lZWRzVXBkYXRlIGlzIHVuZGVmaW5lZFxuXG4gICAgXHRcdFx0dS5zZXRWYWx1ZSggZ2wsIHYudmFsdWUsIHJlbmRlcmVyICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9XG5cbiAgICB9O1xuXG4gICAgV2ViR0xVbmlmb3Jtcy5zZXFXaXRoVmFsdWUgPSBmdW5jdGlvbiggc2VxLCB2YWx1ZXMgKSB7XG5cbiAgICBcdHZhciByID0gW107XG5cbiAgICBcdGZvciAoIHZhciBpID0gMCwgbiA9IHNlcS5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XG5cbiAgICBcdFx0dmFyIHUgPSBzZXFbIGkgXTtcbiAgICBcdFx0aWYgKCB1LmlkIGluIHZhbHVlcyApIHIucHVzaCggdSApO1xuXG4gICAgXHR9XG5cbiAgICBcdHJldHVybiByO1xuXG4gICAgfTtcblxuICAgIFdlYkdMVW5pZm9ybXMuc3BsaXREeW5hbWljID0gZnVuY3Rpb24oIHNlcSwgdmFsdWVzICkge1xuXG4gICAgXHR2YXIgciA9IG51bGwsXG4gICAgXHRcdG4gPSBzZXEubGVuZ3RoLFxuICAgIFx0XHR3ID0gMDtcblxuICAgIFx0Zm9yICggdmFyIGkgPSAwOyBpICE9PSBuOyArKyBpICkge1xuXG4gICAgXHRcdHZhciB1ID0gc2VxWyBpIF0sXG4gICAgXHRcdFx0diA9IHZhbHVlc1sgdS5pZCBdO1xuXG4gICAgXHRcdGlmICggdiAmJiB2LmR5bmFtaWMgPT09IHRydWUgKSB7XG5cbiAgICBcdFx0XHRpZiAoIHIgPT09IG51bGwgKSByID0gW107XG4gICAgXHRcdFx0ci5wdXNoKCB1ICk7XG5cbiAgICBcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdC8vIGluLXBsYWNlIGNvbXBhY3QgJ3NlcScsIHJlbW92aW5nIHRoZSBtYXRjaGVzXG4gICAgXHRcdFx0aWYgKCB3IDwgaSApIHNlcVsgdyBdID0gdTtcbiAgICBcdFx0XHQrKyB3O1xuXG4gICAgXHRcdH1cblxuICAgIFx0fVxuXG4gICAgXHRpZiAoIHcgPCBuICkgc2VxLmxlbmd0aCA9IHc7XG5cbiAgICBcdHJldHVybiByO1xuXG4gICAgfTtcblxuICAgIFdlYkdMVW5pZm9ybXMuZXZhbER5bmFtaWMgPSBmdW5jdGlvbiggc2VxLCB2YWx1ZXMsIG9iamVjdCwgbWF0ZXJpYWwsIGNhbWVyYSApIHtcblxuICAgIFx0Zm9yICggdmFyIGkgPSAwLCBuID0gc2VxLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcblxuICAgIFx0XHR2YXIgdiA9IHZhbHVlc1sgc2VxWyBpIF0uaWQgXSxcbiAgICBcdFx0XHRmID0gdi5vblVwZGF0ZUNhbGxiYWNrO1xuXG4gICAgXHRcdGlmICggZiAhPT0gdW5kZWZpbmVkICkgZi5jYWxsKCB2LCBvYmplY3QsIG1hdGVyaWFsLCBjYW1lcmEgKTtcblxuICAgIFx0fVxuXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFVuaWZvcm0gVXRpbGl0aWVzXG4gICAgICovXG5cbiAgICBleHBvcnRzLlVuaWZvcm1zVXRpbHMgPSB7XG5cbiAgICBcdG1lcmdlOiBmdW5jdGlvbiAoIHVuaWZvcm1zICkge1xuXG4gICAgXHRcdHZhciBtZXJnZWQgPSB7fTtcblxuICAgIFx0XHRmb3IgKCB2YXIgdSA9IDA7IHUgPCB1bmlmb3Jtcy5sZW5ndGg7IHUgKysgKSB7XG5cbiAgICBcdFx0XHR2YXIgdG1wID0gdGhpcy5jbG9uZSggdW5pZm9ybXNbIHUgXSApO1xuXG4gICAgXHRcdFx0Zm9yICggdmFyIHAgaW4gdG1wICkge1xuXG4gICAgXHRcdFx0XHRtZXJnZWRbIHAgXSA9IHRtcFsgcCBdO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gbWVyZ2VkO1xuXG4gICAgXHR9LFxuXG4gICAgXHRjbG9uZTogZnVuY3Rpb24gKCB1bmlmb3Jtc19zcmMgKSB7XG5cbiAgICBcdFx0dmFyIHVuaWZvcm1zX2RzdCA9IHt9O1xuXG4gICAgXHRcdGZvciAoIHZhciB1IGluIHVuaWZvcm1zX3NyYyApIHtcblxuICAgIFx0XHRcdHVuaWZvcm1zX2RzdFsgdSBdID0ge307XG5cbiAgICBcdFx0XHRmb3IgKCB2YXIgcCBpbiB1bmlmb3Jtc19zcmNbIHUgXSApIHtcblxuICAgIFx0XHRcdFx0dmFyIHBhcmFtZXRlcl9zcmMgPSB1bmlmb3Jtc19zcmNbIHUgXVsgcCBdO1xuXG4gICAgXHRcdFx0XHRpZiAoIChwYXJhbWV0ZXJfc3JjICYmIHBhcmFtZXRlcl9zcmMuaXNDb2xvcikgfHxcbiAgICBcdFx0XHRcdFx0IChwYXJhbWV0ZXJfc3JjICYmIHBhcmFtZXRlcl9zcmMuaXNWZWN0b3IyKSB8fFxuICAgIFx0XHRcdFx0XHQgKHBhcmFtZXRlcl9zcmMgJiYgcGFyYW1ldGVyX3NyYy5pc1ZlY3RvcjMpIHx8XG4gICAgXHRcdFx0XHRcdCAocGFyYW1ldGVyX3NyYyAmJiBwYXJhbWV0ZXJfc3JjLmlzVmVjdG9yNCkgfHxcbiAgICBcdFx0XHRcdFx0IChwYXJhbWV0ZXJfc3JjICYmIHBhcmFtZXRlcl9zcmMuaXNNYXRyaXgzKSB8fFxuICAgIFx0XHRcdFx0XHQgKHBhcmFtZXRlcl9zcmMgJiYgcGFyYW1ldGVyX3NyYy5pc01hdHJpeDQpIHx8XG4gICAgXHRcdFx0XHRcdCAocGFyYW1ldGVyX3NyYyAmJiBwYXJhbWV0ZXJfc3JjLmlzVGV4dHVyZSkgKSB7XG5cbiAgICBcdFx0XHRcdFx0dW5pZm9ybXNfZHN0WyB1IF1bIHAgXSA9IHBhcmFtZXRlcl9zcmMuY2xvbmUoKTtcblxuICAgIFx0XHRcdFx0fSBlbHNlIGlmICggQXJyYXkuaXNBcnJheSggcGFyYW1ldGVyX3NyYyApICkge1xuXG4gICAgXHRcdFx0XHRcdHVuaWZvcm1zX2RzdFsgdSBdWyBwIF0gPSBwYXJhbWV0ZXJfc3JjLnNsaWNlKCk7XG5cbiAgICBcdFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdFx0dW5pZm9ybXNfZHN0WyB1IF1bIHAgXSA9IHBhcmFtZXRlcl9zcmM7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIHVuaWZvcm1zX2RzdDtcblxuICAgIFx0fVxuXG4gICAgfTtcblxuICAgIHZhciBhbHBoYW1hcF9mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9BTFBIQU1BUFxcblxcdGRpZmZ1c2VDb2xvci5hICo9IHRleHR1cmUyRCggYWxwaGFNYXAsIHZVdiApLmc7XFxuI2VuZGlmXFxuXCI7XG5cbiAgICB2YXIgYWxwaGFtYXBfcGFyc19mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9BTFBIQU1BUFxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIGFscGhhTWFwO1xcbiNlbmRpZlxcblwiO1xuXG4gICAgdmFyIGFscGhhdGVzdF9mcmFnbWVudCA9IFwiI2lmZGVmIEFMUEhBVEVTVFxcblxcdGlmICggZGlmZnVzZUNvbG9yLmEgPCBBTFBIQVRFU1QgKSBkaXNjYXJkO1xcbiNlbmRpZlxcblwiO1xuXG4gICAgdmFyIGFvbWFwX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX0FPTUFQXFxuXFx0ZmxvYXQgYW1iaWVudE9jY2x1c2lvbiA9ICggdGV4dHVyZTJEKCBhb01hcCwgdlV2MiApLnIgLSAxLjAgKSAqIGFvTWFwSW50ZW5zaXR5ICsgMS4wO1xcblxcdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSAqPSBhbWJpZW50T2NjbHVzaW9uO1xcblxcdCNpZiBkZWZpbmVkKCBVU0VfRU5WTUFQICkgJiYgZGVmaW5lZCggUEhZU0lDQUwgKVxcblxcdFxcdGZsb2F0IGRvdE5WID0gc2F0dXJhdGUoIGRvdCggZ2VvbWV0cnkubm9ybWFsLCBnZW9tZXRyeS52aWV3RGlyICkgKTtcXG5cXHRcXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdFNwZWN1bGFyICo9IGNvbXB1dGVTcGVjdWxhck9jY2x1c2lvbiggZG90TlYsIGFtYmllbnRPY2NsdXNpb24sIG1hdGVyaWFsLnNwZWN1bGFyUm91Z2huZXNzICk7XFxuXFx0I2VuZGlmXFxuI2VuZGlmXFxuXCI7XG5cbiAgICB2YXIgYW9tYXBfcGFyc19mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9BT01BUFxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIGFvTWFwO1xcblxcdHVuaWZvcm0gZmxvYXQgYW9NYXBJbnRlbnNpdHk7XFxuI2VuZGlmXCI7XG5cbiAgICB2YXIgYmVnaW5fdmVydGV4ID0gXCJcXG52ZWMzIHRyYW5zZm9ybWVkID0gdmVjMyggcG9zaXRpb24gKTtcXG5cIjtcblxuICAgIHZhciBiZWdpbm5vcm1hbF92ZXJ0ZXggPSBcIlxcbnZlYzMgb2JqZWN0Tm9ybWFsID0gdmVjMyggbm9ybWFsICk7XFxuXCI7XG5cbiAgICB2YXIgYnNkZnMgPSBcImJvb2wgdGVzdExpZ2h0SW5SYW5nZSggY29uc3QgaW4gZmxvYXQgbGlnaHREaXN0YW5jZSwgY29uc3QgaW4gZmxvYXQgY3V0b2ZmRGlzdGFuY2UgKSB7XFxuXFx0cmV0dXJuIGFueSggYnZlYzIoIGN1dG9mZkRpc3RhbmNlID09IDAuMCwgbGlnaHREaXN0YW5jZSA8IGN1dG9mZkRpc3RhbmNlICkgKTtcXG59XFxuZmxvYXQgcHVuY3R1YWxMaWdodEludGVuc2l0eVRvSXJyYWRpYW5jZUZhY3RvciggY29uc3QgaW4gZmxvYXQgbGlnaHREaXN0YW5jZSwgY29uc3QgaW4gZmxvYXQgY3V0b2ZmRGlzdGFuY2UsIGNvbnN0IGluIGZsb2F0IGRlY2F5RXhwb25lbnQgKSB7XFxuXFx0XFx0aWYoIGRlY2F5RXhwb25lbnQgPiAwLjAgKSB7XFxuI2lmIGRlZmluZWQgKCBQSFlTSUNBTExZX0NPUlJFQ1RfTElHSFRTIClcXG5cXHRcXHRcXHRmbG9hdCBkaXN0YW5jZUZhbGxvZmYgPSAxLjAgLyBtYXgoIHBvdyggbGlnaHREaXN0YW5jZSwgZGVjYXlFeHBvbmVudCApLCAwLjAxICk7XFxuXFx0XFx0XFx0ZmxvYXQgbWF4RGlzdGFuY2VDdXRvZmZGYWN0b3IgPSBwb3cyKCBzYXR1cmF0ZSggMS4wIC0gcG93NCggbGlnaHREaXN0YW5jZSAvIGN1dG9mZkRpc3RhbmNlICkgKSApO1xcblxcdFxcdFxcdHJldHVybiBkaXN0YW5jZUZhbGxvZmYgKiBtYXhEaXN0YW5jZUN1dG9mZkZhY3RvcjtcXG4jZWxzZVxcblxcdFxcdFxcdHJldHVybiBwb3coIHNhdHVyYXRlKCAtbGlnaHREaXN0YW5jZSAvIGN1dG9mZkRpc3RhbmNlICsgMS4wICksIGRlY2F5RXhwb25lbnQgKTtcXG4jZW5kaWZcXG5cXHRcXHR9XFxuXFx0XFx0cmV0dXJuIDEuMDtcXG59XFxudmVjMyBCUkRGX0RpZmZ1c2VfTGFtYmVydCggY29uc3QgaW4gdmVjMyBkaWZmdXNlQ29sb3IgKSB7XFxuXFx0cmV0dXJuIFJFQ0lQUk9DQUxfUEkgKiBkaWZmdXNlQ29sb3I7XFxufVxcbnZlYzMgRl9TY2hsaWNrKCBjb25zdCBpbiB2ZWMzIHNwZWN1bGFyQ29sb3IsIGNvbnN0IGluIGZsb2F0IGRvdExIICkge1xcblxcdGZsb2F0IGZyZXNuZWwgPSBleHAyKCAoIC01LjU1NDczICogZG90TEggLSA2Ljk4MzE2ICkgKiBkb3RMSCApO1xcblxcdHJldHVybiAoIDEuMCAtIHNwZWN1bGFyQ29sb3IgKSAqIGZyZXNuZWwgKyBzcGVjdWxhckNvbG9yO1xcbn1cXG5mbG9hdCBHX0dHWF9TbWl0aCggY29uc3QgaW4gZmxvYXQgYWxwaGEsIGNvbnN0IGluIGZsb2F0IGRvdE5MLCBjb25zdCBpbiBmbG9hdCBkb3ROViApIHtcXG5cXHRmbG9hdCBhMiA9IHBvdzIoIGFscGhhICk7XFxuXFx0ZmxvYXQgZ2wgPSBkb3ROTCArIHNxcnQoIGEyICsgKCAxLjAgLSBhMiApICogcG93MiggZG90TkwgKSApO1xcblxcdGZsb2F0IGd2ID0gZG90TlYgKyBzcXJ0KCBhMiArICggMS4wIC0gYTIgKSAqIHBvdzIoIGRvdE5WICkgKTtcXG5cXHRyZXR1cm4gMS4wIC8gKCBnbCAqIGd2ICk7XFxufVxcbmZsb2F0IEdfR0dYX1NtaXRoQ29ycmVsYXRlZCggY29uc3QgaW4gZmxvYXQgYWxwaGEsIGNvbnN0IGluIGZsb2F0IGRvdE5MLCBjb25zdCBpbiBmbG9hdCBkb3ROViApIHtcXG5cXHRmbG9hdCBhMiA9IHBvdzIoIGFscGhhICk7XFxuXFx0ZmxvYXQgZ3YgPSBkb3ROTCAqIHNxcnQoIGEyICsgKCAxLjAgLSBhMiApICogcG93MiggZG90TlYgKSApO1xcblxcdGZsb2F0IGdsID0gZG90TlYgKiBzcXJ0KCBhMiArICggMS4wIC0gYTIgKSAqIHBvdzIoIGRvdE5MICkgKTtcXG5cXHRyZXR1cm4gMC41IC8gbWF4KCBndiArIGdsLCBFUFNJTE9OICk7XFxufVxcbmZsb2F0IERfR0dYKCBjb25zdCBpbiBmbG9hdCBhbHBoYSwgY29uc3QgaW4gZmxvYXQgZG90TkggKSB7XFxuXFx0ZmxvYXQgYTIgPSBwb3cyKCBhbHBoYSApO1xcblxcdGZsb2F0IGRlbm9tID0gcG93MiggZG90TkggKSAqICggYTIgLSAxLjAgKSArIDEuMDtcXG5cXHRyZXR1cm4gUkVDSVBST0NBTF9QSSAqIGEyIC8gcG93MiggZGVub20gKTtcXG59XFxudmVjMyBCUkRGX1NwZWN1bGFyX0dHWCggY29uc3QgaW4gSW5jaWRlbnRMaWdodCBpbmNpZGVudExpZ2h0LCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBjb25zdCBpbiB2ZWMzIHNwZWN1bGFyQ29sb3IsIGNvbnN0IGluIGZsb2F0IHJvdWdobmVzcyApIHtcXG5cXHRmbG9hdCBhbHBoYSA9IHBvdzIoIHJvdWdobmVzcyApO1xcblxcdHZlYzMgaGFsZkRpciA9IG5vcm1hbGl6ZSggaW5jaWRlbnRMaWdodC5kaXJlY3Rpb24gKyBnZW9tZXRyeS52aWV3RGlyICk7XFxuXFx0ZmxvYXQgZG90TkwgPSBzYXR1cmF0ZSggZG90KCBnZW9tZXRyeS5ub3JtYWwsIGluY2lkZW50TGlnaHQuZGlyZWN0aW9uICkgKTtcXG5cXHRmbG9hdCBkb3ROViA9IHNhdHVyYXRlKCBkb3QoIGdlb21ldHJ5Lm5vcm1hbCwgZ2VvbWV0cnkudmlld0RpciApICk7XFxuXFx0ZmxvYXQgZG90TkggPSBzYXR1cmF0ZSggZG90KCBnZW9tZXRyeS5ub3JtYWwsIGhhbGZEaXIgKSApO1xcblxcdGZsb2F0IGRvdExIID0gc2F0dXJhdGUoIGRvdCggaW5jaWRlbnRMaWdodC5kaXJlY3Rpb24sIGhhbGZEaXIgKSApO1xcblxcdHZlYzMgRiA9IEZfU2NobGljayggc3BlY3VsYXJDb2xvciwgZG90TEggKTtcXG5cXHRmbG9hdCBHID0gR19HR1hfU21pdGhDb3JyZWxhdGVkKCBhbHBoYSwgZG90TkwsIGRvdE5WICk7XFxuXFx0ZmxvYXQgRCA9IERfR0dYKCBhbHBoYSwgZG90TkggKTtcXG5cXHRyZXR1cm4gRiAqICggRyAqIEQgKTtcXG59XFxudmVjMyBCUkRGX1NwZWN1bGFyX0dHWF9FbnZpcm9ubWVudCggY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSwgY29uc3QgaW4gdmVjMyBzcGVjdWxhckNvbG9yLCBjb25zdCBpbiBmbG9hdCByb3VnaG5lc3MgKSB7XFxuXFx0ZmxvYXQgZG90TlYgPSBzYXR1cmF0ZSggZG90KCBnZW9tZXRyeS5ub3JtYWwsIGdlb21ldHJ5LnZpZXdEaXIgKSApO1xcblxcdGNvbnN0IHZlYzQgYzAgPSB2ZWM0KCAtIDEsIC0gMC4wMjc1LCAtIDAuNTcyLCAwLjAyMiApO1xcblxcdGNvbnN0IHZlYzQgYzEgPSB2ZWM0KCAxLCAwLjA0MjUsIDEuMDQsIC0gMC4wNCApO1xcblxcdHZlYzQgciA9IHJvdWdobmVzcyAqIGMwICsgYzE7XFxuXFx0ZmxvYXQgYTAwNCA9IG1pbiggci54ICogci54LCBleHAyKCAtIDkuMjggKiBkb3ROViApICkgKiByLnggKyByLnk7XFxuXFx0dmVjMiBBQiA9IHZlYzIoIC0xLjA0LCAxLjA0ICkgKiBhMDA0ICsgci56dztcXG5cXHRyZXR1cm4gc3BlY3VsYXJDb2xvciAqIEFCLnggKyBBQi55O1xcbn1cXG5mbG9hdCBHX0JsaW5uUGhvbmdfSW1wbGljaXQoICkge1xcblxcdHJldHVybiAwLjI1O1xcbn1cXG5mbG9hdCBEX0JsaW5uUGhvbmcoIGNvbnN0IGluIGZsb2F0IHNoaW5pbmVzcywgY29uc3QgaW4gZmxvYXQgZG90TkggKSB7XFxuXFx0cmV0dXJuIFJFQ0lQUk9DQUxfUEkgKiAoIHNoaW5pbmVzcyAqIDAuNSArIDEuMCApICogcG93KCBkb3ROSCwgc2hpbmluZXNzICk7XFxufVxcbnZlYzMgQlJERl9TcGVjdWxhcl9CbGlublBob25nKCBjb25zdCBpbiBJbmNpZGVudExpZ2h0IGluY2lkZW50TGlnaHQsIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnksIGNvbnN0IGluIHZlYzMgc3BlY3VsYXJDb2xvciwgY29uc3QgaW4gZmxvYXQgc2hpbmluZXNzICkge1xcblxcdHZlYzMgaGFsZkRpciA9IG5vcm1hbGl6ZSggaW5jaWRlbnRMaWdodC5kaXJlY3Rpb24gKyBnZW9tZXRyeS52aWV3RGlyICk7XFxuXFx0ZmxvYXQgZG90TkggPSBzYXR1cmF0ZSggZG90KCBnZW9tZXRyeS5ub3JtYWwsIGhhbGZEaXIgKSApO1xcblxcdGZsb2F0IGRvdExIID0gc2F0dXJhdGUoIGRvdCggaW5jaWRlbnRMaWdodC5kaXJlY3Rpb24sIGhhbGZEaXIgKSApO1xcblxcdHZlYzMgRiA9IEZfU2NobGljayggc3BlY3VsYXJDb2xvciwgZG90TEggKTtcXG5cXHRmbG9hdCBHID0gR19CbGlublBob25nX0ltcGxpY2l0KCApO1xcblxcdGZsb2F0IEQgPSBEX0JsaW5uUGhvbmcoIHNoaW5pbmVzcywgZG90TkggKTtcXG5cXHRyZXR1cm4gRiAqICggRyAqIEQgKTtcXG59XFxuZmxvYXQgR0dYUm91Z2huZXNzVG9CbGlubkV4cG9uZW50KCBjb25zdCBpbiBmbG9hdCBnZ3hSb3VnaG5lc3MgKSB7XFxuXFx0cmV0dXJuICggMi4wIC8gcG93MiggZ2d4Um91Z2huZXNzICsgMC4wMDAxICkgLSAyLjAgKTtcXG59XFxuZmxvYXQgQmxpbm5FeHBvbmVudFRvR0dYUm91Z2huZXNzKCBjb25zdCBpbiBmbG9hdCBibGlubkV4cG9uZW50ICkge1xcblxcdHJldHVybiBzcXJ0KCAyLjAgLyAoIGJsaW5uRXhwb25lbnQgKyAyLjAgKSApO1xcbn1cXG5cIjtcblxuICAgIHZhciBidW1wbWFwX3BhcnNfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfQlVNUE1BUFxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIGJ1bXBNYXA7XFxuXFx0dW5pZm9ybSBmbG9hdCBidW1wU2NhbGU7XFxuXFx0dmVjMiBkSGR4eV9md2QoKSB7XFxuXFx0XFx0dmVjMiBkU1RkeCA9IGRGZHgoIHZVdiApO1xcblxcdFxcdHZlYzIgZFNUZHkgPSBkRmR5KCB2VXYgKTtcXG5cXHRcXHRmbG9hdCBIbGwgPSBidW1wU2NhbGUgKiB0ZXh0dXJlMkQoIGJ1bXBNYXAsIHZVdiApLng7XFxuXFx0XFx0ZmxvYXQgZEJ4ID0gYnVtcFNjYWxlICogdGV4dHVyZTJEKCBidW1wTWFwLCB2VXYgKyBkU1RkeCApLnggLSBIbGw7XFxuXFx0XFx0ZmxvYXQgZEJ5ID0gYnVtcFNjYWxlICogdGV4dHVyZTJEKCBidW1wTWFwLCB2VXYgKyBkU1RkeSApLnggLSBIbGw7XFxuXFx0XFx0cmV0dXJuIHZlYzIoIGRCeCwgZEJ5ICk7XFxuXFx0fVxcblxcdHZlYzMgcGVydHVyYk5vcm1hbEFyYiggdmVjMyBzdXJmX3BvcywgdmVjMyBzdXJmX25vcm0sIHZlYzIgZEhkeHkgKSB7XFxuXFx0XFx0dmVjMyB2U2lnbWFYID0gZEZkeCggc3VyZl9wb3MgKTtcXG5cXHRcXHR2ZWMzIHZTaWdtYVkgPSBkRmR5KCBzdXJmX3BvcyApO1xcblxcdFxcdHZlYzMgdk4gPSBzdXJmX25vcm07XFxuXFx0XFx0dmVjMyBSMSA9IGNyb3NzKCB2U2lnbWFZLCB2TiApO1xcblxcdFxcdHZlYzMgUjIgPSBjcm9zcyggdk4sIHZTaWdtYVggKTtcXG5cXHRcXHRmbG9hdCBmRGV0ID0gZG90KCB2U2lnbWFYLCBSMSApO1xcblxcdFxcdHZlYzMgdkdyYWQgPSBzaWduKCBmRGV0ICkgKiAoIGRIZHh5LnggKiBSMSArIGRIZHh5LnkgKiBSMiApO1xcblxcdFxcdHJldHVybiBub3JtYWxpemUoIGFicyggZkRldCApICogc3VyZl9ub3JtIC0gdkdyYWQgKTtcXG5cXHR9XFxuI2VuZGlmXFxuXCI7XG5cbiAgICB2YXIgY2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50ID0gXCIjaWYgTlVNX0NMSVBQSU5HX1BMQU5FUyA+IDBcXG5cXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fQ0xJUFBJTkdfUExBTkVTOyArKyBpICkge1xcblxcdFxcdHZlYzQgcGxhbmUgPSBjbGlwcGluZ1BsYW5lc1sgaSBdO1xcblxcdFxcdGlmICggZG90KCB2Vmlld1Bvc2l0aW9uLCBwbGFuZS54eXogKSA+IHBsYW5lLncgKSBkaXNjYXJkO1xcblxcdH1cXG4jZW5kaWZcXG5cIjtcblxuICAgIHZhciBjbGlwcGluZ19wbGFuZXNfcGFyc19mcmFnbWVudCA9IFwiI2lmIE5VTV9DTElQUElOR19QTEFORVMgPiAwXFxuXFx0I2lmICEgZGVmaW5lZCggUEhZU0lDQUwgKSAmJiAhIGRlZmluZWQoIFBIT05HIClcXG5cXHRcXHR2YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcXG5cXHQjZW5kaWZcXG5cXHR1bmlmb3JtIHZlYzQgY2xpcHBpbmdQbGFuZXNbIE5VTV9DTElQUElOR19QTEFORVMgXTtcXG4jZW5kaWZcXG5cIjtcblxuICAgIHZhciBjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXggPSBcIiNpZiBOVU1fQ0xJUFBJTkdfUExBTkVTID4gMCAmJiAhIGRlZmluZWQoIFBIWVNJQ0FMICkgJiYgISBkZWZpbmVkKCBQSE9ORyApXFxuXFx0dmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247XFxuI2VuZGlmXFxuXCI7XG5cbiAgICB2YXIgY2xpcHBpbmdfcGxhbmVzX3ZlcnRleCA9IFwiI2lmIE5VTV9DTElQUElOR19QTEFORVMgPiAwICYmICEgZGVmaW5lZCggUEhZU0lDQUwgKSAmJiAhIGRlZmluZWQoIFBIT05HIClcXG5cXHR2Vmlld1Bvc2l0aW9uID0gLSBtdlBvc2l0aW9uLnh5ejtcXG4jZW5kaWZcXG5cIjtcblxuICAgIHZhciBjb2xvcl9mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9DT0xPUlxcblxcdGRpZmZ1c2VDb2xvci5yZ2IgKj0gdkNvbG9yO1xcbiNlbmRpZlwiO1xuXG4gICAgdmFyIGNvbG9yX3BhcnNfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfQ09MT1JcXG5cXHR2YXJ5aW5nIHZlYzMgdkNvbG9yO1xcbiNlbmRpZlxcblwiO1xuXG4gICAgdmFyIGNvbG9yX3BhcnNfdmVydGV4ID0gXCIjaWZkZWYgVVNFX0NPTE9SXFxuXFx0dmFyeWluZyB2ZWMzIHZDb2xvcjtcXG4jZW5kaWZcIjtcblxuICAgIHZhciBjb2xvcl92ZXJ0ZXggPSBcIiNpZmRlZiBVU0VfQ09MT1JcXG5cXHR2Q29sb3IueHl6ID0gY29sb3IueHl6O1xcbiNlbmRpZlwiO1xuXG4gICAgdmFyIGNvbW1vbiA9IFwiI2RlZmluZSBQSSAzLjE0MTU5MjY1MzU5XFxuI2RlZmluZSBQSTIgNi4yODMxODUzMDcxOFxcbiNkZWZpbmUgUkVDSVBST0NBTF9QSSAwLjMxODMwOTg4NjE4XFxuI2RlZmluZSBSRUNJUFJPQ0FMX1BJMiAwLjE1OTE1NDk0XFxuI2RlZmluZSBMT0cyIDEuNDQyNjk1XFxuI2RlZmluZSBFUFNJTE9OIDFlLTZcXG4jZGVmaW5lIHNhdHVyYXRlKGEpIGNsYW1wKCBhLCAwLjAsIDEuMCApXFxuI2RlZmluZSB3aGl0ZUNvbXBsaW1lbnQoYSkgKCAxLjAgLSBzYXR1cmF0ZSggYSApIClcXG5mbG9hdCBwb3cyKCBjb25zdCBpbiBmbG9hdCB4ICkgeyByZXR1cm4geCp4OyB9XFxuZmxvYXQgcG93MyggY29uc3QgaW4gZmxvYXQgeCApIHsgcmV0dXJuIHgqeCp4OyB9XFxuZmxvYXQgcG93NCggY29uc3QgaW4gZmxvYXQgeCApIHsgZmxvYXQgeDIgPSB4Kng7IHJldHVybiB4Mip4MjsgfVxcbmZsb2F0IGF2ZXJhZ2UoIGNvbnN0IGluIHZlYzMgY29sb3IgKSB7IHJldHVybiBkb3QoIGNvbG9yLCB2ZWMzKCAwLjMzMzMgKSApOyB9XFxuaGlnaHAgZmxvYXQgcmFuZCggY29uc3QgaW4gdmVjMiB1diApIHtcXG5cXHRjb25zdCBoaWdocCBmbG9hdCBhID0gMTIuOTg5OCwgYiA9IDc4LjIzMywgYyA9IDQzNzU4LjU0NTM7XFxuXFx0aGlnaHAgZmxvYXQgZHQgPSBkb3QoIHV2Lnh5LCB2ZWMyKCBhLGIgKSApLCBzbiA9IG1vZCggZHQsIFBJICk7XFxuXFx0cmV0dXJuIGZyYWN0KHNpbihzbikgKiBjKTtcXG59XFxuc3RydWN0IEluY2lkZW50TGlnaHQge1xcblxcdHZlYzMgY29sb3I7XFxuXFx0dmVjMyBkaXJlY3Rpb247XFxuXFx0Ym9vbCB2aXNpYmxlO1xcbn07XFxuc3RydWN0IFJlZmxlY3RlZExpZ2h0IHtcXG5cXHR2ZWMzIGRpcmVjdERpZmZ1c2U7XFxuXFx0dmVjMyBkaXJlY3RTcGVjdWxhcjtcXG5cXHR2ZWMzIGluZGlyZWN0RGlmZnVzZTtcXG5cXHR2ZWMzIGluZGlyZWN0U3BlY3VsYXI7XFxufTtcXG5zdHJ1Y3QgR2VvbWV0cmljQ29udGV4dCB7XFxuXFx0dmVjMyBwb3NpdGlvbjtcXG5cXHR2ZWMzIG5vcm1hbDtcXG5cXHR2ZWMzIHZpZXdEaXI7XFxufTtcXG52ZWMzIHRyYW5zZm9ybURpcmVjdGlvbiggaW4gdmVjMyBkaXIsIGluIG1hdDQgbWF0cml4ICkge1xcblxcdHJldHVybiBub3JtYWxpemUoICggbWF0cml4ICogdmVjNCggZGlyLCAwLjAgKSApLnh5eiApO1xcbn1cXG52ZWMzIGludmVyc2VUcmFuc2Zvcm1EaXJlY3Rpb24oIGluIHZlYzMgZGlyLCBpbiBtYXQ0IG1hdHJpeCApIHtcXG5cXHRyZXR1cm4gbm9ybWFsaXplKCAoIHZlYzQoIGRpciwgMC4wICkgKiBtYXRyaXggKS54eXogKTtcXG59XFxudmVjMyBwcm9qZWN0T25QbGFuZShpbiB2ZWMzIHBvaW50LCBpbiB2ZWMzIHBvaW50T25QbGFuZSwgaW4gdmVjMyBwbGFuZU5vcm1hbCApIHtcXG5cXHRmbG9hdCBkaXN0YW5jZSA9IGRvdCggcGxhbmVOb3JtYWwsIHBvaW50IC0gcG9pbnRPblBsYW5lICk7XFxuXFx0cmV0dXJuIC0gZGlzdGFuY2UgKiBwbGFuZU5vcm1hbCArIHBvaW50O1xcbn1cXG5mbG9hdCBzaWRlT2ZQbGFuZSggaW4gdmVjMyBwb2ludCwgaW4gdmVjMyBwb2ludE9uUGxhbmUsIGluIHZlYzMgcGxhbmVOb3JtYWwgKSB7XFxuXFx0cmV0dXJuIHNpZ24oIGRvdCggcG9pbnQgLSBwb2ludE9uUGxhbmUsIHBsYW5lTm9ybWFsICkgKTtcXG59XFxudmVjMyBsaW5lUGxhbmVJbnRlcnNlY3QoIGluIHZlYzMgcG9pbnRPbkxpbmUsIGluIHZlYzMgbGluZURpcmVjdGlvbiwgaW4gdmVjMyBwb2ludE9uUGxhbmUsIGluIHZlYzMgcGxhbmVOb3JtYWwgKSB7XFxuXFx0cmV0dXJuIGxpbmVEaXJlY3Rpb24gKiAoIGRvdCggcGxhbmVOb3JtYWwsIHBvaW50T25QbGFuZSAtIHBvaW50T25MaW5lICkgLyBkb3QoIHBsYW5lTm9ybWFsLCBsaW5lRGlyZWN0aW9uICkgKSArIHBvaW50T25MaW5lO1xcbn1cXG5cIjtcblxuICAgIHZhciBjdWJlX3V2X3JlZmxlY3Rpb25fZnJhZ21lbnQgPSBcIiNpZmRlZiBFTlZNQVBfVFlQRV9DVUJFX1VWXFxuI2RlZmluZSBjdWJlVVZfdGV4dHVyZVNpemUgKDEwMjQuMClcXG5pbnQgZ2V0RmFjZUZyb21EaXJlY3Rpb24odmVjMyBkaXJlY3Rpb24pIHtcXG5cXHR2ZWMzIGFic0RpcmVjdGlvbiA9IGFicyhkaXJlY3Rpb24pO1xcblxcdGludCBmYWNlID0gLTE7XFxuXFx0aWYoIGFic0RpcmVjdGlvbi54ID4gYWJzRGlyZWN0aW9uLnogKSB7XFxuXFx0XFx0aWYoYWJzRGlyZWN0aW9uLnggPiBhYnNEaXJlY3Rpb24ueSApXFxuXFx0XFx0XFx0ZmFjZSA9IGRpcmVjdGlvbi54ID4gMC4wID8gMCA6IDM7XFxuXFx0XFx0ZWxzZVxcblxcdFxcdFxcdGZhY2UgPSBkaXJlY3Rpb24ueSA+IDAuMCA/IDEgOiA0O1xcblxcdH1cXG5cXHRlbHNlIHtcXG5cXHRcXHRpZihhYnNEaXJlY3Rpb24ueiA+IGFic0RpcmVjdGlvbi55IClcXG5cXHRcXHRcXHRmYWNlID0gZGlyZWN0aW9uLnogPiAwLjAgPyAyIDogNTtcXG5cXHRcXHRlbHNlXFxuXFx0XFx0XFx0ZmFjZSA9IGRpcmVjdGlvbi55ID4gMC4wID8gMSA6IDQ7XFxuXFx0fVxcblxcdHJldHVybiBmYWNlO1xcbn1cXG4jZGVmaW5lIGN1YmVVVl9tYXhMb2RzMSAgKGxvZzIoY3ViZVVWX3RleHR1cmVTaXplKjAuMjUpIC0gMS4wKVxcbiNkZWZpbmUgY3ViZVVWX3JhbmdlQ2xhbXAgKGV4cDIoKDYuMCAtIDEuMCkgKiAyLjApKVxcbnZlYzIgTWlwTGV2ZWxJbmZvKCB2ZWMzIHZlYywgZmxvYXQgcm91Z2huZXNzTGV2ZWwsIGZsb2F0IHJvdWdobmVzcyApIHtcXG5cXHRmbG9hdCBzY2FsZSA9IGV4cDIoY3ViZVVWX21heExvZHMxIC0gcm91Z2huZXNzTGV2ZWwpO1xcblxcdGZsb2F0IGR4Um91Z2huZXNzID0gZEZkeChyb3VnaG5lc3MpO1xcblxcdGZsb2F0IGR5Um91Z2huZXNzID0gZEZkeShyb3VnaG5lc3MpO1xcblxcdHZlYzMgZHggPSBkRmR4KCB2ZWMgKiBzY2FsZSAqIGR4Um91Z2huZXNzICk7XFxuXFx0dmVjMyBkeSA9IGRGZHkoIHZlYyAqIHNjYWxlICogZHlSb3VnaG5lc3MgKTtcXG5cXHRmbG9hdCBkID0gbWF4KCBkb3QoIGR4LCBkeCApLCBkb3QoIGR5LCBkeSApICk7XFxuXFx0ZCA9IGNsYW1wKGQsIDEuMCwgY3ViZVVWX3JhbmdlQ2xhbXApO1xcblxcdGZsb2F0IG1pcExldmVsID0gMC41ICogbG9nMihkKTtcXG5cXHRyZXR1cm4gdmVjMihmbG9vcihtaXBMZXZlbCksIGZyYWN0KG1pcExldmVsKSk7XFxufVxcbiNkZWZpbmUgY3ViZVVWX21heExvZHMyIChsb2cyKGN1YmVVVl90ZXh0dXJlU2l6ZSowLjI1KSAtIDIuMClcXG4jZGVmaW5lIGN1YmVVVl9yY3BUZXh0dXJlU2l6ZSAoMS4wIC8gY3ViZVVWX3RleHR1cmVTaXplKVxcbnZlYzIgZ2V0Q3ViZVVWKHZlYzMgZGlyZWN0aW9uLCBmbG9hdCByb3VnaG5lc3NMZXZlbCwgZmxvYXQgbWlwTGV2ZWwpIHtcXG5cXHRtaXBMZXZlbCA9IHJvdWdobmVzc0xldmVsID4gY3ViZVVWX21heExvZHMyIC0gMy4wID8gMC4wIDogbWlwTGV2ZWw7XFxuXFx0ZmxvYXQgYSA9IDE2LjAgKiBjdWJlVVZfcmNwVGV4dHVyZVNpemU7XFxuXFx0dmVjMiBleHAyX3BhY2tlZCA9IGV4cDIoIHZlYzIoIHJvdWdobmVzc0xldmVsLCBtaXBMZXZlbCApICk7XFxuXFx0dmVjMiByY3BfZXhwMl9wYWNrZWQgPSB2ZWMyKCAxLjAgKSAvIGV4cDJfcGFja2VkO1xcblxcdGZsb2F0IHBvd1NjYWxlID0gZXhwMl9wYWNrZWQueCAqIGV4cDJfcGFja2VkLnk7XFxuXFx0ZmxvYXQgc2NhbGUgPSByY3BfZXhwMl9wYWNrZWQueCAqIHJjcF9leHAyX3BhY2tlZC55ICogMC4yNTtcXG5cXHRmbG9hdCBtaXBPZmZzZXQgPSAwLjc1KigxLjAgLSByY3BfZXhwMl9wYWNrZWQueSkgKiByY3BfZXhwMl9wYWNrZWQueDtcXG5cXHRib29sIGJSZXMgPSBtaXBMZXZlbCA9PSAwLjA7XFxuXFx0c2NhbGUgPSAgYlJlcyAmJiAoc2NhbGUgPCBhKSA/IGEgOiBzY2FsZTtcXG5cXHR2ZWMzIHI7XFxuXFx0dmVjMiBvZmZzZXQ7XFxuXFx0aW50IGZhY2UgPSBnZXRGYWNlRnJvbURpcmVjdGlvbihkaXJlY3Rpb24pO1xcblxcdGZsb2F0IHJjcFBvd1NjYWxlID0gMS4wIC8gcG93U2NhbGU7XFxuXFx0aWYoIGZhY2UgPT0gMCkge1xcblxcdFxcdHIgPSB2ZWMzKGRpcmVjdGlvbi54LCAtZGlyZWN0aW9uLnosIGRpcmVjdGlvbi55KTtcXG5cXHRcXHRvZmZzZXQgPSB2ZWMyKDAuMCttaXBPZmZzZXQsMC43NSAqIHJjcFBvd1NjYWxlKTtcXG5cXHRcXHRvZmZzZXQueSA9IGJSZXMgJiYgKG9mZnNldC55IDwgMi4wKmEpID8gIGEgOiBvZmZzZXQueTtcXG5cXHR9XFxuXFx0ZWxzZSBpZiggZmFjZSA9PSAxKSB7XFxuXFx0XFx0ciA9IHZlYzMoZGlyZWN0aW9uLnksIGRpcmVjdGlvbi54LCBkaXJlY3Rpb24ueik7XFxuXFx0XFx0b2Zmc2V0ID0gdmVjMihzY2FsZSttaXBPZmZzZXQsIDAuNzUgKiByY3BQb3dTY2FsZSk7XFxuXFx0XFx0b2Zmc2V0LnkgPSBiUmVzICYmIChvZmZzZXQueSA8IDIuMCphKSA/ICBhIDogb2Zmc2V0Lnk7XFxuXFx0fVxcblxcdGVsc2UgaWYoIGZhY2UgPT0gMikge1xcblxcdFxcdHIgPSB2ZWMzKGRpcmVjdGlvbi56LCBkaXJlY3Rpb24ueCwgZGlyZWN0aW9uLnkpO1xcblxcdFxcdG9mZnNldCA9IHZlYzIoMi4wKnNjYWxlK21pcE9mZnNldCwgMC43NSAqIHJjcFBvd1NjYWxlKTtcXG5cXHRcXHRvZmZzZXQueSA9IGJSZXMgJiYgKG9mZnNldC55IDwgMi4wKmEpID8gIGEgOiBvZmZzZXQueTtcXG5cXHR9XFxuXFx0ZWxzZSBpZiggZmFjZSA9PSAzKSB7XFxuXFx0XFx0ciA9IHZlYzMoZGlyZWN0aW9uLngsIGRpcmVjdGlvbi56LCBkaXJlY3Rpb24ueSk7XFxuXFx0XFx0b2Zmc2V0ID0gdmVjMigwLjArbWlwT2Zmc2V0LDAuNSAqIHJjcFBvd1NjYWxlKTtcXG5cXHRcXHRvZmZzZXQueSA9IGJSZXMgJiYgKG9mZnNldC55IDwgMi4wKmEpID8gIDAuMCA6IG9mZnNldC55O1xcblxcdH1cXG5cXHRlbHNlIGlmKCBmYWNlID09IDQpIHtcXG5cXHRcXHRyID0gdmVjMyhkaXJlY3Rpb24ueSwgZGlyZWN0aW9uLngsIC1kaXJlY3Rpb24ueik7XFxuXFx0XFx0b2Zmc2V0ID0gdmVjMihzY2FsZSttaXBPZmZzZXQsIDAuNSAqIHJjcFBvd1NjYWxlKTtcXG5cXHRcXHRvZmZzZXQueSA9IGJSZXMgJiYgKG9mZnNldC55IDwgMi4wKmEpID8gIDAuMCA6IG9mZnNldC55O1xcblxcdH1cXG5cXHRlbHNlIHtcXG5cXHRcXHRyID0gdmVjMyhkaXJlY3Rpb24ueiwgLWRpcmVjdGlvbi54LCBkaXJlY3Rpb24ueSk7XFxuXFx0XFx0b2Zmc2V0ID0gdmVjMigyLjAqc2NhbGUrbWlwT2Zmc2V0LCAwLjUgKiByY3BQb3dTY2FsZSk7XFxuXFx0XFx0b2Zmc2V0LnkgPSBiUmVzICYmIChvZmZzZXQueSA8IDIuMCphKSA/ICAwLjAgOiBvZmZzZXQueTtcXG5cXHR9XFxuXFx0ciA9IG5vcm1hbGl6ZShyKTtcXG5cXHRmbG9hdCB0ZXhlbE9mZnNldCA9IDAuNSAqIGN1YmVVVl9yY3BUZXh0dXJlU2l6ZTtcXG5cXHR2ZWMyIHMgPSAoIHIueXogLyBhYnMoIHIueCApICsgdmVjMiggMS4wICkgKSAqIDAuNTtcXG5cXHR2ZWMyIGJhc2UgPSBvZmZzZXQgKyB2ZWMyKCB0ZXhlbE9mZnNldCApO1xcblxcdHJldHVybiBiYXNlICsgcyAqICggc2NhbGUgLSAyLjAgKiB0ZXhlbE9mZnNldCApO1xcbn1cXG4jZGVmaW5lIGN1YmVVVl9tYXhMb2RzMyAobG9nMihjdWJlVVZfdGV4dHVyZVNpemUqMC4yNSkgLSAzLjApXFxudmVjNCB0ZXh0dXJlQ3ViZVVWKHZlYzMgcmVmbGVjdGVkRGlyZWN0aW9uLCBmbG9hdCByb3VnaG5lc3MgKSB7XFxuXFx0ZmxvYXQgcm91Z2huZXNzVmFsID0gcm91Z2huZXNzKiBjdWJlVVZfbWF4TG9kczM7XFxuXFx0ZmxvYXQgcjEgPSBmbG9vcihyb3VnaG5lc3NWYWwpO1xcblxcdGZsb2F0IHIyID0gcjEgKyAxLjA7XFxuXFx0ZmxvYXQgdCA9IGZyYWN0KHJvdWdobmVzc1ZhbCk7XFxuXFx0dmVjMiBtaXBJbmZvID0gTWlwTGV2ZWxJbmZvKHJlZmxlY3RlZERpcmVjdGlvbiwgcjEsIHJvdWdobmVzcyk7XFxuXFx0ZmxvYXQgcyA9IG1pcEluZm8ueTtcXG5cXHRmbG9hdCBsZXZlbDAgPSBtaXBJbmZvLng7XFxuXFx0ZmxvYXQgbGV2ZWwxID0gbGV2ZWwwICsgMS4wO1xcblxcdGxldmVsMSA9IGxldmVsMSA+IDUuMCA/IDUuMCA6IGxldmVsMTtcXG5cXHRsZXZlbDAgKz0gbWluKCBmbG9vciggcyArIDAuNSApLCA1LjAgKTtcXG5cXHR2ZWMyIHV2XzEwID0gZ2V0Q3ViZVVWKHJlZmxlY3RlZERpcmVjdGlvbiwgcjEsIGxldmVsMCk7XFxuXFx0dmVjNCBjb2xvcjEwID0gZW52TWFwVGV4ZWxUb0xpbmVhcih0ZXh0dXJlMkQoZW52TWFwLCB1dl8xMCkpO1xcblxcdHZlYzIgdXZfMjAgPSBnZXRDdWJlVVYocmVmbGVjdGVkRGlyZWN0aW9uLCByMiwgbGV2ZWwwKTtcXG5cXHR2ZWM0IGNvbG9yMjAgPSBlbnZNYXBUZXhlbFRvTGluZWFyKHRleHR1cmUyRChlbnZNYXAsIHV2XzIwKSk7XFxuXFx0dmVjNCByZXN1bHQgPSBtaXgoY29sb3IxMCwgY29sb3IyMCwgdCk7XFxuXFx0cmV0dXJuIHZlYzQocmVzdWx0LnJnYiwgMS4wKTtcXG59XFxuI2VuZGlmXFxuXCI7XG5cbiAgICB2YXIgZGVmYXVsdG5vcm1hbF92ZXJ0ZXggPSBcIiNpZmRlZiBGTElQX1NJREVEXFxuXFx0b2JqZWN0Tm9ybWFsID0gLW9iamVjdE5vcm1hbDtcXG4jZW5kaWZcXG52ZWMzIHRyYW5zZm9ybWVkTm9ybWFsID0gbm9ybWFsTWF0cml4ICogb2JqZWN0Tm9ybWFsO1xcblwiO1xuXG4gICAgdmFyIGRpc3BsYWNlbWVudG1hcF9wYXJzX3ZlcnRleCA9IFwiI2lmZGVmIFVTRV9ESVNQTEFDRU1FTlRNQVBcXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBkaXNwbGFjZW1lbnRNYXA7XFxuXFx0dW5pZm9ybSBmbG9hdCBkaXNwbGFjZW1lbnRTY2FsZTtcXG5cXHR1bmlmb3JtIGZsb2F0IGRpc3BsYWNlbWVudEJpYXM7XFxuI2VuZGlmXFxuXCI7XG5cbiAgICB2YXIgZGlzcGxhY2VtZW50bWFwX3ZlcnRleCA9IFwiI2lmZGVmIFVTRV9ESVNQTEFDRU1FTlRNQVBcXG5cXHR0cmFuc2Zvcm1lZCArPSBub3JtYWwgKiAoIHRleHR1cmUyRCggZGlzcGxhY2VtZW50TWFwLCB1diApLnggKiBkaXNwbGFjZW1lbnRTY2FsZSArIGRpc3BsYWNlbWVudEJpYXMgKTtcXG4jZW5kaWZcXG5cIjtcblxuICAgIHZhciBlbWlzc2l2ZW1hcF9mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9FTUlTU0lWRU1BUFxcblxcdHZlYzQgZW1pc3NpdmVDb2xvciA9IHRleHR1cmUyRCggZW1pc3NpdmVNYXAsIHZVdiApO1xcblxcdGVtaXNzaXZlQ29sb3IucmdiID0gZW1pc3NpdmVNYXBUZXhlbFRvTGluZWFyKCBlbWlzc2l2ZUNvbG9yICkucmdiO1xcblxcdHRvdGFsRW1pc3NpdmVSYWRpYW5jZSAqPSBlbWlzc2l2ZUNvbG9yLnJnYjtcXG4jZW5kaWZcXG5cIjtcblxuICAgIHZhciBlbWlzc2l2ZW1hcF9wYXJzX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX0VNSVNTSVZFTUFQXFxuXFx0dW5pZm9ybSBzYW1wbGVyMkQgZW1pc3NpdmVNYXA7XFxuI2VuZGlmXFxuXCI7XG5cbiAgICB2YXIgZW5jb2RpbmdzX2ZyYWdtZW50ID0gXCIgIGdsX0ZyYWdDb2xvciA9IGxpbmVhclRvT3V0cHV0VGV4ZWwoIGdsX0ZyYWdDb2xvciApO1xcblwiO1xuXG4gICAgdmFyIGVuY29kaW5nc19wYXJzX2ZyYWdtZW50ID0gXCJcXG52ZWM0IExpbmVhclRvTGluZWFyKCBpbiB2ZWM0IHZhbHVlICkge1xcbiAgcmV0dXJuIHZhbHVlO1xcbn1cXG52ZWM0IEdhbW1hVG9MaW5lYXIoIGluIHZlYzQgdmFsdWUsIGluIGZsb2F0IGdhbW1hRmFjdG9yICkge1xcbiAgcmV0dXJuIHZlYzQoIHBvdyggdmFsdWUueHl6LCB2ZWMzKCBnYW1tYUZhY3RvciApICksIHZhbHVlLncgKTtcXG59XFxudmVjNCBMaW5lYXJUb0dhbW1hKCBpbiB2ZWM0IHZhbHVlLCBpbiBmbG9hdCBnYW1tYUZhY3RvciApIHtcXG4gIHJldHVybiB2ZWM0KCBwb3coIHZhbHVlLnh5eiwgdmVjMyggMS4wIC8gZ2FtbWFGYWN0b3IgKSApLCB2YWx1ZS53ICk7XFxufVxcbnZlYzQgc1JHQlRvTGluZWFyKCBpbiB2ZWM0IHZhbHVlICkge1xcbiAgcmV0dXJuIHZlYzQoIG1peCggcG93KCB2YWx1ZS5yZ2IgKiAwLjk0Nzg2NzI5ODYgKyB2ZWMzKCAwLjA1MjEzMjcwMTQgKSwgdmVjMyggMi40ICkgKSwgdmFsdWUucmdiICogMC4wNzczOTkzODA4LCB2ZWMzKCBsZXNzVGhhbkVxdWFsKCB2YWx1ZS5yZ2IsIHZlYzMoIDAuMDQwNDUgKSApICkgKSwgdmFsdWUudyApO1xcbn1cXG52ZWM0IExpbmVhclRvc1JHQiggaW4gdmVjNCB2YWx1ZSApIHtcXG4gIHJldHVybiB2ZWM0KCBtaXgoIHBvdyggdmFsdWUucmdiLCB2ZWMzKCAwLjQxNjY2ICkgKSAqIDEuMDU1IC0gdmVjMyggMC4wNTUgKSwgdmFsdWUucmdiICogMTIuOTIsIHZlYzMoIGxlc3NUaGFuRXF1YWwoIHZhbHVlLnJnYiwgdmVjMyggMC4wMDMxMzA4ICkgKSApICksIHZhbHVlLncgKTtcXG59XFxudmVjNCBSR0JFVG9MaW5lYXIoIGluIHZlYzQgdmFsdWUgKSB7XFxuICByZXR1cm4gdmVjNCggdmFsdWUucmdiICogZXhwMiggdmFsdWUuYSAqIDI1NS4wIC0gMTI4LjAgKSwgMS4wICk7XFxufVxcbnZlYzQgTGluZWFyVG9SR0JFKCBpbiB2ZWM0IHZhbHVlICkge1xcbiAgZmxvYXQgbWF4Q29tcG9uZW50ID0gbWF4KCBtYXgoIHZhbHVlLnIsIHZhbHVlLmcgKSwgdmFsdWUuYiApO1xcbiAgZmxvYXQgZkV4cCA9IGNsYW1wKCBjZWlsKCBsb2cyKCBtYXhDb21wb25lbnQgKSApLCAtMTI4LjAsIDEyNy4wICk7XFxuICByZXR1cm4gdmVjNCggdmFsdWUucmdiIC8gZXhwMiggZkV4cCApLCAoIGZFeHAgKyAxMjguMCApIC8gMjU1LjAgKTtcXG59XFxudmVjNCBSR0JNVG9MaW5lYXIoIGluIHZlYzQgdmFsdWUsIGluIGZsb2F0IG1heFJhbmdlICkge1xcbiAgcmV0dXJuIHZlYzQoIHZhbHVlLnh5eiAqIHZhbHVlLncgKiBtYXhSYW5nZSwgMS4wICk7XFxufVxcbnZlYzQgTGluZWFyVG9SR0JNKCBpbiB2ZWM0IHZhbHVlLCBpbiBmbG9hdCBtYXhSYW5nZSApIHtcXG4gIGZsb2F0IG1heFJHQiA9IG1heCggdmFsdWUueCwgbWF4KCB2YWx1ZS5nLCB2YWx1ZS5iICkgKTtcXG4gIGZsb2F0IE0gICAgICA9IGNsYW1wKCBtYXhSR0IgLyBtYXhSYW5nZSwgMC4wLCAxLjAgKTtcXG4gIE0gICAgICAgICAgICA9IGNlaWwoIE0gKiAyNTUuMCApIC8gMjU1LjA7XFxuICByZXR1cm4gdmVjNCggdmFsdWUucmdiIC8gKCBNICogbWF4UmFuZ2UgKSwgTSApO1xcbn1cXG52ZWM0IFJHQkRUb0xpbmVhciggaW4gdmVjNCB2YWx1ZSwgaW4gZmxvYXQgbWF4UmFuZ2UgKSB7XFxuICAgIHJldHVybiB2ZWM0KCB2YWx1ZS5yZ2IgKiAoICggbWF4UmFuZ2UgLyAyNTUuMCApIC8gdmFsdWUuYSApLCAxLjAgKTtcXG59XFxudmVjNCBMaW5lYXJUb1JHQkQoIGluIHZlYzQgdmFsdWUsIGluIGZsb2F0IG1heFJhbmdlICkge1xcbiAgICBmbG9hdCBtYXhSR0IgPSBtYXgoIHZhbHVlLngsIG1heCggdmFsdWUuZywgdmFsdWUuYiApICk7XFxuICAgIGZsb2F0IEQgICAgICA9IG1heCggbWF4UmFuZ2UgLyBtYXhSR0IsIDEuMCApO1xcbiAgICBEICAgICAgICAgICAgPSBtaW4oIGZsb29yKCBEICkgLyAyNTUuMCwgMS4wICk7XFxuICAgIHJldHVybiB2ZWM0KCB2YWx1ZS5yZ2IgKiAoIEQgKiAoIDI1NS4wIC8gbWF4UmFuZ2UgKSApLCBEICk7XFxufVxcbmNvbnN0IG1hdDMgY0xvZ0x1dk0gPSBtYXQzKCAwLjIyMDksIDAuMzM5MCwgMC40MTg0LCAwLjExMzgsIDAuNjc4MCwgMC43MzE5LCAwLjAxMDIsIDAuMTEzMCwgMC4yOTY5ICk7XFxudmVjNCBMaW5lYXJUb0xvZ0x1diggaW4gdmVjNCB2YWx1ZSApICB7XFxuICB2ZWMzIFhwX1lfWFlacCA9IHZhbHVlLnJnYiAqIGNMb2dMdXZNO1xcbiAgWHBfWV9YWVpwID0gbWF4KFhwX1lfWFlacCwgdmVjMygxZS02LCAxZS02LCAxZS02KSk7XFxuICB2ZWM0IHZSZXN1bHQ7XFxuICB2UmVzdWx0Lnh5ID0gWHBfWV9YWVpwLnh5IC8gWHBfWV9YWVpwLno7XFxuICBmbG9hdCBMZSA9IDIuMCAqIGxvZzIoWHBfWV9YWVpwLnkpICsgMTI3LjA7XFxuICB2UmVzdWx0LncgPSBmcmFjdChMZSk7XFxuICB2UmVzdWx0LnogPSAoTGUgLSAoZmxvb3IodlJlc3VsdC53KjI1NS4wKSkvMjU1LjApLzI1NS4wO1xcbiAgcmV0dXJuIHZSZXN1bHQ7XFxufVxcbmNvbnN0IG1hdDMgY0xvZ0x1dkludmVyc2VNID0gbWF0MyggNi4wMDE0LCAtMi43MDA4LCAtMS43OTk2LCAtMS4zMzIwLCAzLjEwMjksIC01Ljc3MjEsIDAuMzAwOCwgLTEuMDg4MiwgNS42MjY4ICk7XFxudmVjNCBMb2dMdXZUb0xpbmVhciggaW4gdmVjNCB2YWx1ZSApIHtcXG4gIGZsb2F0IExlID0gdmFsdWUueiAqIDI1NS4wICsgdmFsdWUudztcXG4gIHZlYzMgWHBfWV9YWVpwO1xcbiAgWHBfWV9YWVpwLnkgPSBleHAyKChMZSAtIDEyNy4wKSAvIDIuMCk7XFxuICBYcF9ZX1hZWnAueiA9IFhwX1lfWFlacC55IC8gdmFsdWUueTtcXG4gIFhwX1lfWFlacC54ID0gdmFsdWUueCAqIFhwX1lfWFlacC56O1xcbiAgdmVjMyB2UkdCID0gWHBfWV9YWVpwLnJnYiAqIGNMb2dMdXZJbnZlcnNlTTtcXG4gIHJldHVybiB2ZWM0KCBtYXgodlJHQiwgMC4wKSwgMS4wICk7XFxufVxcblwiO1xuXG4gICAgdmFyIGVudm1hcF9mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9FTlZNQVBcXG5cXHQjaWYgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTk9STUFMTUFQICkgfHwgZGVmaW5lZCggUEhPTkcgKVxcblxcdFxcdHZlYzMgY2FtZXJhVG9WZXJ0ZXggPSBub3JtYWxpemUoIHZXb3JsZFBvc2l0aW9uIC0gY2FtZXJhUG9zaXRpb24gKTtcXG5cXHRcXHR2ZWMzIHdvcmxkTm9ybWFsID0gaW52ZXJzZVRyYW5zZm9ybURpcmVjdGlvbiggbm9ybWFsLCB2aWV3TWF0cml4ICk7XFxuXFx0XFx0I2lmZGVmIEVOVk1BUF9NT0RFX1JFRkxFQ1RJT05cXG5cXHRcXHRcXHR2ZWMzIHJlZmxlY3RWZWMgPSByZWZsZWN0KCBjYW1lcmFUb1ZlcnRleCwgd29ybGROb3JtYWwgKTtcXG5cXHRcXHQjZWxzZVxcblxcdFxcdFxcdHZlYzMgcmVmbGVjdFZlYyA9IHJlZnJhY3QoIGNhbWVyYVRvVmVydGV4LCB3b3JsZE5vcm1hbCwgcmVmcmFjdGlvblJhdGlvICk7XFxuXFx0XFx0I2VuZGlmXFxuXFx0I2Vsc2VcXG5cXHRcXHR2ZWMzIHJlZmxlY3RWZWMgPSB2UmVmbGVjdDtcXG5cXHQjZW5kaWZcXG5cXHQjaWZkZWYgRU5WTUFQX1RZUEVfQ1VCRVxcblxcdFxcdHZlYzQgZW52Q29sb3IgPSB0ZXh0dXJlQ3ViZSggZW52TWFwLCBmbGlwTm9ybWFsICogdmVjMyggZmxpcEVudk1hcCAqIHJlZmxlY3RWZWMueCwgcmVmbGVjdFZlYy55eiApICk7XFxuXFx0I2VsaWYgZGVmaW5lZCggRU5WTUFQX1RZUEVfRVFVSVJFQyApXFxuXFx0XFx0dmVjMiBzYW1wbGVVVjtcXG5cXHRcXHRzYW1wbGVVVi55ID0gc2F0dXJhdGUoIGZsaXBOb3JtYWwgKiByZWZsZWN0VmVjLnkgKiAwLjUgKyAwLjUgKTtcXG5cXHRcXHRzYW1wbGVVVi54ID0gYXRhbiggZmxpcE5vcm1hbCAqIHJlZmxlY3RWZWMueiwgZmxpcE5vcm1hbCAqIHJlZmxlY3RWZWMueCApICogUkVDSVBST0NBTF9QSTIgKyAwLjU7XFxuXFx0XFx0dmVjNCBlbnZDb2xvciA9IHRleHR1cmUyRCggZW52TWFwLCBzYW1wbGVVViApO1xcblxcdCNlbGlmIGRlZmluZWQoIEVOVk1BUF9UWVBFX1NQSEVSRSApXFxuXFx0XFx0dmVjMyByZWZsZWN0VmlldyA9IGZsaXBOb3JtYWwgKiBub3JtYWxpemUoICggdmlld01hdHJpeCAqIHZlYzQoIHJlZmxlY3RWZWMsIDAuMCApICkueHl6ICsgdmVjMyggMC4wLCAwLjAsIDEuMCApICk7XFxuXFx0XFx0dmVjNCBlbnZDb2xvciA9IHRleHR1cmUyRCggZW52TWFwLCByZWZsZWN0Vmlldy54eSAqIDAuNSArIDAuNSApO1xcblxcdCNlbHNlXFxuXFx0XFx0dmVjNCBlbnZDb2xvciA9IHZlYzQoIDAuMCApO1xcblxcdCNlbmRpZlxcblxcdGVudkNvbG9yID0gZW52TWFwVGV4ZWxUb0xpbmVhciggZW52Q29sb3IgKTtcXG5cXHQjaWZkZWYgRU5WTUFQX0JMRU5ESU5HX01VTFRJUExZXFxuXFx0XFx0b3V0Z29pbmdMaWdodCA9IG1peCggb3V0Z29pbmdMaWdodCwgb3V0Z29pbmdMaWdodCAqIGVudkNvbG9yLnh5eiwgc3BlY3VsYXJTdHJlbmd0aCAqIHJlZmxlY3Rpdml0eSApO1xcblxcdCNlbGlmIGRlZmluZWQoIEVOVk1BUF9CTEVORElOR19NSVggKVxcblxcdFxcdG91dGdvaW5nTGlnaHQgPSBtaXgoIG91dGdvaW5nTGlnaHQsIGVudkNvbG9yLnh5eiwgc3BlY3VsYXJTdHJlbmd0aCAqIHJlZmxlY3Rpdml0eSApO1xcblxcdCNlbGlmIGRlZmluZWQoIEVOVk1BUF9CTEVORElOR19BREQgKVxcblxcdFxcdG91dGdvaW5nTGlnaHQgKz0gZW52Q29sb3IueHl6ICogc3BlY3VsYXJTdHJlbmd0aCAqIHJlZmxlY3Rpdml0eTtcXG5cXHQjZW5kaWZcXG4jZW5kaWZcXG5cIjtcblxuICAgIHZhciBlbnZtYXBfcGFyc19mcmFnbWVudCA9IFwiI2lmIGRlZmluZWQoIFVTRV9FTlZNQVAgKSB8fCBkZWZpbmVkKCBQSFlTSUNBTCApXFxuXFx0dW5pZm9ybSBmbG9hdCByZWZsZWN0aXZpdHk7XFxuXFx0dW5pZm9ybSBmbG9hdCBlbnZNYXBJbnRlbnN0aXk7XFxuI2VuZGlmXFxuI2lmZGVmIFVTRV9FTlZNQVBcXG5cXHQjaWYgISBkZWZpbmVkKCBQSFlTSUNBTCApICYmICggZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTk9STUFMTUFQICkgfHwgZGVmaW5lZCggUEhPTkcgKSApXFxuXFx0XFx0dmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1xcblxcdCNlbmRpZlxcblxcdCNpZmRlZiBFTlZNQVBfVFlQRV9DVUJFXFxuXFx0XFx0dW5pZm9ybSBzYW1wbGVyQ3ViZSBlbnZNYXA7XFxuXFx0I2Vsc2VcXG5cXHRcXHR1bmlmb3JtIHNhbXBsZXIyRCBlbnZNYXA7XFxuXFx0I2VuZGlmXFxuXFx0dW5pZm9ybSBmbG9hdCBmbGlwRW52TWFwO1xcblxcdCNpZiBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKSB8fCBkZWZpbmVkKCBQSE9ORyApIHx8IGRlZmluZWQoIFBIWVNJQ0FMIClcXG5cXHRcXHR1bmlmb3JtIGZsb2F0IHJlZnJhY3Rpb25SYXRpbztcXG5cXHQjZWxzZVxcblxcdFxcdHZhcnlpbmcgdmVjMyB2UmVmbGVjdDtcXG5cXHQjZW5kaWZcXG4jZW5kaWZcXG5cIjtcblxuICAgIHZhciBlbnZtYXBfcGFyc192ZXJ0ZXggPSBcIiNpZmRlZiBVU0VfRU5WTUFQXFxuXFx0I2lmIGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApIHx8IGRlZmluZWQoIFBIT05HIClcXG5cXHRcXHR2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XFxuXFx0I2Vsc2VcXG5cXHRcXHR2YXJ5aW5nIHZlYzMgdlJlZmxlY3Q7XFxuXFx0XFx0dW5pZm9ybSBmbG9hdCByZWZyYWN0aW9uUmF0aW87XFxuXFx0I2VuZGlmXFxuI2VuZGlmXFxuXCI7XG5cbiAgICB2YXIgZW52bWFwX3ZlcnRleCA9IFwiI2lmZGVmIFVTRV9FTlZNQVBcXG5cXHQjaWYgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTk9STUFMTUFQICkgfHwgZGVmaW5lZCggUEhPTkcgKVxcblxcdFxcdHZXb3JsZFBvc2l0aW9uID0gd29ybGRQb3NpdGlvbi54eXo7XFxuXFx0I2Vsc2VcXG5cXHRcXHR2ZWMzIGNhbWVyYVRvVmVydGV4ID0gbm9ybWFsaXplKCB3b3JsZFBvc2l0aW9uLnh5eiAtIGNhbWVyYVBvc2l0aW9uICk7XFxuXFx0XFx0dmVjMyB3b3JsZE5vcm1hbCA9IGludmVyc2VUcmFuc2Zvcm1EaXJlY3Rpb24oIHRyYW5zZm9ybWVkTm9ybWFsLCB2aWV3TWF0cml4ICk7XFxuXFx0XFx0I2lmZGVmIEVOVk1BUF9NT0RFX1JFRkxFQ1RJT05cXG5cXHRcXHRcXHR2UmVmbGVjdCA9IHJlZmxlY3QoIGNhbWVyYVRvVmVydGV4LCB3b3JsZE5vcm1hbCApO1xcblxcdFxcdCNlbHNlXFxuXFx0XFx0XFx0dlJlZmxlY3QgPSByZWZyYWN0KCBjYW1lcmFUb1ZlcnRleCwgd29ybGROb3JtYWwsIHJlZnJhY3Rpb25SYXRpbyApO1xcblxcdFxcdCNlbmRpZlxcblxcdCNlbmRpZlxcbiNlbmRpZlxcblwiO1xuXG4gICAgdmFyIGZvZ19mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9GT0dcXG5cXHQjaWZkZWYgVVNFX0xPR0RFUFRIQlVGX0VYVFxcblxcdFxcdGZsb2F0IGRlcHRoID0gZ2xfRnJhZ0RlcHRoRVhUIC8gZ2xfRnJhZ0Nvb3JkLnc7XFxuXFx0I2Vsc2VcXG5cXHRcXHRmbG9hdCBkZXB0aCA9IGdsX0ZyYWdDb29yZC56IC8gZ2xfRnJhZ0Nvb3JkLnc7XFxuXFx0I2VuZGlmXFxuXFx0I2lmZGVmIEZPR19FWFAyXFxuXFx0XFx0ZmxvYXQgZm9nRmFjdG9yID0gd2hpdGVDb21wbGltZW50KCBleHAyKCAtIGZvZ0RlbnNpdHkgKiBmb2dEZW5zaXR5ICogZGVwdGggKiBkZXB0aCAqIExPRzIgKSApO1xcblxcdCNlbHNlXFxuXFx0XFx0ZmxvYXQgZm9nRmFjdG9yID0gc21vb3Roc3RlcCggZm9nTmVhciwgZm9nRmFyLCBkZXB0aCApO1xcblxcdCNlbmRpZlxcblxcdGdsX0ZyYWdDb2xvci5yZ2IgPSBtaXgoIGdsX0ZyYWdDb2xvci5yZ2IsIGZvZ0NvbG9yLCBmb2dGYWN0b3IgKTtcXG4jZW5kaWZcXG5cIjtcblxuICAgIHZhciBmb2dfcGFyc19mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9GT0dcXG5cXHR1bmlmb3JtIHZlYzMgZm9nQ29sb3I7XFxuXFx0I2lmZGVmIEZPR19FWFAyXFxuXFx0XFx0dW5pZm9ybSBmbG9hdCBmb2dEZW5zaXR5O1xcblxcdCNlbHNlXFxuXFx0XFx0dW5pZm9ybSBmbG9hdCBmb2dOZWFyO1xcblxcdFxcdHVuaWZvcm0gZmxvYXQgZm9nRmFyO1xcblxcdCNlbmRpZlxcbiNlbmRpZlwiO1xuXG4gICAgdmFyIGxpZ2h0bWFwX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX0xJR0hUTUFQXFxuXFx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICs9IFBJICogdGV4dHVyZTJEKCBsaWdodE1hcCwgdlV2MiApLnh5eiAqIGxpZ2h0TWFwSW50ZW5zaXR5O1xcbiNlbmRpZlxcblwiO1xuXG4gICAgdmFyIGxpZ2h0bWFwX3BhcnNfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfTElHSFRNQVBcXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBsaWdodE1hcDtcXG5cXHR1bmlmb3JtIGZsb2F0IGxpZ2h0TWFwSW50ZW5zaXR5O1xcbiNlbmRpZlwiO1xuXG4gICAgdmFyIGxpZ2h0c19sYW1iZXJ0X3ZlcnRleCA9IFwidmVjMyBkaWZmdXNlID0gdmVjMyggMS4wICk7XFxuR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeTtcXG5nZW9tZXRyeS5wb3NpdGlvbiA9IG12UG9zaXRpb24ueHl6O1xcbmdlb21ldHJ5Lm5vcm1hbCA9IG5vcm1hbGl6ZSggdHJhbnNmb3JtZWROb3JtYWwgKTtcXG5nZW9tZXRyeS52aWV3RGlyID0gbm9ybWFsaXplKCAtbXZQb3NpdGlvbi54eXogKTtcXG5HZW9tZXRyaWNDb250ZXh0IGJhY2tHZW9tZXRyeTtcXG5iYWNrR2VvbWV0cnkucG9zaXRpb24gPSBnZW9tZXRyeS5wb3NpdGlvbjtcXG5iYWNrR2VvbWV0cnkubm9ybWFsID0gLWdlb21ldHJ5Lm5vcm1hbDtcXG5iYWNrR2VvbWV0cnkudmlld0RpciA9IGdlb21ldHJ5LnZpZXdEaXI7XFxudkxpZ2h0RnJvbnQgPSB2ZWMzKCAwLjAgKTtcXG4jaWZkZWYgRE9VQkxFX1NJREVEXFxuXFx0dkxpZ2h0QmFjayA9IHZlYzMoIDAuMCApO1xcbiNlbmRpZlxcbkluY2lkZW50TGlnaHQgZGlyZWN0TGlnaHQ7XFxuZmxvYXQgZG90Tkw7XFxudmVjMyBkaXJlY3RMaWdodENvbG9yX0RpZmZ1c2U7XFxuI2lmIE5VTV9QT0lOVF9MSUdIVFMgPiAwXFxuXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX1BPSU5UX0xJR0hUUzsgaSArKyApIHtcXG5cXHRcXHRnZXRQb2ludERpcmVjdExpZ2h0SXJyYWRpYW5jZSggcG9pbnRMaWdodHNbIGkgXSwgZ2VvbWV0cnksIGRpcmVjdExpZ2h0ICk7XFxuXFx0XFx0ZG90TkwgPSBkb3QoIGdlb21ldHJ5Lm5vcm1hbCwgZGlyZWN0TGlnaHQuZGlyZWN0aW9uICk7XFxuXFx0XFx0ZGlyZWN0TGlnaHRDb2xvcl9EaWZmdXNlID0gUEkgKiBkaXJlY3RMaWdodC5jb2xvcjtcXG5cXHRcXHR2TGlnaHRGcm9udCArPSBzYXR1cmF0ZSggZG90TkwgKSAqIGRpcmVjdExpZ2h0Q29sb3JfRGlmZnVzZTtcXG5cXHRcXHQjaWZkZWYgRE9VQkxFX1NJREVEXFxuXFx0XFx0XFx0dkxpZ2h0QmFjayArPSBzYXR1cmF0ZSggLWRvdE5MICkgKiBkaXJlY3RMaWdodENvbG9yX0RpZmZ1c2U7XFxuXFx0XFx0I2VuZGlmXFxuXFx0fVxcbiNlbmRpZlxcbiNpZiBOVU1fU1BPVF9MSUdIVFMgPiAwXFxuXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX1NQT1RfTElHSFRTOyBpICsrICkge1xcblxcdFxcdGdldFNwb3REaXJlY3RMaWdodElycmFkaWFuY2UoIHNwb3RMaWdodHNbIGkgXSwgZ2VvbWV0cnksIGRpcmVjdExpZ2h0ICk7XFxuXFx0XFx0ZG90TkwgPSBkb3QoIGdlb21ldHJ5Lm5vcm1hbCwgZGlyZWN0TGlnaHQuZGlyZWN0aW9uICk7XFxuXFx0XFx0ZGlyZWN0TGlnaHRDb2xvcl9EaWZmdXNlID0gUEkgKiBkaXJlY3RMaWdodC5jb2xvcjtcXG5cXHRcXHR2TGlnaHRGcm9udCArPSBzYXR1cmF0ZSggZG90TkwgKSAqIGRpcmVjdExpZ2h0Q29sb3JfRGlmZnVzZTtcXG5cXHRcXHQjaWZkZWYgRE9VQkxFX1NJREVEXFxuXFx0XFx0XFx0dkxpZ2h0QmFjayArPSBzYXR1cmF0ZSggLWRvdE5MICkgKiBkaXJlY3RMaWdodENvbG9yX0RpZmZ1c2U7XFxuXFx0XFx0I2VuZGlmXFxuXFx0fVxcbiNlbmRpZlxcbiNpZiBOVU1fRElSX0xJR0hUUyA+IDBcXG5cXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fRElSX0xJR0hUUzsgaSArKyApIHtcXG5cXHRcXHRnZXREaXJlY3Rpb25hbERpcmVjdExpZ2h0SXJyYWRpYW5jZSggZGlyZWN0aW9uYWxMaWdodHNbIGkgXSwgZ2VvbWV0cnksIGRpcmVjdExpZ2h0ICk7XFxuXFx0XFx0ZG90TkwgPSBkb3QoIGdlb21ldHJ5Lm5vcm1hbCwgZGlyZWN0TGlnaHQuZGlyZWN0aW9uICk7XFxuXFx0XFx0ZGlyZWN0TGlnaHRDb2xvcl9EaWZmdXNlID0gUEkgKiBkaXJlY3RMaWdodC5jb2xvcjtcXG5cXHRcXHR2TGlnaHRGcm9udCArPSBzYXR1cmF0ZSggZG90TkwgKSAqIGRpcmVjdExpZ2h0Q29sb3JfRGlmZnVzZTtcXG5cXHRcXHQjaWZkZWYgRE9VQkxFX1NJREVEXFxuXFx0XFx0XFx0dkxpZ2h0QmFjayArPSBzYXR1cmF0ZSggLWRvdE5MICkgKiBkaXJlY3RMaWdodENvbG9yX0RpZmZ1c2U7XFxuXFx0XFx0I2VuZGlmXFxuXFx0fVxcbiNlbmRpZlxcbiNpZiBOVU1fSEVNSV9MSUdIVFMgPiAwXFxuXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX0hFTUlfTElHSFRTOyBpICsrICkge1xcblxcdFxcdHZMaWdodEZyb250ICs9IGdldEhlbWlzcGhlcmVMaWdodElycmFkaWFuY2UoIGhlbWlzcGhlcmVMaWdodHNbIGkgXSwgZ2VvbWV0cnkgKTtcXG5cXHRcXHQjaWZkZWYgRE9VQkxFX1NJREVEXFxuXFx0XFx0XFx0dkxpZ2h0QmFjayArPSBnZXRIZW1pc3BoZXJlTGlnaHRJcnJhZGlhbmNlKCBoZW1pc3BoZXJlTGlnaHRzWyBpIF0sIGJhY2tHZW9tZXRyeSApO1xcblxcdFxcdCNlbmRpZlxcblxcdH1cXG4jZW5kaWZcXG5cIjtcblxuICAgIHZhciBsaWdodHNfcGFycyA9IFwidW5pZm9ybSB2ZWMzIGFtYmllbnRMaWdodENvbG9yO1xcbnZlYzMgZ2V0QW1iaWVudExpZ2h0SXJyYWRpYW5jZSggY29uc3QgaW4gdmVjMyBhbWJpZW50TGlnaHRDb2xvciApIHtcXG5cXHR2ZWMzIGlycmFkaWFuY2UgPSBhbWJpZW50TGlnaHRDb2xvcjtcXG5cXHQjaWZuZGVmIFBIWVNJQ0FMTFlfQ09SUkVDVF9MSUdIVFNcXG5cXHRcXHRpcnJhZGlhbmNlICo9IFBJO1xcblxcdCNlbmRpZlxcblxcdHJldHVybiBpcnJhZGlhbmNlO1xcbn1cXG4jaWYgTlVNX0RJUl9MSUdIVFMgPiAwXFxuXFx0c3RydWN0IERpcmVjdGlvbmFsTGlnaHQge1xcblxcdFxcdHZlYzMgZGlyZWN0aW9uO1xcblxcdFxcdHZlYzMgY29sb3I7XFxuXFx0XFx0aW50IHNoYWRvdztcXG5cXHRcXHRmbG9hdCBzaGFkb3dCaWFzO1xcblxcdFxcdGZsb2F0IHNoYWRvd1JhZGl1cztcXG5cXHRcXHR2ZWMyIHNoYWRvd01hcFNpemU7XFxuXFx0fTtcXG5cXHR1bmlmb3JtIERpcmVjdGlvbmFsTGlnaHQgZGlyZWN0aW9uYWxMaWdodHNbIE5VTV9ESVJfTElHSFRTIF07XFxuXFx0dm9pZCBnZXREaXJlY3Rpb25hbERpcmVjdExpZ2h0SXJyYWRpYW5jZSggY29uc3QgaW4gRGlyZWN0aW9uYWxMaWdodCBkaXJlY3Rpb25hbExpZ2h0LCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBvdXQgSW5jaWRlbnRMaWdodCBkaXJlY3RMaWdodCApIHtcXG5cXHRcXHRkaXJlY3RMaWdodC5jb2xvciA9IGRpcmVjdGlvbmFsTGlnaHQuY29sb3I7XFxuXFx0XFx0ZGlyZWN0TGlnaHQuZGlyZWN0aW9uID0gZGlyZWN0aW9uYWxMaWdodC5kaXJlY3Rpb247XFxuXFx0XFx0ZGlyZWN0TGlnaHQudmlzaWJsZSA9IHRydWU7XFxuXFx0fVxcbiNlbmRpZlxcbiNpZiBOVU1fUE9JTlRfTElHSFRTID4gMFxcblxcdHN0cnVjdCBQb2ludExpZ2h0IHtcXG5cXHRcXHR2ZWMzIHBvc2l0aW9uO1xcblxcdFxcdHZlYzMgY29sb3I7XFxuXFx0XFx0ZmxvYXQgZGlzdGFuY2U7XFxuXFx0XFx0ZmxvYXQgZGVjYXk7XFxuXFx0XFx0aW50IHNoYWRvdztcXG5cXHRcXHRmbG9hdCBzaGFkb3dCaWFzO1xcblxcdFxcdGZsb2F0IHNoYWRvd1JhZGl1cztcXG5cXHRcXHR2ZWMyIHNoYWRvd01hcFNpemU7XFxuXFx0fTtcXG5cXHR1bmlmb3JtIFBvaW50TGlnaHQgcG9pbnRMaWdodHNbIE5VTV9QT0lOVF9MSUdIVFMgXTtcXG5cXHR2b2lkIGdldFBvaW50RGlyZWN0TGlnaHRJcnJhZGlhbmNlKCBjb25zdCBpbiBQb2ludExpZ2h0IHBvaW50TGlnaHQsIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnksIG91dCBJbmNpZGVudExpZ2h0IGRpcmVjdExpZ2h0ICkge1xcblxcdFxcdHZlYzMgbFZlY3RvciA9IHBvaW50TGlnaHQucG9zaXRpb24gLSBnZW9tZXRyeS5wb3NpdGlvbjtcXG5cXHRcXHRkaXJlY3RMaWdodC5kaXJlY3Rpb24gPSBub3JtYWxpemUoIGxWZWN0b3IgKTtcXG5cXHRcXHRmbG9hdCBsaWdodERpc3RhbmNlID0gbGVuZ3RoKCBsVmVjdG9yICk7XFxuXFx0XFx0aWYgKCB0ZXN0TGlnaHRJblJhbmdlKCBsaWdodERpc3RhbmNlLCBwb2ludExpZ2h0LmRpc3RhbmNlICkgKSB7XFxuXFx0XFx0XFx0ZGlyZWN0TGlnaHQuY29sb3IgPSBwb2ludExpZ2h0LmNvbG9yO1xcblxcdFxcdFxcdGRpcmVjdExpZ2h0LmNvbG9yICo9IHB1bmN0dWFsTGlnaHRJbnRlbnNpdHlUb0lycmFkaWFuY2VGYWN0b3IoIGxpZ2h0RGlzdGFuY2UsIHBvaW50TGlnaHQuZGlzdGFuY2UsIHBvaW50TGlnaHQuZGVjYXkgKTtcXG5cXHRcXHRcXHRkaXJlY3RMaWdodC52aXNpYmxlID0gdHJ1ZTtcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdGRpcmVjdExpZ2h0LmNvbG9yID0gdmVjMyggMC4wICk7XFxuXFx0XFx0XFx0ZGlyZWN0TGlnaHQudmlzaWJsZSA9IGZhbHNlO1xcblxcdFxcdH1cXG5cXHR9XFxuI2VuZGlmXFxuI2lmIE5VTV9TUE9UX0xJR0hUUyA+IDBcXG5cXHRzdHJ1Y3QgU3BvdExpZ2h0IHtcXG5cXHRcXHR2ZWMzIHBvc2l0aW9uO1xcblxcdFxcdHZlYzMgZGlyZWN0aW9uO1xcblxcdFxcdHZlYzMgY29sb3I7XFxuXFx0XFx0ZmxvYXQgZGlzdGFuY2U7XFxuXFx0XFx0ZmxvYXQgZGVjYXk7XFxuXFx0XFx0ZmxvYXQgY29uZUNvcztcXG5cXHRcXHRmbG9hdCBwZW51bWJyYUNvcztcXG5cXHRcXHRpbnQgc2hhZG93O1xcblxcdFxcdGZsb2F0IHNoYWRvd0JpYXM7XFxuXFx0XFx0ZmxvYXQgc2hhZG93UmFkaXVzO1xcblxcdFxcdHZlYzIgc2hhZG93TWFwU2l6ZTtcXG5cXHR9O1xcblxcdHVuaWZvcm0gU3BvdExpZ2h0IHNwb3RMaWdodHNbIE5VTV9TUE9UX0xJR0hUUyBdO1xcblxcdHZvaWQgZ2V0U3BvdERpcmVjdExpZ2h0SXJyYWRpYW5jZSggY29uc3QgaW4gU3BvdExpZ2h0IHNwb3RMaWdodCwgY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSwgb3V0IEluY2lkZW50TGlnaHQgZGlyZWN0TGlnaHQgICkge1xcblxcdFxcdHZlYzMgbFZlY3RvciA9IHNwb3RMaWdodC5wb3NpdGlvbiAtIGdlb21ldHJ5LnBvc2l0aW9uO1xcblxcdFxcdGRpcmVjdExpZ2h0LmRpcmVjdGlvbiA9IG5vcm1hbGl6ZSggbFZlY3RvciApO1xcblxcdFxcdGZsb2F0IGxpZ2h0RGlzdGFuY2UgPSBsZW5ndGgoIGxWZWN0b3IgKTtcXG5cXHRcXHRmbG9hdCBhbmdsZUNvcyA9IGRvdCggZGlyZWN0TGlnaHQuZGlyZWN0aW9uLCBzcG90TGlnaHQuZGlyZWN0aW9uICk7XFxuXFx0XFx0aWYgKCBhbGwoIGJ2ZWMyKCBhbmdsZUNvcyA+IHNwb3RMaWdodC5jb25lQ29zLCB0ZXN0TGlnaHRJblJhbmdlKCBsaWdodERpc3RhbmNlLCBzcG90TGlnaHQuZGlzdGFuY2UgKSApICkgKSB7XFxuXFx0XFx0XFx0ZmxvYXQgc3BvdEVmZmVjdCA9IHNtb290aHN0ZXAoIHNwb3RMaWdodC5jb25lQ29zLCBzcG90TGlnaHQucGVudW1icmFDb3MsIGFuZ2xlQ29zICk7XFxuXFx0XFx0XFx0ZGlyZWN0TGlnaHQuY29sb3IgPSBzcG90TGlnaHQuY29sb3I7XFxuXFx0XFx0XFx0ZGlyZWN0TGlnaHQuY29sb3IgKj0gc3BvdEVmZmVjdCAqIHB1bmN0dWFsTGlnaHRJbnRlbnNpdHlUb0lycmFkaWFuY2VGYWN0b3IoIGxpZ2h0RGlzdGFuY2UsIHNwb3RMaWdodC5kaXN0YW5jZSwgc3BvdExpZ2h0LmRlY2F5ICk7XFxuXFx0XFx0XFx0ZGlyZWN0TGlnaHQudmlzaWJsZSA9IHRydWU7XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRkaXJlY3RMaWdodC5jb2xvciA9IHZlYzMoIDAuMCApO1xcblxcdFxcdFxcdGRpcmVjdExpZ2h0LnZpc2libGUgPSBmYWxzZTtcXG5cXHRcXHR9XFxuXFx0fVxcbiNlbmRpZlxcbiNpZiBOVU1fSEVNSV9MSUdIVFMgPiAwXFxuXFx0c3RydWN0IEhlbWlzcGhlcmVMaWdodCB7XFxuXFx0XFx0dmVjMyBkaXJlY3Rpb247XFxuXFx0XFx0dmVjMyBza3lDb2xvcjtcXG5cXHRcXHR2ZWMzIGdyb3VuZENvbG9yO1xcblxcdH07XFxuXFx0dW5pZm9ybSBIZW1pc3BoZXJlTGlnaHQgaGVtaXNwaGVyZUxpZ2h0c1sgTlVNX0hFTUlfTElHSFRTIF07XFxuXFx0dmVjMyBnZXRIZW1pc3BoZXJlTGlnaHRJcnJhZGlhbmNlKCBjb25zdCBpbiBIZW1pc3BoZXJlTGlnaHQgaGVtaUxpZ2h0LCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5ICkge1xcblxcdFxcdGZsb2F0IGRvdE5MID0gZG90KCBnZW9tZXRyeS5ub3JtYWwsIGhlbWlMaWdodC5kaXJlY3Rpb24gKTtcXG5cXHRcXHRmbG9hdCBoZW1pRGlmZnVzZVdlaWdodCA9IDAuNSAqIGRvdE5MICsgMC41O1xcblxcdFxcdHZlYzMgaXJyYWRpYW5jZSA9IG1peCggaGVtaUxpZ2h0Lmdyb3VuZENvbG9yLCBoZW1pTGlnaHQuc2t5Q29sb3IsIGhlbWlEaWZmdXNlV2VpZ2h0ICk7XFxuXFx0XFx0I2lmbmRlZiBQSFlTSUNBTExZX0NPUlJFQ1RfTElHSFRTXFxuXFx0XFx0XFx0aXJyYWRpYW5jZSAqPSBQSTtcXG5cXHRcXHQjZW5kaWZcXG5cXHRcXHRyZXR1cm4gaXJyYWRpYW5jZTtcXG5cXHR9XFxuI2VuZGlmXFxuI2lmIGRlZmluZWQoIFVTRV9FTlZNQVAgKSAmJiBkZWZpbmVkKCBQSFlTSUNBTCApXFxuXFx0dmVjMyBnZXRMaWdodFByb2JlSW5kaXJlY3RJcnJhZGlhbmNlKCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBjb25zdCBpbiBpbnQgbWF4TUlQTGV2ZWwgKSB7XFxuXFx0XFx0I2luY2x1ZGUgPG5vcm1hbF9mbGlwPlxcblxcdFxcdHZlYzMgd29ybGROb3JtYWwgPSBpbnZlcnNlVHJhbnNmb3JtRGlyZWN0aW9uKCBnZW9tZXRyeS5ub3JtYWwsIHZpZXdNYXRyaXggKTtcXG5cXHRcXHQjaWZkZWYgRU5WTUFQX1RZUEVfQ1VCRVxcblxcdFxcdFxcdHZlYzMgcXVlcnlWZWMgPSBmbGlwTm9ybWFsICogdmVjMyggZmxpcEVudk1hcCAqIHdvcmxkTm9ybWFsLngsIHdvcmxkTm9ybWFsLnl6ICk7XFxuXFx0XFx0XFx0I2lmZGVmIFRFWFRVUkVfTE9EX0VYVFxcblxcdFxcdFxcdFxcdHZlYzQgZW52TWFwQ29sb3IgPSB0ZXh0dXJlQ3ViZUxvZEVYVCggZW52TWFwLCBxdWVyeVZlYywgZmxvYXQoIG1heE1JUExldmVsICkgKTtcXG5cXHRcXHRcXHQjZWxzZVxcblxcdFxcdFxcdFxcdHZlYzQgZW52TWFwQ29sb3IgPSB0ZXh0dXJlQ3ViZSggZW52TWFwLCBxdWVyeVZlYywgZmxvYXQoIG1heE1JUExldmVsICkgKTtcXG5cXHRcXHRcXHQjZW5kaWZcXG5cXHRcXHRcXHRlbnZNYXBDb2xvci5yZ2IgPSBlbnZNYXBUZXhlbFRvTGluZWFyKCBlbnZNYXBDb2xvciApLnJnYjtcXG5cXHRcXHQjZWxpZiBkZWZpbmVkKCBFTlZNQVBfVFlQRV9DVUJFX1VWIClcXG5cXHRcXHRcXHR2ZWMzIHF1ZXJ5VmVjID0gZmxpcE5vcm1hbCAqIHZlYzMoIGZsaXBFbnZNYXAgKiB3b3JsZE5vcm1hbC54LCB3b3JsZE5vcm1hbC55eiApO1xcblxcdFxcdFxcdHZlYzQgZW52TWFwQ29sb3IgPSB0ZXh0dXJlQ3ViZVVWKCBxdWVyeVZlYywgMS4wICk7XFxuXFx0XFx0I2Vsc2VcXG5cXHRcXHRcXHR2ZWM0IGVudk1hcENvbG9yID0gdmVjNCggMC4wICk7XFxuXFx0XFx0I2VuZGlmXFxuXFx0XFx0cmV0dXJuIFBJICogZW52TWFwQ29sb3IucmdiICogZW52TWFwSW50ZW5zaXR5O1xcblxcdH1cXG5cXHRmbG9hdCBnZXRTcGVjdWxhck1JUExldmVsKCBjb25zdCBpbiBmbG9hdCBibGlublNoaW5pbmVzc0V4cG9uZW50LCBjb25zdCBpbiBpbnQgbWF4TUlQTGV2ZWwgKSB7XFxuXFx0XFx0ZmxvYXQgbWF4TUlQTGV2ZWxTY2FsYXIgPSBmbG9hdCggbWF4TUlQTGV2ZWwgKTtcXG5cXHRcXHRmbG9hdCBkZXNpcmVkTUlQTGV2ZWwgPSBtYXhNSVBMZXZlbFNjYWxhciAtIDAuNzkyNDggLSAwLjUgKiBsb2cyKCBwb3cyKCBibGlublNoaW5pbmVzc0V4cG9uZW50ICkgKyAxLjAgKTtcXG5cXHRcXHRyZXR1cm4gY2xhbXAoIGRlc2lyZWRNSVBMZXZlbCwgMC4wLCBtYXhNSVBMZXZlbFNjYWxhciApO1xcblxcdH1cXG5cXHR2ZWMzIGdldExpZ2h0UHJvYmVJbmRpcmVjdFJhZGlhbmNlKCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBjb25zdCBpbiBmbG9hdCBibGlublNoaW5pbmVzc0V4cG9uZW50LCBjb25zdCBpbiBpbnQgbWF4TUlQTGV2ZWwgKSB7XFxuXFx0XFx0I2lmZGVmIEVOVk1BUF9NT0RFX1JFRkxFQ1RJT05cXG5cXHRcXHRcXHR2ZWMzIHJlZmxlY3RWZWMgPSByZWZsZWN0KCAtZ2VvbWV0cnkudmlld0RpciwgZ2VvbWV0cnkubm9ybWFsICk7XFxuXFx0XFx0I2Vsc2VcXG5cXHRcXHRcXHR2ZWMzIHJlZmxlY3RWZWMgPSByZWZyYWN0KCAtZ2VvbWV0cnkudmlld0RpciwgZ2VvbWV0cnkubm9ybWFsLCByZWZyYWN0aW9uUmF0aW8gKTtcXG5cXHRcXHQjZW5kaWZcXG5cXHRcXHQjaW5jbHVkZSA8bm9ybWFsX2ZsaXA+XFxuXFx0XFx0cmVmbGVjdFZlYyA9IGludmVyc2VUcmFuc2Zvcm1EaXJlY3Rpb24oIHJlZmxlY3RWZWMsIHZpZXdNYXRyaXggKTtcXG5cXHRcXHRmbG9hdCBzcGVjdWxhck1JUExldmVsID0gZ2V0U3BlY3VsYXJNSVBMZXZlbCggYmxpbm5TaGluaW5lc3NFeHBvbmVudCwgbWF4TUlQTGV2ZWwgKTtcXG5cXHRcXHQjaWZkZWYgRU5WTUFQX1RZUEVfQ1VCRVxcblxcdFxcdFxcdHZlYzMgcXVlcnlSZWZsZWN0VmVjID0gZmxpcE5vcm1hbCAqIHZlYzMoIGZsaXBFbnZNYXAgKiByZWZsZWN0VmVjLngsIHJlZmxlY3RWZWMueXogKTtcXG5cXHRcXHRcXHQjaWZkZWYgVEVYVFVSRV9MT0RfRVhUXFxuXFx0XFx0XFx0XFx0dmVjNCBlbnZNYXBDb2xvciA9IHRleHR1cmVDdWJlTG9kRVhUKCBlbnZNYXAsIHF1ZXJ5UmVmbGVjdFZlYywgc3BlY3VsYXJNSVBMZXZlbCApO1xcblxcdFxcdFxcdCNlbHNlXFxuXFx0XFx0XFx0XFx0dmVjNCBlbnZNYXBDb2xvciA9IHRleHR1cmVDdWJlKCBlbnZNYXAsIHF1ZXJ5UmVmbGVjdFZlYywgc3BlY3VsYXJNSVBMZXZlbCApO1xcblxcdFxcdFxcdCNlbmRpZlxcblxcdFxcdFxcdGVudk1hcENvbG9yLnJnYiA9IGVudk1hcFRleGVsVG9MaW5lYXIoIGVudk1hcENvbG9yICkucmdiO1xcblxcdFxcdCNlbGlmIGRlZmluZWQoIEVOVk1BUF9UWVBFX0NVQkVfVVYgKVxcblxcdFxcdFxcdHZlYzMgcXVlcnlSZWZsZWN0VmVjID0gZmxpcE5vcm1hbCAqIHZlYzMoIGZsaXBFbnZNYXAgKiByZWZsZWN0VmVjLngsIHJlZmxlY3RWZWMueXogKTtcXG5cXHRcXHRcXHR2ZWM0IGVudk1hcENvbG9yID0gdGV4dHVyZUN1YmVVVihxdWVyeVJlZmxlY3RWZWMsIEJsaW5uRXhwb25lbnRUb0dHWFJvdWdobmVzcyhibGlublNoaW5pbmVzc0V4cG9uZW50KSk7XFxuXFx0XFx0I2VsaWYgZGVmaW5lZCggRU5WTUFQX1RZUEVfRVFVSVJFQyApXFxuXFx0XFx0XFx0dmVjMiBzYW1wbGVVVjtcXG5cXHRcXHRcXHRzYW1wbGVVVi55ID0gc2F0dXJhdGUoIGZsaXBOb3JtYWwgKiByZWZsZWN0VmVjLnkgKiAwLjUgKyAwLjUgKTtcXG5cXHRcXHRcXHRzYW1wbGVVVi54ID0gYXRhbiggZmxpcE5vcm1hbCAqIHJlZmxlY3RWZWMueiwgZmxpcE5vcm1hbCAqIHJlZmxlY3RWZWMueCApICogUkVDSVBST0NBTF9QSTIgKyAwLjU7XFxuXFx0XFx0XFx0I2lmZGVmIFRFWFRVUkVfTE9EX0VYVFxcblxcdFxcdFxcdFxcdHZlYzQgZW52TWFwQ29sb3IgPSB0ZXh0dXJlMkRMb2RFWFQoIGVudk1hcCwgc2FtcGxlVVYsIHNwZWN1bGFyTUlQTGV2ZWwgKTtcXG5cXHRcXHRcXHQjZWxzZVxcblxcdFxcdFxcdFxcdHZlYzQgZW52TWFwQ29sb3IgPSB0ZXh0dXJlMkQoIGVudk1hcCwgc2FtcGxlVVYsIHNwZWN1bGFyTUlQTGV2ZWwgKTtcXG5cXHRcXHRcXHQjZW5kaWZcXG5cXHRcXHRcXHRlbnZNYXBDb2xvci5yZ2IgPSBlbnZNYXBUZXhlbFRvTGluZWFyKCBlbnZNYXBDb2xvciApLnJnYjtcXG5cXHRcXHQjZWxpZiBkZWZpbmVkKCBFTlZNQVBfVFlQRV9TUEhFUkUgKVxcblxcdFxcdFxcdHZlYzMgcmVmbGVjdFZpZXcgPSBmbGlwTm9ybWFsICogbm9ybWFsaXplKCAoIHZpZXdNYXRyaXggKiB2ZWM0KCByZWZsZWN0VmVjLCAwLjAgKSApLnh5eiArIHZlYzMoIDAuMCwwLjAsMS4wICkgKTtcXG5cXHRcXHRcXHQjaWZkZWYgVEVYVFVSRV9MT0RfRVhUXFxuXFx0XFx0XFx0XFx0dmVjNCBlbnZNYXBDb2xvciA9IHRleHR1cmUyRExvZEVYVCggZW52TWFwLCByZWZsZWN0Vmlldy54eSAqIDAuNSArIDAuNSwgc3BlY3VsYXJNSVBMZXZlbCApO1xcblxcdFxcdFxcdCNlbHNlXFxuXFx0XFx0XFx0XFx0dmVjNCBlbnZNYXBDb2xvciA9IHRleHR1cmUyRCggZW52TWFwLCByZWZsZWN0Vmlldy54eSAqIDAuNSArIDAuNSwgc3BlY3VsYXJNSVBMZXZlbCApO1xcblxcdFxcdFxcdCNlbmRpZlxcblxcdFxcdFxcdGVudk1hcENvbG9yLnJnYiA9IGVudk1hcFRleGVsVG9MaW5lYXIoIGVudk1hcENvbG9yICkucmdiO1xcblxcdFxcdCNlbmRpZlxcblxcdFxcdHJldHVybiBlbnZNYXBDb2xvci5yZ2IgKiBlbnZNYXBJbnRlbnNpdHk7XFxuXFx0fVxcbiNlbmRpZlxcblwiO1xuXG4gICAgdmFyIGxpZ2h0c19waG9uZ19mcmFnbWVudCA9IFwiQmxpbm5QaG9uZ01hdGVyaWFsIG1hdGVyaWFsO1xcbm1hdGVyaWFsLmRpZmZ1c2VDb2xvciA9IGRpZmZ1c2VDb2xvci5yZ2I7XFxubWF0ZXJpYWwuc3BlY3VsYXJDb2xvciA9IHNwZWN1bGFyO1xcbm1hdGVyaWFsLnNwZWN1bGFyU2hpbmluZXNzID0gc2hpbmluZXNzO1xcbm1hdGVyaWFsLnNwZWN1bGFyU3RyZW5ndGggPSBzcGVjdWxhclN0cmVuZ3RoO1xcblwiO1xuXG4gICAgdmFyIGxpZ2h0c19waG9uZ19wYXJzX2ZyYWdtZW50ID0gXCJ2YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcXG4jaWZuZGVmIEZMQVRfU0hBREVEXFxuXFx0dmFyeWluZyB2ZWMzIHZOb3JtYWw7XFxuI2VuZGlmXFxuc3RydWN0IEJsaW5uUGhvbmdNYXRlcmlhbCB7XFxuXFx0dmVjM1xcdGRpZmZ1c2VDb2xvcjtcXG5cXHR2ZWMzXFx0c3BlY3VsYXJDb2xvcjtcXG5cXHRmbG9hdFxcdHNwZWN1bGFyU2hpbmluZXNzO1xcblxcdGZsb2F0XFx0c3BlY3VsYXJTdHJlbmd0aDtcXG59O1xcbnZvaWQgUkVfRGlyZWN0X0JsaW5uUGhvbmcoIGNvbnN0IGluIEluY2lkZW50TGlnaHQgZGlyZWN0TGlnaHQsIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnksIGNvbnN0IGluIEJsaW5uUGhvbmdNYXRlcmlhbCBtYXRlcmlhbCwgaW5vdXQgUmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgKSB7XFxuXFx0ZmxvYXQgZG90TkwgPSBzYXR1cmF0ZSggZG90KCBnZW9tZXRyeS5ub3JtYWwsIGRpcmVjdExpZ2h0LmRpcmVjdGlvbiApICk7XFxuXFx0dmVjMyBpcnJhZGlhbmNlID0gZG90TkwgKiBkaXJlY3RMaWdodC5jb2xvcjtcXG5cXHQjaWZuZGVmIFBIWVNJQ0FMTFlfQ09SUkVDVF9MSUdIVFNcXG5cXHRcXHRpcnJhZGlhbmNlICo9IFBJO1xcblxcdCNlbmRpZlxcblxcdHJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UgKz0gaXJyYWRpYW5jZSAqIEJSREZfRGlmZnVzZV9MYW1iZXJ0KCBtYXRlcmlhbC5kaWZmdXNlQ29sb3IgKTtcXG5cXHRyZWZsZWN0ZWRMaWdodC5kaXJlY3RTcGVjdWxhciArPSBpcnJhZGlhbmNlICogQlJERl9TcGVjdWxhcl9CbGlublBob25nKCBkaXJlY3RMaWdodCwgZ2VvbWV0cnksIG1hdGVyaWFsLnNwZWN1bGFyQ29sb3IsIG1hdGVyaWFsLnNwZWN1bGFyU2hpbmluZXNzICkgKiBtYXRlcmlhbC5zcGVjdWxhclN0cmVuZ3RoO1xcbn1cXG52b2lkIFJFX0luZGlyZWN0RGlmZnVzZV9CbGlublBob25nKCBjb25zdCBpbiB2ZWMzIGlycmFkaWFuY2UsIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnksIGNvbnN0IGluIEJsaW5uUGhvbmdNYXRlcmlhbCBtYXRlcmlhbCwgaW5vdXQgUmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgKSB7XFxuXFx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICs9IGlycmFkaWFuY2UgKiBCUkRGX0RpZmZ1c2VfTGFtYmVydCggbWF0ZXJpYWwuZGlmZnVzZUNvbG9yICk7XFxufVxcbiNkZWZpbmUgUkVfRGlyZWN0XFx0XFx0XFx0XFx0UkVfRGlyZWN0X0JsaW5uUGhvbmdcXG4jZGVmaW5lIFJFX0luZGlyZWN0RGlmZnVzZVxcdFxcdFJFX0luZGlyZWN0RGlmZnVzZV9CbGlublBob25nXFxuI2RlZmluZSBNYXRlcmlhbF9MaWdodFByb2JlTE9EKCBtYXRlcmlhbCApXFx0KDApXFxuXCI7XG5cbiAgICB2YXIgbGlnaHRzX3BoeXNpY2FsX2ZyYWdtZW50ID0gXCJQaHlzaWNhbE1hdGVyaWFsIG1hdGVyaWFsO1xcbm1hdGVyaWFsLmRpZmZ1c2VDb2xvciA9IGRpZmZ1c2VDb2xvci5yZ2IgKiAoIDEuMCAtIG1ldGFsbmVzc0ZhY3RvciApO1xcbm1hdGVyaWFsLnNwZWN1bGFyUm91Z2huZXNzID0gY2xhbXAoIHJvdWdobmVzc0ZhY3RvciwgMC4wNCwgMS4wICk7XFxuI2lmZGVmIFNUQU5EQVJEXFxuXFx0bWF0ZXJpYWwuc3BlY3VsYXJDb2xvciA9IG1peCggdmVjMyggREVGQVVMVF9TUEVDVUxBUl9DT0VGRklDSUVOVCApLCBkaWZmdXNlQ29sb3IucmdiLCBtZXRhbG5lc3NGYWN0b3IgKTtcXG4jZWxzZVxcblxcdG1hdGVyaWFsLnNwZWN1bGFyQ29sb3IgPSBtaXgoIHZlYzMoIE1BWElNVU1fU1BFQ1VMQVJfQ09FRkZJQ0lFTlQgKiBwb3cyKCByZWZsZWN0aXZpdHkgKSApLCBkaWZmdXNlQ29sb3IucmdiLCBtZXRhbG5lc3NGYWN0b3IgKTtcXG5cXHRtYXRlcmlhbC5jbGVhckNvYXQgPSBzYXR1cmF0ZSggY2xlYXJDb2F0ICk7XFx0bWF0ZXJpYWwuY2xlYXJDb2F0Um91Z2huZXNzID0gY2xhbXAoIGNsZWFyQ29hdFJvdWdobmVzcywgMC4wNCwgMS4wICk7XFxuI2VuZGlmXFxuXCI7XG5cbiAgICB2YXIgbGlnaHRzX3BoeXNpY2FsX3BhcnNfZnJhZ21lbnQgPSBcInN0cnVjdCBQaHlzaWNhbE1hdGVyaWFsIHtcXG5cXHR2ZWMzXFx0ZGlmZnVzZUNvbG9yO1xcblxcdGZsb2F0XFx0c3BlY3VsYXJSb3VnaG5lc3M7XFxuXFx0dmVjM1xcdHNwZWN1bGFyQ29sb3I7XFxuXFx0I2lmbmRlZiBTVEFOREFSRFxcblxcdFxcdGZsb2F0IGNsZWFyQ29hdDtcXG5cXHRcXHRmbG9hdCBjbGVhckNvYXRSb3VnaG5lc3M7XFxuXFx0I2VuZGlmXFxufTtcXG4jZGVmaW5lIE1BWElNVU1fU1BFQ1VMQVJfQ09FRkZJQ0lFTlQgMC4xNlxcbiNkZWZpbmUgREVGQVVMVF9TUEVDVUxBUl9DT0VGRklDSUVOVCAwLjA0XFxuZmxvYXQgY2xlYXJDb2F0REhSQXBwcm94KCBjb25zdCBpbiBmbG9hdCByb3VnaG5lc3MsIGNvbnN0IGluIGZsb2F0IGRvdE5MICkge1xcblxcdHJldHVybiBERUZBVUxUX1NQRUNVTEFSX0NPRUZGSUNJRU5UICsgKCAxLjAgLSBERUZBVUxUX1NQRUNVTEFSX0NPRUZGSUNJRU5UICkgKiAoIHBvdyggMS4wIC0gZG90TkwsIDUuMCApICogcG93KCAxLjAgLSByb3VnaG5lc3MsIDIuMCApICk7XFxufVxcbnZvaWQgUkVfRGlyZWN0X1BoeXNpY2FsKCBjb25zdCBpbiBJbmNpZGVudExpZ2h0IGRpcmVjdExpZ2h0LCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBjb25zdCBpbiBQaHlzaWNhbE1hdGVyaWFsIG1hdGVyaWFsLCBpbm91dCBSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCApIHtcXG5cXHRmbG9hdCBkb3ROTCA9IHNhdHVyYXRlKCBkb3QoIGdlb21ldHJ5Lm5vcm1hbCwgZGlyZWN0TGlnaHQuZGlyZWN0aW9uICkgKTtcXG5cXHR2ZWMzIGlycmFkaWFuY2UgPSBkb3ROTCAqIGRpcmVjdExpZ2h0LmNvbG9yO1xcblxcdCNpZm5kZWYgUEhZU0lDQUxMWV9DT1JSRUNUX0xJR0hUU1xcblxcdFxcdGlycmFkaWFuY2UgKj0gUEk7XFxuXFx0I2VuZGlmXFxuXFx0I2lmbmRlZiBTVEFOREFSRFxcblxcdFxcdGZsb2F0IGNsZWFyQ29hdERIUiA9IG1hdGVyaWFsLmNsZWFyQ29hdCAqIGNsZWFyQ29hdERIUkFwcHJveCggbWF0ZXJpYWwuY2xlYXJDb2F0Um91Z2huZXNzLCBkb3ROTCApO1xcblxcdCNlbHNlXFxuXFx0XFx0ZmxvYXQgY2xlYXJDb2F0REhSID0gMC4wO1xcblxcdCNlbmRpZlxcblxcdHJlZmxlY3RlZExpZ2h0LmRpcmVjdFNwZWN1bGFyICs9ICggMS4wIC0gY2xlYXJDb2F0REhSICkgKiBpcnJhZGlhbmNlICogQlJERl9TcGVjdWxhcl9HR1goIGRpcmVjdExpZ2h0LCBnZW9tZXRyeSwgbWF0ZXJpYWwuc3BlY3VsYXJDb2xvciwgbWF0ZXJpYWwuc3BlY3VsYXJSb3VnaG5lc3MgKTtcXG5cXHRyZWZsZWN0ZWRMaWdodC5kaXJlY3REaWZmdXNlICs9ICggMS4wIC0gY2xlYXJDb2F0REhSICkgKiBpcnJhZGlhbmNlICogQlJERl9EaWZmdXNlX0xhbWJlcnQoIG1hdGVyaWFsLmRpZmZ1c2VDb2xvciApO1xcblxcdCNpZm5kZWYgU1RBTkRBUkRcXG5cXHRcXHRyZWZsZWN0ZWRMaWdodC5kaXJlY3RTcGVjdWxhciArPSBpcnJhZGlhbmNlICogbWF0ZXJpYWwuY2xlYXJDb2F0ICogQlJERl9TcGVjdWxhcl9HR1goIGRpcmVjdExpZ2h0LCBnZW9tZXRyeSwgdmVjMyggREVGQVVMVF9TUEVDVUxBUl9DT0VGRklDSUVOVCApLCBtYXRlcmlhbC5jbGVhckNvYXRSb3VnaG5lc3MgKTtcXG5cXHQjZW5kaWZcXG59XFxudm9pZCBSRV9JbmRpcmVjdERpZmZ1c2VfUGh5c2ljYWwoIGNvbnN0IGluIHZlYzMgaXJyYWRpYW5jZSwgY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSwgY29uc3QgaW4gUGh5c2ljYWxNYXRlcmlhbCBtYXRlcmlhbCwgaW5vdXQgUmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgKSB7XFxuXFx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICs9IGlycmFkaWFuY2UgKiBCUkRGX0RpZmZ1c2VfTGFtYmVydCggbWF0ZXJpYWwuZGlmZnVzZUNvbG9yICk7XFxufVxcbnZvaWQgUkVfSW5kaXJlY3RTcGVjdWxhcl9QaHlzaWNhbCggY29uc3QgaW4gdmVjMyByYWRpYW5jZSwgY29uc3QgaW4gdmVjMyBjbGVhckNvYXRSYWRpYW5jZSwgY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSwgY29uc3QgaW4gUGh5c2ljYWxNYXRlcmlhbCBtYXRlcmlhbCwgaW5vdXQgUmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgKSB7XFxuXFx0I2lmbmRlZiBTVEFOREFSRFxcblxcdFxcdGZsb2F0IGRvdE5WID0gc2F0dXJhdGUoIGRvdCggZ2VvbWV0cnkubm9ybWFsLCBnZW9tZXRyeS52aWV3RGlyICkgKTtcXG5cXHRcXHRmbG9hdCBkb3ROTCA9IGRvdE5WO1xcblxcdFxcdGZsb2F0IGNsZWFyQ29hdERIUiA9IG1hdGVyaWFsLmNsZWFyQ29hdCAqIGNsZWFyQ29hdERIUkFwcHJveCggbWF0ZXJpYWwuY2xlYXJDb2F0Um91Z2huZXNzLCBkb3ROTCApO1xcblxcdCNlbHNlXFxuXFx0XFx0ZmxvYXQgY2xlYXJDb2F0REhSID0gMC4wO1xcblxcdCNlbmRpZlxcblxcdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0U3BlY3VsYXIgKz0gKCAxLjAgLSBjbGVhckNvYXRESFIgKSAqIHJhZGlhbmNlICogQlJERl9TcGVjdWxhcl9HR1hfRW52aXJvbm1lbnQoIGdlb21ldHJ5LCBtYXRlcmlhbC5zcGVjdWxhckNvbG9yLCBtYXRlcmlhbC5zcGVjdWxhclJvdWdobmVzcyApO1xcblxcdCNpZm5kZWYgU1RBTkRBUkRcXG5cXHRcXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdFNwZWN1bGFyICs9IGNsZWFyQ29hdFJhZGlhbmNlICogbWF0ZXJpYWwuY2xlYXJDb2F0ICogQlJERl9TcGVjdWxhcl9HR1hfRW52aXJvbm1lbnQoIGdlb21ldHJ5LCB2ZWMzKCBERUZBVUxUX1NQRUNVTEFSX0NPRUZGSUNJRU5UICksIG1hdGVyaWFsLmNsZWFyQ29hdFJvdWdobmVzcyApO1xcblxcdCNlbmRpZlxcbn1cXG4jZGVmaW5lIFJFX0RpcmVjdFxcdFxcdFxcdFxcdFJFX0RpcmVjdF9QaHlzaWNhbFxcbiNkZWZpbmUgUkVfSW5kaXJlY3REaWZmdXNlXFx0XFx0UkVfSW5kaXJlY3REaWZmdXNlX1BoeXNpY2FsXFxuI2RlZmluZSBSRV9JbmRpcmVjdFNwZWN1bGFyXFx0XFx0UkVfSW5kaXJlY3RTcGVjdWxhcl9QaHlzaWNhbFxcbiNkZWZpbmUgTWF0ZXJpYWxfQmxpbm5TaGluaW5lc3NFeHBvbmVudCggbWF0ZXJpYWwgKSAgIEdHWFJvdWdobmVzc1RvQmxpbm5FeHBvbmVudCggbWF0ZXJpYWwuc3BlY3VsYXJSb3VnaG5lc3MgKVxcbiNkZWZpbmUgTWF0ZXJpYWxfQ2xlYXJDb2F0X0JsaW5uU2hpbmluZXNzRXhwb25lbnQoIG1hdGVyaWFsICkgICBHR1hSb3VnaG5lc3NUb0JsaW5uRXhwb25lbnQoIG1hdGVyaWFsLmNsZWFyQ29hdFJvdWdobmVzcyApXFxuZmxvYXQgY29tcHV0ZVNwZWN1bGFyT2NjbHVzaW9uKCBjb25zdCBpbiBmbG9hdCBkb3ROViwgY29uc3QgaW4gZmxvYXQgYW1iaWVudE9jY2x1c2lvbiwgY29uc3QgaW4gZmxvYXQgcm91Z2huZXNzICkge1xcblxcdHJldHVybiBzYXR1cmF0ZSggcG93KCBkb3ROViArIGFtYmllbnRPY2NsdXNpb24sIGV4cDIoIC0gMTYuMCAqIHJvdWdobmVzcyAtIDEuMCApICkgLSAxLjAgKyBhbWJpZW50T2NjbHVzaW9uICk7XFxufVxcblwiO1xuXG4gICAgdmFyIGxpZ2h0c190ZW1wbGF0ZSA9IFwiXFxuR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeTtcXG5nZW9tZXRyeS5wb3NpdGlvbiA9IC0gdlZpZXdQb3NpdGlvbjtcXG5nZW9tZXRyeS5ub3JtYWwgPSBub3JtYWw7XFxuZ2VvbWV0cnkudmlld0RpciA9IG5vcm1hbGl6ZSggdlZpZXdQb3NpdGlvbiApO1xcbkluY2lkZW50TGlnaHQgZGlyZWN0TGlnaHQ7XFxuI2lmICggTlVNX1BPSU5UX0xJR0hUUyA+IDAgKSAmJiBkZWZpbmVkKCBSRV9EaXJlY3QgKVxcblxcdFBvaW50TGlnaHQgcG9pbnRMaWdodDtcXG5cXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fUE9JTlRfTElHSFRTOyBpICsrICkge1xcblxcdFxcdHBvaW50TGlnaHQgPSBwb2ludExpZ2h0c1sgaSBdO1xcblxcdFxcdGdldFBvaW50RGlyZWN0TGlnaHRJcnJhZGlhbmNlKCBwb2ludExpZ2h0LCBnZW9tZXRyeSwgZGlyZWN0TGlnaHQgKTtcXG5cXHRcXHQjaWZkZWYgVVNFX1NIQURPV01BUFxcblxcdFxcdGRpcmVjdExpZ2h0LmNvbG9yICo9IGFsbCggYnZlYzIoIHBvaW50TGlnaHQuc2hhZG93LCBkaXJlY3RMaWdodC52aXNpYmxlICkgKSA/IGdldFBvaW50U2hhZG93KCBwb2ludFNoYWRvd01hcFsgaSBdLCBwb2ludExpZ2h0LnNoYWRvd01hcFNpemUsIHBvaW50TGlnaHQuc2hhZG93QmlhcywgcG9pbnRMaWdodC5zaGFkb3dSYWRpdXMsIHZQb2ludFNoYWRvd0Nvb3JkWyBpIF0gKSA6IDEuMDtcXG5cXHRcXHQjZW5kaWZcXG5cXHRcXHRSRV9EaXJlY3QoIGRpcmVjdExpZ2h0LCBnZW9tZXRyeSwgbWF0ZXJpYWwsIHJlZmxlY3RlZExpZ2h0ICk7XFxuXFx0fVxcbiNlbmRpZlxcbiNpZiAoIE5VTV9TUE9UX0xJR0hUUyA+IDAgKSAmJiBkZWZpbmVkKCBSRV9EaXJlY3QgKVxcblxcdFNwb3RMaWdodCBzcG90TGlnaHQ7XFxuXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX1NQT1RfTElHSFRTOyBpICsrICkge1xcblxcdFxcdHNwb3RMaWdodCA9IHNwb3RMaWdodHNbIGkgXTtcXG5cXHRcXHRnZXRTcG90RGlyZWN0TGlnaHRJcnJhZGlhbmNlKCBzcG90TGlnaHQsIGdlb21ldHJ5LCBkaXJlY3RMaWdodCApO1xcblxcdFxcdCNpZmRlZiBVU0VfU0hBRE9XTUFQXFxuXFx0XFx0ZGlyZWN0TGlnaHQuY29sb3IgKj0gYWxsKCBidmVjMiggc3BvdExpZ2h0LnNoYWRvdywgZGlyZWN0TGlnaHQudmlzaWJsZSApICkgPyBnZXRTaGFkb3coIHNwb3RTaGFkb3dNYXBbIGkgXSwgc3BvdExpZ2h0LnNoYWRvd01hcFNpemUsIHNwb3RMaWdodC5zaGFkb3dCaWFzLCBzcG90TGlnaHQuc2hhZG93UmFkaXVzLCB2U3BvdFNoYWRvd0Nvb3JkWyBpIF0gKSA6IDEuMDtcXG5cXHRcXHQjZW5kaWZcXG5cXHRcXHRSRV9EaXJlY3QoIGRpcmVjdExpZ2h0LCBnZW9tZXRyeSwgbWF0ZXJpYWwsIHJlZmxlY3RlZExpZ2h0ICk7XFxuXFx0fVxcbiNlbmRpZlxcbiNpZiAoIE5VTV9ESVJfTElHSFRTID4gMCApICYmIGRlZmluZWQoIFJFX0RpcmVjdCApXFxuXFx0RGlyZWN0aW9uYWxMaWdodCBkaXJlY3Rpb25hbExpZ2h0O1xcblxcdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9ESVJfTElHSFRTOyBpICsrICkge1xcblxcdFxcdGRpcmVjdGlvbmFsTGlnaHQgPSBkaXJlY3Rpb25hbExpZ2h0c1sgaSBdO1xcblxcdFxcdGdldERpcmVjdGlvbmFsRGlyZWN0TGlnaHRJcnJhZGlhbmNlKCBkaXJlY3Rpb25hbExpZ2h0LCBnZW9tZXRyeSwgZGlyZWN0TGlnaHQgKTtcXG5cXHRcXHQjaWZkZWYgVVNFX1NIQURPV01BUFxcblxcdFxcdGRpcmVjdExpZ2h0LmNvbG9yICo9IGFsbCggYnZlYzIoIGRpcmVjdGlvbmFsTGlnaHQuc2hhZG93LCBkaXJlY3RMaWdodC52aXNpYmxlICkgKSA/IGdldFNoYWRvdyggZGlyZWN0aW9uYWxTaGFkb3dNYXBbIGkgXSwgZGlyZWN0aW9uYWxMaWdodC5zaGFkb3dNYXBTaXplLCBkaXJlY3Rpb25hbExpZ2h0LnNoYWRvd0JpYXMsIGRpcmVjdGlvbmFsTGlnaHQuc2hhZG93UmFkaXVzLCB2RGlyZWN0aW9uYWxTaGFkb3dDb29yZFsgaSBdICkgOiAxLjA7XFxuXFx0XFx0I2VuZGlmXFxuXFx0XFx0UkVfRGlyZWN0KCBkaXJlY3RMaWdodCwgZ2VvbWV0cnksIG1hdGVyaWFsLCByZWZsZWN0ZWRMaWdodCApO1xcblxcdH1cXG4jZW5kaWZcXG4jaWYgZGVmaW5lZCggUkVfSW5kaXJlY3REaWZmdXNlIClcXG5cXHR2ZWMzIGlycmFkaWFuY2UgPSBnZXRBbWJpZW50TGlnaHRJcnJhZGlhbmNlKCBhbWJpZW50TGlnaHRDb2xvciApO1xcblxcdCNpZmRlZiBVU0VfTElHSFRNQVBcXG5cXHRcXHR2ZWMzIGxpZ2h0TWFwSXJyYWRpYW5jZSA9IHRleHR1cmUyRCggbGlnaHRNYXAsIHZVdjIgKS54eXogKiBsaWdodE1hcEludGVuc2l0eTtcXG5cXHRcXHQjaWZuZGVmIFBIWVNJQ0FMTFlfQ09SUkVDVF9MSUdIVFNcXG5cXHRcXHRcXHRsaWdodE1hcElycmFkaWFuY2UgKj0gUEk7XFxuXFx0XFx0I2VuZGlmXFxuXFx0XFx0aXJyYWRpYW5jZSArPSBsaWdodE1hcElycmFkaWFuY2U7XFxuXFx0I2VuZGlmXFxuXFx0I2lmICggTlVNX0hFTUlfTElHSFRTID4gMCApXFxuXFx0XFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX0hFTUlfTElHSFRTOyBpICsrICkge1xcblxcdFxcdFxcdGlycmFkaWFuY2UgKz0gZ2V0SGVtaXNwaGVyZUxpZ2h0SXJyYWRpYW5jZSggaGVtaXNwaGVyZUxpZ2h0c1sgaSBdLCBnZW9tZXRyeSApO1xcblxcdFxcdH1cXG5cXHQjZW5kaWZcXG5cXHQjaWYgZGVmaW5lZCggVVNFX0VOVk1BUCApICYmIGRlZmluZWQoIFBIWVNJQ0FMICkgJiYgZGVmaW5lZCggRU5WTUFQX1RZUEVfQ1VCRV9VViApXFxuXFx0IFxcdGlycmFkaWFuY2UgKz0gZ2V0TGlnaHRQcm9iZUluZGlyZWN0SXJyYWRpYW5jZSggZ2VvbWV0cnksIDggKTtcXG5cXHQjZW5kaWZcXG5cXHRSRV9JbmRpcmVjdERpZmZ1c2UoIGlycmFkaWFuY2UsIGdlb21ldHJ5LCBtYXRlcmlhbCwgcmVmbGVjdGVkTGlnaHQgKTtcXG4jZW5kaWZcXG4jaWYgZGVmaW5lZCggVVNFX0VOVk1BUCApICYmIGRlZmluZWQoIFJFX0luZGlyZWN0U3BlY3VsYXIgKVxcblxcdHZlYzMgcmFkaWFuY2UgPSBnZXRMaWdodFByb2JlSW5kaXJlY3RSYWRpYW5jZSggZ2VvbWV0cnksIE1hdGVyaWFsX0JsaW5uU2hpbmluZXNzRXhwb25lbnQoIG1hdGVyaWFsICksIDggKTtcXG5cXHQjaWZuZGVmIFNUQU5EQVJEXFxuXFx0XFx0dmVjMyBjbGVhckNvYXRSYWRpYW5jZSA9IGdldExpZ2h0UHJvYmVJbmRpcmVjdFJhZGlhbmNlKCBnZW9tZXRyeSwgTWF0ZXJpYWxfQ2xlYXJDb2F0X0JsaW5uU2hpbmluZXNzRXhwb25lbnQoIG1hdGVyaWFsICksIDggKTtcXG5cXHQjZWxzZVxcblxcdFxcdHZlYzMgY2xlYXJDb2F0UmFkaWFuY2UgPSB2ZWMzKCAwLjAgKTtcXG5cXHQjZW5kaWZcXG5cXHRcXHRcXG5cXHRSRV9JbmRpcmVjdFNwZWN1bGFyKCByYWRpYW5jZSwgY2xlYXJDb2F0UmFkaWFuY2UsIGdlb21ldHJ5LCBtYXRlcmlhbCwgcmVmbGVjdGVkTGlnaHQgKTtcXG4jZW5kaWZcXG5cIjtcblxuICAgIHZhciBsb2dkZXB0aGJ1Zl9mcmFnbWVudCA9IFwiI2lmIGRlZmluZWQoVVNFX0xPR0RFUFRIQlVGKSAmJiBkZWZpbmVkKFVTRV9MT0dERVBUSEJVRl9FWFQpXFxuXFx0Z2xfRnJhZ0RlcHRoRVhUID0gbG9nMih2RnJhZ0RlcHRoKSAqIGxvZ0RlcHRoQnVmRkMgKiAwLjU7XFxuI2VuZGlmXCI7XG5cbiAgICB2YXIgbG9nZGVwdGhidWZfcGFyc19mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9MT0dERVBUSEJVRlxcblxcdHVuaWZvcm0gZmxvYXQgbG9nRGVwdGhCdWZGQztcXG5cXHQjaWZkZWYgVVNFX0xPR0RFUFRIQlVGX0VYVFxcblxcdFxcdHZhcnlpbmcgZmxvYXQgdkZyYWdEZXB0aDtcXG5cXHQjZW5kaWZcXG4jZW5kaWZcXG5cIjtcblxuICAgIHZhciBsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleCA9IFwiI2lmZGVmIFVTRV9MT0dERVBUSEJVRlxcblxcdCNpZmRlZiBVU0VfTE9HREVQVEhCVUZfRVhUXFxuXFx0XFx0dmFyeWluZyBmbG9hdCB2RnJhZ0RlcHRoO1xcblxcdCNlbmRpZlxcblxcdHVuaWZvcm0gZmxvYXQgbG9nRGVwdGhCdWZGQztcXG4jZW5kaWZcIjtcblxuICAgIHZhciBsb2dkZXB0aGJ1Zl92ZXJ0ZXggPSBcIiNpZmRlZiBVU0VfTE9HREVQVEhCVUZcXG5cXHRnbF9Qb3NpdGlvbi56ID0gbG9nMihtYXgoIEVQU0lMT04sIGdsX1Bvc2l0aW9uLncgKyAxLjAgKSkgKiBsb2dEZXB0aEJ1ZkZDO1xcblxcdCNpZmRlZiBVU0VfTE9HREVQVEhCVUZfRVhUXFxuXFx0XFx0dkZyYWdEZXB0aCA9IDEuMCArIGdsX1Bvc2l0aW9uLnc7XFxuXFx0I2Vsc2VcXG5cXHRcXHRnbF9Qb3NpdGlvbi56ID0gKGdsX1Bvc2l0aW9uLnogLSAxLjApICogZ2xfUG9zaXRpb24udztcXG5cXHQjZW5kaWZcXG4jZW5kaWZcXG5cIjtcblxuICAgIHZhciBtYXBfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfTUFQXFxuXFx0dmVjNCB0ZXhlbENvbG9yID0gdGV4dHVyZTJEKCBtYXAsIHZVdiApO1xcblxcdHRleGVsQ29sb3IgPSBtYXBUZXhlbFRvTGluZWFyKCB0ZXhlbENvbG9yICk7XFxuXFx0ZGlmZnVzZUNvbG9yICo9IHRleGVsQ29sb3I7XFxuI2VuZGlmXFxuXCI7XG5cbiAgICB2YXIgbWFwX3BhcnNfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfTUFQXFxuXFx0dW5pZm9ybSBzYW1wbGVyMkQgbWFwO1xcbiNlbmRpZlxcblwiO1xuXG4gICAgdmFyIG1hcF9wYXJ0aWNsZV9mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9NQVBcXG5cXHR2ZWM0IG1hcFRleGVsID0gdGV4dHVyZTJEKCBtYXAsIHZlYzIoIGdsX1BvaW50Q29vcmQueCwgMS4wIC0gZ2xfUG9pbnRDb29yZC55ICkgKiBvZmZzZXRSZXBlYXQuencgKyBvZmZzZXRSZXBlYXQueHkgKTtcXG5cXHRkaWZmdXNlQ29sb3IgKj0gbWFwVGV4ZWxUb0xpbmVhciggbWFwVGV4ZWwgKTtcXG4jZW5kaWZcXG5cIjtcblxuICAgIHZhciBtYXBfcGFydGljbGVfcGFyc19mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9NQVBcXG5cXHR1bmlmb3JtIHZlYzQgb2Zmc2V0UmVwZWF0O1xcblxcdHVuaWZvcm0gc2FtcGxlcjJEIG1hcDtcXG4jZW5kaWZcXG5cIjtcblxuICAgIHZhciBtZXRhbG5lc3NtYXBfZnJhZ21lbnQgPSBcImZsb2F0IG1ldGFsbmVzc0ZhY3RvciA9IG1ldGFsbmVzcztcXG4jaWZkZWYgVVNFX01FVEFMTkVTU01BUFxcblxcdHZlYzQgdGV4ZWxNZXRhbG5lc3MgPSB0ZXh0dXJlMkQoIG1ldGFsbmVzc01hcCwgdlV2ICk7XFxuXFx0bWV0YWxuZXNzRmFjdG9yICo9IHRleGVsTWV0YWxuZXNzLnI7XFxuI2VuZGlmXFxuXCI7XG5cbiAgICB2YXIgbWV0YWxuZXNzbWFwX3BhcnNfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfTUVUQUxORVNTTUFQXFxuXFx0dW5pZm9ybSBzYW1wbGVyMkQgbWV0YWxuZXNzTWFwO1xcbiNlbmRpZlwiO1xuXG4gICAgdmFyIG1vcnBobm9ybWFsX3ZlcnRleCA9IFwiI2lmZGVmIFVTRV9NT1JQSE5PUk1BTFNcXG5cXHRvYmplY3ROb3JtYWwgKz0gKCBtb3JwaE5vcm1hbDAgLSBub3JtYWwgKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMCBdO1xcblxcdG9iamVjdE5vcm1hbCArPSAoIG1vcnBoTm9ybWFsMSAtIG5vcm1hbCApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAxIF07XFxuXFx0b2JqZWN0Tm9ybWFsICs9ICggbW9ycGhOb3JtYWwyIC0gbm9ybWFsICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDIgXTtcXG5cXHRvYmplY3ROb3JtYWwgKz0gKCBtb3JwaE5vcm1hbDMgLSBub3JtYWwgKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMyBdO1xcbiNlbmRpZlxcblwiO1xuXG4gICAgdmFyIG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4ID0gXCIjaWZkZWYgVVNFX01PUlBIVEFSR0VUU1xcblxcdCNpZm5kZWYgVVNFX01PUlBITk9STUFMU1xcblxcdHVuaWZvcm0gZmxvYXQgbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyA4IF07XFxuXFx0I2Vsc2VcXG5cXHR1bmlmb3JtIGZsb2F0IG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgNCBdO1xcblxcdCNlbmRpZlxcbiNlbmRpZlwiO1xuXG4gICAgdmFyIG1vcnBodGFyZ2V0X3ZlcnRleCA9IFwiI2lmZGVmIFVTRV9NT1JQSFRBUkdFVFNcXG5cXHR0cmFuc2Zvcm1lZCArPSAoIG1vcnBoVGFyZ2V0MCAtIHBvc2l0aW9uICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDAgXTtcXG5cXHR0cmFuc2Zvcm1lZCArPSAoIG1vcnBoVGFyZ2V0MSAtIHBvc2l0aW9uICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDEgXTtcXG5cXHR0cmFuc2Zvcm1lZCArPSAoIG1vcnBoVGFyZ2V0MiAtIHBvc2l0aW9uICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDIgXTtcXG5cXHR0cmFuc2Zvcm1lZCArPSAoIG1vcnBoVGFyZ2V0MyAtIHBvc2l0aW9uICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDMgXTtcXG5cXHQjaWZuZGVmIFVTRV9NT1JQSE5PUk1BTFNcXG5cXHR0cmFuc2Zvcm1lZCArPSAoIG1vcnBoVGFyZ2V0NCAtIHBvc2l0aW9uICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDQgXTtcXG5cXHR0cmFuc2Zvcm1lZCArPSAoIG1vcnBoVGFyZ2V0NSAtIHBvc2l0aW9uICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDUgXTtcXG5cXHR0cmFuc2Zvcm1lZCArPSAoIG1vcnBoVGFyZ2V0NiAtIHBvc2l0aW9uICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDYgXTtcXG5cXHR0cmFuc2Zvcm1lZCArPSAoIG1vcnBoVGFyZ2V0NyAtIHBvc2l0aW9uICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDcgXTtcXG5cXHQjZW5kaWZcXG4jZW5kaWZcXG5cIjtcblxuICAgIHZhciBub3JtYWxfZmxpcCA9IFwiI2lmZGVmIERPVUJMRV9TSURFRFxcblxcdGZsb2F0IGZsaXBOb3JtYWwgPSAoIGZsb2F0KCBnbF9Gcm9udEZhY2luZyApICogMi4wIC0gMS4wICk7XFxuI2Vsc2VcXG5cXHRmbG9hdCBmbGlwTm9ybWFsID0gMS4wO1xcbiNlbmRpZlxcblwiO1xuXG4gICAgdmFyIG5vcm1hbF9mcmFnbWVudCA9IFwiI2lmZGVmIEZMQVRfU0hBREVEXFxuXFx0dmVjMyBmZHggPSB2ZWMzKCBkRmR4KCB2Vmlld1Bvc2l0aW9uLnggKSwgZEZkeCggdlZpZXdQb3NpdGlvbi55ICksIGRGZHgoIHZWaWV3UG9zaXRpb24ueiApICk7XFxuXFx0dmVjMyBmZHkgPSB2ZWMzKCBkRmR5KCB2Vmlld1Bvc2l0aW9uLnggKSwgZEZkeSggdlZpZXdQb3NpdGlvbi55ICksIGRGZHkoIHZWaWV3UG9zaXRpb24ueiApICk7XFxuXFx0dmVjMyBub3JtYWwgPSBub3JtYWxpemUoIGNyb3NzKCBmZHgsIGZkeSApICk7XFxuI2Vsc2VcXG5cXHR2ZWMzIG5vcm1hbCA9IG5vcm1hbGl6ZSggdk5vcm1hbCApICogZmxpcE5vcm1hbDtcXG4jZW5kaWZcXG4jaWZkZWYgVVNFX05PUk1BTE1BUFxcblxcdG5vcm1hbCA9IHBlcnR1cmJOb3JtYWwyQXJiKCAtdlZpZXdQb3NpdGlvbiwgbm9ybWFsICk7XFxuI2VsaWYgZGVmaW5lZCggVVNFX0JVTVBNQVAgKVxcblxcdG5vcm1hbCA9IHBlcnR1cmJOb3JtYWxBcmIoIC12Vmlld1Bvc2l0aW9uLCBub3JtYWwsIGRIZHh5X2Z3ZCgpICk7XFxuI2VuZGlmXFxuXCI7XG5cbiAgICB2YXIgbm9ybWFsbWFwX3BhcnNfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfTk9STUFMTUFQXFxuXFx0dW5pZm9ybSBzYW1wbGVyMkQgbm9ybWFsTWFwO1xcblxcdHVuaWZvcm0gdmVjMiBub3JtYWxTY2FsZTtcXG5cXHR2ZWMzIHBlcnR1cmJOb3JtYWwyQXJiKCB2ZWMzIGV5ZV9wb3MsIHZlYzMgc3VyZl9ub3JtICkge1xcblxcdFxcdHZlYzMgcTAgPSBkRmR4KCBleWVfcG9zLnh5eiApO1xcblxcdFxcdHZlYzMgcTEgPSBkRmR5KCBleWVfcG9zLnh5eiApO1xcblxcdFxcdHZlYzIgc3QwID0gZEZkeCggdlV2LnN0ICk7XFxuXFx0XFx0dmVjMiBzdDEgPSBkRmR5KCB2VXYuc3QgKTtcXG5cXHRcXHR2ZWMzIFMgPSBub3JtYWxpemUoIHEwICogc3QxLnQgLSBxMSAqIHN0MC50ICk7XFxuXFx0XFx0dmVjMyBUID0gbm9ybWFsaXplKCAtcTAgKiBzdDEucyArIHExICogc3QwLnMgKTtcXG5cXHRcXHR2ZWMzIE4gPSBub3JtYWxpemUoIHN1cmZfbm9ybSApO1xcblxcdFxcdHZlYzMgbWFwTiA9IHRleHR1cmUyRCggbm9ybWFsTWFwLCB2VXYgKS54eXogKiAyLjAgLSAxLjA7XFxuXFx0XFx0bWFwTi54eSA9IG5vcm1hbFNjYWxlICogbWFwTi54eTtcXG5cXHRcXHRtYXQzIHRzbiA9IG1hdDMoIFMsIFQsIE4gKTtcXG5cXHRcXHRyZXR1cm4gbm9ybWFsaXplKCB0c24gKiBtYXBOICk7XFxuXFx0fVxcbiNlbmRpZlxcblwiO1xuXG4gICAgdmFyIHBhY2tpbmcgPSBcInZlYzMgcGFja05vcm1hbFRvUkdCKCBjb25zdCBpbiB2ZWMzIG5vcm1hbCApIHtcXG4gIHJldHVybiBub3JtYWxpemUoIG5vcm1hbCApICogMC41ICsgMC41O1xcbn1cXG52ZWMzIHVucGFja1JHQlRvTm9ybWFsKCBjb25zdCBpbiB2ZWMzIHJnYiApIHtcXG4gIHJldHVybiAxLjAgLSAyLjAgKiByZ2IueHl6O1xcbn1cXG5jb25zdCBmbG9hdCBQYWNrVXBzY2FsZSA9IDI1Ni4gLyAyNTUuO2NvbnN0IGZsb2F0IFVucGFja0Rvd25zY2FsZSA9IDI1NS4gLyAyNTYuO1xcbmNvbnN0IHZlYzMgUGFja0ZhY3RvcnMgPSB2ZWMzKCAyNTYuICogMjU2LiAqIDI1Ni4sIDI1Ni4gKiAyNTYuLCAgMjU2LiApO1xcbmNvbnN0IHZlYzQgVW5wYWNrRmFjdG9ycyA9IFVucGFja0Rvd25zY2FsZSAvIHZlYzQoIFBhY2tGYWN0b3JzLCAxLiApO1xcbmNvbnN0IGZsb2F0IFNoaWZ0UmlnaHQ4ID0gMS4gLyAyNTYuO1xcbnZlYzQgcGFja0RlcHRoVG9SR0JBKCBjb25zdCBpbiBmbG9hdCB2ICkge1xcblxcdHZlYzQgciA9IHZlYzQoIGZyYWN0KCB2ICogUGFja0ZhY3RvcnMgKSwgdiApO1xcblxcdHIueXp3IC09IHIueHl6ICogU2hpZnRSaWdodDg7XFx0cmV0dXJuIHIgKiBQYWNrVXBzY2FsZTtcXG59XFxuZmxvYXQgdW5wYWNrUkdCQVRvRGVwdGgoIGNvbnN0IGluIHZlYzQgdiApIHtcXG5cXHRyZXR1cm4gZG90KCB2LCBVbnBhY2tGYWN0b3JzICk7XFxufVxcbmZsb2F0IHZpZXdaVG9PcnRob2dyYXBoaWNEZXB0aCggY29uc3QgaW4gZmxvYXQgdmlld1osIGNvbnN0IGluIGZsb2F0IG5lYXIsIGNvbnN0IGluIGZsb2F0IGZhciApIHtcXG4gIHJldHVybiAoIHZpZXdaICsgbmVhciApIC8gKCBuZWFyIC0gZmFyICk7XFxufVxcbmZsb2F0IG9ydGhvZ3JhcGhpY0RlcHRoVG9WaWV3WiggY29uc3QgaW4gZmxvYXQgbGluZWFyQ2xpcFosIGNvbnN0IGluIGZsb2F0IG5lYXIsIGNvbnN0IGluIGZsb2F0IGZhciApIHtcXG4gIHJldHVybiBsaW5lYXJDbGlwWiAqICggbmVhciAtIGZhciApIC0gbmVhcjtcXG59XFxuZmxvYXQgdmlld1pUb1BlcnNwZWN0aXZlRGVwdGgoIGNvbnN0IGluIGZsb2F0IHZpZXdaLCBjb25zdCBpbiBmbG9hdCBuZWFyLCBjb25zdCBpbiBmbG9hdCBmYXIgKSB7XFxuICByZXR1cm4gKCggbmVhciArIHZpZXdaICkgKiBmYXIgKSAvICgoIGZhciAtIG5lYXIgKSAqIHZpZXdaICk7XFxufVxcbmZsb2F0IHBlcnNwZWN0aXZlRGVwdGhUb1ZpZXdaKCBjb25zdCBpbiBmbG9hdCBpbnZDbGlwWiwgY29uc3QgaW4gZmxvYXQgbmVhciwgY29uc3QgaW4gZmxvYXQgZmFyICkge1xcbiAgcmV0dXJuICggbmVhciAqIGZhciApIC8gKCAoIGZhciAtIG5lYXIgKSAqIGludkNsaXBaIC0gZmFyICk7XFxufVxcblwiO1xuXG4gICAgdmFyIHByZW11bHRpcGxpZWRfYWxwaGFfZnJhZ21lbnQgPSBcIiNpZmRlZiBQUkVNVUxUSVBMSUVEX0FMUEhBXFxuXFx0Z2xfRnJhZ0NvbG9yLnJnYiAqPSBnbF9GcmFnQ29sb3IuYTtcXG4jZW5kaWZcXG5cIjtcblxuICAgIHZhciBwcm9qZWN0X3ZlcnRleCA9IFwiI2lmZGVmIFVTRV9TS0lOTklOR1xcblxcdHZlYzQgbXZQb3NpdGlvbiA9IG1vZGVsVmlld01hdHJpeCAqIHNraW5uZWQ7XFxuI2Vsc2VcXG5cXHR2ZWM0IG12UG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCB0cmFuc2Zvcm1lZCwgMS4wICk7XFxuI2VuZGlmXFxuZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbXZQb3NpdGlvbjtcXG5cIjtcblxuICAgIHZhciByb3VnaG5lc3NtYXBfZnJhZ21lbnQgPSBcImZsb2F0IHJvdWdobmVzc0ZhY3RvciA9IHJvdWdobmVzcztcXG4jaWZkZWYgVVNFX1JPVUdITkVTU01BUFxcblxcdHZlYzQgdGV4ZWxSb3VnaG5lc3MgPSB0ZXh0dXJlMkQoIHJvdWdobmVzc01hcCwgdlV2ICk7XFxuXFx0cm91Z2huZXNzRmFjdG9yICo9IHRleGVsUm91Z2huZXNzLnI7XFxuI2VuZGlmXFxuXCI7XG5cbiAgICB2YXIgcm91Z2huZXNzbWFwX3BhcnNfZnJhZ21lbnQgPSBcIiNpZmRlZiBVU0VfUk9VR0hORVNTTUFQXFxuXFx0dW5pZm9ybSBzYW1wbGVyMkQgcm91Z2huZXNzTWFwO1xcbiNlbmRpZlwiO1xuXG4gICAgdmFyIHNoYWRvd21hcF9wYXJzX2ZyYWdtZW50ID0gXCIjaWZkZWYgVVNFX1NIQURPV01BUFxcblxcdCNpZiBOVU1fRElSX0xJR0hUUyA+IDBcXG5cXHRcXHR1bmlmb3JtIHNhbXBsZXIyRCBkaXJlY3Rpb25hbFNoYWRvd01hcFsgTlVNX0RJUl9MSUdIVFMgXTtcXG5cXHRcXHR2YXJ5aW5nIHZlYzQgdkRpcmVjdGlvbmFsU2hhZG93Q29vcmRbIE5VTV9ESVJfTElHSFRTIF07XFxuXFx0I2VuZGlmXFxuXFx0I2lmIE5VTV9TUE9UX0xJR0hUUyA+IDBcXG5cXHRcXHR1bmlmb3JtIHNhbXBsZXIyRCBzcG90U2hhZG93TWFwWyBOVU1fU1BPVF9MSUdIVFMgXTtcXG5cXHRcXHR2YXJ5aW5nIHZlYzQgdlNwb3RTaGFkb3dDb29yZFsgTlVNX1NQT1RfTElHSFRTIF07XFxuXFx0I2VuZGlmXFxuXFx0I2lmIE5VTV9QT0lOVF9MSUdIVFMgPiAwXFxuXFx0XFx0dW5pZm9ybSBzYW1wbGVyMkQgcG9pbnRTaGFkb3dNYXBbIE5VTV9QT0lOVF9MSUdIVFMgXTtcXG5cXHRcXHR2YXJ5aW5nIHZlYzQgdlBvaW50U2hhZG93Q29vcmRbIE5VTV9QT0lOVF9MSUdIVFMgXTtcXG5cXHQjZW5kaWZcXG5cXHRmbG9hdCB0ZXh0dXJlMkRDb21wYXJlKCBzYW1wbGVyMkQgZGVwdGhzLCB2ZWMyIHV2LCBmbG9hdCBjb21wYXJlICkge1xcblxcdFxcdHJldHVybiBzdGVwKCBjb21wYXJlLCB1bnBhY2tSR0JBVG9EZXB0aCggdGV4dHVyZTJEKCBkZXB0aHMsIHV2ICkgKSApO1xcblxcdH1cXG5cXHRmbG9hdCB0ZXh0dXJlMkRTaGFkb3dMZXJwKCBzYW1wbGVyMkQgZGVwdGhzLCB2ZWMyIHNpemUsIHZlYzIgdXYsIGZsb2F0IGNvbXBhcmUgKSB7XFxuXFx0XFx0Y29uc3QgdmVjMiBvZmZzZXQgPSB2ZWMyKCAwLjAsIDEuMCApO1xcblxcdFxcdHZlYzIgdGV4ZWxTaXplID0gdmVjMiggMS4wICkgLyBzaXplO1xcblxcdFxcdHZlYzIgY2VudHJvaWRVViA9IGZsb29yKCB1diAqIHNpemUgKyAwLjUgKSAvIHNpemU7XFxuXFx0XFx0ZmxvYXQgbGIgPSB0ZXh0dXJlMkRDb21wYXJlKCBkZXB0aHMsIGNlbnRyb2lkVVYgKyB0ZXhlbFNpemUgKiBvZmZzZXQueHgsIGNvbXBhcmUgKTtcXG5cXHRcXHRmbG9hdCBsdCA9IHRleHR1cmUyRENvbXBhcmUoIGRlcHRocywgY2VudHJvaWRVViArIHRleGVsU2l6ZSAqIG9mZnNldC54eSwgY29tcGFyZSApO1xcblxcdFxcdGZsb2F0IHJiID0gdGV4dHVyZTJEQ29tcGFyZSggZGVwdGhzLCBjZW50cm9pZFVWICsgdGV4ZWxTaXplICogb2Zmc2V0Lnl4LCBjb21wYXJlICk7XFxuXFx0XFx0ZmxvYXQgcnQgPSB0ZXh0dXJlMkRDb21wYXJlKCBkZXB0aHMsIGNlbnRyb2lkVVYgKyB0ZXhlbFNpemUgKiBvZmZzZXQueXksIGNvbXBhcmUgKTtcXG5cXHRcXHR2ZWMyIGYgPSBmcmFjdCggdXYgKiBzaXplICsgMC41ICk7XFxuXFx0XFx0ZmxvYXQgYSA9IG1peCggbGIsIGx0LCBmLnkgKTtcXG5cXHRcXHRmbG9hdCBiID0gbWl4KCByYiwgcnQsIGYueSApO1xcblxcdFxcdGZsb2F0IGMgPSBtaXgoIGEsIGIsIGYueCApO1xcblxcdFxcdHJldHVybiBjO1xcblxcdH1cXG5cXHRmbG9hdCBnZXRTaGFkb3coIHNhbXBsZXIyRCBzaGFkb3dNYXAsIHZlYzIgc2hhZG93TWFwU2l6ZSwgZmxvYXQgc2hhZG93QmlhcywgZmxvYXQgc2hhZG93UmFkaXVzLCB2ZWM0IHNoYWRvd0Nvb3JkICkge1xcblxcdFxcdHNoYWRvd0Nvb3JkLnh5eiAvPSBzaGFkb3dDb29yZC53O1xcblxcdFxcdHNoYWRvd0Nvb3JkLnogKz0gc2hhZG93QmlhcztcXG5cXHRcXHRidmVjNCBpbkZydXN0dW1WZWMgPSBidmVjNCAoIHNoYWRvd0Nvb3JkLnggPj0gMC4wLCBzaGFkb3dDb29yZC54IDw9IDEuMCwgc2hhZG93Q29vcmQueSA+PSAwLjAsIHNoYWRvd0Nvb3JkLnkgPD0gMS4wICk7XFxuXFx0XFx0Ym9vbCBpbkZydXN0dW0gPSBhbGwoIGluRnJ1c3R1bVZlYyApO1xcblxcdFxcdGJ2ZWMyIGZydXN0dW1UZXN0VmVjID0gYnZlYzIoIGluRnJ1c3R1bSwgc2hhZG93Q29vcmQueiA8PSAxLjAgKTtcXG5cXHRcXHRib29sIGZydXN0dW1UZXN0ID0gYWxsKCBmcnVzdHVtVGVzdFZlYyApO1xcblxcdFxcdGlmICggZnJ1c3R1bVRlc3QgKSB7XFxuXFx0XFx0I2lmIGRlZmluZWQoIFNIQURPV01BUF9UWVBFX1BDRiApXFxuXFx0XFx0XFx0dmVjMiB0ZXhlbFNpemUgPSB2ZWMyKCAxLjAgKSAvIHNoYWRvd01hcFNpemU7XFxuXFx0XFx0XFx0ZmxvYXQgZHgwID0gLSB0ZXhlbFNpemUueCAqIHNoYWRvd1JhZGl1cztcXG5cXHRcXHRcXHRmbG9hdCBkeTAgPSAtIHRleGVsU2l6ZS55ICogc2hhZG93UmFkaXVzO1xcblxcdFxcdFxcdGZsb2F0IGR4MSA9ICsgdGV4ZWxTaXplLnggKiBzaGFkb3dSYWRpdXM7XFxuXFx0XFx0XFx0ZmxvYXQgZHkxID0gKyB0ZXhlbFNpemUueSAqIHNoYWRvd1JhZGl1cztcXG5cXHRcXHRcXHRyZXR1cm4gKFxcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDAsIGR5MCApLCBzaGFkb3dDb29yZC56ICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCAwLjAsIGR5MCApLCBzaGFkb3dDb29yZC56ICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDEsIGR5MCApLCBzaGFkb3dDb29yZC56ICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDAsIDAuMCApLCBzaGFkb3dDb29yZC56ICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHksIHNoYWRvd0Nvb3JkLnogKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MSwgMC4wICksIHNoYWRvd0Nvb3JkLnogKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MCwgZHkxICksIHNoYWRvd0Nvb3JkLnogKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIDAuMCwgZHkxICksIHNoYWRvd0Nvb3JkLnogKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MSwgZHkxICksIHNoYWRvd0Nvb3JkLnogKVxcblxcdFxcdFxcdCkgKiAoIDEuMCAvIDkuMCApO1xcblxcdFxcdCNlbGlmIGRlZmluZWQoIFNIQURPV01BUF9UWVBFX1BDRl9TT0ZUIClcXG5cXHRcXHRcXHR2ZWMyIHRleGVsU2l6ZSA9IHZlYzIoIDEuMCApIC8gc2hhZG93TWFwU2l6ZTtcXG5cXHRcXHRcXHRmbG9hdCBkeDAgPSAtIHRleGVsU2l6ZS54ICogc2hhZG93UmFkaXVzO1xcblxcdFxcdFxcdGZsb2F0IGR5MCA9IC0gdGV4ZWxTaXplLnkgKiBzaGFkb3dSYWRpdXM7XFxuXFx0XFx0XFx0ZmxvYXQgZHgxID0gKyB0ZXhlbFNpemUueCAqIHNoYWRvd1JhZGl1cztcXG5cXHRcXHRcXHRmbG9hdCBkeTEgPSArIHRleGVsU2l6ZS55ICogc2hhZG93UmFkaXVzO1xcblxcdFxcdFxcdHJldHVybiAoXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEU2hhZG93TGVycCggc2hhZG93TWFwLCBzaGFkb3dNYXBTaXplLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MCwgZHkwICksIHNoYWRvd0Nvb3JkLnogKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEU2hhZG93TGVycCggc2hhZG93TWFwLCBzaGFkb3dNYXBTaXplLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIDAuMCwgZHkwICksIHNoYWRvd0Nvb3JkLnogKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEU2hhZG93TGVycCggc2hhZG93TWFwLCBzaGFkb3dNYXBTaXplLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MSwgZHkwICksIHNoYWRvd0Nvb3JkLnogKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEU2hhZG93TGVycCggc2hhZG93TWFwLCBzaGFkb3dNYXBTaXplLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MCwgMC4wICksIHNoYWRvd0Nvb3JkLnogKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEU2hhZG93TGVycCggc2hhZG93TWFwLCBzaGFkb3dNYXBTaXplLCBzaGFkb3dDb29yZC54eSwgc2hhZG93Q29vcmQueiApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRTaGFkb3dMZXJwKCBzaGFkb3dNYXAsIHNoYWRvd01hcFNpemUsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgxLCAwLjAgKSwgc2hhZG93Q29vcmQueiApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRTaGFkb3dMZXJwKCBzaGFkb3dNYXAsIHNoYWRvd01hcFNpemUsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgwLCBkeTEgKSwgc2hhZG93Q29vcmQueiApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRTaGFkb3dMZXJwKCBzaGFkb3dNYXAsIHNoYWRvd01hcFNpemUsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggMC4wLCBkeTEgKSwgc2hhZG93Q29vcmQueiApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRTaGFkb3dMZXJwKCBzaGFkb3dNYXAsIHNoYWRvd01hcFNpemUsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgxLCBkeTEgKSwgc2hhZG93Q29vcmQueiApXFxuXFx0XFx0XFx0KSAqICggMS4wIC8gOS4wICk7XFxuXFx0XFx0I2Vsc2VcXG5cXHRcXHRcXHRyZXR1cm4gdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSwgc2hhZG93Q29vcmQueiApO1xcblxcdFxcdCNlbmRpZlxcblxcdFxcdH1cXG5cXHRcXHRyZXR1cm4gMS4wO1xcblxcdH1cXG5cXHR2ZWMyIGN1YmVUb1VWKCB2ZWMzIHYsIGZsb2F0IHRleGVsU2l6ZVkgKSB7XFxuXFx0XFx0dmVjMyBhYnNWID0gYWJzKCB2ICk7XFxuXFx0XFx0ZmxvYXQgc2NhbGVUb0N1YmUgPSAxLjAgLyBtYXgoIGFic1YueCwgbWF4KCBhYnNWLnksIGFic1YueiApICk7XFxuXFx0XFx0YWJzViAqPSBzY2FsZVRvQ3ViZTtcXG5cXHRcXHR2ICo9IHNjYWxlVG9DdWJlICogKCAxLjAgLSAyLjAgKiB0ZXhlbFNpemVZICk7XFxuXFx0XFx0dmVjMiBwbGFuYXIgPSB2Lnh5O1xcblxcdFxcdGZsb2F0IGFsbW9zdEFUZXhlbCA9IDEuNSAqIHRleGVsU2l6ZVk7XFxuXFx0XFx0ZmxvYXQgYWxtb3N0T25lID0gMS4wIC0gYWxtb3N0QVRleGVsO1xcblxcdFxcdGlmICggYWJzVi56ID49IGFsbW9zdE9uZSApIHtcXG5cXHRcXHRcXHRpZiAoIHYueiA+IDAuMCApXFxuXFx0XFx0XFx0XFx0cGxhbmFyLnggPSA0LjAgLSB2Lng7XFxuXFx0XFx0fSBlbHNlIGlmICggYWJzVi54ID49IGFsbW9zdE9uZSApIHtcXG5cXHRcXHRcXHRmbG9hdCBzaWduWCA9IHNpZ24oIHYueCApO1xcblxcdFxcdFxcdHBsYW5hci54ID0gdi56ICogc2lnblggKyAyLjAgKiBzaWduWDtcXG5cXHRcXHR9IGVsc2UgaWYgKCBhYnNWLnkgPj0gYWxtb3N0T25lICkge1xcblxcdFxcdFxcdGZsb2F0IHNpZ25ZID0gc2lnbiggdi55ICk7XFxuXFx0XFx0XFx0cGxhbmFyLnggPSB2LnggKyAyLjAgKiBzaWduWSArIDIuMDtcXG5cXHRcXHRcXHRwbGFuYXIueSA9IHYueiAqIHNpZ25ZIC0gMi4wO1xcblxcdFxcdH1cXG5cXHRcXHRyZXR1cm4gdmVjMiggMC4xMjUsIDAuMjUgKSAqIHBsYW5hciArIHZlYzIoIDAuMzc1LCAwLjc1ICk7XFxuXFx0fVxcblxcdGZsb2F0IGdldFBvaW50U2hhZG93KCBzYW1wbGVyMkQgc2hhZG93TWFwLCB2ZWMyIHNoYWRvd01hcFNpemUsIGZsb2F0IHNoYWRvd0JpYXMsIGZsb2F0IHNoYWRvd1JhZGl1cywgdmVjNCBzaGFkb3dDb29yZCApIHtcXG5cXHRcXHR2ZWMyIHRleGVsU2l6ZSA9IHZlYzIoIDEuMCApIC8gKCBzaGFkb3dNYXBTaXplICogdmVjMiggNC4wLCAyLjAgKSApO1xcblxcdFxcdHZlYzMgbGlnaHRUb1Bvc2l0aW9uID0gc2hhZG93Q29vcmQueHl6O1xcblxcdFxcdHZlYzMgYmQzRCA9IG5vcm1hbGl6ZSggbGlnaHRUb1Bvc2l0aW9uICk7XFxuXFx0XFx0ZmxvYXQgZHAgPSAoIGxlbmd0aCggbGlnaHRUb1Bvc2l0aW9uICkgLSBzaGFkb3dCaWFzICkgLyAxMDAwLjA7XFxuXFx0XFx0I2lmIGRlZmluZWQoIFNIQURPV01BUF9UWVBFX1BDRiApIHx8IGRlZmluZWQoIFNIQURPV01BUF9UWVBFX1BDRl9TT0ZUIClcXG5cXHRcXHRcXHR2ZWMyIG9mZnNldCA9IHZlYzIoIC0gMSwgMSApICogc2hhZG93UmFkaXVzICogdGV4ZWxTaXplLnk7XFxuXFx0XFx0XFx0cmV0dXJuIChcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNEICsgb2Zmc2V0Lnh5eSwgdGV4ZWxTaXplLnkgKSwgZHAgKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCArIG9mZnNldC55eXksIHRleGVsU2l6ZS55ICksIGRwICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgY3ViZVRvVVYoIGJkM0QgKyBvZmZzZXQueHl4LCB0ZXhlbFNpemUueSApLCBkcCApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNEICsgb2Zmc2V0Lnl5eCwgdGV4ZWxTaXplLnkgKSwgZHAgKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCwgdGV4ZWxTaXplLnkgKSwgZHAgKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCArIG9mZnNldC54eHksIHRleGVsU2l6ZS55ICksIGRwICkgK1xcblxcdFxcdFxcdFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgY3ViZVRvVVYoIGJkM0QgKyBvZmZzZXQueXh5LCB0ZXhlbFNpemUueSApLCBkcCApICtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNEICsgb2Zmc2V0Lnh4eCwgdGV4ZWxTaXplLnkgKSwgZHAgKSArXFxuXFx0XFx0XFx0XFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCArIG9mZnNldC55eHgsIHRleGVsU2l6ZS55ICksIGRwIClcXG5cXHRcXHRcXHQpICogKCAxLjAgLyA5LjAgKTtcXG5cXHRcXHQjZWxzZVxcblxcdFxcdFxcdHJldHVybiB0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNELCB0ZXhlbFNpemUueSApLCBkcCApO1xcblxcdFxcdCNlbmRpZlxcblxcdH1cXG4jZW5kaWZcXG5cIjtcblxuICAgIHZhciBzaGFkb3dtYXBfcGFyc192ZXJ0ZXggPSBcIiNpZmRlZiBVU0VfU0hBRE9XTUFQXFxuXFx0I2lmIE5VTV9ESVJfTElHSFRTID4gMFxcblxcdFxcdHVuaWZvcm0gbWF0NCBkaXJlY3Rpb25hbFNoYWRvd01hdHJpeFsgTlVNX0RJUl9MSUdIVFMgXTtcXG5cXHRcXHR2YXJ5aW5nIHZlYzQgdkRpcmVjdGlvbmFsU2hhZG93Q29vcmRbIE5VTV9ESVJfTElHSFRTIF07XFxuXFx0I2VuZGlmXFxuXFx0I2lmIE5VTV9TUE9UX0xJR0hUUyA+IDBcXG5cXHRcXHR1bmlmb3JtIG1hdDQgc3BvdFNoYWRvd01hdHJpeFsgTlVNX1NQT1RfTElHSFRTIF07XFxuXFx0XFx0dmFyeWluZyB2ZWM0IHZTcG90U2hhZG93Q29vcmRbIE5VTV9TUE9UX0xJR0hUUyBdO1xcblxcdCNlbmRpZlxcblxcdCNpZiBOVU1fUE9JTlRfTElHSFRTID4gMFxcblxcdFxcdHVuaWZvcm0gbWF0NCBwb2ludFNoYWRvd01hdHJpeFsgTlVNX1BPSU5UX0xJR0hUUyBdO1xcblxcdFxcdHZhcnlpbmcgdmVjNCB2UG9pbnRTaGFkb3dDb29yZFsgTlVNX1BPSU5UX0xJR0hUUyBdO1xcblxcdCNlbmRpZlxcbiNlbmRpZlxcblwiO1xuXG4gICAgdmFyIHNoYWRvd21hcF92ZXJ0ZXggPSBcIiNpZmRlZiBVU0VfU0hBRE9XTUFQXFxuXFx0I2lmIE5VTV9ESVJfTElHSFRTID4gMFxcblxcdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9ESVJfTElHSFRTOyBpICsrICkge1xcblxcdFxcdHZEaXJlY3Rpb25hbFNoYWRvd0Nvb3JkWyBpIF0gPSBkaXJlY3Rpb25hbFNoYWRvd01hdHJpeFsgaSBdICogd29ybGRQb3NpdGlvbjtcXG5cXHR9XFxuXFx0I2VuZGlmXFxuXFx0I2lmIE5VTV9TUE9UX0xJR0hUUyA+IDBcXG5cXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fU1BPVF9MSUdIVFM7IGkgKysgKSB7XFxuXFx0XFx0dlNwb3RTaGFkb3dDb29yZFsgaSBdID0gc3BvdFNoYWRvd01hdHJpeFsgaSBdICogd29ybGRQb3NpdGlvbjtcXG5cXHR9XFxuXFx0I2VuZGlmXFxuXFx0I2lmIE5VTV9QT0lOVF9MSUdIVFMgPiAwXFxuXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX1BPSU5UX0xJR0hUUzsgaSArKyApIHtcXG5cXHRcXHR2UG9pbnRTaGFkb3dDb29yZFsgaSBdID0gcG9pbnRTaGFkb3dNYXRyaXhbIGkgXSAqIHdvcmxkUG9zaXRpb247XFxuXFx0fVxcblxcdCNlbmRpZlxcbiNlbmRpZlxcblwiO1xuXG4gICAgdmFyIHNoYWRvd21hc2tfcGFyc19mcmFnbWVudCA9IFwiZmxvYXQgZ2V0U2hhZG93TWFzaygpIHtcXG5cXHRmbG9hdCBzaGFkb3cgPSAxLjA7XFxuXFx0I2lmZGVmIFVTRV9TSEFET1dNQVBcXG5cXHQjaWYgTlVNX0RJUl9MSUdIVFMgPiAwXFxuXFx0RGlyZWN0aW9uYWxMaWdodCBkaXJlY3Rpb25hbExpZ2h0O1xcblxcdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9ESVJfTElHSFRTOyBpICsrICkge1xcblxcdFxcdGRpcmVjdGlvbmFsTGlnaHQgPSBkaXJlY3Rpb25hbExpZ2h0c1sgaSBdO1xcblxcdFxcdHNoYWRvdyAqPSBib29sKCBkaXJlY3Rpb25hbExpZ2h0LnNoYWRvdyApID8gZ2V0U2hhZG93KCBkaXJlY3Rpb25hbFNoYWRvd01hcFsgaSBdLCBkaXJlY3Rpb25hbExpZ2h0LnNoYWRvd01hcFNpemUsIGRpcmVjdGlvbmFsTGlnaHQuc2hhZG93QmlhcywgZGlyZWN0aW9uYWxMaWdodC5zaGFkb3dSYWRpdXMsIHZEaXJlY3Rpb25hbFNoYWRvd0Nvb3JkWyBpIF0gKSA6IDEuMDtcXG5cXHR9XFxuXFx0I2VuZGlmXFxuXFx0I2lmIE5VTV9TUE9UX0xJR0hUUyA+IDBcXG5cXHRTcG90TGlnaHQgc3BvdExpZ2h0O1xcblxcdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9TUE9UX0xJR0hUUzsgaSArKyApIHtcXG5cXHRcXHRzcG90TGlnaHQgPSBzcG90TGlnaHRzWyBpIF07XFxuXFx0XFx0c2hhZG93ICo9IGJvb2woIHNwb3RMaWdodC5zaGFkb3cgKSA/IGdldFNoYWRvdyggc3BvdFNoYWRvd01hcFsgaSBdLCBzcG90TGlnaHQuc2hhZG93TWFwU2l6ZSwgc3BvdExpZ2h0LnNoYWRvd0JpYXMsIHNwb3RMaWdodC5zaGFkb3dSYWRpdXMsIHZTcG90U2hhZG93Q29vcmRbIGkgXSApIDogMS4wO1xcblxcdH1cXG5cXHQjZW5kaWZcXG5cXHQjaWYgTlVNX1BPSU5UX0xJR0hUUyA+IDBcXG5cXHRQb2ludExpZ2h0IHBvaW50TGlnaHQ7XFxuXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX1BPSU5UX0xJR0hUUzsgaSArKyApIHtcXG5cXHRcXHRwb2ludExpZ2h0ID0gcG9pbnRMaWdodHNbIGkgXTtcXG5cXHRcXHRzaGFkb3cgKj0gYm9vbCggcG9pbnRMaWdodC5zaGFkb3cgKSA/IGdldFBvaW50U2hhZG93KCBwb2ludFNoYWRvd01hcFsgaSBdLCBwb2ludExpZ2h0LnNoYWRvd01hcFNpemUsIHBvaW50TGlnaHQuc2hhZG93QmlhcywgcG9pbnRMaWdodC5zaGFkb3dSYWRpdXMsIHZQb2ludFNoYWRvd0Nvb3JkWyBpIF0gKSA6IDEuMDtcXG5cXHR9XFxuXFx0I2VuZGlmXFxuXFx0I2VuZGlmXFxuXFx0cmV0dXJuIHNoYWRvdztcXG59XFxuXCI7XG5cbiAgICB2YXIgc2tpbmJhc2VfdmVydGV4ID0gXCIjaWZkZWYgVVNFX1NLSU5OSU5HXFxuXFx0bWF0NCBib25lTWF0WCA9IGdldEJvbmVNYXRyaXgoIHNraW5JbmRleC54ICk7XFxuXFx0bWF0NCBib25lTWF0WSA9IGdldEJvbmVNYXRyaXgoIHNraW5JbmRleC55ICk7XFxuXFx0bWF0NCBib25lTWF0WiA9IGdldEJvbmVNYXRyaXgoIHNraW5JbmRleC56ICk7XFxuXFx0bWF0NCBib25lTWF0VyA9IGdldEJvbmVNYXRyaXgoIHNraW5JbmRleC53ICk7XFxuI2VuZGlmXCI7XG5cbiAgICB2YXIgc2tpbm5pbmdfcGFyc192ZXJ0ZXggPSBcIiNpZmRlZiBVU0VfU0tJTk5JTkdcXG5cXHR1bmlmb3JtIG1hdDQgYmluZE1hdHJpeDtcXG5cXHR1bmlmb3JtIG1hdDQgYmluZE1hdHJpeEludmVyc2U7XFxuXFx0I2lmZGVmIEJPTkVfVEVYVFVSRVxcblxcdFxcdHVuaWZvcm0gc2FtcGxlcjJEIGJvbmVUZXh0dXJlO1xcblxcdFxcdHVuaWZvcm0gaW50IGJvbmVUZXh0dXJlV2lkdGg7XFxuXFx0XFx0dW5pZm9ybSBpbnQgYm9uZVRleHR1cmVIZWlnaHQ7XFxuXFx0XFx0bWF0NCBnZXRCb25lTWF0cml4KCBjb25zdCBpbiBmbG9hdCBpICkge1xcblxcdFxcdFxcdGZsb2F0IGogPSBpICogNC4wO1xcblxcdFxcdFxcdGZsb2F0IHggPSBtb2QoIGosIGZsb2F0KCBib25lVGV4dHVyZVdpZHRoICkgKTtcXG5cXHRcXHRcXHRmbG9hdCB5ID0gZmxvb3IoIGogLyBmbG9hdCggYm9uZVRleHR1cmVXaWR0aCApICk7XFxuXFx0XFx0XFx0ZmxvYXQgZHggPSAxLjAgLyBmbG9hdCggYm9uZVRleHR1cmVXaWR0aCApO1xcblxcdFxcdFxcdGZsb2F0IGR5ID0gMS4wIC8gZmxvYXQoIGJvbmVUZXh0dXJlSGVpZ2h0ICk7XFxuXFx0XFx0XFx0eSA9IGR5ICogKCB5ICsgMC41ICk7XFxuXFx0XFx0XFx0dmVjNCB2MSA9IHRleHR1cmUyRCggYm9uZVRleHR1cmUsIHZlYzIoIGR4ICogKCB4ICsgMC41ICksIHkgKSApO1xcblxcdFxcdFxcdHZlYzQgdjIgPSB0ZXh0dXJlMkQoIGJvbmVUZXh0dXJlLCB2ZWMyKCBkeCAqICggeCArIDEuNSApLCB5ICkgKTtcXG5cXHRcXHRcXHR2ZWM0IHYzID0gdGV4dHVyZTJEKCBib25lVGV4dHVyZSwgdmVjMiggZHggKiAoIHggKyAyLjUgKSwgeSApICk7XFxuXFx0XFx0XFx0dmVjNCB2NCA9IHRleHR1cmUyRCggYm9uZVRleHR1cmUsIHZlYzIoIGR4ICogKCB4ICsgMy41ICksIHkgKSApO1xcblxcdFxcdFxcdG1hdDQgYm9uZSA9IG1hdDQoIHYxLCB2MiwgdjMsIHY0ICk7XFxuXFx0XFx0XFx0cmV0dXJuIGJvbmU7XFxuXFx0XFx0fVxcblxcdCNlbHNlXFxuXFx0XFx0dW5pZm9ybSBtYXQ0IGJvbmVNYXRyaWNlc1sgTUFYX0JPTkVTIF07XFxuXFx0XFx0bWF0NCBnZXRCb25lTWF0cml4KCBjb25zdCBpbiBmbG9hdCBpICkge1xcblxcdFxcdFxcdG1hdDQgYm9uZSA9IGJvbmVNYXRyaWNlc1sgaW50KGkpIF07XFxuXFx0XFx0XFx0cmV0dXJuIGJvbmU7XFxuXFx0XFx0fVxcblxcdCNlbmRpZlxcbiNlbmRpZlxcblwiO1xuXG4gICAgdmFyIHNraW5uaW5nX3ZlcnRleCA9IFwiI2lmZGVmIFVTRV9TS0lOTklOR1xcblxcdHZlYzQgc2tpblZlcnRleCA9IGJpbmRNYXRyaXggKiB2ZWM0KCB0cmFuc2Zvcm1lZCwgMS4wICk7XFxuXFx0dmVjNCBza2lubmVkID0gdmVjNCggMC4wICk7XFxuXFx0c2tpbm5lZCArPSBib25lTWF0WCAqIHNraW5WZXJ0ZXggKiBza2luV2VpZ2h0Lng7XFxuXFx0c2tpbm5lZCArPSBib25lTWF0WSAqIHNraW5WZXJ0ZXggKiBza2luV2VpZ2h0Lnk7XFxuXFx0c2tpbm5lZCArPSBib25lTWF0WiAqIHNraW5WZXJ0ZXggKiBza2luV2VpZ2h0Lno7XFxuXFx0c2tpbm5lZCArPSBib25lTWF0VyAqIHNraW5WZXJ0ZXggKiBza2luV2VpZ2h0Lnc7XFxuXFx0c2tpbm5lZCAgPSBiaW5kTWF0cml4SW52ZXJzZSAqIHNraW5uZWQ7XFxuI2VuZGlmXFxuXCI7XG5cbiAgICB2YXIgc2tpbm5vcm1hbF92ZXJ0ZXggPSBcIiNpZmRlZiBVU0VfU0tJTk5JTkdcXG5cXHRtYXQ0IHNraW5NYXRyaXggPSBtYXQ0KCAwLjAgKTtcXG5cXHRza2luTWF0cml4ICs9IHNraW5XZWlnaHQueCAqIGJvbmVNYXRYO1xcblxcdHNraW5NYXRyaXggKz0gc2tpbldlaWdodC55ICogYm9uZU1hdFk7XFxuXFx0c2tpbk1hdHJpeCArPSBza2luV2VpZ2h0LnogKiBib25lTWF0WjtcXG5cXHRza2luTWF0cml4ICs9IHNraW5XZWlnaHQudyAqIGJvbmVNYXRXO1xcblxcdHNraW5NYXRyaXggID0gYmluZE1hdHJpeEludmVyc2UgKiBza2luTWF0cml4ICogYmluZE1hdHJpeDtcXG5cXHRvYmplY3ROb3JtYWwgPSB2ZWM0KCBza2luTWF0cml4ICogdmVjNCggb2JqZWN0Tm9ybWFsLCAwLjAgKSApLnh5ejtcXG4jZW5kaWZcXG5cIjtcblxuICAgIHZhciBzcGVjdWxhcm1hcF9mcmFnbWVudCA9IFwiZmxvYXQgc3BlY3VsYXJTdHJlbmd0aDtcXG4jaWZkZWYgVVNFX1NQRUNVTEFSTUFQXFxuXFx0dmVjNCB0ZXhlbFNwZWN1bGFyID0gdGV4dHVyZTJEKCBzcGVjdWxhck1hcCwgdlV2ICk7XFxuXFx0c3BlY3VsYXJTdHJlbmd0aCA9IHRleGVsU3BlY3VsYXIucjtcXG4jZWxzZVxcblxcdHNwZWN1bGFyU3RyZW5ndGggPSAxLjA7XFxuI2VuZGlmXCI7XG5cbiAgICB2YXIgc3BlY3VsYXJtYXBfcGFyc19mcmFnbWVudCA9IFwiI2lmZGVmIFVTRV9TUEVDVUxBUk1BUFxcblxcdHVuaWZvcm0gc2FtcGxlcjJEIHNwZWN1bGFyTWFwO1xcbiNlbmRpZlwiO1xuXG4gICAgdmFyIHRvbmVtYXBwaW5nX2ZyYWdtZW50ID0gXCIjaWYgZGVmaW5lZCggVE9ORV9NQVBQSU5HIClcXG4gIGdsX0ZyYWdDb2xvci5yZ2IgPSB0b25lTWFwcGluZyggZ2xfRnJhZ0NvbG9yLnJnYiApO1xcbiNlbmRpZlxcblwiO1xuXG4gICAgdmFyIHRvbmVtYXBwaW5nX3BhcnNfZnJhZ21lbnQgPSBcIiNkZWZpbmUgc2F0dXJhdGUoYSkgY2xhbXAoIGEsIDAuMCwgMS4wIClcXG51bmlmb3JtIGZsb2F0IHRvbmVNYXBwaW5nRXhwb3N1cmU7XFxudW5pZm9ybSBmbG9hdCB0b25lTWFwcGluZ1doaXRlUG9pbnQ7XFxudmVjMyBMaW5lYXJUb25lTWFwcGluZyggdmVjMyBjb2xvciApIHtcXG4gIHJldHVybiB0b25lTWFwcGluZ0V4cG9zdXJlICogY29sb3I7XFxufVxcbnZlYzMgUmVpbmhhcmRUb25lTWFwcGluZyggdmVjMyBjb2xvciApIHtcXG4gIGNvbG9yICo9IHRvbmVNYXBwaW5nRXhwb3N1cmU7XFxuICByZXR1cm4gc2F0dXJhdGUoIGNvbG9yIC8gKCB2ZWMzKCAxLjAgKSArIGNvbG9yICkgKTtcXG59XFxuI2RlZmluZSBVbmNoYXJ0ZWQySGVscGVyKCB4ICkgbWF4KCAoICggeCAqICggMC4xNSAqIHggKyAwLjEwICogMC41MCApICsgMC4yMCAqIDAuMDIgKSAvICggeCAqICggMC4xNSAqIHggKyAwLjUwICkgKyAwLjIwICogMC4zMCApICkgLSAwLjAyIC8gMC4zMCwgdmVjMyggMC4wICkgKVxcbnZlYzMgVW5jaGFydGVkMlRvbmVNYXBwaW5nKCB2ZWMzIGNvbG9yICkge1xcbiAgY29sb3IgKj0gdG9uZU1hcHBpbmdFeHBvc3VyZTtcXG4gIHJldHVybiBzYXR1cmF0ZSggVW5jaGFydGVkMkhlbHBlciggY29sb3IgKSAvIFVuY2hhcnRlZDJIZWxwZXIoIHZlYzMoIHRvbmVNYXBwaW5nV2hpdGVQb2ludCApICkgKTtcXG59XFxudmVjMyBPcHRpbWl6ZWRDaW5lb25Ub25lTWFwcGluZyggdmVjMyBjb2xvciApIHtcXG4gIGNvbG9yICo9IHRvbmVNYXBwaW5nRXhwb3N1cmU7XFxuICBjb2xvciA9IG1heCggdmVjMyggMC4wICksIGNvbG9yIC0gMC4wMDQgKTtcXG4gIHJldHVybiBwb3coICggY29sb3IgKiAoIDYuMiAqIGNvbG9yICsgMC41ICkgKSAvICggY29sb3IgKiAoIDYuMiAqIGNvbG9yICsgMS43ICkgKyAwLjA2ICksIHZlYzMoIDIuMiApICk7XFxufVxcblwiO1xuXG4gICAgdmFyIHV2X3BhcnNfZnJhZ21lbnQgPSBcIiNpZiBkZWZpbmVkKCBVU0VfTUFQICkgfHwgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTk9STUFMTUFQICkgfHwgZGVmaW5lZCggVVNFX1NQRUNVTEFSTUFQICkgfHwgZGVmaW5lZCggVVNFX0FMUEhBTUFQICkgfHwgZGVmaW5lZCggVVNFX0VNSVNTSVZFTUFQICkgfHwgZGVmaW5lZCggVVNFX1JPVUdITkVTU01BUCApIHx8IGRlZmluZWQoIFVTRV9NRVRBTE5FU1NNQVAgKVxcblxcdHZhcnlpbmcgdmVjMiB2VXY7XFxuI2VuZGlmXCI7XG5cbiAgICB2YXIgdXZfcGFyc192ZXJ0ZXggPSBcIiNpZiBkZWZpbmVkKCBVU0VfTUFQICkgfHwgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTk9STUFMTUFQICkgfHwgZGVmaW5lZCggVVNFX1NQRUNVTEFSTUFQICkgfHwgZGVmaW5lZCggVVNFX0FMUEhBTUFQICkgfHwgZGVmaW5lZCggVVNFX0VNSVNTSVZFTUFQICkgfHwgZGVmaW5lZCggVVNFX1JPVUdITkVTU01BUCApIHx8IGRlZmluZWQoIFVTRV9NRVRBTE5FU1NNQVAgKVxcblxcdHZhcnlpbmcgdmVjMiB2VXY7XFxuXFx0dW5pZm9ybSB2ZWM0IG9mZnNldFJlcGVhdDtcXG4jZW5kaWZcXG5cIjtcblxuICAgIHZhciB1dl92ZXJ0ZXggPSBcIiNpZiBkZWZpbmVkKCBVU0VfTUFQICkgfHwgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTk9STUFMTUFQICkgfHwgZGVmaW5lZCggVVNFX1NQRUNVTEFSTUFQICkgfHwgZGVmaW5lZCggVVNFX0FMUEhBTUFQICkgfHwgZGVmaW5lZCggVVNFX0VNSVNTSVZFTUFQICkgfHwgZGVmaW5lZCggVVNFX1JPVUdITkVTU01BUCApIHx8IGRlZmluZWQoIFVTRV9NRVRBTE5FU1NNQVAgKVxcblxcdHZVdiA9IHV2ICogb2Zmc2V0UmVwZWF0Lnp3ICsgb2Zmc2V0UmVwZWF0Lnh5O1xcbiNlbmRpZlwiO1xuXG4gICAgdmFyIHV2Ml9wYXJzX2ZyYWdtZW50ID0gXCIjaWYgZGVmaW5lZCggVVNFX0xJR0hUTUFQICkgfHwgZGVmaW5lZCggVVNFX0FPTUFQIClcXG5cXHR2YXJ5aW5nIHZlYzIgdlV2MjtcXG4jZW5kaWZcIjtcblxuICAgIHZhciB1djJfcGFyc192ZXJ0ZXggPSBcIiNpZiBkZWZpbmVkKCBVU0VfTElHSFRNQVAgKSB8fCBkZWZpbmVkKCBVU0VfQU9NQVAgKVxcblxcdGF0dHJpYnV0ZSB2ZWMyIHV2MjtcXG5cXHR2YXJ5aW5nIHZlYzIgdlV2MjtcXG4jZW5kaWZcIjtcblxuICAgIHZhciB1djJfdmVydGV4ID0gXCIjaWYgZGVmaW5lZCggVVNFX0xJR0hUTUFQICkgfHwgZGVmaW5lZCggVVNFX0FPTUFQIClcXG5cXHR2VXYyID0gdXYyO1xcbiNlbmRpZlwiO1xuXG4gICAgdmFyIHdvcmxkcG9zX3ZlcnRleCA9IFwiI2lmIGRlZmluZWQoIFVTRV9FTlZNQVAgKSB8fCBkZWZpbmVkKCBQSE9ORyApIHx8IGRlZmluZWQoIFBIWVNJQ0FMICkgfHwgZGVmaW5lZCggTEFNQkVSVCApIHx8IGRlZmluZWQgKCBVU0VfU0hBRE9XTUFQIClcXG5cXHQjaWZkZWYgVVNFX1NLSU5OSU5HXFxuXFx0XFx0dmVjNCB3b3JsZFBvc2l0aW9uID0gbW9kZWxNYXRyaXggKiBza2lubmVkO1xcblxcdCNlbHNlXFxuXFx0XFx0dmVjNCB3b3JsZFBvc2l0aW9uID0gbW9kZWxNYXRyaXggKiB2ZWM0KCB0cmFuc2Zvcm1lZCwgMS4wICk7XFxuXFx0I2VuZGlmXFxuI2VuZGlmXFxuXCI7XG5cbiAgICB2YXIgY3ViZV9mcmFnID0gXCJ1bmlmb3JtIHNhbXBsZXJDdWJlIHRDdWJlO1xcbnVuaWZvcm0gZmxvYXQgdEZsaXA7XFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcbnZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbnZvaWQgbWFpbigpIHtcXG5cXHRnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlQ3ViZSggdEN1YmUsIHZlYzMoIHRGbGlwICogdldvcmxkUG9zaXRpb24ueCwgdldvcmxkUG9zaXRpb24ueXogKSApO1xcblxcdGdsX0ZyYWdDb2xvci5hICo9IG9wYWNpdHk7XFxufVxcblwiO1xuXG4gICAgdmFyIGN1YmVfdmVydCA9IFwidmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1xcbiNpbmNsdWRlIDxjb21tb24+XFxudm9pZCBtYWluKCkge1xcblxcdHZXb3JsZFBvc2l0aW9uID0gdHJhbnNmb3JtRGlyZWN0aW9uKCBwb3NpdGlvbiwgbW9kZWxNYXRyaXggKTtcXG5cXHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxcblxcdCNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD5cXG59XFxuXCI7XG5cbiAgICB2YXIgZGVwdGhfZnJhZyA9IFwiI2lmIERFUFRIX1BBQ0tJTkcgPT0gMzIwMFxcblxcdHVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXG4jZW5kaWZcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDxwYWNraW5nPlxcbiNpbmNsdWRlIDx1dl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YWxwaGFtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+XFxudm9pZCBtYWluKCkge1xcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+XFxuXFx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCAxLjAgKTtcXG5cXHQjaWYgREVQVEhfUEFDS0lORyA9PSAzMjAwXFxuXFx0XFx0ZGlmZnVzZUNvbG9yLmEgPSBvcGFjaXR5O1xcblxcdCNlbmRpZlxcblxcdCNpbmNsdWRlIDxtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGFscGhhbWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxhbHBoYXRlc3RfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX2ZyYWdtZW50PlxcblxcdCNpZiBERVBUSF9QQUNLSU5HID09IDMyMDBcXG5cXHRcXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCB2ZWMzKCBnbF9GcmFnQ29vcmQueiApLCBvcGFjaXR5ICk7XFxuXFx0I2VsaWYgREVQVEhfUEFDS0lORyA9PSAzMjAxXFxuXFx0XFx0Z2xfRnJhZ0NvbG9yID0gcGFja0RlcHRoVG9SR0JBKCBnbF9GcmFnQ29vcmQueiApO1xcblxcdCNlbmRpZlxcbn1cXG5cIjtcblxuICAgIHZhciBkZXB0aF92ZXJ0ID0gXCIjaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDx1dl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxtb3JwaHRhcmdldF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8c2tpbm5pbmdfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXg+XFxudm9pZCBtYWluKCkge1xcblxcdCNpbmNsdWRlIDx1dl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5iYXNlX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxcblxcdCNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxtb3JwaHRhcmdldF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5uaW5nX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD5cXG59XFxuXCI7XG5cbiAgICB2YXIgZGlzdGFuY2VSR0JBX2ZyYWcgPSBcInVuaWZvcm0gdmVjMyBsaWdodFBvcztcXG52YXJ5aW5nIHZlYzQgdldvcmxkUG9zaXRpb247XFxuI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8cGFja2luZz5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+XFxudm9pZCBtYWluICgpIHtcXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50PlxcblxcdGdsX0ZyYWdDb2xvciA9IHBhY2tEZXB0aFRvUkdCQSggbGVuZ3RoKCB2V29ybGRQb3NpdGlvbi54eXogLSBsaWdodFBvcy54eXogKSAvIDEwMDAuMCApO1xcbn1cXG5cIjtcblxuICAgIHZhciBkaXN0YW5jZVJHQkFfdmVydCA9IFwidmFyeWluZyB2ZWM0IHZXb3JsZFBvc2l0aW9uO1xcbiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxza2lubmluZ19wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4PlxcbnZvaWQgbWFpbigpIHtcXG5cXHQjaW5jbHVkZSA8c2tpbmJhc2VfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBodGFyZ2V0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbm5pbmdfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8d29ybGRwb3NfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfdmVydGV4PlxcblxcdHZXb3JsZFBvc2l0aW9uID0gd29ybGRQb3NpdGlvbjtcXG59XFxuXCI7XG5cbiAgICB2YXIgZXF1aXJlY3RfZnJhZyA9IFwidW5pZm9ybSBzYW1wbGVyMkQgdEVxdWlyZWN0O1xcbnVuaWZvcm0gZmxvYXQgdEZsaXA7XFxudmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1xcbiNpbmNsdWRlIDxjb21tb24+XFxudm9pZCBtYWluKCkge1xcblxcdHZlYzMgZGlyZWN0aW9uID0gbm9ybWFsaXplKCB2V29ybGRQb3NpdGlvbiApO1xcblxcdHZlYzIgc2FtcGxlVVY7XFxuXFx0c2FtcGxlVVYueSA9IHNhdHVyYXRlKCB0RmxpcCAqIGRpcmVjdGlvbi55ICogLTAuNSArIDAuNSApO1xcblxcdHNhbXBsZVVWLnggPSBhdGFuKCBkaXJlY3Rpb24ueiwgZGlyZWN0aW9uLnggKSAqIFJFQ0lQUk9DQUxfUEkyICsgMC41O1xcblxcdGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCggdEVxdWlyZWN0LCBzYW1wbGVVViApO1xcbn1cXG5cIjtcblxuICAgIHZhciBlcXVpcmVjdF92ZXJ0ID0gXCJ2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XFxuI2luY2x1ZGUgPGNvbW1vbj5cXG52b2lkIG1haW4oKSB7XFxuXFx0dldvcmxkUG9zaXRpb24gPSB0cmFuc2Zvcm1EaXJlY3Rpb24oIHBvc2l0aW9uLCBtb2RlbE1hdHJpeCApO1xcblxcdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHByb2plY3RfdmVydGV4Plxcbn1cXG5cIjtcblxuICAgIHZhciBsaW5lZGFzaGVkX2ZyYWcgPSBcInVuaWZvcm0gdmVjMyBkaWZmdXNlO1xcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXG51bmlmb3JtIGZsb2F0IGRhc2hTaXplO1xcbnVuaWZvcm0gZmxvYXQgdG90YWxTaXplO1xcbnZhcnlpbmcgZmxvYXQgdkxpbmVEaXN0YW5jZTtcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDxjb2xvcl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxmb2dfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+XFxudm9pZCBtYWluKCkge1xcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+XFxuXFx0aWYgKCBtb2QoIHZMaW5lRGlzdGFuY2UsIHRvdGFsU2l6ZSApID4gZGFzaFNpemUgKSB7XFxuXFx0XFx0ZGlzY2FyZDtcXG5cXHR9XFxuXFx0dmVjMyBvdXRnb2luZ0xpZ2h0ID0gdmVjMyggMC4wICk7XFxuXFx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCBkaWZmdXNlLCBvcGFjaXR5ICk7XFxuXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxjb2xvcl9mcmFnbWVudD5cXG5cXHRvdXRnb2luZ0xpZ2h0ID0gZGlmZnVzZUNvbG9yLnJnYjtcXG5cXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCBvdXRnb2luZ0xpZ2h0LCBkaWZmdXNlQ29sb3IuYSApO1xcblxcdCNpbmNsdWRlIDxwcmVtdWx0aXBsaWVkX2FscGhhX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8ZW5jb2RpbmdzX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxmb2dfZnJhZ21lbnQ+XFxufVxcblwiO1xuXG4gICAgdmFyIGxpbmVkYXNoZWRfdmVydCA9IFwidW5pZm9ybSBmbG9hdCBzY2FsZTtcXG5hdHRyaWJ1dGUgZmxvYXQgbGluZURpc3RhbmNlO1xcbnZhcnlpbmcgZmxvYXQgdkxpbmVEaXN0YW5jZTtcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDxjb2xvcl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleD5cXG52b2lkIG1haW4oKSB7XFxuXFx0I2luY2x1ZGUgPGNvbG9yX3ZlcnRleD5cXG5cXHR2TGluZURpc3RhbmNlID0gc2NhbGUgKiBsaW5lRGlzdGFuY2U7XFxuXFx0dmVjNCBtdlBvc2l0aW9uID0gbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1xcblxcdGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG12UG9zaXRpb247XFxuXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD5cXG59XFxuXCI7XG5cbiAgICB2YXIgbWVzaGJhc2ljX2ZyYWcgPSBcInVuaWZvcm0gdmVjMyBkaWZmdXNlO1xcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXG4jaWZuZGVmIEZMQVRfU0hBREVEXFxuXFx0dmFyeWluZyB2ZWMzIHZOb3JtYWw7XFxuI2VuZGlmXFxuI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8Y29sb3JfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8dXZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8dXYyX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPG1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxhbHBoYW1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxhb21hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxlbnZtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Zm9nX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPHNwZWN1bGFybWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50PlxcbnZvaWQgbWFpbigpIHtcXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50PlxcblxcdHZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggZGlmZnVzZSwgb3BhY2l0eSApO1xcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxjb2xvcl9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8YWxwaGFtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGFscGhhdGVzdF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8c3BlY3VsYXJtYXBfZnJhZ21lbnQ+XFxuXFx0UmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQ7XFxuXFx0cmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSA9IHZlYzMoIDAuMCApO1xcblxcdHJlZmxlY3RlZExpZ2h0LmRpcmVjdFNwZWN1bGFyID0gdmVjMyggMC4wICk7XFxuXFx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlID0gZGlmZnVzZUNvbG9yLnJnYjtcXG5cXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdFNwZWN1bGFyID0gdmVjMyggMC4wICk7XFxuXFx0I2luY2x1ZGUgPGFvbWFwX2ZyYWdtZW50PlxcblxcdHZlYzMgb3V0Z29pbmdMaWdodCA9IHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZTtcXG5cXHQjaW5jbHVkZSA8bm9ybWFsX2ZsaXA+XFxuXFx0I2luY2x1ZGUgPGVudm1hcF9mcmFnbWVudD5cXG5cXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCBvdXRnb2luZ0xpZ2h0LCBkaWZmdXNlQ29sb3IuYSApO1xcblxcdCNpbmNsdWRlIDxwcmVtdWx0aXBsaWVkX2FscGhhX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8ZW5jb2RpbmdzX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxmb2dfZnJhZ21lbnQ+XFxufVxcblwiO1xuXG4gICAgdmFyIG1lc2hiYXNpY192ZXJ0ID0gXCIjaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDx1dl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8dXYyX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxlbnZtYXBfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxtb3JwaHRhcmdldF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8c2tpbm5pbmdfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXg+XFxudm9pZCBtYWluKCkge1xcblxcdCNpbmNsdWRlIDx1dl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHV2Ml92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGNvbG9yX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbmJhc2VfdmVydGV4PlxcblxcdCNpZmRlZiBVU0VfRU5WTUFQXFxuXFx0I2luY2x1ZGUgPGJlZ2lubm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bW9ycGhub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2lubm9ybWFsX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8ZGVmYXVsdG5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2VuZGlmXFxuXFx0I2luY2x1ZGUgPGJlZ2luX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bW9ycGh0YXJnZXRfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxza2lubmluZ192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHByb2plY3RfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHdvcmxkcG9zX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8ZW52bWFwX3ZlcnRleD5cXG59XFxuXCI7XG5cbiAgICB2YXIgbWVzaGxhbWJlcnRfZnJhZyA9IFwidW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XFxudW5pZm9ybSB2ZWMzIGVtaXNzaXZlO1xcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXG52YXJ5aW5nIHZlYzMgdkxpZ2h0RnJvbnQ7XFxuI2lmZGVmIERPVUJMRV9TSURFRFxcblxcdHZhcnlpbmcgdmVjMyB2TGlnaHRCYWNrO1xcbiNlbmRpZlxcbiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPHBhY2tpbmc+XFxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPHV2X3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPHV2Ml9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YWxwaGFtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YW9tYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bGlnaHRtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8ZW1pc3NpdmVtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8ZW52bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGJzZGZzPlxcbiNpbmNsdWRlIDxsaWdodHNfcGFycz5cXG4jaW5jbHVkZSA8Zm9nX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPHNoYWRvd21hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxzaGFkb3dtYXNrX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPHNwZWN1bGFybWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50PlxcbnZvaWQgbWFpbigpIHtcXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50PlxcblxcdHZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggZGlmZnVzZSwgb3BhY2l0eSApO1xcblxcdFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ID0gUmVmbGVjdGVkTGlnaHQoIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICksIHZlYzMoIDAuMCApICk7XFxuXFx0dmVjMyB0b3RhbEVtaXNzaXZlUmFkaWFuY2UgPSBlbWlzc2l2ZTtcXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPG1hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8Y29sb3JfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGFscGhhbWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxhbHBoYXRlc3RfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPHNwZWN1bGFybWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxlbWlzc2l2ZW1hcF9mcmFnbWVudD5cXG5cXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgPSBnZXRBbWJpZW50TGlnaHRJcnJhZGlhbmNlKCBhbWJpZW50TGlnaHRDb2xvciApO1xcblxcdCNpbmNsdWRlIDxsaWdodG1hcF9mcmFnbWVudD5cXG5cXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKj0gQlJERl9EaWZmdXNlX0xhbWJlcnQoIGRpZmZ1c2VDb2xvci5yZ2IgKTtcXG5cXHQjaWZkZWYgRE9VQkxFX1NJREVEXFxuXFx0XFx0cmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSA9ICggZ2xfRnJvbnRGYWNpbmcgKSA/IHZMaWdodEZyb250IDogdkxpZ2h0QmFjaztcXG5cXHQjZWxzZVxcblxcdFxcdHJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UgPSB2TGlnaHRGcm9udDtcXG5cXHQjZW5kaWZcXG5cXHRyZWZsZWN0ZWRMaWdodC5kaXJlY3REaWZmdXNlICo9IEJSREZfRGlmZnVzZV9MYW1iZXJ0KCBkaWZmdXNlQ29sb3IucmdiICkgKiBnZXRTaGFkb3dNYXNrKCk7XFxuXFx0I2luY2x1ZGUgPGFvbWFwX2ZyYWdtZW50PlxcblxcdHZlYzMgb3V0Z29pbmdMaWdodCA9IHJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UgKyByZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKyB0b3RhbEVtaXNzaXZlUmFkaWFuY2U7XFxuXFx0I2luY2x1ZGUgPG5vcm1hbF9mbGlwPlxcblxcdCNpbmNsdWRlIDxlbnZtYXBfZnJhZ21lbnQ+XFxuXFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggb3V0Z29pbmdMaWdodCwgZGlmZnVzZUNvbG9yLmEgKTtcXG5cXHQjaW5jbHVkZSA8cHJlbXVsdGlwbGllZF9hbHBoYV9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGVuY29kaW5nc19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8Zm9nX2ZyYWdtZW50Plxcbn1cXG5cIjtcblxuICAgIHZhciBtZXNobGFtYmVydF92ZXJ0ID0gXCIjZGVmaW5lIExBTUJFUlRcXG52YXJ5aW5nIHZlYzMgdkxpZ2h0RnJvbnQ7XFxuI2lmZGVmIERPVUJMRV9TSURFRFxcblxcdHZhcnlpbmcgdmVjMyB2TGlnaHRCYWNrO1xcbiNlbmRpZlxcbiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPHV2X3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDx1djJfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGVudm1hcF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8YnNkZnM+XFxuI2luY2x1ZGUgPGxpZ2h0c19wYXJzPlxcbiNpbmNsdWRlIDxjb2xvcl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHNraW5uaW5nX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxzaGFkb3dtYXBfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXg+XFxudm9pZCBtYWluKCkge1xcblxcdCNpbmNsdWRlIDx1dl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHV2Ml92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGNvbG9yX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8YmVnaW5ub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxtb3JwaG5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5iYXNlX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbm5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGRlZmF1bHRub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBodGFyZ2V0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbm5pbmdfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfdmVydGV4PlxcblxcdCNpbmNsdWRlIDx3b3JsZHBvc192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGVudm1hcF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGxpZ2h0c19sYW1iZXJ0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2hhZG93bWFwX3ZlcnRleD5cXG59XFxuXCI7XG5cbiAgICB2YXIgbWVzaHBob25nX2ZyYWcgPSBcIiNkZWZpbmUgUEhPTkdcXG51bmlmb3JtIHZlYzMgZGlmZnVzZTtcXG51bmlmb3JtIHZlYzMgZW1pc3NpdmU7XFxudW5pZm9ybSB2ZWMzIHNwZWN1bGFyO1xcbnVuaWZvcm0gZmxvYXQgc2hpbmluZXNzO1xcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDxwYWNraW5nPlxcbiNpbmNsdWRlIDxjb2xvcl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDx1dl9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDx1djJfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGFscGhhbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGFvbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGxpZ2h0bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGVtaXNzaXZlbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGVudm1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxmb2dfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YnNkZnM+XFxuI2luY2x1ZGUgPGxpZ2h0c19wYXJzPlxcbiNpbmNsdWRlIDxsaWdodHNfcGhvbmdfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8c2hhZG93bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGJ1bXBtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bm9ybWFsbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPHNwZWN1bGFybWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50PlxcbnZvaWQgbWFpbigpIHtcXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50PlxcblxcdHZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggZGlmZnVzZSwgb3BhY2l0eSApO1xcblxcdFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ID0gUmVmbGVjdGVkTGlnaHQoIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICksIHZlYzMoIDAuMCApICk7XFxuXFx0dmVjMyB0b3RhbEVtaXNzaXZlUmFkaWFuY2UgPSBlbWlzc2l2ZTtcXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPG1hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8Y29sb3JfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGFscGhhbWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxhbHBoYXRlc3RfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPHNwZWN1bGFybWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxub3JtYWxfZmxpcD5cXG5cXHQjaW5jbHVkZSA8bm9ybWFsX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxlbWlzc2l2ZW1hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bGlnaHRzX3Bob25nX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxsaWdodHNfdGVtcGxhdGU+XFxuXFx0I2luY2x1ZGUgPGFvbWFwX2ZyYWdtZW50PlxcblxcdHZlYzMgb3V0Z29pbmdMaWdodCA9IHJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UgKyByZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKyByZWZsZWN0ZWRMaWdodC5kaXJlY3RTcGVjdWxhciArIHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0U3BlY3VsYXIgKyB0b3RhbEVtaXNzaXZlUmFkaWFuY2U7XFxuXFx0I2luY2x1ZGUgPGVudm1hcF9mcmFnbWVudD5cXG5cXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCBvdXRnb2luZ0xpZ2h0LCBkaWZmdXNlQ29sb3IuYSApO1xcblxcdCNpbmNsdWRlIDxwcmVtdWx0aXBsaWVkX2FscGhhX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8ZW5jb2RpbmdzX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxmb2dfZnJhZ21lbnQ+XFxufVxcblwiO1xuXG4gICAgdmFyIG1lc2hwaG9uZ192ZXJ0ID0gXCIjZGVmaW5lIFBIT05HXFxudmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247XFxuI2lmbmRlZiBGTEFUX1NIQURFRFxcblxcdHZhcnlpbmcgdmVjMyB2Tm9ybWFsO1xcbiNlbmRpZlxcbiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPHV2X3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDx1djJfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8ZW52bWFwX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxjb2xvcl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHNraW5uaW5nX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxzaGFkb3dtYXBfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXg+XFxudm9pZCBtYWluKCkge1xcblxcdCNpbmNsdWRlIDx1dl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHV2Ml92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGNvbG9yX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8YmVnaW5ub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxtb3JwaG5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5iYXNlX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbm5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGRlZmF1bHRub3JtYWxfdmVydGV4PlxcbiNpZm5kZWYgRkxBVF9TSEFERURcXG5cXHR2Tm9ybWFsID0gbm9ybWFsaXplKCB0cmFuc2Zvcm1lZE5vcm1hbCApO1xcbiNlbmRpZlxcblxcdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBodGFyZ2V0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbm5pbmdfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfdmVydGV4PlxcblxcdHZWaWV3UG9zaXRpb24gPSAtIG12UG9zaXRpb24ueHl6O1xcblxcdCNpbmNsdWRlIDx3b3JsZHBvc192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGVudm1hcF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNoYWRvd21hcF92ZXJ0ZXg+XFxufVxcblwiO1xuXG4gICAgdmFyIG1lc2hwaHlzaWNhbF9mcmFnID0gXCIjZGVmaW5lIFBIWVNJQ0FMXFxudW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XFxudW5pZm9ybSB2ZWMzIGVtaXNzaXZlO1xcbnVuaWZvcm0gZmxvYXQgcm91Z2huZXNzO1xcbnVuaWZvcm0gZmxvYXQgbWV0YWxuZXNzO1xcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXG4jaWZuZGVmIFNUQU5EQVJEXFxuXFx0dW5pZm9ybSBmbG9hdCBjbGVhckNvYXQ7XFxuXFx0dW5pZm9ybSBmbG9hdCBjbGVhckNvYXRSb3VnaG5lc3M7XFxuI2VuZGlmXFxudW5pZm9ybSBmbG9hdCBlbnZNYXBJbnRlbnNpdHk7XFxudmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247XFxuI2lmbmRlZiBGTEFUX1NIQURFRFxcblxcdHZhcnlpbmcgdmVjMyB2Tm9ybWFsO1xcbiNlbmRpZlxcbiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPHBhY2tpbmc+XFxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPHV2X3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPHV2Ml9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YWxwaGFtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8YW9tYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bGlnaHRtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8ZW1pc3NpdmVtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8ZW52bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGZvZ19wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxic2Rmcz5cXG4jaW5jbHVkZSA8Y3ViZV91dl9yZWZsZWN0aW9uX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxsaWdodHNfcGFycz5cXG4jaW5jbHVkZSA8bGlnaHRzX3BoeXNpY2FsX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPHNoYWRvd21hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxidW1wbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPG5vcm1hbG1hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxyb3VnaG5lc3NtYXBfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8bWV0YWxuZXNzbWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50PlxcbnZvaWQgbWFpbigpIHtcXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50PlxcblxcdHZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggZGlmZnVzZSwgb3BhY2l0eSApO1xcblxcdFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ID0gUmVmbGVjdGVkTGlnaHQoIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICksIHZlYzMoIDAuMCApICk7XFxuXFx0dmVjMyB0b3RhbEVtaXNzaXZlUmFkaWFuY2UgPSBlbWlzc2l2ZTtcXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPG1hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8Y29sb3JfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGFscGhhbWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxhbHBoYXRlc3RfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPHNwZWN1bGFybWFwX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxyb3VnaG5lc3NtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPG1ldGFsbmVzc21hcF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bm9ybWFsX2ZsaXA+XFxuXFx0I2luY2x1ZGUgPG5vcm1hbF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8ZW1pc3NpdmVtYXBfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGxpZ2h0c19waHlzaWNhbF9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bGlnaHRzX3RlbXBsYXRlPlxcblxcdCNpbmNsdWRlIDxhb21hcF9mcmFnbWVudD5cXG5cXHR2ZWMzIG91dGdvaW5nTGlnaHQgPSByZWZsZWN0ZWRMaWdodC5kaXJlY3REaWZmdXNlICsgcmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICsgcmVmbGVjdGVkTGlnaHQuZGlyZWN0U3BlY3VsYXIgKyByZWZsZWN0ZWRMaWdodC5pbmRpcmVjdFNwZWN1bGFyICsgdG90YWxFbWlzc2l2ZVJhZGlhbmNlO1xcblxcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIG91dGdvaW5nTGlnaHQsIGRpZmZ1c2VDb2xvci5hICk7XFxuXFx0I2luY2x1ZGUgPHByZW11bHRpcGxpZWRfYWxwaGFfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxlbmNvZGluZ3NfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGZvZ19mcmFnbWVudD5cXG59XFxuXCI7XG5cbiAgICB2YXIgbWVzaHBoeXNpY2FsX3ZlcnQgPSBcIiNkZWZpbmUgUEhZU0lDQUxcXG52YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcXG4jaWZuZGVmIEZMQVRfU0hBREVEXFxuXFx0dmFyeWluZyB2ZWMzIHZOb3JtYWw7XFxuI2VuZGlmXFxuI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8dXZfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHV2Ml9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxjb2xvcl9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHNraW5uaW5nX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxzaGFkb3dtYXBfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPHNwZWN1bGFybWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXg+XFxudm9pZCBtYWluKCkge1xcblxcdCNpbmNsdWRlIDx1dl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHV2Ml92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGNvbG9yX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8YmVnaW5ub3JtYWxfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxtb3JwaG5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNraW5iYXNlX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbm5vcm1hbF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGRlZmF1bHRub3JtYWxfdmVydGV4PlxcbiNpZm5kZWYgRkxBVF9TSEFERURcXG5cXHR2Tm9ybWFsID0gbm9ybWFsaXplKCB0cmFuc2Zvcm1lZE5vcm1hbCApO1xcbiNlbmRpZlxcblxcdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPG1vcnBodGFyZ2V0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2tpbm5pbmdfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfdmVydGV4PlxcblxcdHZWaWV3UG9zaXRpb24gPSAtIG12UG9zaXRpb24ueHl6O1xcblxcdCNpbmNsdWRlIDx3b3JsZHBvc192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHNoYWRvd21hcF92ZXJ0ZXg+XFxufVxcblwiO1xuXG4gICAgdmFyIG5vcm1hbF9mcmFnID0gXCJ1bmlmb3JtIGZsb2F0IG9wYWNpdHk7XFxudmFyeWluZyB2ZWMzIHZOb3JtYWw7XFxuI2luY2x1ZGUgPGNvbW1vbj5cXG4jaW5jbHVkZSA8cGFja2luZz5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+XFxudm9pZCBtYWluKCkge1xcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+XFxuXFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggcGFja05vcm1hbFRvUkdCKCB2Tm9ybWFsICksIG9wYWNpdHkgKTtcXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfZnJhZ21lbnQ+XFxufVxcblwiO1xuXG4gICAgdmFyIG5vcm1hbF92ZXJ0ID0gXCJ2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDxtb3JwaHRhcmdldF9wYXJzX3ZlcnRleD5cXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleD5cXG52b2lkIG1haW4oKSB7XFxuXFx0dk5vcm1hbCA9IG5vcm1hbGl6ZSggbm9ybWFsTWF0cml4ICogbm9ybWFsICk7XFxuXFx0I2luY2x1ZGUgPGJlZ2luX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bW9ycGh0YXJnZXRfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfdmVydGV4PlxcblxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfdmVydGV4Plxcbn1cXG5cIjtcblxuICAgIHZhciBwb2ludHNfZnJhZyA9IFwidW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcbiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPHBhY2tpbmc+XFxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPG1hcF9wYXJ0aWNsZV9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxmb2dfcGFyc19mcmFnbWVudD5cXG4jaW5jbHVkZSA8c2hhZG93bWFwX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQ+XFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50PlxcbnZvaWQgbWFpbigpIHtcXG5cXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50PlxcblxcdHZlYzMgb3V0Z29pbmdMaWdodCA9IHZlYzMoIDAuMCApO1xcblxcdHZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggZGlmZnVzZSwgb3BhY2l0eSApO1xcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8bWFwX3BhcnRpY2xlX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxjb2xvcl9mcmFnbWVudD5cXG5cXHQjaW5jbHVkZSA8YWxwaGF0ZXN0X2ZyYWdtZW50PlxcblxcdG91dGdvaW5nTGlnaHQgPSBkaWZmdXNlQ29sb3IucmdiO1xcblxcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIG91dGdvaW5nTGlnaHQsIGRpZmZ1c2VDb2xvci5hICk7XFxuXFx0I2luY2x1ZGUgPHByZW11bHRpcGxpZWRfYWxwaGFfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PlxcblxcdCNpbmNsdWRlIDxlbmNvZGluZ3NfZnJhZ21lbnQ+XFxuXFx0I2luY2x1ZGUgPGZvZ19mcmFnbWVudD5cXG59XFxuXCI7XG5cbiAgICB2YXIgcG9pbnRzX3ZlcnQgPSBcInVuaWZvcm0gZmxvYXQgc2l6ZTtcXG51bmlmb3JtIGZsb2F0IHNjYWxlO1xcbiNpbmNsdWRlIDxjb21tb24+XFxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxzaGFkb3dtYXBfcGFyc192ZXJ0ZXg+XFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4PlxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXg+XFxudm9pZCBtYWluKCkge1xcblxcdCNpbmNsdWRlIDxjb2xvcl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGJlZ2luX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XFxuXFx0I2lmZGVmIFVTRV9TSVpFQVRURU5VQVRJT05cXG5cXHRcXHRnbF9Qb2ludFNpemUgPSBzaXplICogKCBzY2FsZSAvIC0gbXZQb3NpdGlvbi56ICk7XFxuXFx0I2Vsc2VcXG5cXHRcXHRnbF9Qb2ludFNpemUgPSBzaXplO1xcblxcdCNlbmRpZlxcblxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHdvcmxkcG9zX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2hhZG93bWFwX3ZlcnRleD5cXG59XFxuXCI7XG5cbiAgICB2YXIgc2hhZG93X2ZyYWcgPSBcInVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXG4jaW5jbHVkZSA8Y29tbW9uPlxcbiNpbmNsdWRlIDxwYWNraW5nPlxcbiNpbmNsdWRlIDxic2Rmcz5cXG4jaW5jbHVkZSA8bGlnaHRzX3BhcnM+XFxuI2luY2x1ZGUgPHNoYWRvd21hcF9wYXJzX2ZyYWdtZW50PlxcbiNpbmNsdWRlIDxzaGFkb3dtYXNrX3BhcnNfZnJhZ21lbnQ+XFxudm9pZCBtYWluKCkge1xcblxcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIDAuMCwgMC4wLCAwLjAsIG9wYWNpdHkgKiAoIDEuMCAgLSBnZXRTaGFkb3dNYXNrKCkgKSApO1xcbn1cXG5cIjtcblxuICAgIHZhciBzaGFkb3dfdmVydCA9IFwiI2luY2x1ZGUgPHNoYWRvd21hcF9wYXJzX3ZlcnRleD5cXG52b2lkIG1haW4oKSB7XFxuXFx0I2luY2x1ZGUgPGJlZ2luX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XFxuXFx0I2luY2x1ZGUgPHdvcmxkcG9zX3ZlcnRleD5cXG5cXHQjaW5jbHVkZSA8c2hhZG93bWFwX3ZlcnRleD5cXG59XFxuXCI7XG5cbiAgICB2YXIgU2hhZGVyQ2h1bmsgPSB7XG4gICAgXHRhbHBoYW1hcF9mcmFnbWVudDogYWxwaGFtYXBfZnJhZ21lbnQsXG4gICAgXHRhbHBoYW1hcF9wYXJzX2ZyYWdtZW50OiBhbHBoYW1hcF9wYXJzX2ZyYWdtZW50LFxuICAgIFx0YWxwaGF0ZXN0X2ZyYWdtZW50OiBhbHBoYXRlc3RfZnJhZ21lbnQsXG4gICAgXHRhb21hcF9mcmFnbWVudDogYW9tYXBfZnJhZ21lbnQsXG4gICAgXHRhb21hcF9wYXJzX2ZyYWdtZW50OiBhb21hcF9wYXJzX2ZyYWdtZW50LFxuICAgIFx0YmVnaW5fdmVydGV4OiBiZWdpbl92ZXJ0ZXgsXG4gICAgXHRiZWdpbm5vcm1hbF92ZXJ0ZXg6IGJlZ2lubm9ybWFsX3ZlcnRleCxcbiAgICBcdGJzZGZzOiBic2RmcyxcbiAgICBcdGJ1bXBtYXBfcGFyc19mcmFnbWVudDogYnVtcG1hcF9wYXJzX2ZyYWdtZW50LFxuICAgIFx0Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50OiBjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQsXG4gICAgXHRjbGlwcGluZ19wbGFuZXNfcGFyc19mcmFnbWVudDogY2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQsXG4gICAgXHRjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXg6IGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleCxcbiAgICBcdGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXg6IGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXgsXG4gICAgXHRjb2xvcl9mcmFnbWVudDogY29sb3JfZnJhZ21lbnQsXG4gICAgXHRjb2xvcl9wYXJzX2ZyYWdtZW50OiBjb2xvcl9wYXJzX2ZyYWdtZW50LFxuICAgIFx0Y29sb3JfcGFyc192ZXJ0ZXg6IGNvbG9yX3BhcnNfdmVydGV4LFxuICAgIFx0Y29sb3JfdmVydGV4OiBjb2xvcl92ZXJ0ZXgsXG4gICAgXHRjb21tb246IGNvbW1vbixcbiAgICBcdGN1YmVfdXZfcmVmbGVjdGlvbl9mcmFnbWVudDogY3ViZV91dl9yZWZsZWN0aW9uX2ZyYWdtZW50LFxuICAgIFx0ZGVmYXVsdG5vcm1hbF92ZXJ0ZXg6IGRlZmF1bHRub3JtYWxfdmVydGV4LFxuICAgIFx0ZGlzcGxhY2VtZW50bWFwX3BhcnNfdmVydGV4OiBkaXNwbGFjZW1lbnRtYXBfcGFyc192ZXJ0ZXgsXG4gICAgXHRkaXNwbGFjZW1lbnRtYXBfdmVydGV4OiBkaXNwbGFjZW1lbnRtYXBfdmVydGV4LFxuICAgIFx0ZW1pc3NpdmVtYXBfZnJhZ21lbnQ6IGVtaXNzaXZlbWFwX2ZyYWdtZW50LFxuICAgIFx0ZW1pc3NpdmVtYXBfcGFyc19mcmFnbWVudDogZW1pc3NpdmVtYXBfcGFyc19mcmFnbWVudCxcbiAgICBcdGVuY29kaW5nc19mcmFnbWVudDogZW5jb2RpbmdzX2ZyYWdtZW50LFxuICAgIFx0ZW5jb2RpbmdzX3BhcnNfZnJhZ21lbnQ6IGVuY29kaW5nc19wYXJzX2ZyYWdtZW50LFxuICAgIFx0ZW52bWFwX2ZyYWdtZW50OiBlbnZtYXBfZnJhZ21lbnQsXG4gICAgXHRlbnZtYXBfcGFyc19mcmFnbWVudDogZW52bWFwX3BhcnNfZnJhZ21lbnQsXG4gICAgXHRlbnZtYXBfcGFyc192ZXJ0ZXg6IGVudm1hcF9wYXJzX3ZlcnRleCxcbiAgICBcdGVudm1hcF92ZXJ0ZXg6IGVudm1hcF92ZXJ0ZXgsXG4gICAgXHRmb2dfZnJhZ21lbnQ6IGZvZ19mcmFnbWVudCxcbiAgICBcdGZvZ19wYXJzX2ZyYWdtZW50OiBmb2dfcGFyc19mcmFnbWVudCxcbiAgICBcdGxpZ2h0bWFwX2ZyYWdtZW50OiBsaWdodG1hcF9mcmFnbWVudCxcbiAgICBcdGxpZ2h0bWFwX3BhcnNfZnJhZ21lbnQ6IGxpZ2h0bWFwX3BhcnNfZnJhZ21lbnQsXG4gICAgXHRsaWdodHNfbGFtYmVydF92ZXJ0ZXg6IGxpZ2h0c19sYW1iZXJ0X3ZlcnRleCxcbiAgICBcdGxpZ2h0c19wYXJzOiBsaWdodHNfcGFycyxcbiAgICBcdGxpZ2h0c19waG9uZ19mcmFnbWVudDogbGlnaHRzX3Bob25nX2ZyYWdtZW50LFxuICAgIFx0bGlnaHRzX3Bob25nX3BhcnNfZnJhZ21lbnQ6IGxpZ2h0c19waG9uZ19wYXJzX2ZyYWdtZW50LFxuICAgIFx0bGlnaHRzX3BoeXNpY2FsX2ZyYWdtZW50OiBsaWdodHNfcGh5c2ljYWxfZnJhZ21lbnQsXG4gICAgXHRsaWdodHNfcGh5c2ljYWxfcGFyc19mcmFnbWVudDogbGlnaHRzX3BoeXNpY2FsX3BhcnNfZnJhZ21lbnQsXG4gICAgXHRsaWdodHNfdGVtcGxhdGU6IGxpZ2h0c190ZW1wbGF0ZSxcbiAgICBcdGxvZ2RlcHRoYnVmX2ZyYWdtZW50OiBsb2dkZXB0aGJ1Zl9mcmFnbWVudCxcbiAgICBcdGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQ6IGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQsXG4gICAgXHRsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleDogbG9nZGVwdGhidWZfcGFyc192ZXJ0ZXgsXG4gICAgXHRsb2dkZXB0aGJ1Zl92ZXJ0ZXg6IGxvZ2RlcHRoYnVmX3ZlcnRleCxcbiAgICBcdG1hcF9mcmFnbWVudDogbWFwX2ZyYWdtZW50LFxuICAgIFx0bWFwX3BhcnNfZnJhZ21lbnQ6IG1hcF9wYXJzX2ZyYWdtZW50LFxuICAgIFx0bWFwX3BhcnRpY2xlX2ZyYWdtZW50OiBtYXBfcGFydGljbGVfZnJhZ21lbnQsXG4gICAgXHRtYXBfcGFydGljbGVfcGFyc19mcmFnbWVudDogbWFwX3BhcnRpY2xlX3BhcnNfZnJhZ21lbnQsXG4gICAgXHRtZXRhbG5lc3NtYXBfZnJhZ21lbnQ6IG1ldGFsbmVzc21hcF9mcmFnbWVudCxcbiAgICBcdG1ldGFsbmVzc21hcF9wYXJzX2ZyYWdtZW50OiBtZXRhbG5lc3NtYXBfcGFyc19mcmFnbWVudCxcbiAgICBcdG1vcnBobm9ybWFsX3ZlcnRleDogbW9ycGhub3JtYWxfdmVydGV4LFxuICAgIFx0bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg6IG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4LFxuICAgIFx0bW9ycGh0YXJnZXRfdmVydGV4OiBtb3JwaHRhcmdldF92ZXJ0ZXgsXG4gICAgXHRub3JtYWxfZmxpcDogbm9ybWFsX2ZsaXAsXG4gICAgXHRub3JtYWxfZnJhZ21lbnQ6IG5vcm1hbF9mcmFnbWVudCxcbiAgICBcdG5vcm1hbG1hcF9wYXJzX2ZyYWdtZW50OiBub3JtYWxtYXBfcGFyc19mcmFnbWVudCxcbiAgICBcdHBhY2tpbmc6IHBhY2tpbmcsXG4gICAgXHRwcmVtdWx0aXBsaWVkX2FscGhhX2ZyYWdtZW50OiBwcmVtdWx0aXBsaWVkX2FscGhhX2ZyYWdtZW50LFxuICAgIFx0cHJvamVjdF92ZXJ0ZXg6IHByb2plY3RfdmVydGV4LFxuICAgIFx0cm91Z2huZXNzbWFwX2ZyYWdtZW50OiByb3VnaG5lc3NtYXBfZnJhZ21lbnQsXG4gICAgXHRyb3VnaG5lc3NtYXBfcGFyc19mcmFnbWVudDogcm91Z2huZXNzbWFwX3BhcnNfZnJhZ21lbnQsXG4gICAgXHRzaGFkb3dtYXBfcGFyc19mcmFnbWVudDogc2hhZG93bWFwX3BhcnNfZnJhZ21lbnQsXG4gICAgXHRzaGFkb3dtYXBfcGFyc192ZXJ0ZXg6IHNoYWRvd21hcF9wYXJzX3ZlcnRleCxcbiAgICBcdHNoYWRvd21hcF92ZXJ0ZXg6IHNoYWRvd21hcF92ZXJ0ZXgsXG4gICAgXHRzaGFkb3dtYXNrX3BhcnNfZnJhZ21lbnQ6IHNoYWRvd21hc2tfcGFyc19mcmFnbWVudCxcbiAgICBcdHNraW5iYXNlX3ZlcnRleDogc2tpbmJhc2VfdmVydGV4LFxuICAgIFx0c2tpbm5pbmdfcGFyc192ZXJ0ZXg6IHNraW5uaW5nX3BhcnNfdmVydGV4LFxuICAgIFx0c2tpbm5pbmdfdmVydGV4OiBza2lubmluZ192ZXJ0ZXgsXG4gICAgXHRza2lubm9ybWFsX3ZlcnRleDogc2tpbm5vcm1hbF92ZXJ0ZXgsXG4gICAgXHRzcGVjdWxhcm1hcF9mcmFnbWVudDogc3BlY3VsYXJtYXBfZnJhZ21lbnQsXG4gICAgXHRzcGVjdWxhcm1hcF9wYXJzX2ZyYWdtZW50OiBzcGVjdWxhcm1hcF9wYXJzX2ZyYWdtZW50LFxuICAgIFx0dG9uZW1hcHBpbmdfZnJhZ21lbnQ6IHRvbmVtYXBwaW5nX2ZyYWdtZW50LFxuICAgIFx0dG9uZW1hcHBpbmdfcGFyc19mcmFnbWVudDogdG9uZW1hcHBpbmdfcGFyc19mcmFnbWVudCxcbiAgICBcdHV2X3BhcnNfZnJhZ21lbnQ6IHV2X3BhcnNfZnJhZ21lbnQsXG4gICAgXHR1dl9wYXJzX3ZlcnRleDogdXZfcGFyc192ZXJ0ZXgsXG4gICAgXHR1dl92ZXJ0ZXg6IHV2X3ZlcnRleCxcbiAgICBcdHV2Ml9wYXJzX2ZyYWdtZW50OiB1djJfcGFyc19mcmFnbWVudCxcbiAgICBcdHV2Ml9wYXJzX3ZlcnRleDogdXYyX3BhcnNfdmVydGV4LFxuICAgIFx0dXYyX3ZlcnRleDogdXYyX3ZlcnRleCxcbiAgICBcdHdvcmxkcG9zX3ZlcnRleDogd29ybGRwb3NfdmVydGV4LFxuXG4gICAgXHRjdWJlX2ZyYWc6IGN1YmVfZnJhZyxcbiAgICBcdGN1YmVfdmVydDogY3ViZV92ZXJ0LFxuICAgIFx0ZGVwdGhfZnJhZzogZGVwdGhfZnJhZyxcbiAgICBcdGRlcHRoX3ZlcnQ6IGRlcHRoX3ZlcnQsXG4gICAgXHRkaXN0YW5jZVJHQkFfZnJhZzogZGlzdGFuY2VSR0JBX2ZyYWcsXG4gICAgXHRkaXN0YW5jZVJHQkFfdmVydDogZGlzdGFuY2VSR0JBX3ZlcnQsXG4gICAgXHRlcXVpcmVjdF9mcmFnOiBlcXVpcmVjdF9mcmFnLFxuICAgIFx0ZXF1aXJlY3RfdmVydDogZXF1aXJlY3RfdmVydCxcbiAgICBcdGxpbmVkYXNoZWRfZnJhZzogbGluZWRhc2hlZF9mcmFnLFxuICAgIFx0bGluZWRhc2hlZF92ZXJ0OiBsaW5lZGFzaGVkX3ZlcnQsXG4gICAgXHRtZXNoYmFzaWNfZnJhZzogbWVzaGJhc2ljX2ZyYWcsXG4gICAgXHRtZXNoYmFzaWNfdmVydDogbWVzaGJhc2ljX3ZlcnQsXG4gICAgXHRtZXNobGFtYmVydF9mcmFnOiBtZXNobGFtYmVydF9mcmFnLFxuICAgIFx0bWVzaGxhbWJlcnRfdmVydDogbWVzaGxhbWJlcnRfdmVydCxcbiAgICBcdG1lc2hwaG9uZ19mcmFnOiBtZXNocGhvbmdfZnJhZyxcbiAgICBcdG1lc2hwaG9uZ192ZXJ0OiBtZXNocGhvbmdfdmVydCxcbiAgICBcdG1lc2hwaHlzaWNhbF9mcmFnOiBtZXNocGh5c2ljYWxfZnJhZyxcbiAgICBcdG1lc2hwaHlzaWNhbF92ZXJ0OiBtZXNocGh5c2ljYWxfdmVydCxcbiAgICBcdG5vcm1hbF9mcmFnOiBub3JtYWxfZnJhZyxcbiAgICBcdG5vcm1hbF92ZXJ0OiBub3JtYWxfdmVydCxcbiAgICBcdHBvaW50c19mcmFnOiBwb2ludHNfZnJhZyxcbiAgICBcdHBvaW50c192ZXJ0OiBwb2ludHNfdmVydCxcbiAgICBcdHNoYWRvd19mcmFnOiBzaGFkb3dfZnJhZyxcbiAgICBcdHNoYWRvd192ZXJ0OiBzaGFkb3dfdmVydFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gQ29sb3IoIHIsIGcsIGIgKSB7XG5cbiAgICBcdGlmICggZyA9PT0gdW5kZWZpbmVkICYmIGIgPT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHQvLyByIGlzIFRIUkVFLkNvbG9yLCBoZXggb3Igc3RyaW5nXG4gICAgXHRcdHJldHVybiB0aGlzLnNldCggciApO1xuXG4gICAgXHR9XG5cbiAgICBcdHJldHVybiB0aGlzLnNldFJHQiggciwgZywgYiApO1xuXG4gICAgfVxuXG4gICAgQ29sb3IucHJvdG90eXBlID0ge1xuXG4gICAgXHRjb25zdHJ1Y3RvcjogQ29sb3IsXG5cbiAgICBcdGlzQ29sb3I6IHRydWUsXG5cbiAgICBcdHI6IDEsIGc6IDEsIGI6IDEsXG5cbiAgICBcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuICAgIFx0XHRpZiAoICh2YWx1ZSAmJiB2YWx1ZS5pc0NvbG9yKSApIHtcblxuICAgIFx0XHRcdHRoaXMuY29weSggdmFsdWUgKTtcblxuICAgIFx0XHR9IGVsc2UgaWYgKCB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICkge1xuXG4gICAgXHRcdFx0dGhpcy5zZXRIZXgoIHZhbHVlICk7XG5cbiAgICBcdFx0fSBlbHNlIGlmICggdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyApIHtcblxuICAgIFx0XHRcdHRoaXMuc2V0U3R5bGUoIHZhbHVlICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRzZXRTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xuXG4gICAgXHRcdHRoaXMuciA9IHNjYWxhcjtcbiAgICBcdFx0dGhpcy5nID0gc2NhbGFyO1xuICAgIFx0XHR0aGlzLmIgPSBzY2FsYXI7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldEhleDogZnVuY3Rpb24gKCBoZXggKSB7XG5cbiAgICBcdFx0aGV4ID0gTWF0aC5mbG9vciggaGV4ICk7XG5cbiAgICBcdFx0dGhpcy5yID0gKCBoZXggPj4gMTYgJiAyNTUgKSAvIDI1NTtcbiAgICBcdFx0dGhpcy5nID0gKCBoZXggPj4gOCAmIDI1NSApIC8gMjU1O1xuICAgIFx0XHR0aGlzLmIgPSAoIGhleCAmIDI1NSApIC8gMjU1O1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRzZXRSR0I6IGZ1bmN0aW9uICggciwgZywgYiApIHtcblxuICAgIFx0XHR0aGlzLnIgPSByO1xuICAgIFx0XHR0aGlzLmcgPSBnO1xuICAgIFx0XHR0aGlzLmIgPSBiO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRzZXRIU0w6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHRmdW5jdGlvbiBodWUycmdiKCBwLCBxLCB0ICkge1xuXG4gICAgXHRcdFx0aWYgKCB0IDwgMCApIHQgKz0gMTtcbiAgICBcdFx0XHRpZiAoIHQgPiAxICkgdCAtPSAxO1xuICAgIFx0XHRcdGlmICggdCA8IDEgLyA2ICkgcmV0dXJuIHAgKyAoIHEgLSBwICkgKiA2ICogdDtcbiAgICBcdFx0XHRpZiAoIHQgPCAxIC8gMiApIHJldHVybiBxO1xuICAgIFx0XHRcdGlmICggdCA8IDIgLyAzICkgcmV0dXJuIHAgKyAoIHEgLSBwICkgKiA2ICogKCAyIC8gMyAtIHQgKTtcbiAgICBcdFx0XHRyZXR1cm4gcDtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIGZ1bmN0aW9uIHNldEhTTCggaCwgcywgbCApIHtcblxuICAgIFx0XHRcdC8vIGgscyxsIHJhbmdlcyBhcmUgaW4gMC4wIC0gMS4wXG4gICAgXHRcdFx0aCA9IGV4cG9ydHMuTWF0aC5ldWNsaWRlYW5Nb2R1bG8oIGgsIDEgKTtcbiAgICBcdFx0XHRzID0gZXhwb3J0cy5NYXRoLmNsYW1wKCBzLCAwLCAxICk7XG4gICAgXHRcdFx0bCA9IGV4cG9ydHMuTWF0aC5jbGFtcCggbCwgMCwgMSApO1xuXG4gICAgXHRcdFx0aWYgKCBzID09PSAwICkge1xuXG4gICAgXHRcdFx0XHR0aGlzLnIgPSB0aGlzLmcgPSB0aGlzLmIgPSBsO1xuXG4gICAgXHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0dmFyIHAgPSBsIDw9IDAuNSA/IGwgKiAoIDEgKyBzICkgOiBsICsgcyAtICggbCAqIHMgKTtcbiAgICBcdFx0XHRcdHZhciBxID0gKCAyICogbCApIC0gcDtcblxuICAgIFx0XHRcdFx0dGhpcy5yID0gaHVlMnJnYiggcSwgcCwgaCArIDEgLyAzICk7XG4gICAgXHRcdFx0XHR0aGlzLmcgPSBodWUycmdiKCBxLCBwLCBoICk7XG4gICAgXHRcdFx0XHR0aGlzLmIgPSBodWUycmdiKCBxLCBwLCBoIC0gMSAvIDMgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHRcdH07XG5cbiAgICBcdH0oKSxcblxuICAgIFx0c2V0U3R5bGU6IGZ1bmN0aW9uICggc3R5bGUgKSB7XG5cbiAgICBcdFx0ZnVuY3Rpb24gaGFuZGxlQWxwaGEoIHN0cmluZyApIHtcblxuICAgIFx0XHRcdGlmICggc3RyaW5nID09PSB1bmRlZmluZWQgKSByZXR1cm47XG5cbiAgICBcdFx0XHRpZiAoIHBhcnNlRmxvYXQoIHN0cmluZyApIDwgMSApIHtcblxuICAgIFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQ29sb3I6IEFscGhhIGNvbXBvbmVudCBvZiAnICsgc3R5bGUgKyAnIHdpbGwgYmUgaWdub3JlZC4nICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG5cbiAgICBcdFx0dmFyIG07XG5cbiAgICBcdFx0aWYgKCBtID0gL14oKD86cmdifGhzbClhPylcXChcXHMqKFteXFwpXSopXFwpLy5leGVjKCBzdHlsZSApICkge1xuXG4gICAgXHRcdFx0Ly8gcmdiIC8gaHNsXG5cbiAgICBcdFx0XHR2YXIgY29sb3I7XG4gICAgXHRcdFx0dmFyIG5hbWUgPSBtWyAxIF07XG4gICAgXHRcdFx0dmFyIGNvbXBvbmVudHMgPSBtWyAyIF07XG5cbiAgICBcdFx0XHRzd2l0Y2ggKCBuYW1lICkge1xuXG4gICAgXHRcdFx0XHRjYXNlICdyZ2InOlxuICAgIFx0XHRcdFx0Y2FzZSAncmdiYSc6XG5cbiAgICBcdFx0XHRcdFx0aWYgKCBjb2xvciA9IC9eKFxcZCspXFxzKixcXHMqKFxcZCspXFxzKixcXHMqKFxcZCspXFxzKigsXFxzKihbMC05XSpcXC4/WzAtOV0rKVxccyopPyQvLmV4ZWMoIGNvbXBvbmVudHMgKSApIHtcblxuICAgIFx0XHRcdFx0XHRcdC8vIHJnYigyNTUsMCwwKSByZ2JhKDI1NSwwLDAsMC41KVxuICAgIFx0XHRcdFx0XHRcdHRoaXMuciA9IE1hdGgubWluKCAyNTUsIHBhcnNlSW50KCBjb2xvclsgMSBdLCAxMCApICkgLyAyNTU7XG4gICAgXHRcdFx0XHRcdFx0dGhpcy5nID0gTWF0aC5taW4oIDI1NSwgcGFyc2VJbnQoIGNvbG9yWyAyIF0sIDEwICkgKSAvIDI1NTtcbiAgICBcdFx0XHRcdFx0XHR0aGlzLmIgPSBNYXRoLm1pbiggMjU1LCBwYXJzZUludCggY29sb3JbIDMgXSwgMTAgKSApIC8gMjU1O1xuXG4gICAgXHRcdFx0XHRcdFx0aGFuZGxlQWxwaGEoIGNvbG9yWyA1IF0gKTtcblxuICAgIFx0XHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0XHRpZiAoIGNvbG9yID0gL14oXFxkKylcXCVcXHMqLFxccyooXFxkKylcXCVcXHMqLFxccyooXFxkKylcXCVcXHMqKCxcXHMqKFswLTldKlxcLj9bMC05XSspXFxzKik/JC8uZXhlYyggY29tcG9uZW50cyApICkge1xuXG4gICAgXHRcdFx0XHRcdFx0Ly8gcmdiKDEwMCUsMCUsMCUpIHJnYmEoMTAwJSwwJSwwJSwwLjUpXG4gICAgXHRcdFx0XHRcdFx0dGhpcy5yID0gTWF0aC5taW4oIDEwMCwgcGFyc2VJbnQoIGNvbG9yWyAxIF0sIDEwICkgKSAvIDEwMDtcbiAgICBcdFx0XHRcdFx0XHR0aGlzLmcgPSBNYXRoLm1pbiggMTAwLCBwYXJzZUludCggY29sb3JbIDIgXSwgMTAgKSApIC8gMTAwO1xuICAgIFx0XHRcdFx0XHRcdHRoaXMuYiA9IE1hdGgubWluKCAxMDAsIHBhcnNlSW50KCBjb2xvclsgMyBdLCAxMCApICkgLyAxMDA7XG5cbiAgICBcdFx0XHRcdFx0XHRoYW5kbGVBbHBoYSggY29sb3JbIDUgXSApO1xuXG4gICAgXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHRcdGJyZWFrO1xuXG4gICAgXHRcdFx0XHRjYXNlICdoc2wnOlxuICAgIFx0XHRcdFx0Y2FzZSAnaHNsYSc6XG5cbiAgICBcdFx0XHRcdFx0aWYgKCBjb2xvciA9IC9eKFswLTldKlxcLj9bMC05XSspXFxzKixcXHMqKFxcZCspXFwlXFxzKixcXHMqKFxcZCspXFwlXFxzKigsXFxzKihbMC05XSpcXC4/WzAtOV0rKVxccyopPyQvLmV4ZWMoIGNvbXBvbmVudHMgKSApIHtcblxuICAgIFx0XHRcdFx0XHRcdC8vIGhzbCgxMjAsNTAlLDUwJSkgaHNsYSgxMjAsNTAlLDUwJSwwLjUpXG4gICAgXHRcdFx0XHRcdFx0dmFyIGggPSBwYXJzZUZsb2F0KCBjb2xvclsgMSBdICkgLyAzNjA7XG4gICAgXHRcdFx0XHRcdFx0dmFyIHMgPSBwYXJzZUludCggY29sb3JbIDIgXSwgMTAgKSAvIDEwMDtcbiAgICBcdFx0XHRcdFx0XHR2YXIgbCA9IHBhcnNlSW50KCBjb2xvclsgMyBdLCAxMCApIC8gMTAwO1xuXG4gICAgXHRcdFx0XHRcdFx0aGFuZGxlQWxwaGEoIGNvbG9yWyA1IF0gKTtcblxuICAgIFx0XHRcdFx0XHRcdHJldHVybiB0aGlzLnNldEhTTCggaCwgcywgbCApO1xuXG4gICAgXHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0XHRicmVhaztcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9IGVsc2UgaWYgKCBtID0gL15cXCMoW0EtRmEtZjAtOV0rKSQvLmV4ZWMoIHN0eWxlICkgKSB7XG5cbiAgICBcdFx0XHQvLyBoZXggY29sb3JcblxuICAgIFx0XHRcdHZhciBoZXggPSBtWyAxIF07XG4gICAgXHRcdFx0dmFyIHNpemUgPSBoZXgubGVuZ3RoO1xuXG4gICAgXHRcdFx0aWYgKCBzaXplID09PSAzICkge1xuXG4gICAgXHRcdFx0XHQvLyAjZmYwXG4gICAgXHRcdFx0XHR0aGlzLnIgPSBwYXJzZUludCggaGV4LmNoYXJBdCggMCApICsgaGV4LmNoYXJBdCggMCApLCAxNiApIC8gMjU1O1xuICAgIFx0XHRcdFx0dGhpcy5nID0gcGFyc2VJbnQoIGhleC5jaGFyQXQoIDEgKSArIGhleC5jaGFyQXQoIDEgKSwgMTYgKSAvIDI1NTtcbiAgICBcdFx0XHRcdHRoaXMuYiA9IHBhcnNlSW50KCBoZXguY2hhckF0KCAyICkgKyBoZXguY2hhckF0KCAyICksIDE2ICkgLyAyNTU7XG5cbiAgICBcdFx0XHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHRcdFx0fSBlbHNlIGlmICggc2l6ZSA9PT0gNiApIHtcblxuICAgIFx0XHRcdFx0Ly8gI2ZmMDAwMFxuICAgIFx0XHRcdFx0dGhpcy5yID0gcGFyc2VJbnQoIGhleC5jaGFyQXQoIDAgKSArIGhleC5jaGFyQXQoIDEgKSwgMTYgKSAvIDI1NTtcbiAgICBcdFx0XHRcdHRoaXMuZyA9IHBhcnNlSW50KCBoZXguY2hhckF0KCAyICkgKyBoZXguY2hhckF0KCAzICksIDE2ICkgLyAyNTU7XG4gICAgXHRcdFx0XHR0aGlzLmIgPSBwYXJzZUludCggaGV4LmNoYXJBdCggNCApICsgaGV4LmNoYXJBdCggNSApLCAxNiApIC8gMjU1O1xuXG4gICAgXHRcdFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdFx0aWYgKCBzdHlsZSAmJiBzdHlsZS5sZW5ndGggPiAwICkge1xuXG4gICAgXHRcdFx0Ly8gY29sb3Iga2V5d29yZHNcbiAgICBcdFx0XHR2YXIgaGV4ID0gZXhwb3J0cy5Db2xvcktleXdvcmRzWyBzdHlsZSBdO1xuXG4gICAgXHRcdFx0aWYgKCBoZXggIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0Ly8gcmVkXG4gICAgXHRcdFx0XHR0aGlzLnNldEhleCggaGV4ICk7XG5cbiAgICBcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHQvLyB1bmtub3duIGNvbG9yXG4gICAgXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Db2xvcjogVW5rbm93biBjb2xvciAnICsgc3R5bGUgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLnIsIHRoaXMuZywgdGhpcy5iICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGNvcHk6IGZ1bmN0aW9uICggY29sb3IgKSB7XG5cbiAgICBcdFx0dGhpcy5yID0gY29sb3IucjtcbiAgICBcdFx0dGhpcy5nID0gY29sb3IuZztcbiAgICBcdFx0dGhpcy5iID0gY29sb3IuYjtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0Y29weUdhbW1hVG9MaW5lYXI6IGZ1bmN0aW9uICggY29sb3IsIGdhbW1hRmFjdG9yICkge1xuXG4gICAgXHRcdGlmICggZ2FtbWFGYWN0b3IgPT09IHVuZGVmaW5lZCApIGdhbW1hRmFjdG9yID0gMi4wO1xuXG4gICAgXHRcdHRoaXMuciA9IE1hdGgucG93KCBjb2xvci5yLCBnYW1tYUZhY3RvciApO1xuICAgIFx0XHR0aGlzLmcgPSBNYXRoLnBvdyggY29sb3IuZywgZ2FtbWFGYWN0b3IgKTtcbiAgICBcdFx0dGhpcy5iID0gTWF0aC5wb3coIGNvbG9yLmIsIGdhbW1hRmFjdG9yICk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGNvcHlMaW5lYXJUb0dhbW1hOiBmdW5jdGlvbiAoIGNvbG9yLCBnYW1tYUZhY3RvciApIHtcblxuICAgIFx0XHRpZiAoIGdhbW1hRmFjdG9yID09PSB1bmRlZmluZWQgKSBnYW1tYUZhY3RvciA9IDIuMDtcblxuICAgIFx0XHR2YXIgc2FmZUludmVyc2UgPSAoIGdhbW1hRmFjdG9yID4gMCApID8gKCAxLjAgLyBnYW1tYUZhY3RvciApIDogMS4wO1xuXG4gICAgXHRcdHRoaXMuciA9IE1hdGgucG93KCBjb2xvci5yLCBzYWZlSW52ZXJzZSApO1xuICAgIFx0XHR0aGlzLmcgPSBNYXRoLnBvdyggY29sb3IuZywgc2FmZUludmVyc2UgKTtcbiAgICBcdFx0dGhpcy5iID0gTWF0aC5wb3coIGNvbG9yLmIsIHNhZmVJbnZlcnNlICk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGNvbnZlcnRHYW1tYVRvTGluZWFyOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dmFyIHIgPSB0aGlzLnIsIGcgPSB0aGlzLmcsIGIgPSB0aGlzLmI7XG5cbiAgICBcdFx0dGhpcy5yID0gciAqIHI7XG4gICAgXHRcdHRoaXMuZyA9IGcgKiBnO1xuICAgIFx0XHR0aGlzLmIgPSBiICogYjtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0Y29udmVydExpbmVhclRvR2FtbWE6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR0aGlzLnIgPSBNYXRoLnNxcnQoIHRoaXMuciApO1xuICAgIFx0XHR0aGlzLmcgPSBNYXRoLnNxcnQoIHRoaXMuZyApO1xuICAgIFx0XHR0aGlzLmIgPSBNYXRoLnNxcnQoIHRoaXMuYiApO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRnZXRIZXg6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHRyZXR1cm4gKCB0aGlzLnIgKiAyNTUgKSA8PCAxNiBeICggdGhpcy5nICogMjU1ICkgPDwgOCBeICggdGhpcy5iICogMjU1ICkgPDwgMDtcblxuICAgIFx0fSxcblxuICAgIFx0Z2V0SGV4U3RyaW5nOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0cmV0dXJuICggJzAwMDAwMCcgKyB0aGlzLmdldEhleCgpLnRvU3RyaW5nKCAxNiApICkuc2xpY2UoIC0gNiApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRnZXRIU0w6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICBcdFx0Ly8gaCxzLGwgcmFuZ2VzIGFyZSBpbiAwLjAgLSAxLjBcblxuICAgIFx0XHR2YXIgaHNsID0gb3B0aW9uYWxUYXJnZXQgfHwgeyBoOiAwLCBzOiAwLCBsOiAwIH07XG5cbiAgICBcdFx0dmFyIHIgPSB0aGlzLnIsIGcgPSB0aGlzLmcsIGIgPSB0aGlzLmI7XG5cbiAgICBcdFx0dmFyIG1heCA9IE1hdGgubWF4KCByLCBnLCBiICk7XG4gICAgXHRcdHZhciBtaW4gPSBNYXRoLm1pbiggciwgZywgYiApO1xuXG4gICAgXHRcdHZhciBodWUsIHNhdHVyYXRpb247XG4gICAgXHRcdHZhciBsaWdodG5lc3MgPSAoIG1pbiArIG1heCApIC8gMi4wO1xuXG4gICAgXHRcdGlmICggbWluID09PSBtYXggKSB7XG5cbiAgICBcdFx0XHRodWUgPSAwO1xuICAgIFx0XHRcdHNhdHVyYXRpb24gPSAwO1xuXG4gICAgXHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHR2YXIgZGVsdGEgPSBtYXggLSBtaW47XG5cbiAgICBcdFx0XHRzYXR1cmF0aW9uID0gbGlnaHRuZXNzIDw9IDAuNSA/IGRlbHRhIC8gKCBtYXggKyBtaW4gKSA6IGRlbHRhIC8gKCAyIC0gbWF4IC0gbWluICk7XG5cbiAgICBcdFx0XHRzd2l0Y2ggKCBtYXggKSB7XG5cbiAgICBcdFx0XHRcdGNhc2UgcjogaHVlID0gKCBnIC0gYiApIC8gZGVsdGEgKyAoIGcgPCBiID8gNiA6IDAgKTsgYnJlYWs7XG4gICAgXHRcdFx0XHRjYXNlIGc6IGh1ZSA9ICggYiAtIHIgKSAvIGRlbHRhICsgMjsgYnJlYWs7XG4gICAgXHRcdFx0XHRjYXNlIGI6IGh1ZSA9ICggciAtIGcgKSAvIGRlbHRhICsgNDsgYnJlYWs7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRodWUgLz0gNjtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0aHNsLmggPSBodWU7XG4gICAgXHRcdGhzbC5zID0gc2F0dXJhdGlvbjtcbiAgICBcdFx0aHNsLmwgPSBsaWdodG5lc3M7XG5cbiAgICBcdFx0cmV0dXJuIGhzbDtcblxuICAgIFx0fSxcblxuICAgIFx0Z2V0U3R5bGU6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHRyZXR1cm4gJ3JnYignICsgKCAoIHRoaXMuciAqIDI1NSApIHwgMCApICsgJywnICsgKCAoIHRoaXMuZyAqIDI1NSApIHwgMCApICsgJywnICsgKCAoIHRoaXMuYiAqIDI1NSApIHwgMCApICsgJyknO1xuXG4gICAgXHR9LFxuXG4gICAgXHRvZmZzZXRIU0w6IGZ1bmN0aW9uICggaCwgcywgbCApIHtcblxuICAgIFx0XHR2YXIgaHNsID0gdGhpcy5nZXRIU0woKTtcblxuICAgIFx0XHRoc2wuaCArPSBoOyBoc2wucyArPSBzOyBoc2wubCArPSBsO1xuXG4gICAgXHRcdHRoaXMuc2V0SFNMKCBoc2wuaCwgaHNsLnMsIGhzbC5sICk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGFkZDogZnVuY3Rpb24gKCBjb2xvciApIHtcblxuICAgIFx0XHR0aGlzLnIgKz0gY29sb3IucjtcbiAgICBcdFx0dGhpcy5nICs9IGNvbG9yLmc7XG4gICAgXHRcdHRoaXMuYiArPSBjb2xvci5iO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRhZGRDb2xvcnM6IGZ1bmN0aW9uICggY29sb3IxLCBjb2xvcjIgKSB7XG5cbiAgICBcdFx0dGhpcy5yID0gY29sb3IxLnIgKyBjb2xvcjIucjtcbiAgICBcdFx0dGhpcy5nID0gY29sb3IxLmcgKyBjb2xvcjIuZztcbiAgICBcdFx0dGhpcy5iID0gY29sb3IxLmIgKyBjb2xvcjIuYjtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0YWRkU2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XG5cbiAgICBcdFx0dGhpcy5yICs9IHM7XG4gICAgXHRcdHRoaXMuZyArPSBzO1xuICAgIFx0XHR0aGlzLmIgKz0gcztcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0c3ViOiBmdW5jdGlvbiggY29sb3IgKSB7XG5cbiAgICBcdFx0dGhpcy5yID0gTWF0aC5tYXgoIDAsIHRoaXMuciAtIGNvbG9yLnIgKTtcbiAgICBcdFx0dGhpcy5nID0gTWF0aC5tYXgoIDAsIHRoaXMuZyAtIGNvbG9yLmcgKTtcbiAgICBcdFx0dGhpcy5iID0gTWF0aC5tYXgoIDAsIHRoaXMuYiAtIGNvbG9yLmIgKTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0bXVsdGlwbHk6IGZ1bmN0aW9uICggY29sb3IgKSB7XG5cbiAgICBcdFx0dGhpcy5yICo9IGNvbG9yLnI7XG4gICAgXHRcdHRoaXMuZyAqPSBjb2xvci5nO1xuICAgIFx0XHR0aGlzLmIgKj0gY29sb3IuYjtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0bXVsdGlwbHlTY2FsYXI6IGZ1bmN0aW9uICggcyApIHtcblxuICAgIFx0XHR0aGlzLnIgKj0gcztcbiAgICBcdFx0dGhpcy5nICo9IHM7XG4gICAgXHRcdHRoaXMuYiAqPSBzO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRsZXJwOiBmdW5jdGlvbiAoIGNvbG9yLCBhbHBoYSApIHtcblxuICAgIFx0XHR0aGlzLnIgKz0gKCBjb2xvci5yIC0gdGhpcy5yICkgKiBhbHBoYTtcbiAgICBcdFx0dGhpcy5nICs9ICggY29sb3IuZyAtIHRoaXMuZyApICogYWxwaGE7XG4gICAgXHRcdHRoaXMuYiArPSAoIGNvbG9yLmIgLSB0aGlzLmIgKSAqIGFscGhhO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRlcXVhbHM6IGZ1bmN0aW9uICggYyApIHtcblxuICAgIFx0XHRyZXR1cm4gKCBjLnIgPT09IHRoaXMuciApICYmICggYy5nID09PSB0aGlzLmcgKSAmJiAoIGMuYiA9PT0gdGhpcy5iICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGZyb21BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xuXG4gICAgXHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG4gICAgXHRcdHRoaXMuciA9IGFycmF5WyBvZmZzZXQgXTtcbiAgICBcdFx0dGhpcy5nID0gYXJyYXlbIG9mZnNldCArIDEgXTtcbiAgICBcdFx0dGhpcy5iID0gYXJyYXlbIG9mZnNldCArIDIgXTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0dG9BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xuXG4gICAgXHRcdGlmICggYXJyYXkgPT09IHVuZGVmaW5lZCApIGFycmF5ID0gW107XG4gICAgXHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG4gICAgXHRcdGFycmF5WyBvZmZzZXQgXSA9IHRoaXMucjtcbiAgICBcdFx0YXJyYXlbIG9mZnNldCArIDEgXSA9IHRoaXMuZztcbiAgICBcdFx0YXJyYXlbIG9mZnNldCArIDIgXSA9IHRoaXMuYjtcblxuICAgIFx0XHRyZXR1cm4gYXJyYXk7XG5cbiAgICBcdH0sXG5cbiAgICBcdHRvSlNPTjogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHJldHVybiB0aGlzLmdldEhleCgpO1xuXG4gICAgXHR9XG5cbiAgICB9O1xuXG4gICAgZXhwb3J0cy5Db2xvcktleXdvcmRzID0geyAnYWxpY2VibHVlJzogMHhGMEY4RkYsICdhbnRpcXVld2hpdGUnOiAweEZBRUJENywgJ2FxdWEnOiAweDAwRkZGRiwgJ2FxdWFtYXJpbmUnOiAweDdGRkZENCwgJ2F6dXJlJzogMHhGMEZGRkYsXG4gICAgJ2JlaWdlJzogMHhGNUY1REMsICdiaXNxdWUnOiAweEZGRTRDNCwgJ2JsYWNrJzogMHgwMDAwMDAsICdibGFuY2hlZGFsbW9uZCc6IDB4RkZFQkNELCAnYmx1ZSc6IDB4MDAwMEZGLCAnYmx1ZXZpb2xldCc6IDB4OEEyQkUyLFxuICAgICdicm93bic6IDB4QTUyQTJBLCAnYnVybHl3b29kJzogMHhERUI4ODcsICdjYWRldGJsdWUnOiAweDVGOUVBMCwgJ2NoYXJ0cmV1c2UnOiAweDdGRkYwMCwgJ2Nob2NvbGF0ZSc6IDB4RDI2OTFFLCAnY29yYWwnOiAweEZGN0Y1MCxcbiAgICAnY29ybmZsb3dlcmJsdWUnOiAweDY0OTVFRCwgJ2Nvcm5zaWxrJzogMHhGRkY4REMsICdjcmltc29uJzogMHhEQzE0M0MsICdjeWFuJzogMHgwMEZGRkYsICdkYXJrYmx1ZSc6IDB4MDAwMDhCLCAnZGFya2N5YW4nOiAweDAwOEI4QixcbiAgICAnZGFya2dvbGRlbnJvZCc6IDB4Qjg4NjBCLCAnZGFya2dyYXknOiAweEE5QTlBOSwgJ2RhcmtncmVlbic6IDB4MDA2NDAwLCAnZGFya2dyZXknOiAweEE5QTlBOSwgJ2RhcmtraGFraSc6IDB4QkRCNzZCLCAnZGFya21hZ2VudGEnOiAweDhCMDA4QixcbiAgICAnZGFya29saXZlZ3JlZW4nOiAweDU1NkIyRiwgJ2RhcmtvcmFuZ2UnOiAweEZGOEMwMCwgJ2RhcmtvcmNoaWQnOiAweDk5MzJDQywgJ2RhcmtyZWQnOiAweDhCMDAwMCwgJ2RhcmtzYWxtb24nOiAweEU5OTY3QSwgJ2RhcmtzZWFncmVlbic6IDB4OEZCQzhGLFxuICAgICdkYXJrc2xhdGVibHVlJzogMHg0ODNEOEIsICdkYXJrc2xhdGVncmF5JzogMHgyRjRGNEYsICdkYXJrc2xhdGVncmV5JzogMHgyRjRGNEYsICdkYXJrdHVycXVvaXNlJzogMHgwMENFRDEsICdkYXJrdmlvbGV0JzogMHg5NDAwRDMsXG4gICAgJ2RlZXBwaW5rJzogMHhGRjE0OTMsICdkZWVwc2t5Ymx1ZSc6IDB4MDBCRkZGLCAnZGltZ3JheSc6IDB4Njk2OTY5LCAnZGltZ3JleSc6IDB4Njk2OTY5LCAnZG9kZ2VyYmx1ZSc6IDB4MUU5MEZGLCAnZmlyZWJyaWNrJzogMHhCMjIyMjIsXG4gICAgJ2Zsb3JhbHdoaXRlJzogMHhGRkZBRjAsICdmb3Jlc3RncmVlbic6IDB4MjI4QjIyLCAnZnVjaHNpYSc6IDB4RkYwMEZGLCAnZ2FpbnNib3JvJzogMHhEQ0RDREMsICdnaG9zdHdoaXRlJzogMHhGOEY4RkYsICdnb2xkJzogMHhGRkQ3MDAsXG4gICAgJ2dvbGRlbnJvZCc6IDB4REFBNTIwLCAnZ3JheSc6IDB4ODA4MDgwLCAnZ3JlZW4nOiAweDAwODAwMCwgJ2dyZWVueWVsbG93JzogMHhBREZGMkYsICdncmV5JzogMHg4MDgwODAsICdob25leWRldyc6IDB4RjBGRkYwLCAnaG90cGluayc6IDB4RkY2OUI0LFxuICAgICdpbmRpYW5yZWQnOiAweENENUM1QywgJ2luZGlnbyc6IDB4NEIwMDgyLCAnaXZvcnknOiAweEZGRkZGMCwgJ2toYWtpJzogMHhGMEU2OEMsICdsYXZlbmRlcic6IDB4RTZFNkZBLCAnbGF2ZW5kZXJibHVzaCc6IDB4RkZGMEY1LCAnbGF3bmdyZWVuJzogMHg3Q0ZDMDAsXG4gICAgJ2xlbW9uY2hpZmZvbic6IDB4RkZGQUNELCAnbGlnaHRibHVlJzogMHhBREQ4RTYsICdsaWdodGNvcmFsJzogMHhGMDgwODAsICdsaWdodGN5YW4nOiAweEUwRkZGRiwgJ2xpZ2h0Z29sZGVucm9keWVsbG93JzogMHhGQUZBRDIsICdsaWdodGdyYXknOiAweEQzRDNEMyxcbiAgICAnbGlnaHRncmVlbic6IDB4OTBFRTkwLCAnbGlnaHRncmV5JzogMHhEM0QzRDMsICdsaWdodHBpbmsnOiAweEZGQjZDMSwgJ2xpZ2h0c2FsbW9uJzogMHhGRkEwN0EsICdsaWdodHNlYWdyZWVuJzogMHgyMEIyQUEsICdsaWdodHNreWJsdWUnOiAweDg3Q0VGQSxcbiAgICAnbGlnaHRzbGF0ZWdyYXknOiAweDc3ODg5OSwgJ2xpZ2h0c2xhdGVncmV5JzogMHg3Nzg4OTksICdsaWdodHN0ZWVsYmx1ZSc6IDB4QjBDNERFLCAnbGlnaHR5ZWxsb3cnOiAweEZGRkZFMCwgJ2xpbWUnOiAweDAwRkYwMCwgJ2xpbWVncmVlbic6IDB4MzJDRDMyLFxuICAgICdsaW5lbic6IDB4RkFGMEU2LCAnbWFnZW50YSc6IDB4RkYwMEZGLCAnbWFyb29uJzogMHg4MDAwMDAsICdtZWRpdW1hcXVhbWFyaW5lJzogMHg2NkNEQUEsICdtZWRpdW1ibHVlJzogMHgwMDAwQ0QsICdtZWRpdW1vcmNoaWQnOiAweEJBNTVEMyxcbiAgICAnbWVkaXVtcHVycGxlJzogMHg5MzcwREIsICdtZWRpdW1zZWFncmVlbic6IDB4M0NCMzcxLCAnbWVkaXVtc2xhdGVibHVlJzogMHg3QjY4RUUsICdtZWRpdW1zcHJpbmdncmVlbic6IDB4MDBGQTlBLCAnbWVkaXVtdHVycXVvaXNlJzogMHg0OEQxQ0MsXG4gICAgJ21lZGl1bXZpb2xldHJlZCc6IDB4QzcxNTg1LCAnbWlkbmlnaHRibHVlJzogMHgxOTE5NzAsICdtaW50Y3JlYW0nOiAweEY1RkZGQSwgJ21pc3R5cm9zZSc6IDB4RkZFNEUxLCAnbW9jY2FzaW4nOiAweEZGRTRCNSwgJ25hdmFqb3doaXRlJzogMHhGRkRFQUQsXG4gICAgJ25hdnknOiAweDAwMDA4MCwgJ29sZGxhY2UnOiAweEZERjVFNiwgJ29saXZlJzogMHg4MDgwMDAsICdvbGl2ZWRyYWInOiAweDZCOEUyMywgJ29yYW5nZSc6IDB4RkZBNTAwLCAnb3JhbmdlcmVkJzogMHhGRjQ1MDAsICdvcmNoaWQnOiAweERBNzBENixcbiAgICAncGFsZWdvbGRlbnJvZCc6IDB4RUVFOEFBLCAncGFsZWdyZWVuJzogMHg5OEZCOTgsICdwYWxldHVycXVvaXNlJzogMHhBRkVFRUUsICdwYWxldmlvbGV0cmVkJzogMHhEQjcwOTMsICdwYXBheWF3aGlwJzogMHhGRkVGRDUsICdwZWFjaHB1ZmYnOiAweEZGREFCOSxcbiAgICAncGVydSc6IDB4Q0Q4NTNGLCAncGluayc6IDB4RkZDMENCLCAncGx1bSc6IDB4RERBMERELCAncG93ZGVyYmx1ZSc6IDB4QjBFMEU2LCAncHVycGxlJzogMHg4MDAwODAsICdyZWQnOiAweEZGMDAwMCwgJ3Jvc3licm93bic6IDB4QkM4RjhGLFxuICAgICdyb3lhbGJsdWUnOiAweDQxNjlFMSwgJ3NhZGRsZWJyb3duJzogMHg4QjQ1MTMsICdzYWxtb24nOiAweEZBODA3MiwgJ3NhbmR5YnJvd24nOiAweEY0QTQ2MCwgJ3NlYWdyZWVuJzogMHgyRThCNTcsICdzZWFzaGVsbCc6IDB4RkZGNUVFLFxuICAgICdzaWVubmEnOiAweEEwNTIyRCwgJ3NpbHZlcic6IDB4QzBDMEMwLCAnc2t5Ymx1ZSc6IDB4ODdDRUVCLCAnc2xhdGVibHVlJzogMHg2QTVBQ0QsICdzbGF0ZWdyYXknOiAweDcwODA5MCwgJ3NsYXRlZ3JleSc6IDB4NzA4MDkwLCAnc25vdyc6IDB4RkZGQUZBLFxuICAgICdzcHJpbmdncmVlbic6IDB4MDBGRjdGLCAnc3RlZWxibHVlJzogMHg0NjgyQjQsICd0YW4nOiAweEQyQjQ4QywgJ3RlYWwnOiAweDAwODA4MCwgJ3RoaXN0bGUnOiAweEQ4QkZEOCwgJ3RvbWF0byc6IDB4RkY2MzQ3LCAndHVycXVvaXNlJzogMHg0MEUwRDAsXG4gICAgJ3Zpb2xldCc6IDB4RUU4MkVFLCAnd2hlYXQnOiAweEY1REVCMywgJ3doaXRlJzogMHhGRkZGRkYsICd3aGl0ZXNtb2tlJzogMHhGNUY1RjUsICd5ZWxsb3cnOiAweEZGRkYwMCwgJ3llbGxvd2dyZWVuJzogMHg5QUNEMzIgfTtcblxuICAgIC8qKlxuICAgICAqIFVuaWZvcm1zIGxpYnJhcnkgZm9yIHNoYXJlZCB3ZWJnbCBzaGFkZXJzXG4gICAgICovXG5cbiAgICB2YXIgVW5pZm9ybXNMaWIgPSB7XG5cbiAgICBcdGNvbW1vbjoge1xuXG4gICAgXHRcdGRpZmZ1c2U6IHsgdmFsdWU6IG5ldyBDb2xvciggMHhlZWVlZWUgKSB9LFxuICAgIFx0XHRvcGFjaXR5OiB7IHZhbHVlOiAxLjAgfSxcblxuICAgIFx0XHRtYXA6IHsgdmFsdWU6IG51bGwgfSxcbiAgICBcdFx0b2Zmc2V0UmVwZWF0OiB7IHZhbHVlOiBuZXcgVmVjdG9yNCggMCwgMCwgMSwgMSApIH0sXG5cbiAgICBcdFx0c3BlY3VsYXJNYXA6IHsgdmFsdWU6IG51bGwgfSxcbiAgICBcdFx0YWxwaGFNYXA6IHsgdmFsdWU6IG51bGwgfSxcblxuICAgIFx0XHRlbnZNYXA6IHsgdmFsdWU6IG51bGwgfSxcbiAgICBcdFx0ZmxpcEVudk1hcDogeyB2YWx1ZTogLSAxIH0sXG4gICAgXHRcdHJlZmxlY3Rpdml0eTogeyB2YWx1ZTogMS4wIH0sXG4gICAgXHRcdHJlZnJhY3Rpb25SYXRpbzogeyB2YWx1ZTogMC45OCB9XG5cbiAgICBcdH0sXG5cbiAgICBcdGFvbWFwOiB7XG5cbiAgICBcdFx0YW9NYXA6IHsgdmFsdWU6IG51bGwgfSxcbiAgICBcdFx0YW9NYXBJbnRlbnNpdHk6IHsgdmFsdWU6IDEgfVxuXG4gICAgXHR9LFxuXG4gICAgXHRsaWdodG1hcDoge1xuXG4gICAgXHRcdGxpZ2h0TWFwOiB7IHZhbHVlOiBudWxsIH0sXG4gICAgXHRcdGxpZ2h0TWFwSW50ZW5zaXR5OiB7IHZhbHVlOiAxIH1cblxuICAgIFx0fSxcblxuICAgIFx0ZW1pc3NpdmVtYXA6IHtcblxuICAgIFx0XHRlbWlzc2l2ZU1hcDogeyB2YWx1ZTogbnVsbCB9XG5cbiAgICBcdH0sXG5cbiAgICBcdGJ1bXBtYXA6IHtcblxuICAgIFx0XHRidW1wTWFwOiB7IHZhbHVlOiBudWxsIH0sXG4gICAgXHRcdGJ1bXBTY2FsZTogeyB2YWx1ZTogMSB9XG5cbiAgICBcdH0sXG5cbiAgICBcdG5vcm1hbG1hcDoge1xuXG4gICAgXHRcdG5vcm1hbE1hcDogeyB2YWx1ZTogbnVsbCB9LFxuICAgIFx0XHRub3JtYWxTY2FsZTogeyB2YWx1ZTogbmV3IFZlY3RvcjIoIDEsIDEgKSB9XG5cbiAgICBcdH0sXG5cbiAgICBcdGRpc3BsYWNlbWVudG1hcDoge1xuXG4gICAgXHRcdGRpc3BsYWNlbWVudE1hcDogeyB2YWx1ZTogbnVsbCB9LFxuICAgIFx0XHRkaXNwbGFjZW1lbnRTY2FsZTogeyB2YWx1ZTogMSB9LFxuICAgIFx0XHRkaXNwbGFjZW1lbnRCaWFzOiB7IHZhbHVlOiAwIH1cblxuICAgIFx0fSxcblxuICAgIFx0cm91Z2huZXNzbWFwOiB7XG5cbiAgICBcdFx0cm91Z2huZXNzTWFwOiB7IHZhbHVlOiBudWxsIH1cblxuICAgIFx0fSxcblxuICAgIFx0bWV0YWxuZXNzbWFwOiB7XG5cbiAgICBcdFx0bWV0YWxuZXNzTWFwOiB7IHZhbHVlOiBudWxsIH1cblxuICAgIFx0fSxcblxuICAgIFx0Zm9nOiB7XG5cbiAgICBcdFx0Zm9nRGVuc2l0eTogeyB2YWx1ZTogMC4wMDAyNSB9LFxuICAgIFx0XHRmb2dOZWFyOiB7IHZhbHVlOiAxIH0sXG4gICAgXHRcdGZvZ0ZhcjogeyB2YWx1ZTogMjAwMCB9LFxuICAgIFx0XHRmb2dDb2xvcjogeyB2YWx1ZTogbmV3IENvbG9yKCAweGZmZmZmZiApIH1cblxuICAgIFx0fSxcblxuICAgIFx0bGlnaHRzOiB7XG5cbiAgICBcdFx0YW1iaWVudExpZ2h0Q29sb3I6IHsgdmFsdWU6IFtdIH0sXG5cbiAgICBcdFx0ZGlyZWN0aW9uYWxMaWdodHM6IHsgdmFsdWU6IFtdLCBwcm9wZXJ0aWVzOiB7XG4gICAgXHRcdFx0ZGlyZWN0aW9uOiB7fSxcbiAgICBcdFx0XHRjb2xvcjoge30sXG5cbiAgICBcdFx0XHRzaGFkb3c6IHt9LFxuICAgIFx0XHRcdHNoYWRvd0JpYXM6IHt9LFxuICAgIFx0XHRcdHNoYWRvd1JhZGl1czoge30sXG4gICAgXHRcdFx0c2hhZG93TWFwU2l6ZToge31cbiAgICBcdFx0fSB9LFxuXG4gICAgXHRcdGRpcmVjdGlvbmFsU2hhZG93TWFwOiB7IHZhbHVlOiBbXSB9LFxuICAgIFx0XHRkaXJlY3Rpb25hbFNoYWRvd01hdHJpeDogeyB2YWx1ZTogW10gfSxcblxuICAgIFx0XHRzcG90TGlnaHRzOiB7IHZhbHVlOiBbXSwgcHJvcGVydGllczoge1xuICAgIFx0XHRcdGNvbG9yOiB7fSxcbiAgICBcdFx0XHRwb3NpdGlvbjoge30sXG4gICAgXHRcdFx0ZGlyZWN0aW9uOiB7fSxcbiAgICBcdFx0XHRkaXN0YW5jZToge30sXG4gICAgXHRcdFx0Y29uZUNvczoge30sXG4gICAgXHRcdFx0cGVudW1icmFDb3M6IHt9LFxuICAgIFx0XHRcdGRlY2F5OiB7fSxcblxuICAgIFx0XHRcdHNoYWRvdzoge30sXG4gICAgXHRcdFx0c2hhZG93Qmlhczoge30sXG4gICAgXHRcdFx0c2hhZG93UmFkaXVzOiB7fSxcbiAgICBcdFx0XHRzaGFkb3dNYXBTaXplOiB7fVxuICAgIFx0XHR9IH0sXG5cbiAgICBcdFx0c3BvdFNoYWRvd01hcDogeyB2YWx1ZTogW10gfSxcbiAgICBcdFx0c3BvdFNoYWRvd01hdHJpeDogeyB2YWx1ZTogW10gfSxcblxuICAgIFx0XHRwb2ludExpZ2h0czogeyB2YWx1ZTogW10sIHByb3BlcnRpZXM6IHtcbiAgICBcdFx0XHRjb2xvcjoge30sXG4gICAgXHRcdFx0cG9zaXRpb246IHt9LFxuICAgIFx0XHRcdGRlY2F5OiB7fSxcbiAgICBcdFx0XHRkaXN0YW5jZToge30sXG5cbiAgICBcdFx0XHRzaGFkb3c6IHt9LFxuICAgIFx0XHRcdHNoYWRvd0JpYXM6IHt9LFxuICAgIFx0XHRcdHNoYWRvd1JhZGl1czoge30sXG4gICAgXHRcdFx0c2hhZG93TWFwU2l6ZToge31cbiAgICBcdFx0fSB9LFxuXG4gICAgXHRcdHBvaW50U2hhZG93TWFwOiB7IHZhbHVlOiBbXSB9LFxuICAgIFx0XHRwb2ludFNoYWRvd01hdHJpeDogeyB2YWx1ZTogW10gfSxcblxuICAgIFx0XHRoZW1pc3BoZXJlTGlnaHRzOiB7IHZhbHVlOiBbXSwgcHJvcGVydGllczoge1xuICAgIFx0XHRcdGRpcmVjdGlvbjoge30sXG4gICAgXHRcdFx0c2t5Q29sb3I6IHt9LFxuICAgIFx0XHRcdGdyb3VuZENvbG9yOiB7fVxuICAgIFx0XHR9IH1cblxuICAgIFx0fSxcblxuICAgIFx0cG9pbnRzOiB7XG5cbiAgICBcdFx0ZGlmZnVzZTogeyB2YWx1ZTogbmV3IENvbG9yKCAweGVlZWVlZSApIH0sXG4gICAgXHRcdG9wYWNpdHk6IHsgdmFsdWU6IDEuMCB9LFxuICAgIFx0XHRzaXplOiB7IHZhbHVlOiAxLjAgfSxcbiAgICBcdFx0c2NhbGU6IHsgdmFsdWU6IDEuMCB9LFxuICAgIFx0XHRtYXA6IHsgdmFsdWU6IG51bGwgfSxcbiAgICBcdFx0b2Zmc2V0UmVwZWF0OiB7IHZhbHVlOiBuZXcgVmVjdG9yNCggMCwgMCwgMSwgMSApIH1cblxuICAgIFx0fVxuXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gICAgICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAgICAgKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICAgICAqL1xuXG4gICAgdmFyIFNoYWRlckxpYiA9IHtcblxuICAgIFx0YmFzaWM6IHtcblxuICAgIFx0XHR1bmlmb3JtczogZXhwb3J0cy5Vbmlmb3Jtc1V0aWxzLm1lcmdlKCBbXG5cbiAgICBcdFx0XHRVbmlmb3Jtc0xpYi5jb21tb24sXG4gICAgXHRcdFx0VW5pZm9ybXNMaWIuYW9tYXAsXG4gICAgXHRcdFx0VW5pZm9ybXNMaWIuZm9nXG5cbiAgICBcdFx0XSApLFxuXG4gICAgXHRcdHZlcnRleFNoYWRlcjogU2hhZGVyQ2h1bmsubWVzaGJhc2ljX3ZlcnQsXG4gICAgXHRcdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJDaHVuay5tZXNoYmFzaWNfZnJhZ1xuXG4gICAgXHR9LFxuXG4gICAgXHRsYW1iZXJ0OiB7XG5cbiAgICBcdFx0dW5pZm9ybXM6IGV4cG9ydHMuVW5pZm9ybXNVdGlscy5tZXJnZSggW1xuXG4gICAgXHRcdFx0VW5pZm9ybXNMaWIuY29tbW9uLFxuICAgIFx0XHRcdFVuaWZvcm1zTGliLmFvbWFwLFxuICAgIFx0XHRcdFVuaWZvcm1zTGliLmxpZ2h0bWFwLFxuICAgIFx0XHRcdFVuaWZvcm1zTGliLmVtaXNzaXZlbWFwLFxuICAgIFx0XHRcdFVuaWZvcm1zTGliLmZvZyxcbiAgICBcdFx0XHRVbmlmb3Jtc0xpYi5saWdodHMsXG5cbiAgICBcdFx0XHR7XG4gICAgXHRcdFx0XHRlbWlzc2l2ZSA6IHsgdmFsdWU6IG5ldyBDb2xvciggMHgwMDAwMDAgKSB9XG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdF0gKSxcblxuICAgIFx0XHR2ZXJ0ZXhTaGFkZXI6IFNoYWRlckNodW5rLm1lc2hsYW1iZXJ0X3ZlcnQsXG4gICAgXHRcdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJDaHVuay5tZXNobGFtYmVydF9mcmFnXG5cbiAgICBcdH0sXG5cbiAgICBcdHBob25nOiB7XG5cbiAgICBcdFx0dW5pZm9ybXM6IGV4cG9ydHMuVW5pZm9ybXNVdGlscy5tZXJnZSggW1xuXG4gICAgXHRcdFx0VW5pZm9ybXNMaWIuY29tbW9uLFxuICAgIFx0XHRcdFVuaWZvcm1zTGliLmFvbWFwLFxuICAgIFx0XHRcdFVuaWZvcm1zTGliLmxpZ2h0bWFwLFxuICAgIFx0XHRcdFVuaWZvcm1zTGliLmVtaXNzaXZlbWFwLFxuICAgIFx0XHRcdFVuaWZvcm1zTGliLmJ1bXBtYXAsXG4gICAgXHRcdFx0VW5pZm9ybXNMaWIubm9ybWFsbWFwLFxuICAgIFx0XHRcdFVuaWZvcm1zTGliLmRpc3BsYWNlbWVudG1hcCxcbiAgICBcdFx0XHRVbmlmb3Jtc0xpYi5mb2csXG4gICAgXHRcdFx0VW5pZm9ybXNMaWIubGlnaHRzLFxuXG4gICAgXHRcdFx0e1xuICAgIFx0XHRcdFx0ZW1pc3NpdmUgOiB7IHZhbHVlOiBuZXcgQ29sb3IoIDB4MDAwMDAwICkgfSxcbiAgICBcdFx0XHRcdHNwZWN1bGFyIDogeyB2YWx1ZTogbmV3IENvbG9yKCAweDExMTExMSApIH0sXG4gICAgXHRcdFx0XHRzaGluaW5lc3M6IHsgdmFsdWU6IDMwIH1cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XSApLFxuXG4gICAgXHRcdHZlcnRleFNoYWRlcjogU2hhZGVyQ2h1bmsubWVzaHBob25nX3ZlcnQsXG4gICAgXHRcdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJDaHVuay5tZXNocGhvbmdfZnJhZ1xuXG4gICAgXHR9LFxuXG4gICAgXHRzdGFuZGFyZDoge1xuXG4gICAgXHRcdHVuaWZvcm1zOiBleHBvcnRzLlVuaWZvcm1zVXRpbHMubWVyZ2UoIFtcblxuICAgIFx0XHRcdFVuaWZvcm1zTGliLmNvbW1vbixcbiAgICBcdFx0XHRVbmlmb3Jtc0xpYi5hb21hcCxcbiAgICBcdFx0XHRVbmlmb3Jtc0xpYi5saWdodG1hcCxcbiAgICBcdFx0XHRVbmlmb3Jtc0xpYi5lbWlzc2l2ZW1hcCxcbiAgICBcdFx0XHRVbmlmb3Jtc0xpYi5idW1wbWFwLFxuICAgIFx0XHRcdFVuaWZvcm1zTGliLm5vcm1hbG1hcCxcbiAgICBcdFx0XHRVbmlmb3Jtc0xpYi5kaXNwbGFjZW1lbnRtYXAsXG4gICAgXHRcdFx0VW5pZm9ybXNMaWIucm91Z2huZXNzbWFwLFxuICAgIFx0XHRcdFVuaWZvcm1zTGliLm1ldGFsbmVzc21hcCxcbiAgICBcdFx0XHRVbmlmb3Jtc0xpYi5mb2csXG4gICAgXHRcdFx0VW5pZm9ybXNMaWIubGlnaHRzLFxuXG4gICAgXHRcdFx0e1xuICAgIFx0XHRcdFx0ZW1pc3NpdmUgOiB7IHZhbHVlOiBuZXcgQ29sb3IoIDB4MDAwMDAwICkgfSxcbiAgICBcdFx0XHRcdHJvdWdobmVzczogeyB2YWx1ZTogMC41IH0sXG4gICAgXHRcdFx0XHRtZXRhbG5lc3M6IHsgdmFsdWU6IDAgfSxcbiAgICBcdFx0XHRcdGVudk1hcEludGVuc2l0eSA6IHsgdmFsdWU6IDEgfSwgLy8gdGVtcG9yYXJ5XG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdF0gKSxcblxuICAgIFx0XHR2ZXJ0ZXhTaGFkZXI6IFNoYWRlckNodW5rLm1lc2hwaHlzaWNhbF92ZXJ0LFxuICAgIFx0XHRmcmFnbWVudFNoYWRlcjogU2hhZGVyQ2h1bmsubWVzaHBoeXNpY2FsX2ZyYWdcblxuICAgIFx0fSxcblxuICAgIFx0cG9pbnRzOiB7XG5cbiAgICBcdFx0dW5pZm9ybXM6IGV4cG9ydHMuVW5pZm9ybXNVdGlscy5tZXJnZSggW1xuXG4gICAgXHRcdFx0VW5pZm9ybXNMaWIucG9pbnRzLFxuICAgIFx0XHRcdFVuaWZvcm1zTGliLmZvZ1xuXG4gICAgXHRcdF0gKSxcblxuICAgIFx0XHR2ZXJ0ZXhTaGFkZXI6IFNoYWRlckNodW5rLnBvaW50c192ZXJ0LFxuICAgIFx0XHRmcmFnbWVudFNoYWRlcjogU2hhZGVyQ2h1bmsucG9pbnRzX2ZyYWdcblxuICAgIFx0fSxcblxuICAgIFx0ZGFzaGVkOiB7XG5cbiAgICBcdFx0dW5pZm9ybXM6IGV4cG9ydHMuVW5pZm9ybXNVdGlscy5tZXJnZSggW1xuXG4gICAgXHRcdFx0VW5pZm9ybXNMaWIuY29tbW9uLFxuICAgIFx0XHRcdFVuaWZvcm1zTGliLmZvZyxcblxuICAgIFx0XHRcdHtcbiAgICBcdFx0XHRcdHNjYWxlICAgIDogeyB2YWx1ZTogMSB9LFxuICAgIFx0XHRcdFx0ZGFzaFNpemUgOiB7IHZhbHVlOiAxIH0sXG4gICAgXHRcdFx0XHR0b3RhbFNpemU6IHsgdmFsdWU6IDIgfVxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRdICksXG5cbiAgICBcdFx0dmVydGV4U2hhZGVyOiBTaGFkZXJDaHVuay5saW5lZGFzaGVkX3ZlcnQsXG4gICAgXHRcdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJDaHVuay5saW5lZGFzaGVkX2ZyYWdcblxuICAgIFx0fSxcblxuICAgIFx0ZGVwdGg6IHtcblxuICAgIFx0XHR1bmlmb3JtczogZXhwb3J0cy5Vbmlmb3Jtc1V0aWxzLm1lcmdlKCBbXG5cbiAgICBcdFx0XHRVbmlmb3Jtc0xpYi5jb21tb24sXG4gICAgXHRcdFx0VW5pZm9ybXNMaWIuZGlzcGxhY2VtZW50bWFwXG5cbiAgICBcdFx0XSApLFxuXG4gICAgXHRcdHZlcnRleFNoYWRlcjogU2hhZGVyQ2h1bmsuZGVwdGhfdmVydCxcbiAgICBcdFx0ZnJhZ21lbnRTaGFkZXI6IFNoYWRlckNodW5rLmRlcHRoX2ZyYWdcblxuICAgIFx0fSxcblxuICAgIFx0bm9ybWFsOiB7XG5cbiAgICBcdFx0dW5pZm9ybXM6IHtcblxuICAgIFx0XHRcdG9wYWNpdHkgOiB7IHZhbHVlOiAxLjAgfVxuXG4gICAgXHRcdH0sXG5cbiAgICBcdFx0dmVydGV4U2hhZGVyOiBTaGFkZXJDaHVuay5ub3JtYWxfdmVydCxcbiAgICBcdFx0ZnJhZ21lbnRTaGFkZXI6IFNoYWRlckNodW5rLm5vcm1hbF9mcmFnXG5cbiAgICBcdH0sXG5cbiAgICBcdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBcdC8vXHRDdWJlIG1hcCBzaGFkZXJcbiAgICBcdCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbiAgICBcdGN1YmU6IHtcblxuICAgIFx0XHR1bmlmb3Jtczoge1xuICAgIFx0XHRcdHRDdWJlOiB7IHZhbHVlOiBudWxsIH0sXG4gICAgXHRcdFx0dEZsaXA6IHsgdmFsdWU6IC0gMSB9LFxuICAgIFx0XHRcdG9wYWNpdHk6IHsgdmFsdWU6IDEuMCB9XG4gICAgXHRcdH0sXG5cbiAgICBcdFx0dmVydGV4U2hhZGVyOiBTaGFkZXJDaHVuay5jdWJlX3ZlcnQsXG4gICAgXHRcdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJDaHVuay5jdWJlX2ZyYWdcblxuICAgIFx0fSxcblxuICAgIFx0LyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIFx0Ly9cdEN1YmUgbWFwIHNoYWRlclxuICAgIFx0IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuICAgIFx0ZXF1aXJlY3Q6IHtcblxuICAgIFx0XHR1bmlmb3Jtczoge1xuICAgIFx0XHRcdHRFcXVpcmVjdDogeyB2YWx1ZTogbnVsbCB9LFxuICAgIFx0XHRcdHRGbGlwOiB7IHZhbHVlOiAtIDEgfVxuICAgIFx0XHR9LFxuXG4gICAgXHRcdHZlcnRleFNoYWRlcjogU2hhZGVyQ2h1bmsuZXF1aXJlY3RfdmVydCxcbiAgICBcdFx0ZnJhZ21lbnRTaGFkZXI6IFNoYWRlckNodW5rLmVxdWlyZWN0X2ZyYWdcblxuICAgIFx0fSxcblxuICAgIFx0ZGlzdGFuY2VSR0JBOiB7XG5cbiAgICBcdFx0dW5pZm9ybXM6IHtcblxuICAgIFx0XHRcdGxpZ2h0UG9zOiB7IHZhbHVlOiBuZXcgVmVjdG9yMygpIH1cblxuICAgIFx0XHR9LFxuXG4gICAgXHRcdHZlcnRleFNoYWRlcjogU2hhZGVyQ2h1bmsuZGlzdGFuY2VSR0JBX3ZlcnQsXG4gICAgXHRcdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJDaHVuay5kaXN0YW5jZVJHQkFfZnJhZ1xuXG4gICAgXHR9XG5cbiAgICB9O1xuXG4gICAgU2hhZGVyTGliLnBoeXNpY2FsID0ge1xuXG4gICAgXHR1bmlmb3JtczogZXhwb3J0cy5Vbmlmb3Jtc1V0aWxzLm1lcmdlKCBbXG5cbiAgICBcdFx0U2hhZGVyTGliLnN0YW5kYXJkLnVuaWZvcm1zLFxuXG4gICAgXHRcdHtcbiAgICBcdFx0XHRjbGVhckNvYXQ6IHsgdmFsdWU6IDAgfSxcbiAgICBcdFx0XHRjbGVhckNvYXRSb3VnaG5lc3M6IHsgdmFsdWU6IDAgfVxuICAgIFx0XHR9XG5cbiAgICBcdF0gKSxcblxuICAgIFx0dmVydGV4U2hhZGVyOiBTaGFkZXJDaHVuay5tZXNocGh5c2ljYWxfdmVydCxcbiAgICBcdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJDaHVuay5tZXNocGh5c2ljYWxfZnJhZ1xuXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIEJveDIoIG1pbiwgbWF4ICkge1xuXG4gICAgXHR0aGlzLm1pbiA9ICggbWluICE9PSB1bmRlZmluZWQgKSA/IG1pbiA6IG5ldyBWZWN0b3IyKCArIEluZmluaXR5LCArIEluZmluaXR5ICk7XG4gICAgXHR0aGlzLm1heCA9ICggbWF4ICE9PSB1bmRlZmluZWQgKSA/IG1heCA6IG5ldyBWZWN0b3IyKCAtIEluZmluaXR5LCAtIEluZmluaXR5ICk7XG5cbiAgICB9XG5cbiAgICBCb3gyLnByb3RvdHlwZSA9IHtcblxuICAgIFx0Y29uc3RydWN0b3I6IEJveDIsXG5cbiAgICBcdHNldDogZnVuY3Rpb24gKCBtaW4sIG1heCApIHtcblxuICAgIFx0XHR0aGlzLm1pbi5jb3B5KCBtaW4gKTtcbiAgICBcdFx0dGhpcy5tYXguY29weSggbWF4ICk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldEZyb21Qb2ludHM6IGZ1bmN0aW9uICggcG9pbnRzICkge1xuXG4gICAgXHRcdHRoaXMubWFrZUVtcHR5KCk7XG5cbiAgICBcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuICAgIFx0XHRcdHRoaXMuZXhwYW5kQnlQb2ludCggcG9pbnRzWyBpIF0gKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldEZyb21DZW50ZXJBbmRTaXplOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dmFyIHYxID0gbmV3IFZlY3RvcjIoKTtcblxuICAgIFx0XHRyZXR1cm4gZnVuY3Rpb24gc2V0RnJvbUNlbnRlckFuZFNpemUoIGNlbnRlciwgc2l6ZSApIHtcblxuICAgIFx0XHRcdHZhciBoYWxmU2l6ZSA9IHYxLmNvcHkoIHNpemUgKS5tdWx0aXBseVNjYWxhciggMC41ICk7XG4gICAgXHRcdFx0dGhpcy5taW4uY29weSggY2VudGVyICkuc3ViKCBoYWxmU2l6ZSApO1xuICAgIFx0XHRcdHRoaXMubWF4LmNvcHkoIGNlbnRlciApLmFkZCggaGFsZlNpemUgKTtcblxuICAgIFx0XHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHRcdH07XG5cbiAgICBcdH0oKSxcblxuICAgIFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGNvcHk6IGZ1bmN0aW9uICggYm94ICkge1xuXG4gICAgXHRcdHRoaXMubWluLmNvcHkoIGJveC5taW4gKTtcbiAgICBcdFx0dGhpcy5tYXguY29weSggYm94Lm1heCApO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRtYWtlRW1wdHk6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR0aGlzLm1pbi54ID0gdGhpcy5taW4ueSA9ICsgSW5maW5pdHk7XG4gICAgXHRcdHRoaXMubWF4LnggPSB0aGlzLm1heC55ID0gLSBJbmZpbml0eTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0aXNFbXB0eTogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdC8vIHRoaXMgaXMgYSBtb3JlIHJvYnVzdCBjaGVjayBmb3IgZW1wdHkgdGhhbiAoIHZvbHVtZSA8PSAwICkgYmVjYXVzZSB2b2x1bWUgY2FuIGdldCBwb3NpdGl2ZSB3aXRoIHR3byBuZWdhdGl2ZSBheGVzXG5cbiAgICBcdFx0cmV0dXJuICggdGhpcy5tYXgueCA8IHRoaXMubWluLnggKSB8fCAoIHRoaXMubWF4LnkgPCB0aGlzLm1pbi55ICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGdldENlbnRlcjogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgIFx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjIoKTtcbiAgICBcdFx0cmV0dXJuIHRoaXMuaXNFbXB0eSgpID8gcmVzdWx0LnNldCggMCwgMCApIDogcmVzdWx0LmFkZFZlY3RvcnMoIHRoaXMubWluLCB0aGlzLm1heCApLm11bHRpcGx5U2NhbGFyKCAwLjUgKTtcblxuICAgIFx0fSxcblxuICAgIFx0Z2V0U2l6ZTogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgIFx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjIoKTtcbiAgICBcdFx0cmV0dXJuIHRoaXMuaXNFbXB0eSgpID8gcmVzdWx0LnNldCggMCwgMCApIDogcmVzdWx0LnN1YlZlY3RvcnMoIHRoaXMubWF4LCB0aGlzLm1pbiApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRleHBhbmRCeVBvaW50OiBmdW5jdGlvbiAoIHBvaW50ICkge1xuXG4gICAgXHRcdHRoaXMubWluLm1pbiggcG9pbnQgKTtcbiAgICBcdFx0dGhpcy5tYXgubWF4KCBwb2ludCApO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRleHBhbmRCeVZlY3RvcjogZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XG5cbiAgICBcdFx0dGhpcy5taW4uc3ViKCB2ZWN0b3IgKTtcbiAgICBcdFx0dGhpcy5tYXguYWRkKCB2ZWN0b3IgKTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0ZXhwYW5kQnlTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xuXG4gICAgXHRcdHRoaXMubWluLmFkZFNjYWxhciggLSBzY2FsYXIgKTtcbiAgICBcdFx0dGhpcy5tYXguYWRkU2NhbGFyKCBzY2FsYXIgKTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0Y29udGFpbnNQb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcblxuICAgIFx0XHRpZiAoIHBvaW50LnggPCB0aGlzLm1pbi54IHx8IHBvaW50LnggPiB0aGlzLm1heC54IHx8XG4gICAgXHRcdCAgICAgcG9pbnQueSA8IHRoaXMubWluLnkgfHwgcG9pbnQueSA+IHRoaXMubWF4LnkgKSB7XG5cbiAgICBcdFx0XHRyZXR1cm4gZmFsc2U7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiB0cnVlO1xuXG4gICAgXHR9LFxuXG4gICAgXHRjb250YWluc0JveDogZnVuY3Rpb24gKCBib3ggKSB7XG5cbiAgICBcdFx0aWYgKCAoIHRoaXMubWluLnggPD0gYm94Lm1pbi54ICkgJiYgKCBib3gubWF4LnggPD0gdGhpcy5tYXgueCApICYmXG4gICAgXHRcdCAgICAgKCB0aGlzLm1pbi55IDw9IGJveC5taW4ueSApICYmICggYm94Lm1heC55IDw9IHRoaXMubWF4LnkgKSApIHtcblxuICAgIFx0XHRcdHJldHVybiB0cnVlO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gZmFsc2U7XG5cbiAgICBcdH0sXG5cbiAgICBcdGdldFBhcmFtZXRlcjogZnVuY3Rpb24gKCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICBcdFx0Ly8gVGhpcyBjYW4gcG90ZW50aWFsbHkgaGF2ZSBhIGRpdmlkZSBieSB6ZXJvIGlmIHRoZSBib3hcbiAgICBcdFx0Ly8gaGFzIGEgc2l6ZSBkaW1lbnNpb24gb2YgMC5cblxuICAgIFx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjIoKTtcblxuICAgIFx0XHRyZXR1cm4gcmVzdWx0LnNldChcbiAgICBcdFx0XHQoIHBvaW50LnggLSB0aGlzLm1pbi54ICkgLyAoIHRoaXMubWF4LnggLSB0aGlzLm1pbi54ICksXG4gICAgXHRcdFx0KCBwb2ludC55IC0gdGhpcy5taW4ueSApIC8gKCB0aGlzLm1heC55IC0gdGhpcy5taW4ueSApXG4gICAgXHRcdCk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGludGVyc2VjdHNCb3g6IGZ1bmN0aW9uICggYm94ICkge1xuXG4gICAgXHRcdC8vIHVzaW5nIDYgc3BsaXR0aW5nIHBsYW5lcyB0byBydWxlIG91dCBpbnRlcnNlY3Rpb25zLlxuXG4gICAgXHRcdGlmICggYm94Lm1heC54IDwgdGhpcy5taW4ueCB8fCBib3gubWluLnggPiB0aGlzLm1heC54IHx8XG4gICAgXHRcdCAgICAgYm94Lm1heC55IDwgdGhpcy5taW4ueSB8fCBib3gubWluLnkgPiB0aGlzLm1heC55ICkge1xuXG4gICAgXHRcdFx0cmV0dXJuIGZhbHNlO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gdHJ1ZTtcblxuICAgIFx0fSxcblxuICAgIFx0Y2xhbXBQb2ludDogZnVuY3Rpb24gKCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICBcdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IyKCk7XG4gICAgXHRcdHJldHVybiByZXN1bHQuY29weSggcG9pbnQgKS5jbGFtcCggdGhpcy5taW4sIHRoaXMubWF4ICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGRpc3RhbmNlVG9Qb2ludDogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHZhciB2MSA9IG5ldyBWZWN0b3IyKCk7XG5cbiAgICBcdFx0cmV0dXJuIGZ1bmN0aW9uIGRpc3RhbmNlVG9Qb2ludCggcG9pbnQgKSB7XG5cbiAgICBcdFx0XHR2YXIgY2xhbXBlZFBvaW50ID0gdjEuY29weSggcG9pbnQgKS5jbGFtcCggdGhpcy5taW4sIHRoaXMubWF4ICk7XG4gICAgXHRcdFx0cmV0dXJuIGNsYW1wZWRQb2ludC5zdWIoIHBvaW50ICkubGVuZ3RoKCk7XG5cbiAgICBcdFx0fTtcblxuICAgIFx0fSgpLFxuXG4gICAgXHRpbnRlcnNlY3Q6IGZ1bmN0aW9uICggYm94ICkge1xuXG4gICAgXHRcdHRoaXMubWluLm1heCggYm94Lm1pbiApO1xuICAgIFx0XHR0aGlzLm1heC5taW4oIGJveC5tYXggKTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0dW5pb246IGZ1bmN0aW9uICggYm94ICkge1xuXG4gICAgXHRcdHRoaXMubWluLm1pbiggYm94Lm1pbiApO1xuICAgIFx0XHR0aGlzLm1heC5tYXgoIGJveC5tYXggKTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0dHJhbnNsYXRlOiBmdW5jdGlvbiAoIG9mZnNldCApIHtcblxuICAgIFx0XHR0aGlzLm1pbi5hZGQoIG9mZnNldCApO1xuICAgIFx0XHR0aGlzLm1heC5hZGQoIG9mZnNldCApO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRlcXVhbHM6IGZ1bmN0aW9uICggYm94ICkge1xuXG4gICAgXHRcdHJldHVybiBib3gubWluLmVxdWFscyggdGhpcy5taW4gKSAmJiBib3gubWF4LmVxdWFscyggdGhpcy5tYXggKTtcblxuICAgIFx0fVxuXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG4gICAgICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIExlbnNGbGFyZVBsdWdpbiggcmVuZGVyZXIsIGZsYXJlcyApIHtcblxuICAgIFx0dmFyIGdsID0gcmVuZGVyZXIuY29udGV4dDtcbiAgICBcdHZhciBzdGF0ZSA9IHJlbmRlcmVyLnN0YXRlO1xuXG4gICAgXHR2YXIgdmVydGV4QnVmZmVyLCBlbGVtZW50QnVmZmVyO1xuICAgIFx0dmFyIHNoYWRlciwgcHJvZ3JhbSwgYXR0cmlidXRlcywgdW5pZm9ybXM7XG5cbiAgICBcdHZhciB0ZW1wVGV4dHVyZSwgb2NjbHVzaW9uVGV4dHVyZTtcblxuICAgIFx0ZnVuY3Rpb24gaW5pdCgpIHtcblxuICAgIFx0XHR2YXIgdmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KCBbXG4gICAgXHRcdFx0LSAxLCAtIDEsICAwLCAwLFxuICAgIFx0XHRcdCAxLCAtIDEsICAxLCAwLFxuICAgIFx0XHRcdCAxLCAgMSwgIDEsIDEsXG4gICAgXHRcdFx0LSAxLCAgMSwgIDAsIDFcbiAgICBcdFx0XSApO1xuXG4gICAgXHRcdHZhciBmYWNlcyA9IG5ldyBVaW50MTZBcnJheSggW1xuICAgIFx0XHRcdDAsIDEsIDIsXG4gICAgXHRcdFx0MCwgMiwgM1xuICAgIFx0XHRdICk7XG5cbiAgICBcdFx0Ly8gYnVmZmVyc1xuXG4gICAgXHRcdHZlcnRleEJ1ZmZlciAgICAgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBcdFx0ZWxlbWVudEJ1ZmZlciAgICA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuXG4gICAgXHRcdGdsLmJpbmRCdWZmZXIoIGdsLkFSUkFZX0JVRkZFUiwgdmVydGV4QnVmZmVyICk7XG4gICAgXHRcdGdsLmJ1ZmZlckRhdGEoIGdsLkFSUkFZX0JVRkZFUiwgdmVydGljZXMsIGdsLlNUQVRJQ19EUkFXICk7XG5cbiAgICBcdFx0Z2wuYmluZEJ1ZmZlciggZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGVsZW1lbnRCdWZmZXIgKTtcbiAgICBcdFx0Z2wuYnVmZmVyRGF0YSggZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGZhY2VzLCBnbC5TVEFUSUNfRFJBVyApO1xuXG4gICAgXHRcdC8vIHRleHR1cmVzXG5cbiAgICBcdFx0dGVtcFRleHR1cmUgICAgICA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICBcdFx0b2NjbHVzaW9uVGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcblxuICAgIFx0XHRzdGF0ZS5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgdGVtcFRleHR1cmUgKTtcbiAgICBcdFx0Z2wudGV4SW1hZ2UyRCggZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCLCAxNiwgMTYsIDAsIGdsLlJHQiwgZ2wuVU5TSUdORURfQllURSwgbnVsbCApO1xuICAgIFx0XHRnbC50ZXhQYXJhbWV0ZXJpKCBnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSApO1xuICAgIFx0XHRnbC50ZXhQYXJhbWV0ZXJpKCBnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSApO1xuICAgIFx0XHRnbC50ZXhQYXJhbWV0ZXJpKCBnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QgKTtcbiAgICBcdFx0Z2wudGV4UGFyYW1ldGVyaSggZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5ORUFSRVNUICk7XG5cbiAgICBcdFx0c3RhdGUuYmluZFRleHR1cmUoIGdsLlRFWFRVUkVfMkQsIG9jY2x1c2lvblRleHR1cmUgKTtcbiAgICBcdFx0Z2wudGV4SW1hZ2UyRCggZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgMTYsIDE2LCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBudWxsICk7XG4gICAgXHRcdGdsLnRleFBhcmFtZXRlcmkoIGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFICk7XG4gICAgXHRcdGdsLnRleFBhcmFtZXRlcmkoIGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFICk7XG4gICAgXHRcdGdsLnRleFBhcmFtZXRlcmkoIGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTkVBUkVTVCApO1xuICAgIFx0XHRnbC50ZXhQYXJhbWV0ZXJpKCBnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QgKTtcblxuICAgIFx0XHRzaGFkZXIgPSB7XG5cbiAgICBcdFx0XHR2ZXJ0ZXhTaGFkZXI6IFtcblxuICAgIFx0XHRcdFx0XCJ1bmlmb3JtIGxvd3AgaW50IHJlbmRlclR5cGU7XCIsXG5cbiAgICBcdFx0XHRcdFwidW5pZm9ybSB2ZWMzIHNjcmVlblBvc2l0aW9uO1wiLFxuICAgIFx0XHRcdFx0XCJ1bmlmb3JtIHZlYzIgc2NhbGU7XCIsXG4gICAgXHRcdFx0XHRcInVuaWZvcm0gZmxvYXQgcm90YXRpb247XCIsXG5cbiAgICBcdFx0XHRcdFwidW5pZm9ybSBzYW1wbGVyMkQgb2NjbHVzaW9uTWFwO1wiLFxuXG4gICAgXHRcdFx0XHRcImF0dHJpYnV0ZSB2ZWMyIHBvc2l0aW9uO1wiLFxuICAgIFx0XHRcdFx0XCJhdHRyaWJ1dGUgdmVjMiB1djtcIixcblxuICAgIFx0XHRcdFx0XCJ2YXJ5aW5nIHZlYzIgdlVWO1wiLFxuICAgIFx0XHRcdFx0XCJ2YXJ5aW5nIGZsb2F0IHZWaXNpYmlsaXR5O1wiLFxuXG4gICAgXHRcdFx0XHRcInZvaWQgbWFpbigpIHtcIixcblxuICAgIFx0XHRcdFx0XHRcInZVViA9IHV2O1wiLFxuXG4gICAgXHRcdFx0XHRcdFwidmVjMiBwb3MgPSBwb3NpdGlvbjtcIixcblxuICAgIFx0XHRcdFx0XHRcImlmICggcmVuZGVyVHlwZSA9PSAyICkge1wiLFxuXG4gICAgXHRcdFx0XHRcdFx0XCJ2ZWM0IHZpc2liaWxpdHkgPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC4xLCAwLjEgKSApO1wiLFxuICAgIFx0XHRcdFx0XHRcdFwidmlzaWJpbGl0eSArPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC41LCAwLjEgKSApO1wiLFxuICAgIFx0XHRcdFx0XHRcdFwidmlzaWJpbGl0eSArPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC45LCAwLjEgKSApO1wiLFxuICAgIFx0XHRcdFx0XHRcdFwidmlzaWJpbGl0eSArPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC45LCAwLjUgKSApO1wiLFxuICAgIFx0XHRcdFx0XHRcdFwidmlzaWJpbGl0eSArPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC45LCAwLjkgKSApO1wiLFxuICAgIFx0XHRcdFx0XHRcdFwidmlzaWJpbGl0eSArPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC41LCAwLjkgKSApO1wiLFxuICAgIFx0XHRcdFx0XHRcdFwidmlzaWJpbGl0eSArPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC4xLCAwLjkgKSApO1wiLFxuICAgIFx0XHRcdFx0XHRcdFwidmlzaWJpbGl0eSArPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC4xLCAwLjUgKSApO1wiLFxuICAgIFx0XHRcdFx0XHRcdFwidmlzaWJpbGl0eSArPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC41LCAwLjUgKSApO1wiLFxuXG4gICAgXHRcdFx0XHRcdFx0XCJ2VmlzaWJpbGl0eSA9ICAgICAgICB2aXNpYmlsaXR5LnIgLyA5LjA7XCIsXG4gICAgXHRcdFx0XHRcdFx0XCJ2VmlzaWJpbGl0eSAqPSAxLjAgLSB2aXNpYmlsaXR5LmcgLyA5LjA7XCIsXG4gICAgXHRcdFx0XHRcdFx0XCJ2VmlzaWJpbGl0eSAqPSAgICAgICB2aXNpYmlsaXR5LmIgLyA5LjA7XCIsXG4gICAgXHRcdFx0XHRcdFx0XCJ2VmlzaWJpbGl0eSAqPSAxLjAgLSB2aXNpYmlsaXR5LmEgLyA5LjA7XCIsXG5cbiAgICBcdFx0XHRcdFx0XHRcInBvcy54ID0gY29zKCByb3RhdGlvbiApICogcG9zaXRpb24ueCAtIHNpbiggcm90YXRpb24gKSAqIHBvc2l0aW9uLnk7XCIsXG4gICAgXHRcdFx0XHRcdFx0XCJwb3MueSA9IHNpbiggcm90YXRpb24gKSAqIHBvc2l0aW9uLnggKyBjb3MoIHJvdGF0aW9uICkgKiBwb3NpdGlvbi55O1wiLFxuXG4gICAgXHRcdFx0XHRcdFwifVwiLFxuXG4gICAgXHRcdFx0XHRcdFwiZ2xfUG9zaXRpb24gPSB2ZWM0KCAoIHBvcyAqIHNjYWxlICsgc2NyZWVuUG9zaXRpb24ueHkgKS54eSwgc2NyZWVuUG9zaXRpb24ueiwgMS4wICk7XCIsXG5cbiAgICBcdFx0XHRcdFwifVwiXG5cbiAgICBcdFx0XHRdLmpvaW4oIFwiXFxuXCIgKSxcblxuICAgIFx0XHRcdGZyYWdtZW50U2hhZGVyOiBbXG5cbiAgICBcdFx0XHRcdFwidW5pZm9ybSBsb3dwIGludCByZW5kZXJUeXBlO1wiLFxuXG4gICAgXHRcdFx0XHRcInVuaWZvcm0gc2FtcGxlcjJEIG1hcDtcIixcbiAgICBcdFx0XHRcdFwidW5pZm9ybSBmbG9hdCBvcGFjaXR5O1wiLFxuICAgIFx0XHRcdFx0XCJ1bmlmb3JtIHZlYzMgY29sb3I7XCIsXG5cbiAgICBcdFx0XHRcdFwidmFyeWluZyB2ZWMyIHZVVjtcIixcbiAgICBcdFx0XHRcdFwidmFyeWluZyBmbG9hdCB2VmlzaWJpbGl0eTtcIixcblxuICAgIFx0XHRcdFx0XCJ2b2lkIG1haW4oKSB7XCIsXG5cbiAgICBcdFx0XHRcdFx0Ly8gcGluayBzcXVhcmVcblxuICAgIFx0XHRcdFx0XHRcImlmICggcmVuZGVyVHlwZSA9PSAwICkge1wiLFxuXG4gICAgXHRcdFx0XHRcdFx0XCJnbF9GcmFnQ29sb3IgPSB2ZWM0KCAxLjAsIDAuMCwgMS4wLCAwLjAgKTtcIixcblxuICAgIFx0XHRcdFx0XHQvLyByZXN0b3JlXG5cbiAgICBcdFx0XHRcdFx0XCJ9IGVsc2UgaWYgKCByZW5kZXJUeXBlID09IDEgKSB7XCIsXG5cbiAgICBcdFx0XHRcdFx0XHRcImdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCggbWFwLCB2VVYgKTtcIixcblxuICAgIFx0XHRcdFx0XHQvLyBmbGFyZVxuXG4gICAgXHRcdFx0XHRcdFwifSBlbHNlIHtcIixcblxuICAgIFx0XHRcdFx0XHRcdFwidmVjNCB0ZXh0dXJlID0gdGV4dHVyZTJEKCBtYXAsIHZVViApO1wiLFxuICAgIFx0XHRcdFx0XHRcdFwidGV4dHVyZS5hICo9IG9wYWNpdHkgKiB2VmlzaWJpbGl0eTtcIixcbiAgICBcdFx0XHRcdFx0XHRcImdsX0ZyYWdDb2xvciA9IHRleHR1cmU7XCIsXG4gICAgXHRcdFx0XHRcdFx0XCJnbF9GcmFnQ29sb3IucmdiICo9IGNvbG9yO1wiLFxuXG4gICAgXHRcdFx0XHRcdFwifVwiLFxuXG4gICAgXHRcdFx0XHRcIn1cIlxuXG4gICAgXHRcdFx0XS5qb2luKCBcIlxcblwiIClcblxuICAgIFx0XHR9O1xuXG4gICAgXHRcdHByb2dyYW0gPSBjcmVhdGVQcm9ncmFtKCBzaGFkZXIgKTtcblxuICAgIFx0XHRhdHRyaWJ1dGVzID0ge1xuICAgIFx0XHRcdHZlcnRleDogZ2wuZ2V0QXR0cmliTG9jYXRpb24gKCBwcm9ncmFtLCBcInBvc2l0aW9uXCIgKSxcbiAgICBcdFx0XHR1djogICAgIGdsLmdldEF0dHJpYkxvY2F0aW9uICggcHJvZ3JhbSwgXCJ1dlwiIClcbiAgICBcdFx0fTtcblxuICAgIFx0XHR1bmlmb3JtcyA9IHtcbiAgICBcdFx0XHRyZW5kZXJUeXBlOiAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCBcInJlbmRlclR5cGVcIiApLFxuICAgIFx0XHRcdG1hcDogICAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sIFwibWFwXCIgKSxcbiAgICBcdFx0XHRvY2NsdXNpb25NYXA6ICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCBcIm9jY2x1c2lvbk1hcFwiICksXG4gICAgXHRcdFx0b3BhY2l0eTogICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgXCJvcGFjaXR5XCIgKSxcbiAgICBcdFx0XHRjb2xvcjogICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCBcImNvbG9yXCIgKSxcbiAgICBcdFx0XHRzY2FsZTogICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCBcInNjYWxlXCIgKSxcbiAgICBcdFx0XHRyb3RhdGlvbjogICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCBcInJvdGF0aW9uXCIgKSxcbiAgICBcdFx0XHRzY3JlZW5Qb3NpdGlvbjogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCBcInNjcmVlblBvc2l0aW9uXCIgKVxuICAgIFx0XHR9O1xuXG4gICAgXHR9XG5cbiAgICBcdC8qXG4gICAgXHQgKiBSZW5kZXIgbGVucyBmbGFyZXNcbiAgICBcdCAqIE1ldGhvZDogcmVuZGVycyAxNngxNiAweGZmMDBmZi1jb2xvcmVkIHBvaW50cyBzY2F0dGVyZWQgb3ZlciB0aGUgbGlnaHQgc291cmNlIGFyZWEsXG4gICAgXHQgKiAgICAgICAgIHJlYWRzIHRoZXNlIGJhY2sgYW5kIGNhbGN1bGF0ZXMgb2NjbHVzaW9uLlxuICAgIFx0ICovXG5cbiAgICBcdHRoaXMucmVuZGVyID0gZnVuY3Rpb24gKCBzY2VuZSwgY2FtZXJhLCB2aWV3cG9ydCApIHtcblxuICAgIFx0XHRpZiAoIGZsYXJlcy5sZW5ndGggPT09IDAgKSByZXR1cm47XG5cbiAgICBcdFx0dmFyIHRlbXBQb3NpdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG5cbiAgICBcdFx0dmFyIGludkFzcGVjdCA9IHZpZXdwb3J0LncgLyB2aWV3cG9ydC56LFxuICAgIFx0XHRcdGhhbGZWaWV3cG9ydFdpZHRoID0gdmlld3BvcnQueiAqIDAuNSxcbiAgICBcdFx0XHRoYWxmVmlld3BvcnRIZWlnaHQgPSB2aWV3cG9ydC53ICogMC41O1xuXG4gICAgXHRcdHZhciBzaXplID0gMTYgLyB2aWV3cG9ydC53LFxuICAgIFx0XHRcdHNjYWxlID0gbmV3IFZlY3RvcjIoIHNpemUgKiBpbnZBc3BlY3QsIHNpemUgKTtcblxuICAgIFx0XHR2YXIgc2NyZWVuUG9zaXRpb24gPSBuZXcgVmVjdG9yMyggMSwgMSwgMCApLFxuICAgIFx0XHRcdHNjcmVlblBvc2l0aW9uUGl4ZWxzID0gbmV3IFZlY3RvcjIoIDEsIDEgKTtcblxuICAgIFx0XHR2YXIgdmFsaWRBcmVhID0gbmV3IEJveDIoKTtcblxuICAgIFx0XHR2YWxpZEFyZWEubWluLnNldCggMCwgMCApO1xuICAgIFx0XHR2YWxpZEFyZWEubWF4LnNldCggdmlld3BvcnQueiAtIDE2LCB2aWV3cG9ydC53IC0gMTYgKTtcblxuICAgIFx0XHRpZiAoIHByb2dyYW0gPT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdGluaXQoKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0Z2wudXNlUHJvZ3JhbSggcHJvZ3JhbSApO1xuXG4gICAgXHRcdHN0YXRlLmluaXRBdHRyaWJ1dGVzKCk7XG4gICAgXHRcdHN0YXRlLmVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlcy52ZXJ0ZXggKTtcbiAgICBcdFx0c3RhdGUuZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzLnV2ICk7XG4gICAgXHRcdHN0YXRlLmRpc2FibGVVbnVzZWRBdHRyaWJ1dGVzKCk7XG5cbiAgICBcdFx0Ly8gbG9vcCB0aHJvdWdoIGFsbCBsZW5zIGZsYXJlcyB0byB1cGRhdGUgdGhlaXIgb2NjbHVzaW9uIGFuZCBwb3NpdGlvbnNcbiAgICBcdFx0Ly8gc2V0dXAgZ2wgYW5kIGNvbW1vbiB1c2VkIGF0dHJpYnMvdW5pZm9ybXNcblxuICAgIFx0XHRnbC51bmlmb3JtMWkoIHVuaWZvcm1zLm9jY2x1c2lvbk1hcCwgMCApO1xuICAgIFx0XHRnbC51bmlmb3JtMWkoIHVuaWZvcm1zLm1hcCwgMSApO1xuXG4gICAgXHRcdGdsLmJpbmRCdWZmZXIoIGdsLkFSUkFZX0JVRkZFUiwgdmVydGV4QnVmZmVyICk7XG4gICAgXHRcdGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMudmVydGV4LCAyLCBnbC5GTE9BVCwgZmFsc2UsIDIgKiA4LCAwICk7XG4gICAgXHRcdGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMudXYsIDIsIGdsLkZMT0FULCBmYWxzZSwgMiAqIDgsIDggKTtcblxuICAgIFx0XHRnbC5iaW5kQnVmZmVyKCBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgZWxlbWVudEJ1ZmZlciApO1xuXG4gICAgXHRcdHN0YXRlLmRpc2FibGUoIGdsLkNVTExfRkFDRSApO1xuICAgIFx0XHRzdGF0ZS5zZXREZXB0aFdyaXRlKCBmYWxzZSApO1xuXG4gICAgXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGZsYXJlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgXHRcdFx0c2l6ZSA9IDE2IC8gdmlld3BvcnQudztcbiAgICBcdFx0XHRzY2FsZS5zZXQoIHNpemUgKiBpbnZBc3BlY3QsIHNpemUgKTtcblxuICAgIFx0XHRcdC8vIGNhbGMgb2JqZWN0IHNjcmVlbiBwb3NpdGlvblxuXG4gICAgXHRcdFx0dmFyIGZsYXJlID0gZmxhcmVzWyBpIF07XG5cbiAgICBcdFx0XHR0ZW1wUG9zaXRpb24uc2V0KCBmbGFyZS5tYXRyaXhXb3JsZC5lbGVtZW50c1sgMTIgXSwgZmxhcmUubWF0cml4V29ybGQuZWxlbWVudHNbIDEzIF0sIGZsYXJlLm1hdHJpeFdvcmxkLmVsZW1lbnRzWyAxNCBdICk7XG5cbiAgICBcdFx0XHR0ZW1wUG9zaXRpb24uYXBwbHlNYXRyaXg0KCBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlICk7XG4gICAgXHRcdFx0dGVtcFBvc2l0aW9uLmFwcGx5UHJvamVjdGlvbiggY2FtZXJhLnByb2plY3Rpb25NYXRyaXggKTtcblxuICAgIFx0XHRcdC8vIHNldHVwIGFycmF5cyBmb3IgZ2wgcHJvZ3JhbXNcblxuICAgIFx0XHRcdHNjcmVlblBvc2l0aW9uLmNvcHkoIHRlbXBQb3NpdGlvbiApO1xuXG4gICAgXHRcdFx0Ly8gaG9yaXpvbnRhbCBhbmQgdmVydGljYWwgY29vcmRpbmF0ZSBvZiB0aGUgbG93ZXIgbGVmdCBjb3JuZXIgb2YgdGhlIHBpeGVscyB0byBjb3B5XG5cbiAgICBcdFx0XHRzY3JlZW5Qb3NpdGlvblBpeGVscy54ID0gdmlld3BvcnQueCArICggc2NyZWVuUG9zaXRpb24ueCAqIGhhbGZWaWV3cG9ydFdpZHRoICkgKyBoYWxmVmlld3BvcnRXaWR0aCAtIDg7XG4gICAgXHRcdFx0c2NyZWVuUG9zaXRpb25QaXhlbHMueSA9IHZpZXdwb3J0LnkgKyAoIHNjcmVlblBvc2l0aW9uLnkgKiBoYWxmVmlld3BvcnRIZWlnaHQgKSArIGhhbGZWaWV3cG9ydEhlaWdodCAtIDg7XG5cbiAgICBcdFx0XHQvLyBzY3JlZW4gY3VsbFxuXG4gICAgXHRcdFx0aWYgKCB2YWxpZEFyZWEuY29udGFpbnNQb2ludCggc2NyZWVuUG9zaXRpb25QaXhlbHMgKSA9PT0gdHJ1ZSApIHtcblxuICAgIFx0XHRcdFx0Ly8gc2F2ZSBjdXJyZW50IFJHQiB0byB0ZW1wIHRleHR1cmVcblxuICAgIFx0XHRcdFx0c3RhdGUuYWN0aXZlVGV4dHVyZSggZ2wuVEVYVFVSRTAgKTtcbiAgICBcdFx0XHRcdHN0YXRlLmJpbmRUZXh0dXJlKCBnbC5URVhUVVJFXzJELCBudWxsICk7XG4gICAgXHRcdFx0XHRzdGF0ZS5hY3RpdmVUZXh0dXJlKCBnbC5URVhUVVJFMSApO1xuICAgIFx0XHRcdFx0c3RhdGUuYmluZFRleHR1cmUoIGdsLlRFWFRVUkVfMkQsIHRlbXBUZXh0dXJlICk7XG4gICAgXHRcdFx0XHRnbC5jb3B5VGV4SW1hZ2UyRCggZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCLCBzY3JlZW5Qb3NpdGlvblBpeGVscy54LCBzY3JlZW5Qb3NpdGlvblBpeGVscy55LCAxNiwgMTYsIDAgKTtcblxuXG4gICAgXHRcdFx0XHQvLyByZW5kZXIgcGluayBxdWFkXG5cbiAgICBcdFx0XHRcdGdsLnVuaWZvcm0xaSggdW5pZm9ybXMucmVuZGVyVHlwZSwgMCApO1xuICAgIFx0XHRcdFx0Z2wudW5pZm9ybTJmKCB1bmlmb3Jtcy5zY2FsZSwgc2NhbGUueCwgc2NhbGUueSApO1xuICAgIFx0XHRcdFx0Z2wudW5pZm9ybTNmKCB1bmlmb3Jtcy5zY3JlZW5Qb3NpdGlvbiwgc2NyZWVuUG9zaXRpb24ueCwgc2NyZWVuUG9zaXRpb24ueSwgc2NyZWVuUG9zaXRpb24ueiApO1xuXG4gICAgXHRcdFx0XHRzdGF0ZS5kaXNhYmxlKCBnbC5CTEVORCApO1xuICAgIFx0XHRcdFx0c3RhdGUuZW5hYmxlKCBnbC5ERVBUSF9URVNUICk7XG5cbiAgICBcdFx0XHRcdGdsLmRyYXdFbGVtZW50cyggZ2wuVFJJQU5HTEVTLCA2LCBnbC5VTlNJR05FRF9TSE9SVCwgMCApO1xuXG5cbiAgICBcdFx0XHRcdC8vIGNvcHkgcmVzdWx0IHRvIG9jY2x1c2lvbk1hcFxuXG4gICAgXHRcdFx0XHRzdGF0ZS5hY3RpdmVUZXh0dXJlKCBnbC5URVhUVVJFMCApO1xuICAgIFx0XHRcdFx0c3RhdGUuYmluZFRleHR1cmUoIGdsLlRFWFRVUkVfMkQsIG9jY2x1c2lvblRleHR1cmUgKTtcbiAgICBcdFx0XHRcdGdsLmNvcHlUZXhJbWFnZTJEKCBnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBzY3JlZW5Qb3NpdGlvblBpeGVscy54LCBzY3JlZW5Qb3NpdGlvblBpeGVscy55LCAxNiwgMTYsIDAgKTtcblxuXG4gICAgXHRcdFx0XHQvLyByZXN0b3JlIGdyYXBoaWNzXG5cbiAgICBcdFx0XHRcdGdsLnVuaWZvcm0xaSggdW5pZm9ybXMucmVuZGVyVHlwZSwgMSApO1xuICAgIFx0XHRcdFx0c3RhdGUuZGlzYWJsZSggZ2wuREVQVEhfVEVTVCApO1xuXG4gICAgXHRcdFx0XHRzdGF0ZS5hY3RpdmVUZXh0dXJlKCBnbC5URVhUVVJFMSApO1xuICAgIFx0XHRcdFx0c3RhdGUuYmluZFRleHR1cmUoIGdsLlRFWFRVUkVfMkQsIHRlbXBUZXh0dXJlICk7XG4gICAgXHRcdFx0XHRnbC5kcmF3RWxlbWVudHMoIGdsLlRSSUFOR0xFUywgNiwgZ2wuVU5TSUdORURfU0hPUlQsIDAgKTtcblxuXG4gICAgXHRcdFx0XHQvLyB1cGRhdGUgb2JqZWN0IHBvc2l0aW9uc1xuXG4gICAgXHRcdFx0XHRmbGFyZS5wb3NpdGlvblNjcmVlbi5jb3B5KCBzY3JlZW5Qb3NpdGlvbiApO1xuXG4gICAgXHRcdFx0XHRpZiAoIGZsYXJlLmN1c3RvbVVwZGF0ZUNhbGxiYWNrICkge1xuXG4gICAgXHRcdFx0XHRcdGZsYXJlLmN1c3RvbVVwZGF0ZUNhbGxiYWNrKCBmbGFyZSApO1xuXG4gICAgXHRcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHRcdGZsYXJlLnVwZGF0ZUxlbnNGbGFyZXMoKTtcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHQvLyByZW5kZXIgZmxhcmVzXG5cbiAgICBcdFx0XHRcdGdsLnVuaWZvcm0xaSggdW5pZm9ybXMucmVuZGVyVHlwZSwgMiApO1xuICAgIFx0XHRcdFx0c3RhdGUuZW5hYmxlKCBnbC5CTEVORCApO1xuXG4gICAgXHRcdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gZmxhcmUubGVuc0ZsYXJlcy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuICAgIFx0XHRcdFx0XHR2YXIgc3ByaXRlID0gZmxhcmUubGVuc0ZsYXJlc1sgaiBdO1xuXG4gICAgXHRcdFx0XHRcdGlmICggc3ByaXRlLm9wYWNpdHkgPiAwLjAwMSAmJiBzcHJpdGUuc2NhbGUgPiAwLjAwMSApIHtcblxuICAgIFx0XHRcdFx0XHRcdHNjcmVlblBvc2l0aW9uLnggPSBzcHJpdGUueDtcbiAgICBcdFx0XHRcdFx0XHRzY3JlZW5Qb3NpdGlvbi55ID0gc3ByaXRlLnk7XG4gICAgXHRcdFx0XHRcdFx0c2NyZWVuUG9zaXRpb24ueiA9IHNwcml0ZS56O1xuXG4gICAgXHRcdFx0XHRcdFx0c2l6ZSA9IHNwcml0ZS5zaXplICogc3ByaXRlLnNjYWxlIC8gdmlld3BvcnQudztcblxuICAgIFx0XHRcdFx0XHRcdHNjYWxlLnggPSBzaXplICogaW52QXNwZWN0O1xuICAgIFx0XHRcdFx0XHRcdHNjYWxlLnkgPSBzaXplO1xuXG4gICAgXHRcdFx0XHRcdFx0Z2wudW5pZm9ybTNmKCB1bmlmb3Jtcy5zY3JlZW5Qb3NpdGlvbiwgc2NyZWVuUG9zaXRpb24ueCwgc2NyZWVuUG9zaXRpb24ueSwgc2NyZWVuUG9zaXRpb24ueiApO1xuICAgIFx0XHRcdFx0XHRcdGdsLnVuaWZvcm0yZiggdW5pZm9ybXMuc2NhbGUsIHNjYWxlLngsIHNjYWxlLnkgKTtcbiAgICBcdFx0XHRcdFx0XHRnbC51bmlmb3JtMWYoIHVuaWZvcm1zLnJvdGF0aW9uLCBzcHJpdGUucm90YXRpb24gKTtcblxuICAgIFx0XHRcdFx0XHRcdGdsLnVuaWZvcm0xZiggdW5pZm9ybXMub3BhY2l0eSwgc3ByaXRlLm9wYWNpdHkgKTtcbiAgICBcdFx0XHRcdFx0XHRnbC51bmlmb3JtM2YoIHVuaWZvcm1zLmNvbG9yLCBzcHJpdGUuY29sb3Iuciwgc3ByaXRlLmNvbG9yLmcsIHNwcml0ZS5jb2xvci5iICk7XG5cbiAgICBcdFx0XHRcdFx0XHRzdGF0ZS5zZXRCbGVuZGluZyggc3ByaXRlLmJsZW5kaW5nLCBzcHJpdGUuYmxlbmRFcXVhdGlvbiwgc3ByaXRlLmJsZW5kU3JjLCBzcHJpdGUuYmxlbmREc3QgKTtcbiAgICBcdFx0XHRcdFx0XHRyZW5kZXJlci5zZXRUZXh0dXJlMkQoIHNwcml0ZS50ZXh0dXJlLCAxICk7XG5cbiAgICBcdFx0XHRcdFx0XHRnbC5kcmF3RWxlbWVudHMoIGdsLlRSSUFOR0xFUywgNiwgZ2wuVU5TSUdORURfU0hPUlQsIDAgKTtcblxuICAgIFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdFx0Ly8gcmVzdG9yZSBnbFxuXG4gICAgXHRcdHN0YXRlLmVuYWJsZSggZ2wuQ1VMTF9GQUNFICk7XG4gICAgXHRcdHN0YXRlLmVuYWJsZSggZ2wuREVQVEhfVEVTVCApO1xuICAgIFx0XHRzdGF0ZS5zZXREZXB0aFdyaXRlKCB0cnVlICk7XG5cbiAgICBcdFx0cmVuZGVyZXIucmVzZXRHTFN0YXRlKCk7XG5cbiAgICBcdH07XG5cbiAgICBcdGZ1bmN0aW9uIGNyZWF0ZVByb2dyYW0oIHNoYWRlciApIHtcblxuICAgIFx0XHR2YXIgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcblxuICAgIFx0XHR2YXIgZnJhZ21lbnRTaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoIGdsLkZSQUdNRU5UX1NIQURFUiApO1xuICAgIFx0XHR2YXIgdmVydGV4U2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKCBnbC5WRVJURVhfU0hBREVSICk7XG5cbiAgICBcdFx0dmFyIHByZWZpeCA9IFwicHJlY2lzaW9uIFwiICsgcmVuZGVyZXIuZ2V0UHJlY2lzaW9uKCkgKyBcIiBmbG9hdDtcXG5cIjtcblxuICAgIFx0XHRnbC5zaGFkZXJTb3VyY2UoIGZyYWdtZW50U2hhZGVyLCBwcmVmaXggKyBzaGFkZXIuZnJhZ21lbnRTaGFkZXIgKTtcbiAgICBcdFx0Z2wuc2hhZGVyU291cmNlKCB2ZXJ0ZXhTaGFkZXIsIHByZWZpeCArIHNoYWRlci52ZXJ0ZXhTaGFkZXIgKTtcblxuICAgIFx0XHRnbC5jb21waWxlU2hhZGVyKCBmcmFnbWVudFNoYWRlciApO1xuICAgIFx0XHRnbC5jb21waWxlU2hhZGVyKCB2ZXJ0ZXhTaGFkZXIgKTtcblxuICAgIFx0XHRnbC5hdHRhY2hTaGFkZXIoIHByb2dyYW0sIGZyYWdtZW50U2hhZGVyICk7XG4gICAgXHRcdGdsLmF0dGFjaFNoYWRlciggcHJvZ3JhbSwgdmVydGV4U2hhZGVyICk7XG5cbiAgICBcdFx0Z2wubGlua1Byb2dyYW0oIHByb2dyYW0gKTtcblxuICAgIFx0XHRyZXR1cm4gcHJvZ3JhbTtcblxuICAgIFx0fVxuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAgICAgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gU3ByaXRlUGx1Z2luKCByZW5kZXJlciwgc3ByaXRlcyApIHtcblxuICAgIFx0dmFyIGdsID0gcmVuZGVyZXIuY29udGV4dDtcbiAgICBcdHZhciBzdGF0ZSA9IHJlbmRlcmVyLnN0YXRlO1xuXG4gICAgXHR2YXIgdmVydGV4QnVmZmVyLCBlbGVtZW50QnVmZmVyO1xuICAgIFx0dmFyIHByb2dyYW0sIGF0dHJpYnV0ZXMsIHVuaWZvcm1zO1xuXG4gICAgXHR2YXIgdGV4dHVyZTtcblxuICAgIFx0Ly8gZGVjb21wb3NlIG1hdHJpeFdvcmxkXG5cbiAgICBcdHZhciBzcHJpdGVQb3NpdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG4gICAgXHR2YXIgc3ByaXRlUm90YXRpb24gPSBuZXcgUXVhdGVybmlvbigpO1xuICAgIFx0dmFyIHNwcml0ZVNjYWxlID0gbmV3IFZlY3RvcjMoKTtcblxuICAgIFx0ZnVuY3Rpb24gaW5pdCgpIHtcblxuICAgIFx0XHR2YXIgdmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KCBbXG4gICAgXHRcdFx0LSAwLjUsIC0gMC41LCAgMCwgMCxcbiAgICBcdFx0XHQgIDAuNSwgLSAwLjUsICAxLCAwLFxuICAgIFx0XHRcdCAgMC41LCAgIDAuNSwgIDEsIDEsXG4gICAgXHRcdFx0LSAwLjUsICAgMC41LCAgMCwgMVxuICAgIFx0XHRdICk7XG5cbiAgICBcdFx0dmFyIGZhY2VzID0gbmV3IFVpbnQxNkFycmF5KCBbXG4gICAgXHRcdFx0MCwgMSwgMixcbiAgICBcdFx0XHQwLCAyLCAzXG4gICAgXHRcdF0gKTtcblxuICAgIFx0XHR2ZXJ0ZXhCdWZmZXIgID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgXHRcdGVsZW1lbnRCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcblxuICAgIFx0XHRnbC5iaW5kQnVmZmVyKCBnbC5BUlJBWV9CVUZGRVIsIHZlcnRleEJ1ZmZlciApO1xuICAgIFx0XHRnbC5idWZmZXJEYXRhKCBnbC5BUlJBWV9CVUZGRVIsIHZlcnRpY2VzLCBnbC5TVEFUSUNfRFJBVyApO1xuXG4gICAgXHRcdGdsLmJpbmRCdWZmZXIoIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBlbGVtZW50QnVmZmVyICk7XG4gICAgXHRcdGdsLmJ1ZmZlckRhdGEoIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBmYWNlcywgZ2wuU1RBVElDX0RSQVcgKTtcblxuICAgIFx0XHRwcm9ncmFtID0gY3JlYXRlUHJvZ3JhbSgpO1xuXG4gICAgXHRcdGF0dHJpYnV0ZXMgPSB7XG4gICAgXHRcdFx0cG9zaXRpb246XHRcdFx0Z2wuZ2V0QXR0cmliTG9jYXRpb24gKCBwcm9ncmFtLCAncG9zaXRpb24nICksXG4gICAgXHRcdFx0dXY6XHRcdFx0XHRcdGdsLmdldEF0dHJpYkxvY2F0aW9uICggcHJvZ3JhbSwgJ3V2JyApXG4gICAgXHRcdH07XG5cbiAgICBcdFx0dW5pZm9ybXMgPSB7XG4gICAgXHRcdFx0dXZPZmZzZXQ6XHRcdFx0Z2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAndXZPZmZzZXQnICksXG4gICAgXHRcdFx0dXZTY2FsZTpcdFx0XHRnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICd1dlNjYWxlJyApLFxuXG4gICAgXHRcdFx0cm90YXRpb246XHRcdFx0Z2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAncm90YXRpb24nICksXG4gICAgXHRcdFx0c2NhbGU6XHRcdFx0XHRnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdzY2FsZScgKSxcblxuICAgIFx0XHRcdGNvbG9yOlx0XHRcdFx0Z2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnY29sb3InICksXG4gICAgXHRcdFx0bWFwOlx0XHRcdFx0Z2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnbWFwJyApLFxuICAgIFx0XHRcdG9wYWNpdHk6XHRcdFx0Z2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnb3BhY2l0eScgKSxcblxuICAgIFx0XHRcdG1vZGVsVmlld01hdHJpeDogXHRnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdtb2RlbFZpZXdNYXRyaXgnICksXG4gICAgXHRcdFx0cHJvamVjdGlvbk1hdHJpeDpcdGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ3Byb2plY3Rpb25NYXRyaXgnICksXG5cbiAgICBcdFx0XHRmb2dUeXBlOlx0XHRcdGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ2ZvZ1R5cGUnICksXG4gICAgXHRcdFx0Zm9nRGVuc2l0eTpcdFx0XHRnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdmb2dEZW5zaXR5JyApLFxuICAgIFx0XHRcdGZvZ05lYXI6XHRcdFx0Z2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnZm9nTmVhcicgKSxcbiAgICBcdFx0XHRmb2dGYXI6XHRcdFx0XHRnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdmb2dGYXInICksXG4gICAgXHRcdFx0Zm9nQ29sb3I6XHRcdFx0Z2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnZm9nQ29sb3InICksXG5cbiAgICBcdFx0XHRhbHBoYVRlc3Q6XHRcdFx0Z2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnYWxwaGFUZXN0JyApXG4gICAgXHRcdH07XG5cbiAgICBcdFx0dmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyggJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnLCAnY2FudmFzJyApO1xuICAgIFx0XHRjYW52YXMud2lkdGggPSA4O1xuICAgIFx0XHRjYW52YXMuaGVpZ2h0ID0gODtcblxuICAgIFx0XHR2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCAnMmQnICk7XG4gICAgXHRcdGNvbnRleHQuZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICBcdFx0Y29udGV4dC5maWxsUmVjdCggMCwgMCwgOCwgOCApO1xuXG4gICAgXHRcdHRleHR1cmUgPSBuZXcgVGV4dHVyZSggY2FudmFzICk7XG4gICAgXHRcdHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgXHR9XG5cbiAgICBcdHRoaXMucmVuZGVyID0gZnVuY3Rpb24gKCBzY2VuZSwgY2FtZXJhICkge1xuXG4gICAgXHRcdGlmICggc3ByaXRlcy5sZW5ndGggPT09IDAgKSByZXR1cm47XG5cbiAgICBcdFx0Ly8gc2V0dXAgZ2xcblxuICAgIFx0XHRpZiAoIHByb2dyYW0gPT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdGluaXQoKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0Z2wudXNlUHJvZ3JhbSggcHJvZ3JhbSApO1xuXG4gICAgXHRcdHN0YXRlLmluaXRBdHRyaWJ1dGVzKCk7XG4gICAgXHRcdHN0YXRlLmVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlcy5wb3NpdGlvbiApO1xuICAgIFx0XHRzdGF0ZS5lbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXMudXYgKTtcbiAgICBcdFx0c3RhdGUuZGlzYWJsZVVudXNlZEF0dHJpYnV0ZXMoKTtcblxuICAgIFx0XHRzdGF0ZS5kaXNhYmxlKCBnbC5DVUxMX0ZBQ0UgKTtcbiAgICBcdFx0c3RhdGUuZW5hYmxlKCBnbC5CTEVORCApO1xuXG4gICAgXHRcdGdsLmJpbmRCdWZmZXIoIGdsLkFSUkFZX0JVRkZFUiwgdmVydGV4QnVmZmVyICk7XG4gICAgXHRcdGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMucG9zaXRpb24sIDIsIGdsLkZMT0FULCBmYWxzZSwgMiAqIDgsIDAgKTtcbiAgICBcdFx0Z2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy51diwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAyICogOCwgOCApO1xuXG4gICAgXHRcdGdsLmJpbmRCdWZmZXIoIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBlbGVtZW50QnVmZmVyICk7XG5cbiAgICBcdFx0Z2wudW5pZm9ybU1hdHJpeDRmdiggdW5pZm9ybXMucHJvamVjdGlvbk1hdHJpeCwgZmFsc2UsIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4LmVsZW1lbnRzICk7XG5cbiAgICBcdFx0c3RhdGUuYWN0aXZlVGV4dHVyZSggZ2wuVEVYVFVSRTAgKTtcbiAgICBcdFx0Z2wudW5pZm9ybTFpKCB1bmlmb3Jtcy5tYXAsIDAgKTtcblxuICAgIFx0XHR2YXIgb2xkRm9nVHlwZSA9IDA7XG4gICAgXHRcdHZhciBzY2VuZUZvZ1R5cGUgPSAwO1xuICAgIFx0XHR2YXIgZm9nID0gc2NlbmUuZm9nO1xuXG4gICAgXHRcdGlmICggZm9nICkge1xuXG4gICAgXHRcdFx0Z2wudW5pZm9ybTNmKCB1bmlmb3Jtcy5mb2dDb2xvciwgZm9nLmNvbG9yLnIsIGZvZy5jb2xvci5nLCBmb2cuY29sb3IuYiApO1xuXG4gICAgXHRcdFx0aWYgKCAoZm9nICYmIGZvZy5pc0ZvZykgKSB7XG5cbiAgICBcdFx0XHRcdGdsLnVuaWZvcm0xZiggdW5pZm9ybXMuZm9nTmVhciwgZm9nLm5lYXIgKTtcbiAgICBcdFx0XHRcdGdsLnVuaWZvcm0xZiggdW5pZm9ybXMuZm9nRmFyLCBmb2cuZmFyICk7XG5cbiAgICBcdFx0XHRcdGdsLnVuaWZvcm0xaSggdW5pZm9ybXMuZm9nVHlwZSwgMSApO1xuICAgIFx0XHRcdFx0b2xkRm9nVHlwZSA9IDE7XG4gICAgXHRcdFx0XHRzY2VuZUZvZ1R5cGUgPSAxO1xuXG4gICAgXHRcdFx0fSBlbHNlIGlmICggKGZvZyAmJiBmb2cuaXNGb2dFeHAyKSApIHtcblxuICAgIFx0XHRcdFx0Z2wudW5pZm9ybTFmKCB1bmlmb3Jtcy5mb2dEZW5zaXR5LCBmb2cuZGVuc2l0eSApO1xuXG4gICAgXHRcdFx0XHRnbC51bmlmb3JtMWkoIHVuaWZvcm1zLmZvZ1R5cGUsIDIgKTtcbiAgICBcdFx0XHRcdG9sZEZvZ1R5cGUgPSAyO1xuICAgIFx0XHRcdFx0c2NlbmVGb2dUeXBlID0gMjtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0Z2wudW5pZm9ybTFpKCB1bmlmb3Jtcy5mb2dUeXBlLCAwICk7XG4gICAgXHRcdFx0b2xkRm9nVHlwZSA9IDA7XG4gICAgXHRcdFx0c2NlbmVGb2dUeXBlID0gMDtcblxuICAgIFx0XHR9XG5cblxuICAgIFx0XHQvLyB1cGRhdGUgcG9zaXRpb25zIGFuZCBzb3J0XG5cbiAgICBcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gc3ByaXRlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgXHRcdFx0dmFyIHNwcml0ZSA9IHNwcml0ZXNbIGkgXTtcblxuICAgIFx0XHRcdHNwcml0ZS5tb2RlbFZpZXdNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSwgc3ByaXRlLm1hdHJpeFdvcmxkICk7XG4gICAgXHRcdFx0c3ByaXRlLnogPSAtIHNwcml0ZS5tb2RlbFZpZXdNYXRyaXguZWxlbWVudHNbIDE0IF07XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHNwcml0ZXMuc29ydCggcGFpbnRlclNvcnRTdGFibGUgKTtcblxuICAgIFx0XHQvLyByZW5kZXIgYWxsIHNwcml0ZXNcblxuICAgIFx0XHR2YXIgc2NhbGUgPSBbXTtcblxuICAgIFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBzcHJpdGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICBcdFx0XHR2YXIgc3ByaXRlID0gc3ByaXRlc1sgaSBdO1xuICAgIFx0XHRcdHZhciBtYXRlcmlhbCA9IHNwcml0ZS5tYXRlcmlhbDtcblxuICAgIFx0XHRcdGlmICggbWF0ZXJpYWwudmlzaWJsZSA9PT0gZmFsc2UgKSBjb250aW51ZTtcblxuICAgIFx0XHRcdGdsLnVuaWZvcm0xZiggdW5pZm9ybXMuYWxwaGFUZXN0LCBtYXRlcmlhbC5hbHBoYVRlc3QgKTtcbiAgICBcdFx0XHRnbC51bmlmb3JtTWF0cml4NGZ2KCB1bmlmb3Jtcy5tb2RlbFZpZXdNYXRyaXgsIGZhbHNlLCBzcHJpdGUubW9kZWxWaWV3TWF0cml4LmVsZW1lbnRzICk7XG5cbiAgICBcdFx0XHRzcHJpdGUubWF0cml4V29ybGQuZGVjb21wb3NlKCBzcHJpdGVQb3NpdGlvbiwgc3ByaXRlUm90YXRpb24sIHNwcml0ZVNjYWxlICk7XG5cbiAgICBcdFx0XHRzY2FsZVsgMCBdID0gc3ByaXRlU2NhbGUueDtcbiAgICBcdFx0XHRzY2FsZVsgMSBdID0gc3ByaXRlU2NhbGUueTtcblxuICAgIFx0XHRcdHZhciBmb2dUeXBlID0gMDtcblxuICAgIFx0XHRcdGlmICggc2NlbmUuZm9nICYmIG1hdGVyaWFsLmZvZyApIHtcblxuICAgIFx0XHRcdFx0Zm9nVHlwZSA9IHNjZW5lRm9nVHlwZTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdGlmICggb2xkRm9nVHlwZSAhPT0gZm9nVHlwZSApIHtcblxuICAgIFx0XHRcdFx0Z2wudW5pZm9ybTFpKCB1bmlmb3Jtcy5mb2dUeXBlLCBmb2dUeXBlICk7XG4gICAgXHRcdFx0XHRvbGRGb2dUeXBlID0gZm9nVHlwZTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdGlmICggbWF0ZXJpYWwubWFwICE9PSBudWxsICkge1xuXG4gICAgXHRcdFx0XHRnbC51bmlmb3JtMmYoIHVuaWZvcm1zLnV2T2Zmc2V0LCBtYXRlcmlhbC5tYXAub2Zmc2V0LngsIG1hdGVyaWFsLm1hcC5vZmZzZXQueSApO1xuICAgIFx0XHRcdFx0Z2wudW5pZm9ybTJmKCB1bmlmb3Jtcy51dlNjYWxlLCBtYXRlcmlhbC5tYXAucmVwZWF0LngsIG1hdGVyaWFsLm1hcC5yZXBlYXQueSApO1xuXG4gICAgXHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0Z2wudW5pZm9ybTJmKCB1bmlmb3Jtcy51dk9mZnNldCwgMCwgMCApO1xuICAgIFx0XHRcdFx0Z2wudW5pZm9ybTJmKCB1bmlmb3Jtcy51dlNjYWxlLCAxLCAxICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRnbC51bmlmb3JtMWYoIHVuaWZvcm1zLm9wYWNpdHksIG1hdGVyaWFsLm9wYWNpdHkgKTtcbiAgICBcdFx0XHRnbC51bmlmb3JtM2YoIHVuaWZvcm1zLmNvbG9yLCBtYXRlcmlhbC5jb2xvci5yLCBtYXRlcmlhbC5jb2xvci5nLCBtYXRlcmlhbC5jb2xvci5iICk7XG5cbiAgICBcdFx0XHRnbC51bmlmb3JtMWYoIHVuaWZvcm1zLnJvdGF0aW9uLCBtYXRlcmlhbC5yb3RhdGlvbiApO1xuICAgIFx0XHRcdGdsLnVuaWZvcm0yZnYoIHVuaWZvcm1zLnNjYWxlLCBzY2FsZSApO1xuXG4gICAgXHRcdFx0c3RhdGUuc2V0QmxlbmRpbmcoIG1hdGVyaWFsLmJsZW5kaW5nLCBtYXRlcmlhbC5ibGVuZEVxdWF0aW9uLCBtYXRlcmlhbC5ibGVuZFNyYywgbWF0ZXJpYWwuYmxlbmREc3QgKTtcbiAgICBcdFx0XHRzdGF0ZS5zZXREZXB0aFRlc3QoIG1hdGVyaWFsLmRlcHRoVGVzdCApO1xuICAgIFx0XHRcdHN0YXRlLnNldERlcHRoV3JpdGUoIG1hdGVyaWFsLmRlcHRoV3JpdGUgKTtcblxuICAgIFx0XHRcdGlmICggbWF0ZXJpYWwubWFwICkge1xuXG4gICAgXHRcdFx0XHRyZW5kZXJlci5zZXRUZXh0dXJlMkQoIG1hdGVyaWFsLm1hcCwgMCApO1xuXG4gICAgXHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0cmVuZGVyZXIuc2V0VGV4dHVyZTJEKCB0ZXh0dXJlLCAwICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRnbC5kcmF3RWxlbWVudHMoIGdsLlRSSUFOR0xFUywgNiwgZ2wuVU5TSUdORURfU0hPUlQsIDAgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0Ly8gcmVzdG9yZSBnbFxuXG4gICAgXHRcdHN0YXRlLmVuYWJsZSggZ2wuQ1VMTF9GQUNFICk7XG5cbiAgICBcdFx0cmVuZGVyZXIucmVzZXRHTFN0YXRlKCk7XG5cbiAgICBcdH07XG5cbiAgICBcdGZ1bmN0aW9uIGNyZWF0ZVByb2dyYW0oKSB7XG5cbiAgICBcdFx0dmFyIHByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XG5cbiAgICBcdFx0dmFyIHZlcnRleFNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlciggZ2wuVkVSVEVYX1NIQURFUiApO1xuICAgIFx0XHR2YXIgZnJhZ21lbnRTaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoIGdsLkZSQUdNRU5UX1NIQURFUiApO1xuXG4gICAgXHRcdGdsLnNoYWRlclNvdXJjZSggdmVydGV4U2hhZGVyLCBbXG5cbiAgICBcdFx0XHQncHJlY2lzaW9uICcgKyByZW5kZXJlci5nZXRQcmVjaXNpb24oKSArICcgZmxvYXQ7JyxcblxuICAgIFx0XHRcdCd1bmlmb3JtIG1hdDQgbW9kZWxWaWV3TWF0cml4OycsXG4gICAgXHRcdFx0J3VuaWZvcm0gbWF0NCBwcm9qZWN0aW9uTWF0cml4OycsXG4gICAgXHRcdFx0J3VuaWZvcm0gZmxvYXQgcm90YXRpb247JyxcbiAgICBcdFx0XHQndW5pZm9ybSB2ZWMyIHNjYWxlOycsXG4gICAgXHRcdFx0J3VuaWZvcm0gdmVjMiB1dk9mZnNldDsnLFxuICAgIFx0XHRcdCd1bmlmb3JtIHZlYzIgdXZTY2FsZTsnLFxuXG4gICAgXHRcdFx0J2F0dHJpYnV0ZSB2ZWMyIHBvc2l0aW9uOycsXG4gICAgXHRcdFx0J2F0dHJpYnV0ZSB2ZWMyIHV2OycsXG5cbiAgICBcdFx0XHQndmFyeWluZyB2ZWMyIHZVVjsnLFxuXG4gICAgXHRcdFx0J3ZvaWQgbWFpbigpIHsnLFxuXG4gICAgXHRcdFx0XHQndlVWID0gdXZPZmZzZXQgKyB1diAqIHV2U2NhbGU7JyxcblxuICAgIFx0XHRcdFx0J3ZlYzIgYWxpZ25lZFBvc2l0aW9uID0gcG9zaXRpb24gKiBzY2FsZTsnLFxuXG4gICAgXHRcdFx0XHQndmVjMiByb3RhdGVkUG9zaXRpb247JyxcbiAgICBcdFx0XHRcdCdyb3RhdGVkUG9zaXRpb24ueCA9IGNvcyggcm90YXRpb24gKSAqIGFsaWduZWRQb3NpdGlvbi54IC0gc2luKCByb3RhdGlvbiApICogYWxpZ25lZFBvc2l0aW9uLnk7JyxcbiAgICBcdFx0XHRcdCdyb3RhdGVkUG9zaXRpb24ueSA9IHNpbiggcm90YXRpb24gKSAqIGFsaWduZWRQb3NpdGlvbi54ICsgY29zKCByb3RhdGlvbiApICogYWxpZ25lZFBvc2l0aW9uLnk7JyxcblxuICAgIFx0XHRcdFx0J3ZlYzQgZmluYWxQb3NpdGlvbjsnLFxuXG4gICAgXHRcdFx0XHQnZmluYWxQb3NpdGlvbiA9IG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIDAuMCwgMC4wLCAwLjAsIDEuMCApOycsXG4gICAgXHRcdFx0XHQnZmluYWxQb3NpdGlvbi54eSArPSByb3RhdGVkUG9zaXRpb247JyxcbiAgICBcdFx0XHRcdCdmaW5hbFBvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIGZpbmFsUG9zaXRpb247JyxcblxuICAgIFx0XHRcdFx0J2dsX1Bvc2l0aW9uID0gZmluYWxQb3NpdGlvbjsnLFxuXG4gICAgXHRcdFx0J30nXG5cbiAgICBcdFx0XS5qb2luKCAnXFxuJyApICk7XG5cbiAgICBcdFx0Z2wuc2hhZGVyU291cmNlKCBmcmFnbWVudFNoYWRlciwgW1xuXG4gICAgXHRcdFx0J3ByZWNpc2lvbiAnICsgcmVuZGVyZXIuZ2V0UHJlY2lzaW9uKCkgKyAnIGZsb2F0OycsXG5cbiAgICBcdFx0XHQndW5pZm9ybSB2ZWMzIGNvbG9yOycsXG4gICAgXHRcdFx0J3VuaWZvcm0gc2FtcGxlcjJEIG1hcDsnLFxuICAgIFx0XHRcdCd1bmlmb3JtIGZsb2F0IG9wYWNpdHk7JyxcblxuICAgIFx0XHRcdCd1bmlmb3JtIGludCBmb2dUeXBlOycsXG4gICAgXHRcdFx0J3VuaWZvcm0gdmVjMyBmb2dDb2xvcjsnLFxuICAgIFx0XHRcdCd1bmlmb3JtIGZsb2F0IGZvZ0RlbnNpdHk7JyxcbiAgICBcdFx0XHQndW5pZm9ybSBmbG9hdCBmb2dOZWFyOycsXG4gICAgXHRcdFx0J3VuaWZvcm0gZmxvYXQgZm9nRmFyOycsXG4gICAgXHRcdFx0J3VuaWZvcm0gZmxvYXQgYWxwaGFUZXN0OycsXG5cbiAgICBcdFx0XHQndmFyeWluZyB2ZWMyIHZVVjsnLFxuXG4gICAgXHRcdFx0J3ZvaWQgbWFpbigpIHsnLFxuXG4gICAgXHRcdFx0XHQndmVjNCB0ZXh0dXJlID0gdGV4dHVyZTJEKCBtYXAsIHZVViApOycsXG5cbiAgICBcdFx0XHRcdCdpZiAoIHRleHR1cmUuYSA8IGFscGhhVGVzdCApIGRpc2NhcmQ7JyxcblxuICAgIFx0XHRcdFx0J2dsX0ZyYWdDb2xvciA9IHZlYzQoIGNvbG9yICogdGV4dHVyZS54eXosIHRleHR1cmUuYSAqIG9wYWNpdHkgKTsnLFxuXG4gICAgXHRcdFx0XHQnaWYgKCBmb2dUeXBlID4gMCApIHsnLFxuXG4gICAgXHRcdFx0XHRcdCdmbG9hdCBkZXB0aCA9IGdsX0ZyYWdDb29yZC56IC8gZ2xfRnJhZ0Nvb3JkLnc7JyxcbiAgICBcdFx0XHRcdFx0J2Zsb2F0IGZvZ0ZhY3RvciA9IDAuMDsnLFxuXG4gICAgXHRcdFx0XHRcdCdpZiAoIGZvZ1R5cGUgPT0gMSApIHsnLFxuXG4gICAgXHRcdFx0XHRcdFx0J2ZvZ0ZhY3RvciA9IHNtb290aHN0ZXAoIGZvZ05lYXIsIGZvZ0ZhciwgZGVwdGggKTsnLFxuXG4gICAgXHRcdFx0XHRcdCd9IGVsc2UgeycsXG5cbiAgICBcdFx0XHRcdFx0XHQnY29uc3QgZmxvYXQgTE9HMiA9IDEuNDQyNjk1OycsXG4gICAgXHRcdFx0XHRcdFx0J2ZvZ0ZhY3RvciA9IGV4cDIoIC0gZm9nRGVuc2l0eSAqIGZvZ0RlbnNpdHkgKiBkZXB0aCAqIGRlcHRoICogTE9HMiApOycsXG4gICAgXHRcdFx0XHRcdFx0J2ZvZ0ZhY3RvciA9IDEuMCAtIGNsYW1wKCBmb2dGYWN0b3IsIDAuMCwgMS4wICk7JyxcblxuICAgIFx0XHRcdFx0XHQnfScsXG5cbiAgICBcdFx0XHRcdFx0J2dsX0ZyYWdDb2xvciA9IG1peCggZ2xfRnJhZ0NvbG9yLCB2ZWM0KCBmb2dDb2xvciwgZ2xfRnJhZ0NvbG9yLncgKSwgZm9nRmFjdG9yICk7JyxcblxuICAgIFx0XHRcdFx0J30nLFxuXG4gICAgXHRcdFx0J30nXG5cbiAgICBcdFx0XS5qb2luKCAnXFxuJyApICk7XG5cbiAgICBcdFx0Z2wuY29tcGlsZVNoYWRlciggdmVydGV4U2hhZGVyICk7XG4gICAgXHRcdGdsLmNvbXBpbGVTaGFkZXIoIGZyYWdtZW50U2hhZGVyICk7XG5cbiAgICBcdFx0Z2wuYXR0YWNoU2hhZGVyKCBwcm9ncmFtLCB2ZXJ0ZXhTaGFkZXIgKTtcbiAgICBcdFx0Z2wuYXR0YWNoU2hhZGVyKCBwcm9ncmFtLCBmcmFnbWVudFNoYWRlciApO1xuXG4gICAgXHRcdGdsLmxpbmtQcm9ncmFtKCBwcm9ncmFtICk7XG5cbiAgICBcdFx0cmV0dXJuIHByb2dyYW07XG5cbiAgICBcdH1cblxuICAgIFx0ZnVuY3Rpb24gcGFpbnRlclNvcnRTdGFibGUoIGEsIGIgKSB7XG5cbiAgICBcdFx0aWYgKCBhLnJlbmRlck9yZGVyICE9PSBiLnJlbmRlck9yZGVyICkge1xuXG4gICAgXHRcdFx0cmV0dXJuIGEucmVuZGVyT3JkZXIgLSBiLnJlbmRlck9yZGVyO1xuXG4gICAgXHRcdH0gZWxzZSBpZiAoIGEueiAhPT0gYi56ICkge1xuXG4gICAgXHRcdFx0cmV0dXJuIGIueiAtIGEuejtcblxuICAgIFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0cmV0dXJuIGIuaWQgLSBhLmlkO1xuXG4gICAgXHRcdH1cblxuICAgIFx0fVxuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAgICAgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gTWF0ZXJpYWwoKSB7XG5cbiAgICBcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgJ2lkJywgeyB2YWx1ZTogTWF0ZXJpYWxJZENvdW50KCkgfSApO1xuXG4gICAgXHR0aGlzLnV1aWQgPSBleHBvcnRzLk1hdGguZ2VuZXJhdGVVVUlEKCk7XG5cbiAgICBcdHRoaXMubmFtZSA9ICcnO1xuICAgIFx0dGhpcy50eXBlID0gJ01hdGVyaWFsJztcblxuICAgIFx0dGhpcy5mb2cgPSB0cnVlO1xuICAgIFx0dGhpcy5saWdodHMgPSB0cnVlO1xuXG4gICAgXHR0aGlzLmJsZW5kaW5nID0gTm9ybWFsQmxlbmRpbmc7XG4gICAgXHR0aGlzLnNpZGUgPSBGcm9udFNpZGU7XG4gICAgXHR0aGlzLnNoYWRpbmcgPSBTbW9vdGhTaGFkaW5nOyAvLyBUSFJFRS5GbGF0U2hhZGluZywgVEhSRUUuU21vb3RoU2hhZGluZ1xuICAgIFx0dGhpcy52ZXJ0ZXhDb2xvcnMgPSBOb0NvbG9yczsgLy8gVEhSRUUuTm9Db2xvcnMsIFRIUkVFLlZlcnRleENvbG9ycywgVEhSRUUuRmFjZUNvbG9yc1xuXG4gICAgXHR0aGlzLm9wYWNpdHkgPSAxO1xuICAgIFx0dGhpcy50cmFuc3BhcmVudCA9IGZhbHNlO1xuXG4gICAgXHR0aGlzLmJsZW5kU3JjID0gU3JjQWxwaGFGYWN0b3I7XG4gICAgXHR0aGlzLmJsZW5kRHN0ID0gT25lTWludXNTcmNBbHBoYUZhY3RvcjtcbiAgICBcdHRoaXMuYmxlbmRFcXVhdGlvbiA9IEFkZEVxdWF0aW9uO1xuICAgIFx0dGhpcy5ibGVuZFNyY0FscGhhID0gbnVsbDtcbiAgICBcdHRoaXMuYmxlbmREc3RBbHBoYSA9IG51bGw7XG4gICAgXHR0aGlzLmJsZW5kRXF1YXRpb25BbHBoYSA9IG51bGw7XG5cbiAgICBcdHRoaXMuZGVwdGhGdW5jID0gTGVzc0VxdWFsRGVwdGg7XG4gICAgXHR0aGlzLmRlcHRoVGVzdCA9IHRydWU7XG4gICAgXHR0aGlzLmRlcHRoV3JpdGUgPSB0cnVlO1xuXG4gICAgXHR0aGlzLmNsaXBwaW5nUGxhbmVzID0gbnVsbDtcbiAgICBcdHRoaXMuY2xpcFNoYWRvd3MgPSBmYWxzZTtcblxuICAgIFx0dGhpcy5jb2xvcldyaXRlID0gdHJ1ZTtcblxuICAgIFx0dGhpcy5wcmVjaXNpb24gPSBudWxsOyAvLyBvdmVycmlkZSB0aGUgcmVuZGVyZXIncyBkZWZhdWx0IHByZWNpc2lvbiBmb3IgdGhpcyBtYXRlcmlhbFxuXG4gICAgXHR0aGlzLnBvbHlnb25PZmZzZXQgPSBmYWxzZTtcbiAgICBcdHRoaXMucG9seWdvbk9mZnNldEZhY3RvciA9IDA7XG4gICAgXHR0aGlzLnBvbHlnb25PZmZzZXRVbml0cyA9IDA7XG5cbiAgICBcdHRoaXMuYWxwaGFUZXN0ID0gMDtcbiAgICBcdHRoaXMucHJlbXVsdGlwbGllZEFscGhhID0gZmFsc2U7XG5cbiAgICBcdHRoaXMub3ZlcmRyYXcgPSAwOyAvLyBPdmVyZHJhd24gcGl4ZWxzICh0eXBpY2FsbHkgYmV0d2VlbiAwIGFuZCAxKSBmb3IgZml4aW5nIGFudGlhbGlhc2luZyBnYXBzIGluIENhbnZhc1JlbmRlcmVyXG5cbiAgICBcdHRoaXMudmlzaWJsZSA9IHRydWU7XG5cbiAgICBcdHRoaXMuX25lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgIH1cblxuICAgIE1hdGVyaWFsLnByb3RvdHlwZSA9IHtcblxuICAgIFx0Y29uc3RydWN0b3I6IE1hdGVyaWFsLFxuXG4gICAgXHRpc01hdGVyaWFsOiB0cnVlLFxuXG4gICAgXHRnZXQgbmVlZHNVcGRhdGUoKSB7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMuX25lZWRzVXBkYXRlO1xuXG4gICAgXHR9LFxuXG4gICAgXHRzZXQgbmVlZHNVcGRhdGUoIHZhbHVlICkge1xuXG4gICAgXHRcdGlmICggdmFsdWUgPT09IHRydWUgKSB0aGlzLnVwZGF0ZSgpO1xuICAgIFx0XHR0aGlzLl9uZWVkc1VwZGF0ZSA9IHZhbHVlO1xuXG4gICAgXHR9LFxuXG4gICAgXHRzZXRWYWx1ZXM6IGZ1bmN0aW9uICggdmFsdWVzICkge1xuXG4gICAgXHRcdGlmICggdmFsdWVzID09PSB1bmRlZmluZWQgKSByZXR1cm47XG5cbiAgICBcdFx0Zm9yICggdmFyIGtleSBpbiB2YWx1ZXMgKSB7XG5cbiAgICBcdFx0XHR2YXIgbmV3VmFsdWUgPSB2YWx1ZXNbIGtleSBdO1xuXG4gICAgXHRcdFx0aWYgKCBuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0XHRjb25zb2xlLndhcm4oIFwiVEhSRUUuTWF0ZXJpYWw6ICdcIiArIGtleSArIFwiJyBwYXJhbWV0ZXIgaXMgdW5kZWZpbmVkLlwiICk7XG4gICAgXHRcdFx0XHRjb250aW51ZTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdHZhciBjdXJyZW50VmFsdWUgPSB0aGlzWyBrZXkgXTtcblxuICAgIFx0XHRcdGlmICggY3VycmVudFZhbHVlID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRcdGNvbnNvbGUud2FybiggXCJUSFJFRS5cIiArIHRoaXMudHlwZSArIFwiOiAnXCIgKyBrZXkgKyBcIicgaXMgbm90IGEgcHJvcGVydHkgb2YgdGhpcyBtYXRlcmlhbC5cIiApO1xuICAgIFx0XHRcdFx0Y29udGludWU7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRpZiAoIChjdXJyZW50VmFsdWUgJiYgY3VycmVudFZhbHVlLmlzQ29sb3IpICkge1xuXG4gICAgXHRcdFx0XHRjdXJyZW50VmFsdWUuc2V0KCBuZXdWYWx1ZSApO1xuXG4gICAgXHRcdFx0fSBlbHNlIGlmICggKGN1cnJlbnRWYWx1ZSAmJiBjdXJyZW50VmFsdWUuaXNWZWN0b3IzKSAmJiAobmV3VmFsdWUgJiYgbmV3VmFsdWUuaXNWZWN0b3IzKSApIHtcblxuICAgIFx0XHRcdFx0Y3VycmVudFZhbHVlLmNvcHkoIG5ld1ZhbHVlICk7XG5cbiAgICBcdFx0XHR9IGVsc2UgaWYgKCBrZXkgPT09ICdvdmVyZHJhdycgKSB7XG5cbiAgICBcdFx0XHRcdC8vIGVuc3VyZSBvdmVyZHJhdyBpcyBiYWNrd2FyZHMtY29tcGF0aWJsZSB3aXRoIGxlZ2FjeSBib29sZWFuIHR5cGVcbiAgICBcdFx0XHRcdHRoaXNbIGtleSBdID0gTnVtYmVyKCBuZXdWYWx1ZSApO1xuXG4gICAgXHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0dGhpc1sga2V5IF0gPSBuZXdWYWx1ZTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdH0sXG5cbiAgICBcdHRvSlNPTjogZnVuY3Rpb24gKCBtZXRhICkge1xuXG4gICAgXHRcdHZhciBpc1Jvb3QgPSBtZXRhID09PSB1bmRlZmluZWQ7XG5cbiAgICBcdFx0aWYgKCBpc1Jvb3QgKSB7XG5cbiAgICBcdFx0XHRtZXRhID0ge1xuICAgIFx0XHRcdFx0dGV4dHVyZXM6IHt9LFxuICAgIFx0XHRcdFx0aW1hZ2VzOiB7fVxuICAgIFx0XHRcdH07XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHZhciBkYXRhID0ge1xuICAgIFx0XHRcdG1ldGFkYXRhOiB7XG4gICAgXHRcdFx0XHR2ZXJzaW9uOiA0LjQsXG4gICAgXHRcdFx0XHR0eXBlOiAnTWF0ZXJpYWwnLFxuICAgIFx0XHRcdFx0Z2VuZXJhdG9yOiAnTWF0ZXJpYWwudG9KU09OJ1xuICAgIFx0XHRcdH1cbiAgICBcdFx0fTtcblxuICAgIFx0XHQvLyBzdGFuZGFyZCBNYXRlcmlhbCBzZXJpYWxpemF0aW9uXG4gICAgXHRcdGRhdGEudXVpZCA9IHRoaXMudXVpZDtcbiAgICBcdFx0ZGF0YS50eXBlID0gdGhpcy50eXBlO1xuXG4gICAgXHRcdGlmICggdGhpcy5uYW1lICE9PSAnJyApIGRhdGEubmFtZSA9IHRoaXMubmFtZTtcblxuICAgIFx0XHRpZiAoICh0aGlzLmNvbG9yICYmIHRoaXMuY29sb3IuaXNDb2xvcikgKSBkYXRhLmNvbG9yID0gdGhpcy5jb2xvci5nZXRIZXgoKTtcblxuICAgIFx0XHRpZiAoIHRoaXMucm91Z2huZXNzICE9PSB1bmRlZmluZWQgKSBkYXRhLnJvdWdobmVzcyA9IHRoaXMucm91Z2huZXNzO1xuICAgIFx0XHRpZiAoIHRoaXMubWV0YWxuZXNzICE9PSB1bmRlZmluZWQgKSBkYXRhLm1ldGFsbmVzcyA9IHRoaXMubWV0YWxuZXNzO1xuXG4gICAgXHRcdGlmICggKHRoaXMuZW1pc3NpdmUgJiYgdGhpcy5lbWlzc2l2ZS5pc0NvbG9yKSApIGRhdGEuZW1pc3NpdmUgPSB0aGlzLmVtaXNzaXZlLmdldEhleCgpO1xuICAgIFx0XHRpZiAoICh0aGlzLnNwZWN1bGFyICYmIHRoaXMuc3BlY3VsYXIuaXNDb2xvcikgKSBkYXRhLnNwZWN1bGFyID0gdGhpcy5zcGVjdWxhci5nZXRIZXgoKTtcbiAgICBcdFx0aWYgKCB0aGlzLnNoaW5pbmVzcyAhPT0gdW5kZWZpbmVkICkgZGF0YS5zaGluaW5lc3MgPSB0aGlzLnNoaW5pbmVzcztcblxuICAgIFx0XHRpZiAoICh0aGlzLm1hcCAmJiB0aGlzLm1hcC5pc1RleHR1cmUpICkgZGF0YS5tYXAgPSB0aGlzLm1hcC50b0pTT04oIG1ldGEgKS51dWlkO1xuICAgIFx0XHRpZiAoICh0aGlzLmFscGhhTWFwICYmIHRoaXMuYWxwaGFNYXAuaXNUZXh0dXJlKSApIGRhdGEuYWxwaGFNYXAgPSB0aGlzLmFscGhhTWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XG4gICAgXHRcdGlmICggKHRoaXMubGlnaHRNYXAgJiYgdGhpcy5saWdodE1hcC5pc1RleHR1cmUpICkgZGF0YS5saWdodE1hcCA9IHRoaXMubGlnaHRNYXAudG9KU09OKCBtZXRhICkudXVpZDtcbiAgICBcdFx0aWYgKCAodGhpcy5idW1wTWFwICYmIHRoaXMuYnVtcE1hcC5pc1RleHR1cmUpICkge1xuXG4gICAgXHRcdFx0ZGF0YS5idW1wTWFwID0gdGhpcy5idW1wTWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XG4gICAgXHRcdFx0ZGF0YS5idW1wU2NhbGUgPSB0aGlzLmJ1bXBTY2FsZTtcblxuICAgIFx0XHR9XG4gICAgXHRcdGlmICggKHRoaXMubm9ybWFsTWFwICYmIHRoaXMubm9ybWFsTWFwLmlzVGV4dHVyZSkgKSB7XG5cbiAgICBcdFx0XHRkYXRhLm5vcm1hbE1hcCA9IHRoaXMubm9ybWFsTWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XG4gICAgXHRcdFx0ZGF0YS5ub3JtYWxTY2FsZSA9IHRoaXMubm9ybWFsU2NhbGUudG9BcnJheSgpO1xuXG4gICAgXHRcdH1cbiAgICBcdFx0aWYgKCAodGhpcy5kaXNwbGFjZW1lbnRNYXAgJiYgdGhpcy5kaXNwbGFjZW1lbnRNYXAuaXNUZXh0dXJlKSApIHtcblxuICAgIFx0XHRcdGRhdGEuZGlzcGxhY2VtZW50TWFwID0gdGhpcy5kaXNwbGFjZW1lbnRNYXAudG9KU09OKCBtZXRhICkudXVpZDtcbiAgICBcdFx0XHRkYXRhLmRpc3BsYWNlbWVudFNjYWxlID0gdGhpcy5kaXNwbGFjZW1lbnRTY2FsZTtcbiAgICBcdFx0XHRkYXRhLmRpc3BsYWNlbWVudEJpYXMgPSB0aGlzLmRpc3BsYWNlbWVudEJpYXM7XG5cbiAgICBcdFx0fVxuICAgIFx0XHRpZiAoICh0aGlzLnJvdWdobmVzc01hcCAmJiB0aGlzLnJvdWdobmVzc01hcC5pc1RleHR1cmUpICkgZGF0YS5yb3VnaG5lc3NNYXAgPSB0aGlzLnJvdWdobmVzc01hcC50b0pTT04oIG1ldGEgKS51dWlkO1xuICAgIFx0XHRpZiAoICh0aGlzLm1ldGFsbmVzc01hcCAmJiB0aGlzLm1ldGFsbmVzc01hcC5pc1RleHR1cmUpICkgZGF0YS5tZXRhbG5lc3NNYXAgPSB0aGlzLm1ldGFsbmVzc01hcC50b0pTT04oIG1ldGEgKS51dWlkO1xuXG4gICAgXHRcdGlmICggKHRoaXMuZW1pc3NpdmVNYXAgJiYgdGhpcy5lbWlzc2l2ZU1hcC5pc1RleHR1cmUpICkgZGF0YS5lbWlzc2l2ZU1hcCA9IHRoaXMuZW1pc3NpdmVNYXAudG9KU09OKCBtZXRhICkudXVpZDtcbiAgICBcdFx0aWYgKCAodGhpcy5zcGVjdWxhck1hcCAmJiB0aGlzLnNwZWN1bGFyTWFwLmlzVGV4dHVyZSkgKSBkYXRhLnNwZWN1bGFyTWFwID0gdGhpcy5zcGVjdWxhck1hcC50b0pTT04oIG1ldGEgKS51dWlkO1xuXG4gICAgXHRcdGlmICggKHRoaXMuZW52TWFwICYmIHRoaXMuZW52TWFwLmlzVGV4dHVyZSkgKSB7XG5cbiAgICBcdFx0XHRkYXRhLmVudk1hcCA9IHRoaXMuZW52TWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XG4gICAgXHRcdFx0ZGF0YS5yZWZsZWN0aXZpdHkgPSB0aGlzLnJlZmxlY3Rpdml0eTsgLy8gU2NhbGUgYmVoaW5kIGVudk1hcFxuXG4gICAgXHRcdH1cblxuICAgIFx0XHRpZiAoIHRoaXMuc2l6ZSAhPT0gdW5kZWZpbmVkICkgZGF0YS5zaXplID0gdGhpcy5zaXplO1xuICAgIFx0XHRpZiAoIHRoaXMuc2l6ZUF0dGVudWF0aW9uICE9PSB1bmRlZmluZWQgKSBkYXRhLnNpemVBdHRlbnVhdGlvbiA9IHRoaXMuc2l6ZUF0dGVudWF0aW9uO1xuXG4gICAgXHRcdGlmICggdGhpcy5ibGVuZGluZyAhPT0gTm9ybWFsQmxlbmRpbmcgKSBkYXRhLmJsZW5kaW5nID0gdGhpcy5ibGVuZGluZztcbiAgICBcdFx0aWYgKCB0aGlzLnNoYWRpbmcgIT09IFNtb290aFNoYWRpbmcgKSBkYXRhLnNoYWRpbmcgPSB0aGlzLnNoYWRpbmc7XG4gICAgXHRcdGlmICggdGhpcy5zaWRlICE9PSBGcm9udFNpZGUgKSBkYXRhLnNpZGUgPSB0aGlzLnNpZGU7XG4gICAgXHRcdGlmICggdGhpcy52ZXJ0ZXhDb2xvcnMgIT09IE5vQ29sb3JzICkgZGF0YS52ZXJ0ZXhDb2xvcnMgPSB0aGlzLnZlcnRleENvbG9ycztcblxuICAgIFx0XHRpZiAoIHRoaXMub3BhY2l0eSA8IDEgKSBkYXRhLm9wYWNpdHkgPSB0aGlzLm9wYWNpdHk7XG4gICAgXHRcdGlmICggdGhpcy50cmFuc3BhcmVudCA9PT0gdHJ1ZSApIGRhdGEudHJhbnNwYXJlbnQgPSB0aGlzLnRyYW5zcGFyZW50O1xuXG4gICAgXHRcdGRhdGEuZGVwdGhGdW5jID0gdGhpcy5kZXB0aEZ1bmM7XG4gICAgXHRcdGRhdGEuZGVwdGhUZXN0ID0gdGhpcy5kZXB0aFRlc3Q7XG4gICAgXHRcdGRhdGEuZGVwdGhXcml0ZSA9IHRoaXMuZGVwdGhXcml0ZTtcblxuICAgIFx0XHRpZiAoIHRoaXMuYWxwaGFUZXN0ID4gMCApIGRhdGEuYWxwaGFUZXN0ID0gdGhpcy5hbHBoYVRlc3Q7XG4gICAgXHRcdGlmICggdGhpcy5wcmVtdWx0aXBsaWVkQWxwaGEgPT09IHRydWUgKSBkYXRhLnByZW11bHRpcGxpZWRBbHBoYSA9IHRoaXMucHJlbXVsdGlwbGllZEFscGhhO1xuICAgIFx0XHRpZiAoIHRoaXMud2lyZWZyYW1lID09PSB0cnVlICkgZGF0YS53aXJlZnJhbWUgPSB0aGlzLndpcmVmcmFtZTtcbiAgICBcdFx0aWYgKCB0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA+IDEgKSBkYXRhLndpcmVmcmFtZUxpbmV3aWR0aCA9IHRoaXMud2lyZWZyYW1lTGluZXdpZHRoO1xuICAgIFx0XHRpZiAoIHRoaXMud2lyZWZyYW1lTGluZWNhcCAhPT0gJ3JvdW5kJyApIGRhdGEud2lyZWZyYW1lTGluZWNhcCA9IHRoaXMud2lyZWZyYW1lTGluZWNhcDtcbiAgICBcdFx0aWYgKCB0aGlzLndpcmVmcmFtZUxpbmVqb2luICE9PSAncm91bmQnICkgZGF0YS53aXJlZnJhbWVMaW5lam9pbiA9IHRoaXMud2lyZWZyYW1lTGluZWpvaW47XG5cbiAgICBcdFx0ZGF0YS5za2lubmluZyA9IHRoaXMuc2tpbm5pbmc7XG4gICAgXHRcdGRhdGEubW9ycGhUYXJnZXRzID0gdGhpcy5tb3JwaFRhcmdldHM7XG5cbiAgICBcdFx0Ly8gVE9ETzogQ29waWVkIGZyb20gT2JqZWN0M0QudG9KU09OXG5cbiAgICBcdFx0ZnVuY3Rpb24gZXh0cmFjdEZyb21DYWNoZSggY2FjaGUgKSB7XG5cbiAgICBcdFx0XHR2YXIgdmFsdWVzID0gW107XG5cbiAgICBcdFx0XHRmb3IgKCB2YXIga2V5IGluIGNhY2hlICkge1xuXG4gICAgXHRcdFx0XHR2YXIgZGF0YSA9IGNhY2hlWyBrZXkgXTtcbiAgICBcdFx0XHRcdGRlbGV0ZSBkYXRhLm1ldGFkYXRhO1xuICAgIFx0XHRcdFx0dmFsdWVzLnB1c2goIGRhdGEgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdHJldHVybiB2YWx1ZXM7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGlmICggaXNSb290ICkge1xuXG4gICAgXHRcdFx0dmFyIHRleHR1cmVzID0gZXh0cmFjdEZyb21DYWNoZSggbWV0YS50ZXh0dXJlcyApO1xuICAgIFx0XHRcdHZhciBpbWFnZXMgPSBleHRyYWN0RnJvbUNhY2hlKCBtZXRhLmltYWdlcyApO1xuXG4gICAgXHRcdFx0aWYgKCB0ZXh0dXJlcy5sZW5ndGggPiAwICkgZGF0YS50ZXh0dXJlcyA9IHRleHR1cmVzO1xuICAgIFx0XHRcdGlmICggaW1hZ2VzLmxlbmd0aCA+IDAgKSBkYXRhLmltYWdlcyA9IGltYWdlcztcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIGRhdGE7XG5cbiAgICBcdH0sXG5cbiAgICBcdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuICAgIFx0XHR0aGlzLm5hbWUgPSBzb3VyY2UubmFtZTtcblxuICAgIFx0XHR0aGlzLmZvZyA9IHNvdXJjZS5mb2c7XG4gICAgXHRcdHRoaXMubGlnaHRzID0gc291cmNlLmxpZ2h0cztcblxuICAgIFx0XHR0aGlzLmJsZW5kaW5nID0gc291cmNlLmJsZW5kaW5nO1xuICAgIFx0XHR0aGlzLnNpZGUgPSBzb3VyY2Uuc2lkZTtcbiAgICBcdFx0dGhpcy5zaGFkaW5nID0gc291cmNlLnNoYWRpbmc7XG4gICAgXHRcdHRoaXMudmVydGV4Q29sb3JzID0gc291cmNlLnZlcnRleENvbG9ycztcblxuICAgIFx0XHR0aGlzLm9wYWNpdHkgPSBzb3VyY2Uub3BhY2l0eTtcbiAgICBcdFx0dGhpcy50cmFuc3BhcmVudCA9IHNvdXJjZS50cmFuc3BhcmVudDtcblxuICAgIFx0XHR0aGlzLmJsZW5kU3JjID0gc291cmNlLmJsZW5kU3JjO1xuICAgIFx0XHR0aGlzLmJsZW5kRHN0ID0gc291cmNlLmJsZW5kRHN0O1xuICAgIFx0XHR0aGlzLmJsZW5kRXF1YXRpb24gPSBzb3VyY2UuYmxlbmRFcXVhdGlvbjtcbiAgICBcdFx0dGhpcy5ibGVuZFNyY0FscGhhID0gc291cmNlLmJsZW5kU3JjQWxwaGE7XG4gICAgXHRcdHRoaXMuYmxlbmREc3RBbHBoYSA9IHNvdXJjZS5ibGVuZERzdEFscGhhO1xuICAgIFx0XHR0aGlzLmJsZW5kRXF1YXRpb25BbHBoYSA9IHNvdXJjZS5ibGVuZEVxdWF0aW9uQWxwaGE7XG5cbiAgICBcdFx0dGhpcy5kZXB0aEZ1bmMgPSBzb3VyY2UuZGVwdGhGdW5jO1xuICAgIFx0XHR0aGlzLmRlcHRoVGVzdCA9IHNvdXJjZS5kZXB0aFRlc3Q7XG4gICAgXHRcdHRoaXMuZGVwdGhXcml0ZSA9IHNvdXJjZS5kZXB0aFdyaXRlO1xuXG4gICAgXHRcdHRoaXMuY29sb3JXcml0ZSA9IHNvdXJjZS5jb2xvcldyaXRlO1xuXG4gICAgXHRcdHRoaXMucHJlY2lzaW9uID0gc291cmNlLnByZWNpc2lvbjtcblxuICAgIFx0XHR0aGlzLnBvbHlnb25PZmZzZXQgPSBzb3VyY2UucG9seWdvbk9mZnNldDtcbiAgICBcdFx0dGhpcy5wb2x5Z29uT2Zmc2V0RmFjdG9yID0gc291cmNlLnBvbHlnb25PZmZzZXRGYWN0b3I7XG4gICAgXHRcdHRoaXMucG9seWdvbk9mZnNldFVuaXRzID0gc291cmNlLnBvbHlnb25PZmZzZXRVbml0cztcblxuICAgIFx0XHR0aGlzLmFscGhhVGVzdCA9IHNvdXJjZS5hbHBoYVRlc3Q7XG5cbiAgICBcdFx0dGhpcy5wcmVtdWx0aXBsaWVkQWxwaGEgPSBzb3VyY2UucHJlbXVsdGlwbGllZEFscGhhO1xuXG4gICAgXHRcdHRoaXMub3ZlcmRyYXcgPSBzb3VyY2Uub3ZlcmRyYXc7XG5cbiAgICBcdFx0dGhpcy52aXNpYmxlID0gc291cmNlLnZpc2libGU7XG4gICAgXHRcdHRoaXMuY2xpcFNoYWRvd3MgPSBzb3VyY2UuY2xpcFNoYWRvd3M7XG5cbiAgICBcdFx0dmFyIHNyY1BsYW5lcyA9IHNvdXJjZS5jbGlwcGluZ1BsYW5lcyxcbiAgICBcdFx0XHRkc3RQbGFuZXMgPSBudWxsO1xuXG4gICAgXHRcdGlmICggc3JjUGxhbmVzICE9PSBudWxsICkge1xuXG4gICAgXHRcdFx0dmFyIG4gPSBzcmNQbGFuZXMubGVuZ3RoO1xuICAgIFx0XHRcdGRzdFBsYW5lcyA9IG5ldyBBcnJheSggbiApO1xuXG4gICAgXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpICE9PSBuOyArKyBpIClcbiAgICBcdFx0XHRcdGRzdFBsYW5lc1sgaSBdID0gc3JjUGxhbmVzWyBpIF0uY2xvbmUoKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0dGhpcy5jbGlwcGluZ1BsYW5lcyA9IGRzdFBsYW5lcztcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0dXBkYXRlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dGhpcy5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICd1cGRhdGUnIH0gKTtcblxuICAgIFx0fSxcblxuICAgIFx0ZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHRoaXMuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAnZGlzcG9zZScgfSApO1xuXG4gICAgXHR9XG5cbiAgICB9O1xuXG4gICAgT2JqZWN0LmFzc2lnbiggTWF0ZXJpYWwucHJvdG90eXBlLCBFdmVudERpc3BhdGNoZXIucHJvdG90eXBlICk7XG5cbiAgICB2YXIgY291bnQkMSA9IDA7XG4gICAgZnVuY3Rpb24gTWF0ZXJpYWxJZENvdW50KCkgeyByZXR1cm4gY291bnQkMSsrOyB9O1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAgICAgKlxuICAgICAqIHBhcmFtZXRlcnMgPSB7XG4gICAgICogIGRlZmluZXM6IHsgXCJsYWJlbFwiIDogXCJ2YWx1ZVwiIH0sXG4gICAgICogIHVuaWZvcm1zOiB7IFwicGFyYW1ldGVyMVwiOiB7IHZhbHVlOiAxLjAgfSwgXCJwYXJhbWV0ZXIyXCI6IHsgdmFsdWUyOiAyIH0gfSxcbiAgICAgKlxuICAgICAqICBmcmFnbWVudFNoYWRlcjogPHN0cmluZz4sXG4gICAgICogIHZlcnRleFNoYWRlcjogPHN0cmluZz4sXG4gICAgICpcbiAgICAgKiAgd2lyZWZyYW1lOiA8Ym9vbGVhbj4sXG4gICAgICogIHdpcmVmcmFtZUxpbmV3aWR0aDogPGZsb2F0PixcbiAgICAgKlxuICAgICAqICBsaWdodHM6IDxib29sPixcbiAgICAgKlxuICAgICAqICBza2lubmluZzogPGJvb2w+LFxuICAgICAqICBtb3JwaFRhcmdldHM6IDxib29sPixcbiAgICAgKiAgbW9ycGhOb3JtYWxzOiA8Ym9vbD5cbiAgICAgKiB9XG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBTaGFkZXJNYXRlcmlhbCggcGFyYW1ldGVycyApIHtcblxuICAgIFx0TWF0ZXJpYWwuY2FsbCggdGhpcyApO1xuXG4gICAgXHR0aGlzLnR5cGUgPSAnU2hhZGVyTWF0ZXJpYWwnO1xuXG4gICAgXHR0aGlzLmRlZmluZXMgPSB7fTtcbiAgICBcdHRoaXMudW5pZm9ybXMgPSB7fTtcblxuICAgIFx0dGhpcy52ZXJ0ZXhTaGFkZXIgPSAndm9pZCBtYWluKCkge1xcblxcdGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcXG59JztcbiAgICBcdHRoaXMuZnJhZ21lbnRTaGFkZXIgPSAndm9pZCBtYWluKCkge1xcblxcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIDEuMCwgMC4wLCAwLjAsIDEuMCApO1xcbn0nO1xuXG4gICAgXHR0aGlzLmxpbmV3aWR0aCA9IDE7XG5cbiAgICBcdHRoaXMud2lyZWZyYW1lID0gZmFsc2U7XG4gICAgXHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XG5cbiAgICBcdHRoaXMuZm9nID0gZmFsc2U7IC8vIHNldCB0byB1c2Ugc2NlbmUgZm9nXG4gICAgXHR0aGlzLmxpZ2h0cyA9IGZhbHNlOyAvLyBzZXQgdG8gdXNlIHNjZW5lIGxpZ2h0c1xuICAgIFx0dGhpcy5jbGlwcGluZyA9IGZhbHNlOyAvLyBzZXQgdG8gdXNlIHVzZXItZGVmaW5lZCBjbGlwcGluZyBwbGFuZXNcblxuICAgIFx0dGhpcy5za2lubmluZyA9IGZhbHNlOyAvLyBzZXQgdG8gdXNlIHNraW5uaW5nIGF0dHJpYnV0ZSBzdHJlYW1zXG4gICAgXHR0aGlzLm1vcnBoVGFyZ2V0cyA9IGZhbHNlOyAvLyBzZXQgdG8gdXNlIG1vcnBoIHRhcmdldHNcbiAgICBcdHRoaXMubW9ycGhOb3JtYWxzID0gZmFsc2U7IC8vIHNldCB0byB1c2UgbW9ycGggbm9ybWFsc1xuXG4gICAgXHR0aGlzLmV4dGVuc2lvbnMgPSB7XG4gICAgXHRcdGRlcml2YXRpdmVzOiBmYWxzZSwgLy8gc2V0IHRvIHVzZSBkZXJpdmF0aXZlc1xuICAgIFx0XHRmcmFnRGVwdGg6IGZhbHNlLCAvLyBzZXQgdG8gdXNlIGZyYWdtZW50IGRlcHRoIHZhbHVlc1xuICAgIFx0XHRkcmF3QnVmZmVyczogZmFsc2UsIC8vIHNldCB0byB1c2UgZHJhdyBidWZmZXJzXG4gICAgXHRcdHNoYWRlclRleHR1cmVMT0Q6IGZhbHNlIC8vIHNldCB0byB1c2Ugc2hhZGVyIHRleHR1cmUgTE9EXG4gICAgXHR9O1xuXG4gICAgXHQvLyBXaGVuIHJlbmRlcmVkIGdlb21ldHJ5IGRvZXNuJ3QgaW5jbHVkZSB0aGVzZSBhdHRyaWJ1dGVzIGJ1dCB0aGUgbWF0ZXJpYWwgZG9lcyxcbiAgICBcdC8vIHVzZSB0aGVzZSBkZWZhdWx0IHZhbHVlcyBpbiBXZWJHTC4gVGhpcyBhdm9pZHMgZXJyb3JzIHdoZW4gYnVmZmVyIGRhdGEgaXMgbWlzc2luZy5cbiAgICBcdHRoaXMuZGVmYXVsdEF0dHJpYnV0ZVZhbHVlcyA9IHtcbiAgICBcdFx0J2NvbG9yJzogWyAxLCAxLCAxIF0sXG4gICAgXHRcdCd1dic6IFsgMCwgMCBdLFxuICAgIFx0XHQndXYyJzogWyAwLCAwIF1cbiAgICBcdH07XG5cbiAgICBcdHRoaXMuaW5kZXgwQXR0cmlidXRlTmFtZSA9IHVuZGVmaW5lZDtcblxuICAgIFx0aWYgKCBwYXJhbWV0ZXJzICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0aWYgKCBwYXJhbWV0ZXJzLmF0dHJpYnV0ZXMgIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5TaGFkZXJNYXRlcmlhbDogYXR0cmlidXRlcyBzaG91bGQgbm93IGJlIGRlZmluZWQgaW4gVEhSRUUuQnVmZmVyR2VvbWV0cnkgaW5zdGVhZC4nICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XG5cbiAgICBcdH1cblxuICAgIH1cblxuICAgIFNoYWRlck1hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE1hdGVyaWFsLnByb3RvdHlwZSApO1xuICAgIFNoYWRlck1hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNoYWRlck1hdGVyaWFsO1xuXG4gICAgU2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlLmlzU2hhZGVyTWF0ZXJpYWwgPSB0cnVlO1xuXG4gICAgU2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuICAgIFx0TWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XG5cbiAgICBcdHRoaXMuZnJhZ21lbnRTaGFkZXIgPSBzb3VyY2UuZnJhZ21lbnRTaGFkZXI7XG4gICAgXHR0aGlzLnZlcnRleFNoYWRlciA9IHNvdXJjZS52ZXJ0ZXhTaGFkZXI7XG5cbiAgICBcdHRoaXMudW5pZm9ybXMgPSBleHBvcnRzLlVuaWZvcm1zVXRpbHMuY2xvbmUoIHNvdXJjZS51bmlmb3JtcyApO1xuXG4gICAgXHR0aGlzLmRlZmluZXMgPSBzb3VyY2UuZGVmaW5lcztcblxuICAgIFx0dGhpcy53aXJlZnJhbWUgPSBzb3VyY2Uud2lyZWZyYW1lO1xuICAgIFx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSBzb3VyY2Uud2lyZWZyYW1lTGluZXdpZHRoO1xuXG4gICAgXHR0aGlzLmxpZ2h0cyA9IHNvdXJjZS5saWdodHM7XG4gICAgXHR0aGlzLmNsaXBwaW5nID0gc291cmNlLmNsaXBwaW5nO1xuXG4gICAgXHR0aGlzLnNraW5uaW5nID0gc291cmNlLnNraW5uaW5nO1xuXG4gICAgXHR0aGlzLm1vcnBoVGFyZ2V0cyA9IHNvdXJjZS5tb3JwaFRhcmdldHM7XG4gICAgXHR0aGlzLm1vcnBoTm9ybWFscyA9IHNvdXJjZS5tb3JwaE5vcm1hbHM7XG5cbiAgICBcdHRoaXMuZXh0ZW5zaW9ucyA9IHNvdXJjZS5leHRlbnNpb25zO1xuXG4gICAgXHRyZXR1cm4gdGhpcztcblxuICAgIH07XG5cbiAgICBTaGFkZXJNYXRlcmlhbC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCBtZXRhICkge1xuXG4gICAgXHR2YXIgZGF0YSA9IE1hdGVyaWFsLnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcywgbWV0YSApO1xuXG4gICAgXHRkYXRhLnVuaWZvcm1zID0gdGhpcy51bmlmb3JtcztcbiAgICBcdGRhdGEudmVydGV4U2hhZGVyID0gdGhpcy52ZXJ0ZXhTaGFkZXI7XG4gICAgXHRkYXRhLmZyYWdtZW50U2hhZGVyID0gdGhpcy5mcmFnbWVudFNoYWRlcjtcblxuICAgIFx0cmV0dXJuIGRhdGE7XG5cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAgICAgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICAgICAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwczovL2NsYXJhLmlvXG4gICAgICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG4gICAgICpcbiAgICAgKiBwYXJhbWV0ZXJzID0ge1xuICAgICAqXG4gICAgICogIG9wYWNpdHk6IDxmbG9hdD4sXG4gICAgICpcbiAgICAgKiAgbWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICAgICAqXG4gICAgICogIGFscGhhTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICAgICAqXG4gICAgICogIGRpc3BsYWNlbWVudE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAgICAgKiAgZGlzcGxhY2VtZW50U2NhbGU6IDxmbG9hdD4sXG4gICAgICogIGRpc3BsYWNlbWVudEJpYXM6IDxmbG9hdD4sXG4gICAgICpcbiAgICAgKiAgd2lyZWZyYW1lOiA8Ym9vbGVhbj4sXG4gICAgICogIHdpcmVmcmFtZUxpbmV3aWR0aDogPGZsb2F0PlxuICAgICAqIH1cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIE1lc2hEZXB0aE1hdGVyaWFsKCBwYXJhbWV0ZXJzICkge1xuXG4gICAgXHRNYXRlcmlhbC5jYWxsKCB0aGlzICk7XG5cbiAgICBcdHRoaXMudHlwZSA9ICdNZXNoRGVwdGhNYXRlcmlhbCc7XG5cbiAgICBcdHRoaXMuZGVwdGhQYWNraW5nID0gQmFzaWNEZXB0aFBhY2tpbmc7XG5cbiAgICBcdHRoaXMuc2tpbm5pbmcgPSBmYWxzZTtcbiAgICBcdHRoaXMubW9ycGhUYXJnZXRzID0gZmFsc2U7XG5cbiAgICBcdHRoaXMubWFwID0gbnVsbDtcblxuICAgIFx0dGhpcy5hbHBoYU1hcCA9IG51bGw7XG5cbiAgICBcdHRoaXMuZGlzcGxhY2VtZW50TWFwID0gbnVsbDtcbiAgICBcdHRoaXMuZGlzcGxhY2VtZW50U2NhbGUgPSAxO1xuICAgIFx0dGhpcy5kaXNwbGFjZW1lbnRCaWFzID0gMDtcblxuICAgIFx0dGhpcy53aXJlZnJhbWUgPSBmYWxzZTtcbiAgICBcdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMTtcblxuICAgIFx0dGhpcy5mb2cgPSBmYWxzZTtcbiAgICBcdHRoaXMubGlnaHRzID0gZmFsc2U7XG5cbiAgICBcdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XG5cbiAgICB9XG5cbiAgICBNZXNoRGVwdGhNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBNYXRlcmlhbC5wcm90b3R5cGUgKTtcbiAgICBNZXNoRGVwdGhNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNZXNoRGVwdGhNYXRlcmlhbDtcblxuICAgIE1lc2hEZXB0aE1hdGVyaWFsLnByb3RvdHlwZS5pc01lc2hEZXB0aE1hdGVyaWFsID0gdHJ1ZTtcblxuICAgIE1lc2hEZXB0aE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cbiAgICBcdE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG4gICAgXHR0aGlzLmRlcHRoUGFja2luZyA9IHNvdXJjZS5kZXB0aFBhY2tpbmc7XG5cbiAgICBcdHRoaXMuc2tpbm5pbmcgPSBzb3VyY2Uuc2tpbm5pbmc7XG4gICAgXHR0aGlzLm1vcnBoVGFyZ2V0cyA9IHNvdXJjZS5tb3JwaFRhcmdldHM7XG5cbiAgICBcdHRoaXMubWFwID0gc291cmNlLm1hcDtcblxuICAgIFx0dGhpcy5hbHBoYU1hcCA9IHNvdXJjZS5hbHBoYU1hcDtcblxuICAgIFx0dGhpcy5kaXNwbGFjZW1lbnRNYXAgPSBzb3VyY2UuZGlzcGxhY2VtZW50TWFwO1xuICAgIFx0dGhpcy5kaXNwbGFjZW1lbnRTY2FsZSA9IHNvdXJjZS5kaXNwbGFjZW1lbnRTY2FsZTtcbiAgICBcdHRoaXMuZGlzcGxhY2VtZW50QmlhcyA9IHNvdXJjZS5kaXNwbGFjZW1lbnRCaWFzO1xuXG4gICAgXHR0aGlzLndpcmVmcmFtZSA9IHNvdXJjZS53aXJlZnJhbWU7XG4gICAgXHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IHNvdXJjZS53aXJlZnJhbWVMaW5ld2lkdGg7XG5cbiAgICBcdHJldHVybiB0aGlzO1xuXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cbiAgICAgKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIEJveDMoIG1pbiwgbWF4ICkge1xuXG4gICAgXHR0aGlzLm1pbiA9ICggbWluICE9PSB1bmRlZmluZWQgKSA/IG1pbiA6IG5ldyBWZWN0b3IzKCArIEluZmluaXR5LCArIEluZmluaXR5LCArIEluZmluaXR5ICk7XG4gICAgXHR0aGlzLm1heCA9ICggbWF4ICE9PSB1bmRlZmluZWQgKSA/IG1heCA6IG5ldyBWZWN0b3IzKCAtIEluZmluaXR5LCAtIEluZmluaXR5LCAtIEluZmluaXR5ICk7XG5cbiAgICB9XG5cbiAgICBCb3gzLnByb3RvdHlwZSA9IHtcblxuICAgIFx0Y29uc3RydWN0b3I6IEJveDMsXG5cbiAgICBcdGlzQm94MzogdHJ1ZSxcblxuICAgIFx0c2V0OiBmdW5jdGlvbiAoIG1pbiwgbWF4ICkge1xuXG4gICAgXHRcdHRoaXMubWluLmNvcHkoIG1pbiApO1xuICAgIFx0XHR0aGlzLm1heC5jb3B5KCBtYXggKTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0c2V0RnJvbUFycmF5OiBmdW5jdGlvbiAoIGFycmF5ICkge1xuXG4gICAgXHRcdHZhciBtaW5YID0gKyBJbmZpbml0eTtcbiAgICBcdFx0dmFyIG1pblkgPSArIEluZmluaXR5O1xuICAgIFx0XHR2YXIgbWluWiA9ICsgSW5maW5pdHk7XG5cbiAgICBcdFx0dmFyIG1heFggPSAtIEluZmluaXR5O1xuICAgIFx0XHR2YXIgbWF4WSA9IC0gSW5maW5pdHk7XG4gICAgXHRcdHZhciBtYXhaID0gLSBJbmZpbml0eTtcblxuICAgIFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBhcnJheS5sZW5ndGg7IGkgPCBsOyBpICs9IDMgKSB7XG5cbiAgICBcdFx0XHR2YXIgeCA9IGFycmF5WyBpIF07XG4gICAgXHRcdFx0dmFyIHkgPSBhcnJheVsgaSArIDEgXTtcbiAgICBcdFx0XHR2YXIgeiA9IGFycmF5WyBpICsgMiBdO1xuXG4gICAgXHRcdFx0aWYgKCB4IDwgbWluWCApIG1pblggPSB4O1xuICAgIFx0XHRcdGlmICggeSA8IG1pblkgKSBtaW5ZID0geTtcbiAgICBcdFx0XHRpZiAoIHogPCBtaW5aICkgbWluWiA9IHo7XG5cbiAgICBcdFx0XHRpZiAoIHggPiBtYXhYICkgbWF4WCA9IHg7XG4gICAgXHRcdFx0aWYgKCB5ID4gbWF4WSApIG1heFkgPSB5O1xuICAgIFx0XHRcdGlmICggeiA+IG1heFogKSBtYXhaID0gejtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0dGhpcy5taW4uc2V0KCBtaW5YLCBtaW5ZLCBtaW5aICk7XG4gICAgXHRcdHRoaXMubWF4LnNldCggbWF4WCwgbWF4WSwgbWF4WiApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRzZXRGcm9tUG9pbnRzOiBmdW5jdGlvbiAoIHBvaW50cyApIHtcblxuICAgIFx0XHR0aGlzLm1ha2VFbXB0eSgpO1xuXG4gICAgXHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICBcdFx0XHR0aGlzLmV4cGFuZEJ5UG9pbnQoIHBvaW50c1sgaSBdICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRzZXRGcm9tQ2VudGVyQW5kU2l6ZTogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCk7XG5cbiAgICBcdFx0cmV0dXJuIGZ1bmN0aW9uIHNldEZyb21DZW50ZXJBbmRTaXplKCBjZW50ZXIsIHNpemUgKSB7XG5cbiAgICBcdFx0XHR2YXIgaGFsZlNpemUgPSB2MS5jb3B5KCBzaXplICkubXVsdGlwbHlTY2FsYXIoIDAuNSApO1xuXG4gICAgXHRcdFx0dGhpcy5taW4uY29weSggY2VudGVyICkuc3ViKCBoYWxmU2l6ZSApO1xuICAgIFx0XHRcdHRoaXMubWF4LmNvcHkoIGNlbnRlciApLmFkZCggaGFsZlNpemUgKTtcblxuICAgIFx0XHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHRcdH07XG5cbiAgICBcdH0oKSxcblxuICAgIFx0c2V0RnJvbU9iamVjdDogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdC8vIENvbXB1dGVzIHRoZSB3b3JsZC1heGlzLWFsaWduZWQgYm91bmRpbmcgYm94IG9mIGFuIG9iamVjdCAoaW5jbHVkaW5nIGl0cyBjaGlsZHJlbiksXG4gICAgXHRcdC8vIGFjY291bnRpbmcgZm9yIGJvdGggdGhlIG9iamVjdCdzLCBhbmQgY2hpbGRyZW4ncywgd29ybGQgdHJhbnNmb3Jtc1xuXG4gICAgXHRcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCk7XG5cbiAgICBcdFx0cmV0dXJuIGZ1bmN0aW9uIHNldEZyb21PYmplY3QoIG9iamVjdCApIHtcblxuICAgIFx0XHRcdHZhciBzY29wZSA9IHRoaXM7XG5cbiAgICBcdFx0XHRvYmplY3QudXBkYXRlTWF0cml4V29ybGQoIHRydWUgKTtcblxuICAgIFx0XHRcdHRoaXMubWFrZUVtcHR5KCk7XG5cbiAgICBcdFx0XHRvYmplY3QudHJhdmVyc2UoIGZ1bmN0aW9uICggbm9kZSApIHtcblxuICAgIFx0XHRcdFx0dmFyIGdlb21ldHJ5ID0gbm9kZS5nZW9tZXRyeTtcblxuICAgIFx0XHRcdFx0aWYgKCBnZW9tZXRyeSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0XHRcdGlmICggKGdlb21ldHJ5ICYmIGdlb21ldHJ5LmlzR2VvbWV0cnkpICkge1xuXG4gICAgXHRcdFx0XHRcdFx0dmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXM7XG5cbiAgICBcdFx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gdmVydGljZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHRcdHYxLmNvcHkoIHZlcnRpY2VzWyBpIF0gKTtcbiAgICBcdFx0XHRcdFx0XHRcdHYxLmFwcGx5TWF0cml4NCggbm9kZS5tYXRyaXhXb3JsZCApO1xuXG4gICAgXHRcdFx0XHRcdFx0XHRzY29wZS5leHBhbmRCeVBvaW50KCB2MSApO1xuXG4gICAgXHRcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHRcdH0gZWxzZSBpZiAoIChnZW9tZXRyeSAmJiBnZW9tZXRyeS5pc0J1ZmZlckdlb21ldHJ5KSApIHtcblxuICAgIFx0XHRcdFx0XHRcdHZhciBhdHRyaWJ1dGUgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXG4gICAgXHRcdFx0XHRcdFx0aWYgKCBhdHRyaWJ1dGUgIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0XHRcdFx0dmFyIGFycmF5LCBvZmZzZXQsIHN0cmlkZTtcblxuICAgIFx0XHRcdFx0XHRcdFx0aWYgKCAoYXR0cmlidXRlICYmIGF0dHJpYnV0ZS5pc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlKSApIHtcblxuICAgIFx0XHRcdFx0XHRcdFx0XHRhcnJheSA9IGF0dHJpYnV0ZS5kYXRhLmFycmF5O1xuICAgIFx0XHRcdFx0XHRcdFx0XHRvZmZzZXQgPSBhdHRyaWJ1dGUub2Zmc2V0O1xuICAgIFx0XHRcdFx0XHRcdFx0XHRzdHJpZGUgPSBhdHRyaWJ1dGUuZGF0YS5zdHJpZGU7XG5cbiAgICBcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdFx0XHRcdFx0YXJyYXkgPSBhdHRyaWJ1dGUuYXJyYXk7XG4gICAgXHRcdFx0XHRcdFx0XHRcdG9mZnNldCA9IDA7XG4gICAgXHRcdFx0XHRcdFx0XHRcdHN0cmlkZSA9IDM7XG5cbiAgICBcdFx0XHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0XHRcdFx0Zm9yICggdmFyIGkgPSBvZmZzZXQsIGlsID0gYXJyYXkubGVuZ3RoOyBpIDwgaWw7IGkgKz0gc3RyaWRlICkge1xuXG4gICAgXHRcdFx0XHRcdFx0XHRcdHYxLmZyb21BcnJheSggYXJyYXksIGkgKTtcbiAgICBcdFx0XHRcdFx0XHRcdFx0djEuYXBwbHlNYXRyaXg0KCBub2RlLm1hdHJpeFdvcmxkICk7XG5cbiAgICBcdFx0XHRcdFx0XHRcdFx0c2NvcGUuZXhwYW5kQnlQb2ludCggdjEgKTtcblxuICAgIFx0XHRcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0fSApO1xuXG4gICAgXHRcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdFx0fTtcblxuICAgIFx0fSgpLFxuXG4gICAgXHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblxuICAgIFx0fSxcblxuICAgIFx0Y29weTogZnVuY3Rpb24gKCBib3ggKSB7XG5cbiAgICBcdFx0dGhpcy5taW4uY29weSggYm94Lm1pbiApO1xuICAgIFx0XHR0aGlzLm1heC5jb3B5KCBib3gubWF4ICk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdG1ha2VFbXB0eTogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHRoaXMubWluLnggPSB0aGlzLm1pbi55ID0gdGhpcy5taW4ueiA9ICsgSW5maW5pdHk7XG4gICAgXHRcdHRoaXMubWF4LnggPSB0aGlzLm1heC55ID0gdGhpcy5tYXgueiA9IC0gSW5maW5pdHk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGlzRW1wdHk6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHQvLyB0aGlzIGlzIGEgbW9yZSByb2J1c3QgY2hlY2sgZm9yIGVtcHR5IHRoYW4gKCB2b2x1bWUgPD0gMCApIGJlY2F1c2Ugdm9sdW1lIGNhbiBnZXQgcG9zaXRpdmUgd2l0aCB0d28gbmVnYXRpdmUgYXhlc1xuXG4gICAgXHRcdHJldHVybiAoIHRoaXMubWF4LnggPCB0aGlzLm1pbi54ICkgfHwgKCB0aGlzLm1heC55IDwgdGhpcy5taW4ueSApIHx8ICggdGhpcy5tYXgueiA8IHRoaXMubWluLnogKTtcblxuICAgIFx0fSxcblxuICAgIFx0Z2V0Q2VudGVyOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgXHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMygpO1xuICAgIFx0XHRyZXR1cm4gdGhpcy5pc0VtcHR5KCkgPyByZXN1bHQuc2V0KCAwLCAwLCAwICkgOiByZXN1bHQuYWRkVmVjdG9ycyggdGhpcy5taW4sIHRoaXMubWF4ICkubXVsdGlwbHlTY2FsYXIoIDAuNSApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRnZXRTaXplOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgXHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMygpO1xuICAgIFx0XHRyZXR1cm4gdGhpcy5pc0VtcHR5KCkgPyByZXN1bHQuc2V0KCAwLCAwLCAwICkgOiByZXN1bHQuc3ViVmVjdG9ycyggdGhpcy5tYXgsIHRoaXMubWluICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGV4cGFuZEJ5UG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XG5cbiAgICBcdFx0dGhpcy5taW4ubWluKCBwb2ludCApO1xuICAgIFx0XHR0aGlzLm1heC5tYXgoIHBvaW50ICk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGV4cGFuZEJ5VmVjdG9yOiBmdW5jdGlvbiAoIHZlY3RvciApIHtcblxuICAgIFx0XHR0aGlzLm1pbi5zdWIoIHZlY3RvciApO1xuICAgIFx0XHR0aGlzLm1heC5hZGQoIHZlY3RvciApO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRleHBhbmRCeVNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XG5cbiAgICBcdFx0dGhpcy5taW4uYWRkU2NhbGFyKCAtIHNjYWxhciApO1xuICAgIFx0XHR0aGlzLm1heC5hZGRTY2FsYXIoIHNjYWxhciApO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRjb250YWluc1BvaW50OiBmdW5jdGlvbiAoIHBvaW50ICkge1xuXG4gICAgXHRcdGlmICggcG9pbnQueCA8IHRoaXMubWluLnggfHwgcG9pbnQueCA+IHRoaXMubWF4LnggfHxcbiAgICBcdFx0XHRcdCBwb2ludC55IDwgdGhpcy5taW4ueSB8fCBwb2ludC55ID4gdGhpcy5tYXgueSB8fFxuICAgIFx0XHRcdFx0IHBvaW50LnogPCB0aGlzLm1pbi56IHx8IHBvaW50LnogPiB0aGlzLm1heC56ICkge1xuXG4gICAgXHRcdFx0cmV0dXJuIGZhbHNlO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gdHJ1ZTtcblxuICAgIFx0fSxcblxuICAgIFx0Y29udGFpbnNCb3g6IGZ1bmN0aW9uICggYm94ICkge1xuXG4gICAgXHRcdGlmICggKCB0aGlzLm1pbi54IDw9IGJveC5taW4ueCApICYmICggYm94Lm1heC54IDw9IHRoaXMubWF4LnggKSAmJlxuICAgIFx0XHRcdCAoIHRoaXMubWluLnkgPD0gYm94Lm1pbi55ICkgJiYgKCBib3gubWF4LnkgPD0gdGhpcy5tYXgueSApICYmXG4gICAgXHRcdFx0ICggdGhpcy5taW4ueiA8PSBib3gubWluLnogKSAmJiAoIGJveC5tYXgueiA8PSB0aGlzLm1heC56ICkgKSB7XG5cbiAgICBcdFx0XHRyZXR1cm4gdHJ1ZTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIGZhbHNlO1xuXG4gICAgXHR9LFxuXG4gICAgXHRnZXRQYXJhbWV0ZXI6IGZ1bmN0aW9uICggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgXHRcdC8vIFRoaXMgY2FuIHBvdGVudGlhbGx5IGhhdmUgYSBkaXZpZGUgYnkgemVybyBpZiB0aGUgYm94XG4gICAgXHRcdC8vIGhhcyBhIHNpemUgZGltZW5zaW9uIG9mIDAuXG5cbiAgICBcdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IzKCk7XG5cbiAgICBcdFx0cmV0dXJuIHJlc3VsdC5zZXQoXG4gICAgXHRcdFx0KCBwb2ludC54IC0gdGhpcy5taW4ueCApIC8gKCB0aGlzLm1heC54IC0gdGhpcy5taW4ueCApLFxuICAgIFx0XHRcdCggcG9pbnQueSAtIHRoaXMubWluLnkgKSAvICggdGhpcy5tYXgueSAtIHRoaXMubWluLnkgKSxcbiAgICBcdFx0XHQoIHBvaW50LnogLSB0aGlzLm1pbi56ICkgLyAoIHRoaXMubWF4LnogLSB0aGlzLm1pbi56IClcbiAgICBcdFx0KTtcblxuICAgIFx0fSxcblxuICAgIFx0aW50ZXJzZWN0c0JveDogZnVuY3Rpb24gKCBib3ggKSB7XG5cbiAgICBcdFx0Ly8gdXNpbmcgNiBzcGxpdHRpbmcgcGxhbmVzIHRvIHJ1bGUgb3V0IGludGVyc2VjdGlvbnMuXG5cbiAgICBcdFx0aWYgKCBib3gubWF4LnggPCB0aGlzLm1pbi54IHx8IGJveC5taW4ueCA+IHRoaXMubWF4LnggfHxcbiAgICBcdFx0XHRcdCBib3gubWF4LnkgPCB0aGlzLm1pbi55IHx8IGJveC5taW4ueSA+IHRoaXMubWF4LnkgfHxcbiAgICBcdFx0XHRcdCBib3gubWF4LnogPCB0aGlzLm1pbi56IHx8IGJveC5taW4ueiA+IHRoaXMubWF4LnogKSB7XG5cbiAgICBcdFx0XHRyZXR1cm4gZmFsc2U7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiB0cnVlO1xuXG4gICAgXHR9LFxuXG4gICAgXHRpbnRlcnNlY3RzU3BoZXJlOiAoIGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR2YXIgY2xvc2VzdFBvaW50O1xuXG4gICAgXHRcdHJldHVybiBmdW5jdGlvbiBpbnRlcnNlY3RzU3BoZXJlKCBzcGhlcmUgKSB7XG5cbiAgICBcdFx0XHRpZiAoIGNsb3Nlc3RQb2ludCA9PT0gdW5kZWZpbmVkICkgY2xvc2VzdFBvaW50ID0gbmV3IFZlY3RvcjMoKTtcblxuICAgIFx0XHRcdC8vIEZpbmQgdGhlIHBvaW50IG9uIHRoZSBBQUJCIGNsb3Nlc3QgdG8gdGhlIHNwaGVyZSBjZW50ZXIuXG4gICAgXHRcdFx0dGhpcy5jbGFtcFBvaW50KCBzcGhlcmUuY2VudGVyLCBjbG9zZXN0UG9pbnQgKTtcblxuICAgIFx0XHRcdC8vIElmIHRoYXQgcG9pbnQgaXMgaW5zaWRlIHRoZSBzcGhlcmUsIHRoZSBBQUJCIGFuZCBzcGhlcmUgaW50ZXJzZWN0LlxuICAgIFx0XHRcdHJldHVybiBjbG9zZXN0UG9pbnQuZGlzdGFuY2VUb1NxdWFyZWQoIHNwaGVyZS5jZW50ZXIgKSA8PSAoIHNwaGVyZS5yYWRpdXMgKiBzcGhlcmUucmFkaXVzICk7XG5cbiAgICBcdFx0fTtcblxuICAgIFx0fSApKCksXG5cbiAgICBcdGludGVyc2VjdHNQbGFuZTogZnVuY3Rpb24gKCBwbGFuZSApIHtcblxuICAgIFx0XHQvLyBXZSBjb21wdXRlIHRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIGRvdCBwcm9kdWN0IHZhbHVlcy4gSWYgdGhvc2UgdmFsdWVzXG4gICAgXHRcdC8vIGFyZSBvbiB0aGUgc2FtZSBzaWRlIChiYWNrIG9yIGZyb250KSBvZiB0aGUgcGxhbmUsIHRoZW4gdGhlcmUgaXMgbm8gaW50ZXJzZWN0aW9uLlxuXG4gICAgXHRcdHZhciBtaW4sIG1heDtcblxuICAgIFx0XHRpZiAoIHBsYW5lLm5vcm1hbC54ID4gMCApIHtcblxuICAgIFx0XHRcdG1pbiA9IHBsYW5lLm5vcm1hbC54ICogdGhpcy5taW4ueDtcbiAgICBcdFx0XHRtYXggPSBwbGFuZS5ub3JtYWwueCAqIHRoaXMubWF4Lng7XG5cbiAgICBcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdG1pbiA9IHBsYW5lLm5vcm1hbC54ICogdGhpcy5tYXgueDtcbiAgICBcdFx0XHRtYXggPSBwbGFuZS5ub3JtYWwueCAqIHRoaXMubWluLng7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGlmICggcGxhbmUubm9ybWFsLnkgPiAwICkge1xuXG4gICAgXHRcdFx0bWluICs9IHBsYW5lLm5vcm1hbC55ICogdGhpcy5taW4ueTtcbiAgICBcdFx0XHRtYXggKz0gcGxhbmUubm9ybWFsLnkgKiB0aGlzLm1heC55O1xuXG4gICAgXHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRtaW4gKz0gcGxhbmUubm9ybWFsLnkgKiB0aGlzLm1heC55O1xuICAgIFx0XHRcdG1heCArPSBwbGFuZS5ub3JtYWwueSAqIHRoaXMubWluLnk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGlmICggcGxhbmUubm9ybWFsLnogPiAwICkge1xuXG4gICAgXHRcdFx0bWluICs9IHBsYW5lLm5vcm1hbC56ICogdGhpcy5taW4uejtcbiAgICBcdFx0XHRtYXggKz0gcGxhbmUubm9ybWFsLnogKiB0aGlzLm1heC56O1xuXG4gICAgXHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRtaW4gKz0gcGxhbmUubm9ybWFsLnogKiB0aGlzLm1heC56O1xuICAgIFx0XHRcdG1heCArPSBwbGFuZS5ub3JtYWwueiAqIHRoaXMubWluLno7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiAoIG1pbiA8PSBwbGFuZS5jb25zdGFudCAmJiBtYXggPj0gcGxhbmUuY29uc3RhbnQgKTtcblxuICAgIFx0fSxcblxuICAgIFx0Y2xhbXBQb2ludDogZnVuY3Rpb24gKCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICBcdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IzKCk7XG4gICAgXHRcdHJldHVybiByZXN1bHQuY29weSggcG9pbnQgKS5jbGFtcCggdGhpcy5taW4sIHRoaXMubWF4ICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGRpc3RhbmNlVG9Qb2ludDogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCk7XG5cbiAgICBcdFx0cmV0dXJuIGZ1bmN0aW9uIGRpc3RhbmNlVG9Qb2ludCggcG9pbnQgKSB7XG5cbiAgICBcdFx0XHR2YXIgY2xhbXBlZFBvaW50ID0gdjEuY29weSggcG9pbnQgKS5jbGFtcCggdGhpcy5taW4sIHRoaXMubWF4ICk7XG4gICAgXHRcdFx0cmV0dXJuIGNsYW1wZWRQb2ludC5zdWIoIHBvaW50ICkubGVuZ3RoKCk7XG5cbiAgICBcdFx0fTtcblxuICAgIFx0fSgpLFxuXG4gICAgXHRnZXRCb3VuZGluZ1NwaGVyZTogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCk7XG5cbiAgICBcdFx0cmV0dXJuIGZ1bmN0aW9uIGdldEJvdW5kaW5nU3BoZXJlKCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgIFx0XHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgU3BoZXJlKCk7XG5cbiAgICBcdFx0XHR0aGlzLmdldENlbnRlciggcmVzdWx0LmNlbnRlciApO1xuXG4gICAgXHRcdFx0cmVzdWx0LnJhZGl1cyA9IHRoaXMuc2l6ZSggdjEgKS5sZW5ndGgoKSAqIDAuNTtcblxuICAgIFx0XHRcdHJldHVybiByZXN1bHQ7XG5cbiAgICBcdFx0fTtcblxuICAgIFx0fSgpLFxuXG4gICAgXHRpbnRlcnNlY3Q6IGZ1bmN0aW9uICggYm94ICkge1xuXG4gICAgXHRcdHRoaXMubWluLm1heCggYm94Lm1pbiApO1xuICAgIFx0XHR0aGlzLm1heC5taW4oIGJveC5tYXggKTtcblxuICAgIFx0XHQvLyBlbnN1cmUgdGhhdCBpZiB0aGVyZSBpcyBubyBvdmVybGFwLCB0aGUgcmVzdWx0IGlzIGZ1bGx5IGVtcHR5LCBub3Qgc2xpZ2h0bHkgZW1wdHkgd2l0aCBub24taW5mLytpbmYgdmFsdWVzIHRoYXQgd2lsbCBjYXVzZSBzdWJzZXF1ZW5jZSBpbnRlcnNlY3RzIHRvIGVycm9uZW91c2x5IHJldHVybiB2YWxpZCB2YWx1ZXMuXG4gICAgXHRcdGlmKCB0aGlzLmlzRW1wdHkoKSApIHRoaXMubWFrZUVtcHR5KCk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdHVuaW9uOiBmdW5jdGlvbiAoIGJveCApIHtcblxuICAgIFx0XHR0aGlzLm1pbi5taW4oIGJveC5taW4gKTtcbiAgICBcdFx0dGhpcy5tYXgubWF4KCBib3gubWF4ICk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGFwcGx5TWF0cml4NDogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHZhciBwb2ludHMgPSBbXG4gICAgXHRcdFx0bmV3IFZlY3RvcjMoKSxcbiAgICBcdFx0XHRuZXcgVmVjdG9yMygpLFxuICAgIFx0XHRcdG5ldyBWZWN0b3IzKCksXG4gICAgXHRcdFx0bmV3IFZlY3RvcjMoKSxcbiAgICBcdFx0XHRuZXcgVmVjdG9yMygpLFxuICAgIFx0XHRcdG5ldyBWZWN0b3IzKCksXG4gICAgXHRcdFx0bmV3IFZlY3RvcjMoKSxcbiAgICBcdFx0XHRuZXcgVmVjdG9yMygpXG4gICAgXHRcdF07XG5cbiAgICBcdFx0cmV0dXJuIGZ1bmN0aW9uIGFwcGx5TWF0cml4NCggbWF0cml4ICkge1xuXG4gICAgXHRcdFx0Ly8gdHJhbnNmb3JtIG9mIGVtcHR5IGJveCBpcyBhbiBlbXB0eSBib3guXG4gICAgXHRcdFx0aWYoIHRoaXMuaXNFbXB0eSgpICkgcmV0dXJuIHRoaXM7XG5cbiAgICBcdFx0XHQvLyBOT1RFOiBJIGFtIHVzaW5nIGEgYmluYXJ5IHBhdHRlcm4gdG8gc3BlY2lmeSBhbGwgMl4zIGNvbWJpbmF0aW9ucyBiZWxvd1xuICAgIFx0XHRcdHBvaW50c1sgMCBdLnNldCggdGhpcy5taW4ueCwgdGhpcy5taW4ueSwgdGhpcy5taW4ueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDAwMFxuICAgIFx0XHRcdHBvaW50c1sgMSBdLnNldCggdGhpcy5taW4ueCwgdGhpcy5taW4ueSwgdGhpcy5tYXgueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDAwMVxuICAgIFx0XHRcdHBvaW50c1sgMiBdLnNldCggdGhpcy5taW4ueCwgdGhpcy5tYXgueSwgdGhpcy5taW4ueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDAxMFxuICAgIFx0XHRcdHBvaW50c1sgMyBdLnNldCggdGhpcy5taW4ueCwgdGhpcy5tYXgueSwgdGhpcy5tYXgueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDAxMVxuICAgIFx0XHRcdHBvaW50c1sgNCBdLnNldCggdGhpcy5tYXgueCwgdGhpcy5taW4ueSwgdGhpcy5taW4ueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDEwMFxuICAgIFx0XHRcdHBvaW50c1sgNSBdLnNldCggdGhpcy5tYXgueCwgdGhpcy5taW4ueSwgdGhpcy5tYXgueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDEwMVxuICAgIFx0XHRcdHBvaW50c1sgNiBdLnNldCggdGhpcy5tYXgueCwgdGhpcy5tYXgueSwgdGhpcy5taW4ueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDExMFxuICAgIFx0XHRcdHBvaW50c1sgNyBdLnNldCggdGhpcy5tYXgueCwgdGhpcy5tYXgueSwgdGhpcy5tYXgueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7XHQvLyAxMTFcblxuICAgIFx0XHRcdHRoaXMuc2V0RnJvbVBvaW50cyggcG9pbnRzICk7XG5cbiAgICBcdFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0XHR9O1xuXG4gICAgXHR9KCksXG5cbiAgICBcdHRyYW5zbGF0ZTogZnVuY3Rpb24gKCBvZmZzZXQgKSB7XG5cbiAgICBcdFx0dGhpcy5taW4uYWRkKCBvZmZzZXQgKTtcbiAgICBcdFx0dGhpcy5tYXguYWRkKCBvZmZzZXQgKTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0ZXF1YWxzOiBmdW5jdGlvbiAoIGJveCApIHtcblxuICAgIFx0XHRyZXR1cm4gYm94Lm1pbi5lcXVhbHMoIHRoaXMubWluICkgJiYgYm94Lm1heC5lcXVhbHMoIHRoaXMubWF4ICk7XG5cbiAgICBcdH1cblxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXG4gICAgICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIFNwaGVyZSggY2VudGVyLCByYWRpdXMgKSB7XG5cbiAgICBcdHRoaXMuY2VudGVyID0gKCBjZW50ZXIgIT09IHVuZGVmaW5lZCApID8gY2VudGVyIDogbmV3IFZlY3RvcjMoKTtcbiAgICBcdHRoaXMucmFkaXVzID0gKCByYWRpdXMgIT09IHVuZGVmaW5lZCApID8gcmFkaXVzIDogMDtcblxuICAgIH1cblxuICAgIFNwaGVyZS5wcm90b3R5cGUgPSB7XG5cbiAgICBcdGNvbnN0cnVjdG9yOiBTcGhlcmUsXG5cbiAgICBcdHNldDogZnVuY3Rpb24gKCBjZW50ZXIsIHJhZGl1cyApIHtcblxuICAgIFx0XHR0aGlzLmNlbnRlci5jb3B5KCBjZW50ZXIgKTtcbiAgICBcdFx0dGhpcy5yYWRpdXMgPSByYWRpdXM7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldEZyb21Qb2ludHM6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR2YXIgYm94ID0gbmV3IEJveDMoKTtcblxuICAgIFx0XHRyZXR1cm4gZnVuY3Rpb24gc2V0RnJvbVBvaW50cyggcG9pbnRzLCBvcHRpb25hbENlbnRlciApIHtcblxuICAgIFx0XHRcdHZhciBjZW50ZXIgPSB0aGlzLmNlbnRlcjtcblxuICAgIFx0XHRcdGlmICggb3B0aW9uYWxDZW50ZXIgIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0Y2VudGVyLmNvcHkoIG9wdGlvbmFsQ2VudGVyICk7XG5cbiAgICBcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHRib3guc2V0RnJvbVBvaW50cyggcG9pbnRzICkuZ2V0Q2VudGVyKCBjZW50ZXIgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdHZhciBtYXhSYWRpdXNTcSA9IDA7XG5cbiAgICBcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgXHRcdFx0XHRtYXhSYWRpdXNTcSA9IE1hdGgubWF4KCBtYXhSYWRpdXNTcSwgY2VudGVyLmRpc3RhbmNlVG9TcXVhcmVkKCBwb2ludHNbIGkgXSApICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHR0aGlzLnJhZGl1cyA9IE1hdGguc3FydCggbWF4UmFkaXVzU3EgKTtcblxuICAgIFx0XHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHRcdH07XG5cbiAgICBcdH0oKSxcblxuICAgIFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGNvcHk6IGZ1bmN0aW9uICggc3BoZXJlICkge1xuXG4gICAgXHRcdHRoaXMuY2VudGVyLmNvcHkoIHNwaGVyZS5jZW50ZXIgKTtcbiAgICBcdFx0dGhpcy5yYWRpdXMgPSBzcGhlcmUucmFkaXVzO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRlbXB0eTogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHJldHVybiAoIHRoaXMucmFkaXVzIDw9IDAgKTtcblxuICAgIFx0fSxcblxuICAgIFx0Y29udGFpbnNQb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcblxuICAgIFx0XHRyZXR1cm4gKCBwb2ludC5kaXN0YW5jZVRvU3F1YXJlZCggdGhpcy5jZW50ZXIgKSA8PSAoIHRoaXMucmFkaXVzICogdGhpcy5yYWRpdXMgKSApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRkaXN0YW5jZVRvUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XG5cbiAgICBcdFx0cmV0dXJuICggcG9pbnQuZGlzdGFuY2VUbyggdGhpcy5jZW50ZXIgKSAtIHRoaXMucmFkaXVzICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGludGVyc2VjdHNTcGhlcmU6IGZ1bmN0aW9uICggc3BoZXJlICkge1xuXG4gICAgXHRcdHZhciByYWRpdXNTdW0gPSB0aGlzLnJhZGl1cyArIHNwaGVyZS5yYWRpdXM7XG5cbiAgICBcdFx0cmV0dXJuIHNwaGVyZS5jZW50ZXIuZGlzdGFuY2VUb1NxdWFyZWQoIHRoaXMuY2VudGVyICkgPD0gKCByYWRpdXNTdW0gKiByYWRpdXNTdW0gKTtcblxuICAgIFx0fSxcblxuICAgIFx0aW50ZXJzZWN0c0JveDogZnVuY3Rpb24gKCBib3ggKSB7XG5cbiAgICBcdFx0cmV0dXJuIGJveC5pbnRlcnNlY3RzU3BoZXJlKCB0aGlzICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGludGVyc2VjdHNQbGFuZTogZnVuY3Rpb24gKCBwbGFuZSApIHtcblxuICAgIFx0XHQvLyBXZSB1c2UgdGhlIGZvbGxvd2luZyBlcXVhdGlvbiB0byBjb21wdXRlIHRoZSBzaWduZWQgZGlzdGFuY2UgZnJvbVxuICAgIFx0XHQvLyB0aGUgY2VudGVyIG9mIHRoZSBzcGhlcmUgdG8gdGhlIHBsYW5lLlxuICAgIFx0XHQvL1xuICAgIFx0XHQvLyBkaXN0YW5jZSA9IHEgKiBuIC0gZFxuICAgIFx0XHQvL1xuICAgIFx0XHQvLyBJZiB0aGlzIGRpc3RhbmNlIGlzIGdyZWF0ZXIgdGhhbiB0aGUgcmFkaXVzIG9mIHRoZSBzcGhlcmUsXG4gICAgXHRcdC8vIHRoZW4gdGhlcmUgaXMgbm8gaW50ZXJzZWN0aW9uLlxuXG4gICAgXHRcdHJldHVybiBNYXRoLmFicyggdGhpcy5jZW50ZXIuZG90KCBwbGFuZS5ub3JtYWwgKSAtIHBsYW5lLmNvbnN0YW50ICkgPD0gdGhpcy5yYWRpdXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGNsYW1wUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgXHRcdHZhciBkZWx0YUxlbmd0aFNxID0gdGhpcy5jZW50ZXIuZGlzdGFuY2VUb1NxdWFyZWQoIHBvaW50ICk7XG5cbiAgICBcdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IzKCk7XG5cbiAgICBcdFx0cmVzdWx0LmNvcHkoIHBvaW50ICk7XG5cbiAgICBcdFx0aWYgKCBkZWx0YUxlbmd0aFNxID4gKCB0aGlzLnJhZGl1cyAqIHRoaXMucmFkaXVzICkgKSB7XG5cbiAgICBcdFx0XHRyZXN1bHQuc3ViKCB0aGlzLmNlbnRlciApLm5vcm1hbGl6ZSgpO1xuICAgIFx0XHRcdHJlc3VsdC5tdWx0aXBseVNjYWxhciggdGhpcy5yYWRpdXMgKS5hZGQoIHRoaXMuY2VudGVyICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiByZXN1bHQ7XG5cbiAgICBcdH0sXG5cbiAgICBcdGdldEJvdW5kaW5nQm94OiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgXHRcdHZhciBib3ggPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgQm94MygpO1xuXG4gICAgXHRcdGJveC5zZXQoIHRoaXMuY2VudGVyLCB0aGlzLmNlbnRlciApO1xuICAgIFx0XHRib3guZXhwYW5kQnlTY2FsYXIoIHRoaXMucmFkaXVzICk7XG5cbiAgICBcdFx0cmV0dXJuIGJveDtcblxuICAgIFx0fSxcblxuICAgIFx0YXBwbHlNYXRyaXg0OiBmdW5jdGlvbiAoIG1hdHJpeCApIHtcblxuICAgIFx0XHR0aGlzLmNlbnRlci5hcHBseU1hdHJpeDQoIG1hdHJpeCApO1xuICAgIFx0XHR0aGlzLnJhZGl1cyA9IHRoaXMucmFkaXVzICogbWF0cml4LmdldE1heFNjYWxlT25BeGlzKCk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdHRyYW5zbGF0ZTogZnVuY3Rpb24gKCBvZmZzZXQgKSB7XG5cbiAgICBcdFx0dGhpcy5jZW50ZXIuYWRkKCBvZmZzZXQgKTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0ZXF1YWxzOiBmdW5jdGlvbiAoIHNwaGVyZSApIHtcblxuICAgIFx0XHRyZXR1cm4gc3BoZXJlLmNlbnRlci5lcXVhbHMoIHRoaXMuY2VudGVyICkgJiYgKCBzcGhlcmUucmFkaXVzID09PSB0aGlzLnJhZGl1cyApO1xuXG4gICAgXHR9XG5cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAgICAgKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAgICAgKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXG4gICAgICogQGF1dGhvciB0c2Nod1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gTWF0cml4MygpIHtcblxuICAgIFx0dGhpcy5lbGVtZW50cyA9IG5ldyBGbG9hdDMyQXJyYXkoIFtcblxuICAgIFx0XHQxLCAwLCAwLFxuICAgIFx0XHQwLCAxLCAwLFxuICAgIFx0XHQwLCAwLCAxXG5cbiAgICBcdF0gKTtcblxuICAgIFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID4gMCApIHtcblxuICAgIFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuTWF0cml4MzogdGhlIGNvbnN0cnVjdG9yIG5vIGxvbmdlciByZWFkcyBhcmd1bWVudHMuIHVzZSAuc2V0KCkgaW5zdGVhZC4nICk7XG5cbiAgICBcdH1cblxuICAgIH1cblxuICAgIE1hdHJpeDMucHJvdG90eXBlID0ge1xuXG4gICAgXHRjb25zdHJ1Y3RvcjogTWF0cml4MyxcblxuICAgIFx0aXNNYXRyaXgzOiB0cnVlLFxuXG4gICAgXHRzZXQ6IGZ1bmN0aW9uICggbjExLCBuMTIsIG4xMywgbjIxLCBuMjIsIG4yMywgbjMxLCBuMzIsIG4zMyApIHtcblxuICAgIFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG4gICAgXHRcdHRlWyAwIF0gPSBuMTE7IHRlWyAxIF0gPSBuMjE7IHRlWyAyIF0gPSBuMzE7XG4gICAgXHRcdHRlWyAzIF0gPSBuMTI7IHRlWyA0IF0gPSBuMjI7IHRlWyA1IF0gPSBuMzI7XG4gICAgXHRcdHRlWyA2IF0gPSBuMTM7IHRlWyA3IF0gPSBuMjM7IHRlWyA4IF0gPSBuMzM7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGlkZW50aXR5OiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dGhpcy5zZXQoXG5cbiAgICBcdFx0XHQxLCAwLCAwLFxuICAgIFx0XHRcdDAsIDEsIDAsXG4gICAgXHRcdFx0MCwgMCwgMVxuXG4gICAgXHRcdCk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuZnJvbUFycmF5KCB0aGlzLmVsZW1lbnRzICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGNvcHk6IGZ1bmN0aW9uICggbSApIHtcblxuICAgIFx0XHR2YXIgbWUgPSBtLmVsZW1lbnRzO1xuXG4gICAgXHRcdHRoaXMuc2V0KFxuXG4gICAgXHRcdFx0bWVbIDAgXSwgbWVbIDMgXSwgbWVbIDYgXSxcbiAgICBcdFx0XHRtZVsgMSBdLCBtZVsgNCBdLCBtZVsgNyBdLFxuICAgIFx0XHRcdG1lWyAyIF0sIG1lWyA1IF0sIG1lWyA4IF1cblxuICAgIFx0XHQpO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRzZXRGcm9tTWF0cml4NDogZnVuY3Rpb24oIG0gKSB7XG5cbiAgICBcdFx0dmFyIG1lID0gbS5lbGVtZW50cztcblxuICAgIFx0XHR0aGlzLnNldChcblxuICAgIFx0XHRcdG1lWyAwIF0sIG1lWyA0IF0sIG1lWyAgOCBdLFxuICAgIFx0XHRcdG1lWyAxIF0sIG1lWyA1IF0sIG1lWyAgOSBdLFxuICAgIFx0XHRcdG1lWyAyIF0sIG1lWyA2IF0sIG1lWyAxMCBdXG5cbiAgICBcdFx0KTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0YXBwbHlUb1ZlY3RvcjNBcnJheTogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHZhciB2MTtcblxuICAgIFx0XHRyZXR1cm4gZnVuY3Rpb24gYXBwbHlUb1ZlY3RvcjNBcnJheSggYXJyYXksIG9mZnNldCwgbGVuZ3RoICkge1xuXG4gICAgXHRcdFx0aWYgKCB2MSA9PT0gdW5kZWZpbmVkICkgdjEgPSBuZXcgVmVjdG9yMygpO1xuICAgIFx0XHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuICAgIFx0XHRcdGlmICggbGVuZ3RoID09PSB1bmRlZmluZWQgKSBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICBcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGogPSBvZmZzZXQ7IGkgPCBsZW5ndGg7IGkgKz0gMywgaiArPSAzICkge1xuXG4gICAgXHRcdFx0XHR2MS5mcm9tQXJyYXkoIGFycmF5LCBqICk7XG4gICAgXHRcdFx0XHR2MS5hcHBseU1hdHJpeDMoIHRoaXMgKTtcbiAgICBcdFx0XHRcdHYxLnRvQXJyYXkoIGFycmF5LCBqICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRyZXR1cm4gYXJyYXk7XG5cbiAgICBcdFx0fTtcblxuICAgIFx0fSgpLFxuXG4gICAgXHRhcHBseVRvQnVmZmVyOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dmFyIHYxO1xuXG4gICAgXHRcdHJldHVybiBmdW5jdGlvbiBhcHBseVRvQnVmZmVyKCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoICkge1xuXG4gICAgXHRcdFx0aWYgKCB2MSA9PT0gdW5kZWZpbmVkICkgdjEgPSBuZXcgVmVjdG9yMygpO1xuICAgIFx0XHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuICAgIFx0XHRcdGlmICggbGVuZ3RoID09PSB1bmRlZmluZWQgKSBsZW5ndGggPSBidWZmZXIubGVuZ3RoIC8gYnVmZmVyLml0ZW1TaXplO1xuXG4gICAgXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBqID0gb2Zmc2V0OyBpIDwgbGVuZ3RoOyBpICsrLCBqICsrICkge1xuXG4gICAgXHRcdFx0XHR2MS54ID0gYnVmZmVyLmdldFgoIGogKTtcbiAgICBcdFx0XHRcdHYxLnkgPSBidWZmZXIuZ2V0WSggaiApO1xuICAgIFx0XHRcdFx0djEueiA9IGJ1ZmZlci5nZXRaKCBqICk7XG5cbiAgICBcdFx0XHRcdHYxLmFwcGx5TWF0cml4MyggdGhpcyApO1xuXG4gICAgXHRcdFx0XHRidWZmZXIuc2V0WFlaKCB2MS54LCB2MS55LCB2MS56ICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRyZXR1cm4gYnVmZmVyO1xuXG4gICAgXHRcdH07XG5cbiAgICBcdH0oKSxcblxuICAgIFx0bXVsdGlwbHlTY2FsYXI6IGZ1bmN0aW9uICggcyApIHtcblxuICAgIFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG4gICAgXHRcdHRlWyAwIF0gKj0gczsgdGVbIDMgXSAqPSBzOyB0ZVsgNiBdICo9IHM7XG4gICAgXHRcdHRlWyAxIF0gKj0gczsgdGVbIDQgXSAqPSBzOyB0ZVsgNyBdICo9IHM7XG4gICAgXHRcdHRlWyAyIF0gKj0gczsgdGVbIDUgXSAqPSBzOyB0ZVsgOCBdICo9IHM7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGRldGVybWluYW50OiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuICAgIFx0XHR2YXIgYSA9IHRlWyAwIF0sIGIgPSB0ZVsgMSBdLCBjID0gdGVbIDIgXSxcbiAgICBcdFx0XHRkID0gdGVbIDMgXSwgZSA9IHRlWyA0IF0sIGYgPSB0ZVsgNSBdLFxuICAgIFx0XHRcdGcgPSB0ZVsgNiBdLCBoID0gdGVbIDcgXSwgaSA9IHRlWyA4IF07XG5cbiAgICBcdFx0cmV0dXJuIGEgKiBlICogaSAtIGEgKiBmICogaCAtIGIgKiBkICogaSArIGIgKiBmICogZyArIGMgKiBkICogaCAtIGMgKiBlICogZztcblxuICAgIFx0fSxcblxuICAgIFx0Z2V0SW52ZXJzZTogZnVuY3Rpb24gKCBtYXRyaXgsIHRocm93T25EZWdlbmVyYXRlICkge1xuXG4gICAgXHRcdGlmICggKG1hdHJpeCAmJiBtYXRyaXguaXNNYXRyaXg0KSApIHtcblxuICAgIFx0XHRcdGNvbnNvbGUuZXJyb3IoIFwiVEhSRUUuTWF0cml4My5nZXRJbnZlcnNlIG5vIGxvbmdlciB0YWtlcyBhIE1hdHJpeDQgYXJndW1lbnQuXCIgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0dmFyIG1lID0gbWF0cml4LmVsZW1lbnRzLFxuICAgIFx0XHRcdHRlID0gdGhpcy5lbGVtZW50cyxcblxuICAgIFx0XHRcdG4xMSA9IG1lWyAwIF0sIG4yMSA9IG1lWyAxIF0sIG4zMSA9IG1lWyAyIF0sXG4gICAgXHRcdFx0bjEyID0gbWVbIDMgXSwgbjIyID0gbWVbIDQgXSwgbjMyID0gbWVbIDUgXSxcbiAgICBcdFx0XHRuMTMgPSBtZVsgNiBdLCBuMjMgPSBtZVsgNyBdLCBuMzMgPSBtZVsgOCBdLFxuXG4gICAgXHRcdFx0dDExID0gbjMzICogbjIyIC0gbjMyICogbjIzLFxuICAgIFx0XHRcdHQxMiA9IG4zMiAqIG4xMyAtIG4zMyAqIG4xMixcbiAgICBcdFx0XHR0MTMgPSBuMjMgKiBuMTIgLSBuMjIgKiBuMTMsXG5cbiAgICBcdFx0XHRkZXQgPSBuMTEgKiB0MTEgKyBuMjEgKiB0MTIgKyBuMzEgKiB0MTM7XG5cbiAgICBcdFx0aWYgKCBkZXQgPT09IDAgKSB7XG5cbiAgICBcdFx0XHR2YXIgbXNnID0gXCJUSFJFRS5NYXRyaXgzLmdldEludmVyc2UoKTogY2FuJ3QgaW52ZXJ0IG1hdHJpeCwgZGV0ZXJtaW5hbnQgaXMgMFwiO1xuXG4gICAgXHRcdFx0aWYgKCB0aHJvd09uRGVnZW5lcmF0ZSA9PT0gdHJ1ZSApIHtcblxuICAgIFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBtc2cgKTtcblxuICAgIFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdGNvbnNvbGUud2FybiggbXNnICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRyZXR1cm4gdGhpcy5pZGVudGl0eSgpO1xuICAgIFx0XHR9XG5cbiAgICBcdFx0dmFyIGRldEludiA9IDEgLyBkZXQ7XG5cbiAgICBcdFx0dGVbIDAgXSA9IHQxMSAqIGRldEludjtcbiAgICBcdFx0dGVbIDEgXSA9ICggbjMxICogbjIzIC0gbjMzICogbjIxICkgKiBkZXRJbnY7XG4gICAgXHRcdHRlWyAyIF0gPSAoIG4zMiAqIG4yMSAtIG4zMSAqIG4yMiApICogZGV0SW52O1xuXG4gICAgXHRcdHRlWyAzIF0gPSB0MTIgKiBkZXRJbnY7XG4gICAgXHRcdHRlWyA0IF0gPSAoIG4zMyAqIG4xMSAtIG4zMSAqIG4xMyApICogZGV0SW52O1xuICAgIFx0XHR0ZVsgNSBdID0gKCBuMzEgKiBuMTIgLSBuMzIgKiBuMTEgKSAqIGRldEludjtcblxuICAgIFx0XHR0ZVsgNiBdID0gdDEzICogZGV0SW52O1xuICAgIFx0XHR0ZVsgNyBdID0gKCBuMjEgKiBuMTMgLSBuMjMgKiBuMTEgKSAqIGRldEludjtcbiAgICBcdFx0dGVbIDggXSA9ICggbjIyICogbjExIC0gbjIxICogbjEyICkgKiBkZXRJbnY7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdHRyYW5zcG9zZTogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHZhciB0bXAsIG0gPSB0aGlzLmVsZW1lbnRzO1xuXG4gICAgXHRcdHRtcCA9IG1bIDEgXTsgbVsgMSBdID0gbVsgMyBdOyBtWyAzIF0gPSB0bXA7XG4gICAgXHRcdHRtcCA9IG1bIDIgXTsgbVsgMiBdID0gbVsgNiBdOyBtWyA2IF0gPSB0bXA7XG4gICAgXHRcdHRtcCA9IG1bIDUgXTsgbVsgNSBdID0gbVsgNyBdOyBtWyA3IF0gPSB0bXA7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGZsYXR0ZW5Ub0FycmF5T2Zmc2V0OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XG5cbiAgICBcdFx0Y29uc29sZS53YXJuKCBcIlRIUkVFLk1hdHJpeDM6IC5mbGF0dGVuVG9BcnJheU9mZnNldCBpcyBkZXByZWNhdGVkIFwiICtcbiAgICBcdFx0XHRcdFwiLSBqdXN0IHVzZSAudG9BcnJheSBpbnN0ZWFkLlwiICk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMudG9BcnJheSggYXJyYXksIG9mZnNldCApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRnZXROb3JtYWxNYXRyaXg6IGZ1bmN0aW9uICggbWF0cml4NCApIHtcblxuICAgIFx0XHRyZXR1cm4gdGhpcy5zZXRGcm9tTWF0cml4NCggbWF0cml4NCApLmdldEludmVyc2UoIHRoaXMgKS50cmFuc3Bvc2UoKTtcblxuICAgIFx0fSxcblxuICAgIFx0dHJhbnNwb3NlSW50b0FycmF5OiBmdW5jdGlvbiAoIHIgKSB7XG5cbiAgICBcdFx0dmFyIG0gPSB0aGlzLmVsZW1lbnRzO1xuXG4gICAgXHRcdHJbIDAgXSA9IG1bIDAgXTtcbiAgICBcdFx0clsgMSBdID0gbVsgMyBdO1xuICAgIFx0XHRyWyAyIF0gPSBtWyA2IF07XG4gICAgXHRcdHJbIDMgXSA9IG1bIDEgXTtcbiAgICBcdFx0clsgNCBdID0gbVsgNCBdO1xuICAgIFx0XHRyWyA1IF0gPSBtWyA3IF07XG4gICAgXHRcdHJbIDYgXSA9IG1bIDIgXTtcbiAgICBcdFx0clsgNyBdID0gbVsgNSBdO1xuICAgIFx0XHRyWyA4IF0gPSBtWyA4IF07XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGZyb21BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xuXG4gICAgXHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG4gICAgXHRcdGZvciggdmFyIGkgPSAwOyBpIDwgOTsgaSArKyApIHtcblxuICAgIFx0XHRcdHRoaXMuZWxlbWVudHNbIGkgXSA9IGFycmF5WyBpICsgb2Zmc2V0IF07XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHR0b0FycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XG5cbiAgICBcdFx0aWYgKCBhcnJheSA9PT0gdW5kZWZpbmVkICkgYXJyYXkgPSBbXTtcbiAgICBcdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cbiAgICBcdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuICAgIFx0XHRhcnJheVsgb2Zmc2V0IF0gPSB0ZVsgMCBdO1xuICAgIFx0XHRhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGVbIDEgXTtcbiAgICBcdFx0YXJyYXlbIG9mZnNldCArIDIgXSA9IHRlWyAyIF07XG5cbiAgICBcdFx0YXJyYXlbIG9mZnNldCArIDMgXSA9IHRlWyAzIF07XG4gICAgXHRcdGFycmF5WyBvZmZzZXQgKyA0IF0gPSB0ZVsgNCBdO1xuICAgIFx0XHRhcnJheVsgb2Zmc2V0ICsgNSBdID0gdGVbIDUgXTtcblxuICAgIFx0XHRhcnJheVsgb2Zmc2V0ICsgNiBdID0gdGVbIDYgXTtcbiAgICBcdFx0YXJyYXlbIG9mZnNldCArIDcgXSA9IHRlWyA3IF07XG4gICAgXHRcdGFycmF5WyBvZmZzZXQgKyA4IF0gID0gdGVbIDggXTtcblxuICAgIFx0XHRyZXR1cm4gYXJyYXk7XG5cbiAgICBcdH1cblxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBQbGFuZSggbm9ybWFsLCBjb25zdGFudCApIHtcblxuICAgIFx0dGhpcy5ub3JtYWwgPSAoIG5vcm1hbCAhPT0gdW5kZWZpbmVkICkgPyBub3JtYWwgOiBuZXcgVmVjdG9yMyggMSwgMCwgMCApO1xuICAgIFx0dGhpcy5jb25zdGFudCA9ICggY29uc3RhbnQgIT09IHVuZGVmaW5lZCApID8gY29uc3RhbnQgOiAwO1xuXG4gICAgfVxuXG4gICAgUGxhbmUucHJvdG90eXBlID0ge1xuXG4gICAgXHRjb25zdHJ1Y3RvcjogUGxhbmUsXG5cbiAgICBcdHNldDogZnVuY3Rpb24gKCBub3JtYWwsIGNvbnN0YW50ICkge1xuXG4gICAgXHRcdHRoaXMubm9ybWFsLmNvcHkoIG5vcm1hbCApO1xuICAgIFx0XHR0aGlzLmNvbnN0YW50ID0gY29uc3RhbnQ7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldENvbXBvbmVudHM6IGZ1bmN0aW9uICggeCwgeSwgeiwgdyApIHtcblxuICAgIFx0XHR0aGlzLm5vcm1hbC5zZXQoIHgsIHksIHogKTtcbiAgICBcdFx0dGhpcy5jb25zdGFudCA9IHc7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldEZyb21Ob3JtYWxBbmRDb3BsYW5hclBvaW50OiBmdW5jdGlvbiAoIG5vcm1hbCwgcG9pbnQgKSB7XG5cbiAgICBcdFx0dGhpcy5ub3JtYWwuY29weSggbm9ybWFsICk7XG4gICAgXHRcdHRoaXMuY29uc3RhbnQgPSAtIHBvaW50LmRvdCggdGhpcy5ub3JtYWwgKTtcdC8vIG11c3QgYmUgdGhpcy5ub3JtYWwsIG5vdCBub3JtYWwsIGFzIHRoaXMubm9ybWFsIGlzIG5vcm1hbGl6ZWRcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0c2V0RnJvbUNvcGxhbmFyUG9pbnRzOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoKTtcbiAgICBcdFx0dmFyIHYyID0gbmV3IFZlY3RvcjMoKTtcblxuICAgIFx0XHRyZXR1cm4gZnVuY3Rpb24gc2V0RnJvbUNvcGxhbmFyUG9pbnRzKCBhLCBiLCBjICkge1xuXG4gICAgXHRcdFx0dmFyIG5vcm1hbCA9IHYxLnN1YlZlY3RvcnMoIGMsIGIgKS5jcm9zcyggdjIuc3ViVmVjdG9ycyggYSwgYiApICkubm9ybWFsaXplKCk7XG5cbiAgICBcdFx0XHQvLyBROiBzaG91bGQgYW4gZXJyb3IgYmUgdGhyb3duIGlmIG5vcm1hbCBpcyB6ZXJvIChlLmcuIGRlZ2VuZXJhdGUgcGxhbmUpP1xuXG4gICAgXHRcdFx0dGhpcy5zZXRGcm9tTm9ybWFsQW5kQ29wbGFuYXJQb2ludCggbm9ybWFsLCBhICk7XG5cbiAgICBcdFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0XHR9O1xuXG4gICAgXHR9KCksXG5cbiAgICBcdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRjb3B5OiBmdW5jdGlvbiAoIHBsYW5lICkge1xuXG4gICAgXHRcdHRoaXMubm9ybWFsLmNvcHkoIHBsYW5lLm5vcm1hbCApO1xuICAgIFx0XHR0aGlzLmNvbnN0YW50ID0gcGxhbmUuY29uc3RhbnQ7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdG5vcm1hbGl6ZTogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdC8vIE5vdGU6IHdpbGwgbGVhZCB0byBhIGRpdmlkZSBieSB6ZXJvIGlmIHRoZSBwbGFuZSBpcyBpbnZhbGlkLlxuXG4gICAgXHRcdHZhciBpbnZlcnNlTm9ybWFsTGVuZ3RoID0gMS4wIC8gdGhpcy5ub3JtYWwubGVuZ3RoKCk7XG4gICAgXHRcdHRoaXMubm9ybWFsLm11bHRpcGx5U2NhbGFyKCBpbnZlcnNlTm9ybWFsTGVuZ3RoICk7XG4gICAgXHRcdHRoaXMuY29uc3RhbnQgKj0gaW52ZXJzZU5vcm1hbExlbmd0aDtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0bmVnYXRlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dGhpcy5jb25zdGFudCAqPSAtIDE7XG4gICAgXHRcdHRoaXMubm9ybWFsLm5lZ2F0ZSgpO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRkaXN0YW5jZVRvUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMubm9ybWFsLmRvdCggcG9pbnQgKSArIHRoaXMuY29uc3RhbnQ7XG5cbiAgICBcdH0sXG5cbiAgICBcdGRpc3RhbmNlVG9TcGhlcmU6IGZ1bmN0aW9uICggc3BoZXJlICkge1xuXG4gICAgXHRcdHJldHVybiB0aGlzLmRpc3RhbmNlVG9Qb2ludCggc3BoZXJlLmNlbnRlciApIC0gc3BoZXJlLnJhZGl1cztcblxuICAgIFx0fSxcblxuICAgIFx0cHJvamVjdFBvaW50OiBmdW5jdGlvbiAoIHBvaW50LCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgIFx0XHRyZXR1cm4gdGhpcy5vcnRob1BvaW50KCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKS5zdWIoIHBvaW50ICkubmVnYXRlKCk7XG5cbiAgICBcdH0sXG5cbiAgICBcdG9ydGhvUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgXHRcdHZhciBwZXJwZW5kaWN1bGFyTWFnbml0dWRlID0gdGhpcy5kaXN0YW5jZVRvUG9pbnQoIHBvaW50ICk7XG5cbiAgICBcdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IzKCk7XG4gICAgXHRcdHJldHVybiByZXN1bHQuY29weSggdGhpcy5ub3JtYWwgKS5tdWx0aXBseVNjYWxhciggcGVycGVuZGljdWxhck1hZ25pdHVkZSApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRpbnRlcnNlY3RMaW5lOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoKTtcblxuICAgIFx0XHRyZXR1cm4gZnVuY3Rpb24gaW50ZXJzZWN0TGluZSggbGluZSwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICBcdFx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjMoKTtcblxuICAgIFx0XHRcdHZhciBkaXJlY3Rpb24gPSBsaW5lLmRlbHRhKCB2MSApO1xuXG4gICAgXHRcdFx0dmFyIGRlbm9taW5hdG9yID0gdGhpcy5ub3JtYWwuZG90KCBkaXJlY3Rpb24gKTtcblxuICAgIFx0XHRcdGlmICggZGVub21pbmF0b3IgPT09IDAgKSB7XG5cbiAgICBcdFx0XHRcdC8vIGxpbmUgaXMgY29wbGFuYXIsIHJldHVybiBvcmlnaW5cbiAgICBcdFx0XHRcdGlmICggdGhpcy5kaXN0YW5jZVRvUG9pbnQoIGxpbmUuc3RhcnQgKSA9PT0gMCApIHtcblxuICAgIFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0LmNvcHkoIGxpbmUuc3RhcnQgKTtcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHQvLyBVbnN1cmUgaWYgdGhpcyBpcyB0aGUgY29ycmVjdCBtZXRob2QgdG8gaGFuZGxlIHRoaXMgY2FzZS5cbiAgICBcdFx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHR2YXIgdCA9IC0gKCBsaW5lLnN0YXJ0LmRvdCggdGhpcy5ub3JtYWwgKSArIHRoaXMuY29uc3RhbnQgKSAvIGRlbm9taW5hdG9yO1xuXG4gICAgXHRcdFx0aWYgKCB0IDwgMCB8fCB0ID4gMSApIHtcblxuICAgIFx0XHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdHJldHVybiByZXN1bHQuY29weSggZGlyZWN0aW9uICkubXVsdGlwbHlTY2FsYXIoIHQgKS5hZGQoIGxpbmUuc3RhcnQgKTtcblxuICAgIFx0XHR9O1xuXG4gICAgXHR9KCksXG5cbiAgICBcdGludGVyc2VjdHNMaW5lOiBmdW5jdGlvbiAoIGxpbmUgKSB7XG5cbiAgICBcdFx0Ly8gTm90ZTogdGhpcyB0ZXN0cyBpZiBhIGxpbmUgaW50ZXJzZWN0cyB0aGUgcGxhbmUsIG5vdCB3aGV0aGVyIGl0IChvciBpdHMgZW5kLXBvaW50cykgYXJlIGNvcGxhbmFyIHdpdGggaXQuXG5cbiAgICBcdFx0dmFyIHN0YXJ0U2lnbiA9IHRoaXMuZGlzdGFuY2VUb1BvaW50KCBsaW5lLnN0YXJ0ICk7XG4gICAgXHRcdHZhciBlbmRTaWduID0gdGhpcy5kaXN0YW5jZVRvUG9pbnQoIGxpbmUuZW5kICk7XG5cbiAgICBcdFx0cmV0dXJuICggc3RhcnRTaWduIDwgMCAmJiBlbmRTaWduID4gMCApIHx8ICggZW5kU2lnbiA8IDAgJiYgc3RhcnRTaWduID4gMCApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRpbnRlcnNlY3RzQm94OiBmdW5jdGlvbiAoIGJveCApIHtcblxuICAgIFx0XHRyZXR1cm4gYm94LmludGVyc2VjdHNQbGFuZSggdGhpcyApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRpbnRlcnNlY3RzU3BoZXJlOiBmdW5jdGlvbiAoIHNwaGVyZSApIHtcblxuICAgIFx0XHRyZXR1cm4gc3BoZXJlLmludGVyc2VjdHNQbGFuZSggdGhpcyApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRjb3BsYW5hclBvaW50OiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgXHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMygpO1xuICAgIFx0XHRyZXR1cm4gcmVzdWx0LmNvcHkoIHRoaXMubm9ybWFsICkubXVsdGlwbHlTY2FsYXIoIC0gdGhpcy5jb25zdGFudCApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRhcHBseU1hdHJpeDQ6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR2YXIgdjEgPSBuZXcgVmVjdG9yMygpO1xuICAgIFx0XHR2YXIgbTEgPSBuZXcgTWF0cml4MygpO1xuXG4gICAgXHRcdHJldHVybiBmdW5jdGlvbiBhcHBseU1hdHJpeDQoIG1hdHJpeCwgb3B0aW9uYWxOb3JtYWxNYXRyaXggKSB7XG5cbiAgICBcdFx0XHR2YXIgcmVmZXJlbmNlUG9pbnQgPSB0aGlzLmNvcGxhbmFyUG9pbnQoIHYxICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTtcblxuICAgIFx0XHRcdC8vIHRyYW5zZm9ybSBub3JtYWwgYmFzZWQgb24gdGhlb3J5IGhlcmU6XG4gICAgXHRcdFx0Ly8gaHR0cDovL3d3dy5zb25naG8uY2Evb3BlbmdsL2dsX25vcm1hbHRyYW5zZm9ybS5odG1sXG4gICAgXHRcdFx0dmFyIG5vcm1hbE1hdHJpeCA9IG9wdGlvbmFsTm9ybWFsTWF0cml4IHx8IG0xLmdldE5vcm1hbE1hdHJpeCggbWF0cml4ICk7XG4gICAgXHRcdFx0dmFyIG5vcm1hbCA9IHRoaXMubm9ybWFsLmFwcGx5TWF0cml4Myggbm9ybWFsTWF0cml4ICkubm9ybWFsaXplKCk7XG5cbiAgICBcdFx0XHQvLyByZWNhbGN1bGF0ZSBjb25zdGFudCAobGlrZSBpbiBzZXRGcm9tTm9ybWFsQW5kQ29wbGFuYXJQb2ludClcbiAgICBcdFx0XHR0aGlzLmNvbnN0YW50ID0gLSByZWZlcmVuY2VQb2ludC5kb3QoIG5vcm1hbCApO1xuXG4gICAgXHRcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdFx0fTtcblxuICAgIFx0fSgpLFxuXG4gICAgXHR0cmFuc2xhdGU6IGZ1bmN0aW9uICggb2Zmc2V0ICkge1xuXG4gICAgXHRcdHRoaXMuY29uc3RhbnQgPSB0aGlzLmNvbnN0YW50IC0gb2Zmc2V0LmRvdCggdGhpcy5ub3JtYWwgKTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0ZXF1YWxzOiBmdW5jdGlvbiAoIHBsYW5lICkge1xuXG4gICAgXHRcdHJldHVybiBwbGFuZS5ub3JtYWwuZXF1YWxzKCB0aGlzLm5vcm1hbCApICYmICggcGxhbmUuY29uc3RhbnQgPT09IHRoaXMuY29uc3RhbnQgKTtcblxuICAgIFx0fVxuXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gICAgICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAgICAgKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBGcnVzdHVtKCBwMCwgcDEsIHAyLCBwMywgcDQsIHA1ICkge1xuXG4gICAgXHR0aGlzLnBsYW5lcyA9IFtcblxuICAgIFx0XHQoIHAwICE9PSB1bmRlZmluZWQgKSA/IHAwIDogbmV3IFBsYW5lKCksXG4gICAgXHRcdCggcDEgIT09IHVuZGVmaW5lZCApID8gcDEgOiBuZXcgUGxhbmUoKSxcbiAgICBcdFx0KCBwMiAhPT0gdW5kZWZpbmVkICkgPyBwMiA6IG5ldyBQbGFuZSgpLFxuICAgIFx0XHQoIHAzICE9PSB1bmRlZmluZWQgKSA/IHAzIDogbmV3IFBsYW5lKCksXG4gICAgXHRcdCggcDQgIT09IHVuZGVmaW5lZCApID8gcDQgOiBuZXcgUGxhbmUoKSxcbiAgICBcdFx0KCBwNSAhPT0gdW5kZWZpbmVkICkgPyBwNSA6IG5ldyBQbGFuZSgpXG5cbiAgICBcdF07XG5cbiAgICB9XG5cbiAgICBGcnVzdHVtLnByb3RvdHlwZSA9IHtcblxuICAgIFx0Y29uc3RydWN0b3I6IEZydXN0dW0sXG5cbiAgICBcdHNldDogZnVuY3Rpb24gKCBwMCwgcDEsIHAyLCBwMywgcDQsIHA1ICkge1xuXG4gICAgXHRcdHZhciBwbGFuZXMgPSB0aGlzLnBsYW5lcztcblxuICAgIFx0XHRwbGFuZXNbIDAgXS5jb3B5KCBwMCApO1xuICAgIFx0XHRwbGFuZXNbIDEgXS5jb3B5KCBwMSApO1xuICAgIFx0XHRwbGFuZXNbIDIgXS5jb3B5KCBwMiApO1xuICAgIFx0XHRwbGFuZXNbIDMgXS5jb3B5KCBwMyApO1xuICAgIFx0XHRwbGFuZXNbIDQgXS5jb3B5KCBwNCApO1xuICAgIFx0XHRwbGFuZXNbIDUgXS5jb3B5KCBwNSApO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblxuICAgIFx0fSxcblxuICAgIFx0Y29weTogZnVuY3Rpb24gKCBmcnVzdHVtICkge1xuXG4gICAgXHRcdHZhciBwbGFuZXMgPSB0aGlzLnBsYW5lcztcblxuICAgIFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCA2OyBpICsrICkge1xuXG4gICAgXHRcdFx0cGxhbmVzWyBpIF0uY29weSggZnJ1c3R1bS5wbGFuZXNbIGkgXSApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0c2V0RnJvbU1hdHJpeDogZnVuY3Rpb24gKCBtICkge1xuXG4gICAgXHRcdHZhciBwbGFuZXMgPSB0aGlzLnBsYW5lcztcbiAgICBcdFx0dmFyIG1lID0gbS5lbGVtZW50cztcbiAgICBcdFx0dmFyIG1lMCA9IG1lWyAwIF0sIG1lMSA9IG1lWyAxIF0sIG1lMiA9IG1lWyAyIF0sIG1lMyA9IG1lWyAzIF07XG4gICAgXHRcdHZhciBtZTQgPSBtZVsgNCBdLCBtZTUgPSBtZVsgNSBdLCBtZTYgPSBtZVsgNiBdLCBtZTcgPSBtZVsgNyBdO1xuICAgIFx0XHR2YXIgbWU4ID0gbWVbIDggXSwgbWU5ID0gbWVbIDkgXSwgbWUxMCA9IG1lWyAxMCBdLCBtZTExID0gbWVbIDExIF07XG4gICAgXHRcdHZhciBtZTEyID0gbWVbIDEyIF0sIG1lMTMgPSBtZVsgMTMgXSwgbWUxNCA9IG1lWyAxNCBdLCBtZTE1ID0gbWVbIDE1IF07XG5cbiAgICBcdFx0cGxhbmVzWyAwIF0uc2V0Q29tcG9uZW50cyggbWUzIC0gbWUwLCBtZTcgLSBtZTQsIG1lMTEgLSBtZTgsIG1lMTUgLSBtZTEyICkubm9ybWFsaXplKCk7XG4gICAgXHRcdHBsYW5lc1sgMSBdLnNldENvbXBvbmVudHMoIG1lMyArIG1lMCwgbWU3ICsgbWU0LCBtZTExICsgbWU4LCBtZTE1ICsgbWUxMiApLm5vcm1hbGl6ZSgpO1xuICAgIFx0XHRwbGFuZXNbIDIgXS5zZXRDb21wb25lbnRzKCBtZTMgKyBtZTEsIG1lNyArIG1lNSwgbWUxMSArIG1lOSwgbWUxNSArIG1lMTMgKS5ub3JtYWxpemUoKTtcbiAgICBcdFx0cGxhbmVzWyAzIF0uc2V0Q29tcG9uZW50cyggbWUzIC0gbWUxLCBtZTcgLSBtZTUsIG1lMTEgLSBtZTksIG1lMTUgLSBtZTEzICkubm9ybWFsaXplKCk7XG4gICAgXHRcdHBsYW5lc1sgNCBdLnNldENvbXBvbmVudHMoIG1lMyAtIG1lMiwgbWU3IC0gbWU2LCBtZTExIC0gbWUxMCwgbWUxNSAtIG1lMTQgKS5ub3JtYWxpemUoKTtcbiAgICBcdFx0cGxhbmVzWyA1IF0uc2V0Q29tcG9uZW50cyggbWUzICsgbWUyLCBtZTcgKyBtZTYsIG1lMTEgKyBtZTEwLCBtZTE1ICsgbWUxNCApLm5vcm1hbGl6ZSgpO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRpbnRlcnNlY3RzT2JqZWN0OiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dmFyIHNwaGVyZSA9IG5ldyBTcGhlcmUoKTtcblxuICAgIFx0XHRyZXR1cm4gZnVuY3Rpb24gaW50ZXJzZWN0c09iamVjdCggb2JqZWN0ICkge1xuXG4gICAgXHRcdFx0dmFyIGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5O1xuXG4gICAgXHRcdFx0aWYgKCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCApXG4gICAgXHRcdFx0XHRnZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcblxuICAgIFx0XHRcdHNwaGVyZS5jb3B5KCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSApXG4gICAgXHRcdFx0XHQuYXBwbHlNYXRyaXg0KCBvYmplY3QubWF0cml4V29ybGQgKTtcblxuICAgIFx0XHRcdHJldHVybiB0aGlzLmludGVyc2VjdHNTcGhlcmUoIHNwaGVyZSApO1xuXG4gICAgXHRcdH07XG5cbiAgICBcdH0oKSxcblxuICAgIFx0aW50ZXJzZWN0c1Nwcml0ZTogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHZhciBzcGhlcmUgPSBuZXcgU3BoZXJlKCk7XG5cbiAgICBcdFx0cmV0dXJuIGZ1bmN0aW9uIGludGVyc2VjdHNTcHJpdGUoIHNwcml0ZSApIHtcblxuICAgIFx0XHRcdHNwaGVyZS5jZW50ZXIuc2V0KCAwLCAwLCAwICk7XG4gICAgXHRcdFx0c3BoZXJlLnJhZGl1cyA9IDAuNzA3MTA2NzgxMTg2NTQ3NjtcbiAgICBcdFx0XHRzcGhlcmUuYXBwbHlNYXRyaXg0KCBzcHJpdGUubWF0cml4V29ybGQgKTtcblxuICAgIFx0XHRcdHJldHVybiB0aGlzLmludGVyc2VjdHNTcGhlcmUoIHNwaGVyZSApO1xuXG4gICAgXHRcdH07XG5cbiAgICBcdH0oKSxcblxuICAgIFx0aW50ZXJzZWN0c1NwaGVyZTogZnVuY3Rpb24gKCBzcGhlcmUgKSB7XG5cbiAgICBcdFx0dmFyIHBsYW5lcyA9IHRoaXMucGxhbmVzO1xuICAgIFx0XHR2YXIgY2VudGVyID0gc3BoZXJlLmNlbnRlcjtcbiAgICBcdFx0dmFyIG5lZ1JhZGl1cyA9IC0gc3BoZXJlLnJhZGl1cztcblxuICAgIFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCA2OyBpICsrICkge1xuXG4gICAgXHRcdFx0dmFyIGRpc3RhbmNlID0gcGxhbmVzWyBpIF0uZGlzdGFuY2VUb1BvaW50KCBjZW50ZXIgKTtcblxuICAgIFx0XHRcdGlmICggZGlzdGFuY2UgPCBuZWdSYWRpdXMgKSB7XG5cbiAgICBcdFx0XHRcdHJldHVybiBmYWxzZTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIHRydWU7XG5cbiAgICBcdH0sXG5cbiAgICBcdGludGVyc2VjdHNCb3g6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR2YXIgcDEgPSBuZXcgVmVjdG9yMygpLFxuICAgIFx0XHRcdHAyID0gbmV3IFZlY3RvcjMoKTtcblxuICAgIFx0XHRyZXR1cm4gZnVuY3Rpb24gaW50ZXJzZWN0c0JveCggYm94ICkge1xuXG4gICAgXHRcdFx0dmFyIHBsYW5lcyA9IHRoaXMucGxhbmVzO1xuXG4gICAgXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgNiA7IGkgKysgKSB7XG5cbiAgICBcdFx0XHRcdHZhciBwbGFuZSA9IHBsYW5lc1sgaSBdO1xuXG4gICAgXHRcdFx0XHRwMS54ID0gcGxhbmUubm9ybWFsLnggPiAwID8gYm94Lm1pbi54IDogYm94Lm1heC54O1xuICAgIFx0XHRcdFx0cDIueCA9IHBsYW5lLm5vcm1hbC54ID4gMCA/IGJveC5tYXgueCA6IGJveC5taW4ueDtcbiAgICBcdFx0XHRcdHAxLnkgPSBwbGFuZS5ub3JtYWwueSA+IDAgPyBib3gubWluLnkgOiBib3gubWF4Lnk7XG4gICAgXHRcdFx0XHRwMi55ID0gcGxhbmUubm9ybWFsLnkgPiAwID8gYm94Lm1heC55IDogYm94Lm1pbi55O1xuICAgIFx0XHRcdFx0cDEueiA9IHBsYW5lLm5vcm1hbC56ID4gMCA/IGJveC5taW4ueiA6IGJveC5tYXguejtcbiAgICBcdFx0XHRcdHAyLnogPSBwbGFuZS5ub3JtYWwueiA+IDAgPyBib3gubWF4LnogOiBib3gubWluLno7XG5cbiAgICBcdFx0XHRcdHZhciBkMSA9IHBsYW5lLmRpc3RhbmNlVG9Qb2ludCggcDEgKTtcbiAgICBcdFx0XHRcdHZhciBkMiA9IHBsYW5lLmRpc3RhbmNlVG9Qb2ludCggcDIgKTtcblxuICAgIFx0XHRcdFx0Ly8gaWYgYm90aCBvdXRzaWRlIHBsYW5lLCBubyBpbnRlcnNlY3Rpb25cblxuICAgIFx0XHRcdFx0aWYgKCBkMSA8IDAgJiYgZDIgPCAwICkge1xuXG4gICAgXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0cmV0dXJuIHRydWU7XG5cbiAgICBcdFx0fTtcblxuICAgIFx0fSgpLFxuXG5cbiAgICBcdGNvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XG5cbiAgICBcdFx0dmFyIHBsYW5lcyA9IHRoaXMucGxhbmVzO1xuXG4gICAgXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IDY7IGkgKysgKSB7XG5cbiAgICBcdFx0XHRpZiAoIHBsYW5lc1sgaSBdLmRpc3RhbmNlVG9Qb2ludCggcG9pbnQgKSA8IDAgKSB7XG5cbiAgICBcdFx0XHRcdHJldHVybiBmYWxzZTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIHRydWU7XG5cbiAgICBcdH1cblxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBXZWJHTFNoYWRvd01hcCggX3JlbmRlcmVyLCBfbGlnaHRzLCBfb2JqZWN0cywgY2FwYWJpbGl0aWVzICkge1xuXG4gICAgXHR2YXIgX2dsID0gX3JlbmRlcmVyLmNvbnRleHQsXG4gICAgXHRfc3RhdGUgPSBfcmVuZGVyZXIuc3RhdGUsXG4gICAgXHRfZnJ1c3R1bSA9IG5ldyBGcnVzdHVtKCksXG4gICAgXHRfcHJvalNjcmVlbk1hdHJpeCA9IG5ldyBNYXRyaXg0KCksXG5cbiAgICBcdF9saWdodFNoYWRvd3MgPSBfbGlnaHRzLnNoYWRvd3MsXG5cbiAgICBcdF9zaGFkb3dNYXBTaXplID0gbmV3IFZlY3RvcjIoKSxcbiAgICBcdF9tYXhTaGFkb3dNYXBTaXplID0gbmV3IFZlY3RvcjIoIGNhcGFiaWxpdGllcy5tYXhUZXh0dXJlU2l6ZSwgY2FwYWJpbGl0aWVzLm1heFRleHR1cmVTaXplICksXG5cbiAgICBcdF9sb29rVGFyZ2V0ID0gbmV3IFZlY3RvcjMoKSxcbiAgICBcdF9saWdodFBvc2l0aW9uV29ybGQgPSBuZXcgVmVjdG9yMygpLFxuXG4gICAgXHRfcmVuZGVyTGlzdCA9IFtdLFxuXG4gICAgXHRfTW9ycGhpbmdGbGFnID0gMSxcbiAgICBcdF9Ta2lubmluZ0ZsYWcgPSAyLFxuXG4gICAgXHRfTnVtYmVyT2ZNYXRlcmlhbFZhcmlhbnRzID0gKCBfTW9ycGhpbmdGbGFnIHwgX1NraW5uaW5nRmxhZyApICsgMSxcblxuICAgIFx0X2RlcHRoTWF0ZXJpYWxzID0gbmV3IEFycmF5KCBfTnVtYmVyT2ZNYXRlcmlhbFZhcmlhbnRzICksXG4gICAgXHRfZGlzdGFuY2VNYXRlcmlhbHMgPSBuZXcgQXJyYXkoIF9OdW1iZXJPZk1hdGVyaWFsVmFyaWFudHMgKSxcblxuICAgIFx0X21hdGVyaWFsQ2FjaGUgPSB7fTtcblxuICAgIFx0dmFyIGN1YmVEaXJlY3Rpb25zID0gW1xuICAgIFx0XHRuZXcgVmVjdG9yMyggMSwgMCwgMCApLCBuZXcgVmVjdG9yMyggLSAxLCAwLCAwICksIG5ldyBWZWN0b3IzKCAwLCAwLCAxICksXG4gICAgXHRcdG5ldyBWZWN0b3IzKCAwLCAwLCAtIDEgKSwgbmV3IFZlY3RvcjMoIDAsIDEsIDAgKSwgbmV3IFZlY3RvcjMoIDAsIC0gMSwgMCApXG4gICAgXHRdO1xuXG4gICAgXHR2YXIgY3ViZVVwcyA9IFtcbiAgICBcdFx0bmV3IFZlY3RvcjMoIDAsIDEsIDAgKSwgbmV3IFZlY3RvcjMoIDAsIDEsIDAgKSwgbmV3IFZlY3RvcjMoIDAsIDEsIDAgKSxcbiAgICBcdFx0bmV3IFZlY3RvcjMoIDAsIDEsIDAgKSwgbmV3IFZlY3RvcjMoIDAsIDAsIDEgKSxcdG5ldyBWZWN0b3IzKCAwLCAwLCAtIDEgKVxuICAgIFx0XTtcblxuICAgIFx0dmFyIGN1YmUyRFZpZXdQb3J0cyA9IFtcbiAgICBcdFx0bmV3IFZlY3RvcjQoKSwgbmV3IFZlY3RvcjQoKSwgbmV3IFZlY3RvcjQoKSxcbiAgICBcdFx0bmV3IFZlY3RvcjQoKSwgbmV3IFZlY3RvcjQoKSwgbmV3IFZlY3RvcjQoKVxuICAgIFx0XTtcblxuICAgIFx0Ly8gaW5pdFxuXG4gICAgXHR2YXIgZGVwdGhNYXRlcmlhbFRlbXBsYXRlID0gbmV3IE1lc2hEZXB0aE1hdGVyaWFsKCk7XG4gICAgXHRkZXB0aE1hdGVyaWFsVGVtcGxhdGUuZGVwdGhQYWNraW5nID0gUkdCQURlcHRoUGFja2luZztcbiAgICBcdGRlcHRoTWF0ZXJpYWxUZW1wbGF0ZS5jbGlwcGluZyA9IHRydWU7XG5cbiAgICBcdHZhciBkaXN0YW5jZVNoYWRlciA9IFNoYWRlckxpYlsgXCJkaXN0YW5jZVJHQkFcIiBdO1xuICAgIFx0dmFyIGRpc3RhbmNlVW5pZm9ybXMgPSBleHBvcnRzLlVuaWZvcm1zVXRpbHMuY2xvbmUoIGRpc3RhbmNlU2hhZGVyLnVuaWZvcm1zICk7XG5cbiAgICBcdGZvciAoIHZhciBpID0gMDsgaSAhPT0gX051bWJlck9mTWF0ZXJpYWxWYXJpYW50czsgKysgaSApIHtcblxuICAgIFx0XHR2YXIgdXNlTW9ycGhpbmcgPSAoIGkgJiBfTW9ycGhpbmdGbGFnICkgIT09IDA7XG4gICAgXHRcdHZhciB1c2VTa2lubmluZyA9ICggaSAmIF9Ta2lubmluZ0ZsYWcgKSAhPT0gMDtcblxuICAgIFx0XHR2YXIgZGVwdGhNYXRlcmlhbCA9IGRlcHRoTWF0ZXJpYWxUZW1wbGF0ZS5jbG9uZSgpO1xuICAgIFx0XHRkZXB0aE1hdGVyaWFsLm1vcnBoVGFyZ2V0cyA9IHVzZU1vcnBoaW5nO1xuICAgIFx0XHRkZXB0aE1hdGVyaWFsLnNraW5uaW5nID0gdXNlU2tpbm5pbmc7XG5cbiAgICBcdFx0X2RlcHRoTWF0ZXJpYWxzWyBpIF0gPSBkZXB0aE1hdGVyaWFsO1xuXG4gICAgXHRcdHZhciBkaXN0YW5jZU1hdGVyaWFsID0gbmV3IFNoYWRlck1hdGVyaWFsKCB7XG4gICAgXHRcdFx0ZGVmaW5lczoge1xuICAgIFx0XHRcdFx0J1VTRV9TSEFET1dNQVAnOiAnJ1xuICAgIFx0XHRcdH0sXG4gICAgXHRcdFx0dW5pZm9ybXM6IGRpc3RhbmNlVW5pZm9ybXMsXG4gICAgXHRcdFx0dmVydGV4U2hhZGVyOiBkaXN0YW5jZVNoYWRlci52ZXJ0ZXhTaGFkZXIsXG4gICAgXHRcdFx0ZnJhZ21lbnRTaGFkZXI6IGRpc3RhbmNlU2hhZGVyLmZyYWdtZW50U2hhZGVyLFxuICAgIFx0XHRcdG1vcnBoVGFyZ2V0czogdXNlTW9ycGhpbmcsXG4gICAgXHRcdFx0c2tpbm5pbmc6IHVzZVNraW5uaW5nLFxuICAgIFx0XHRcdGNsaXBwaW5nOiB0cnVlXG4gICAgXHRcdH0gKTtcblxuICAgIFx0XHRfZGlzdGFuY2VNYXRlcmlhbHNbIGkgXSA9IGRpc3RhbmNlTWF0ZXJpYWw7XG5cbiAgICBcdH1cblxuICAgIFx0Ly9cblxuICAgIFx0dmFyIHNjb3BlID0gdGhpcztcblxuICAgIFx0dGhpcy5lbmFibGVkID0gZmFsc2U7XG5cbiAgICBcdHRoaXMuYXV0b1VwZGF0ZSA9IHRydWU7XG4gICAgXHR0aGlzLm5lZWRzVXBkYXRlID0gZmFsc2U7XG5cbiAgICBcdHRoaXMudHlwZSA9IFBDRlNoYWRvd01hcDtcblxuICAgIFx0dGhpcy5yZW5kZXJSZXZlcnNlU2lkZWQgPSB0cnVlO1xuICAgIFx0dGhpcy5yZW5kZXJTaW5nbGVTaWRlZCA9IHRydWU7XG5cbiAgICBcdHRoaXMucmVuZGVyID0gZnVuY3Rpb24gKCBzY2VuZSwgY2FtZXJhICkge1xuXG4gICAgXHRcdGlmICggc2NvcGUuZW5hYmxlZCA9PT0gZmFsc2UgKSByZXR1cm47XG4gICAgXHRcdGlmICggc2NvcGUuYXV0b1VwZGF0ZSA9PT0gZmFsc2UgJiYgc2NvcGUubmVlZHNVcGRhdGUgPT09IGZhbHNlICkgcmV0dXJuO1xuXG4gICAgXHRcdGlmICggX2xpZ2h0U2hhZG93cy5sZW5ndGggPT09IDAgKSByZXR1cm47XG5cbiAgICBcdFx0Ly8gU2V0IEdMIHN0YXRlIGZvciBkZXB0aCBtYXAuXG4gICAgXHRcdF9zdGF0ZS5jbGVhckNvbG9yKCAxLCAxLCAxLCAxICk7XG4gICAgXHRcdF9zdGF0ZS5kaXNhYmxlKCBfZ2wuQkxFTkQgKTtcbiAgICBcdFx0X3N0YXRlLnNldERlcHRoVGVzdCggdHJ1ZSApO1xuICAgIFx0XHRfc3RhdGUuc2V0U2Npc3NvclRlc3QoIGZhbHNlICk7XG5cbiAgICBcdFx0Ly8gcmVuZGVyIGRlcHRoIG1hcFxuXG4gICAgXHRcdHZhciBmYWNlQ291bnQsIGlzUG9pbnRMaWdodDtcblxuICAgIFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gX2xpZ2h0U2hhZG93cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuICAgIFx0XHRcdHZhciBsaWdodCA9IF9saWdodFNoYWRvd3NbIGkgXTtcbiAgICBcdFx0XHR2YXIgc2hhZG93ID0gbGlnaHQuc2hhZG93O1xuXG4gICAgXHRcdFx0aWYgKCBzaGFkb3cgPT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xTaGFkb3dNYXA6JywgbGlnaHQsICdoYXMgbm8gc2hhZG93LicgKTtcbiAgICBcdFx0XHRcdGNvbnRpbnVlO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0dmFyIHNoYWRvd0NhbWVyYSA9IHNoYWRvdy5jYW1lcmE7XG5cbiAgICBcdFx0XHRfc2hhZG93TWFwU2l6ZS5jb3B5KCBzaGFkb3cubWFwU2l6ZSApO1xuICAgIFx0XHRcdF9zaGFkb3dNYXBTaXplLm1pbiggX21heFNoYWRvd01hcFNpemUgKTtcblxuICAgIFx0XHRcdGlmICggKGxpZ2h0ICYmIGxpZ2h0LmlzUG9pbnRMaWdodCkgKSB7XG5cbiAgICBcdFx0XHRcdGZhY2VDb3VudCA9IDY7XG4gICAgXHRcdFx0XHRpc1BvaW50TGlnaHQgPSB0cnVlO1xuXG4gICAgXHRcdFx0XHR2YXIgdnBXaWR0aCA9IF9zaGFkb3dNYXBTaXplLng7XG4gICAgXHRcdFx0XHR2YXIgdnBIZWlnaHQgPSBfc2hhZG93TWFwU2l6ZS55O1xuXG4gICAgXHRcdFx0XHQvLyBUaGVzZSB2aWV3cG9ydHMgbWFwIGEgY3ViZS1tYXAgb250byBhIDJEIHRleHR1cmUgd2l0aCB0aGVcbiAgICBcdFx0XHRcdC8vIGZvbGxvd2luZyBvcmllbnRhdGlvbjpcbiAgICBcdFx0XHRcdC8vXG4gICAgXHRcdFx0XHQvLyAgeHpYWlxuICAgIFx0XHRcdFx0Ly8gICB5IFlcbiAgICBcdFx0XHRcdC8vXG4gICAgXHRcdFx0XHQvLyBYIC0gUG9zaXRpdmUgeCBkaXJlY3Rpb25cbiAgICBcdFx0XHRcdC8vIHggLSBOZWdhdGl2ZSB4IGRpcmVjdGlvblxuICAgIFx0XHRcdFx0Ly8gWSAtIFBvc2l0aXZlIHkgZGlyZWN0aW9uXG4gICAgXHRcdFx0XHQvLyB5IC0gTmVnYXRpdmUgeSBkaXJlY3Rpb25cbiAgICBcdFx0XHRcdC8vIFogLSBQb3NpdGl2ZSB6IGRpcmVjdGlvblxuICAgIFx0XHRcdFx0Ly8geiAtIE5lZ2F0aXZlIHogZGlyZWN0aW9uXG5cbiAgICBcdFx0XHRcdC8vIHBvc2l0aXZlIFhcbiAgICBcdFx0XHRcdGN1YmUyRFZpZXdQb3J0c1sgMCBdLnNldCggdnBXaWR0aCAqIDIsIHZwSGVpZ2h0LCB2cFdpZHRoLCB2cEhlaWdodCApO1xuICAgIFx0XHRcdFx0Ly8gbmVnYXRpdmUgWFxuICAgIFx0XHRcdFx0Y3ViZTJEVmlld1BvcnRzWyAxIF0uc2V0KCAwLCB2cEhlaWdodCwgdnBXaWR0aCwgdnBIZWlnaHQgKTtcbiAgICBcdFx0XHRcdC8vIHBvc2l0aXZlIFpcbiAgICBcdFx0XHRcdGN1YmUyRFZpZXdQb3J0c1sgMiBdLnNldCggdnBXaWR0aCAqIDMsIHZwSGVpZ2h0LCB2cFdpZHRoLCB2cEhlaWdodCApO1xuICAgIFx0XHRcdFx0Ly8gbmVnYXRpdmUgWlxuICAgIFx0XHRcdFx0Y3ViZTJEVmlld1BvcnRzWyAzIF0uc2V0KCB2cFdpZHRoLCB2cEhlaWdodCwgdnBXaWR0aCwgdnBIZWlnaHQgKTtcbiAgICBcdFx0XHRcdC8vIHBvc2l0aXZlIFlcbiAgICBcdFx0XHRcdGN1YmUyRFZpZXdQb3J0c1sgNCBdLnNldCggdnBXaWR0aCAqIDMsIDAsIHZwV2lkdGgsIHZwSGVpZ2h0ICk7XG4gICAgXHRcdFx0XHQvLyBuZWdhdGl2ZSBZXG4gICAgXHRcdFx0XHRjdWJlMkRWaWV3UG9ydHNbIDUgXS5zZXQoIHZwV2lkdGgsIDAsIHZwV2lkdGgsIHZwSGVpZ2h0ICk7XG5cbiAgICBcdFx0XHRcdF9zaGFkb3dNYXBTaXplLnggKj0gNC4wO1xuICAgIFx0XHRcdFx0X3NoYWRvd01hcFNpemUueSAqPSAyLjA7XG5cbiAgICBcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHRmYWNlQ291bnQgPSAxO1xuICAgIFx0XHRcdFx0aXNQb2ludExpZ2h0ID0gZmFsc2U7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRpZiAoIHNoYWRvdy5tYXAgPT09IG51bGwgKSB7XG5cbiAgICBcdFx0XHRcdHZhciBwYXJzID0geyBtaW5GaWx0ZXI6IE5lYXJlc3RGaWx0ZXIsIG1hZ0ZpbHRlcjogTmVhcmVzdEZpbHRlciwgZm9ybWF0OiBSR0JBRm9ybWF0IH07XG5cbiAgICBcdFx0XHRcdHNoYWRvdy5tYXAgPSBuZXcgV2ViR0xSZW5kZXJUYXJnZXQoIF9zaGFkb3dNYXBTaXplLngsIF9zaGFkb3dNYXBTaXplLnksIHBhcnMgKTtcblxuICAgIFx0XHRcdFx0c2hhZG93Q2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdGlmICggKHNoYWRvdyAmJiBzaGFkb3cuaXNTcG90TGlnaHRTaGFkb3cpICkge1xuXG4gICAgXHRcdFx0XHRzaGFkb3cudXBkYXRlKCBsaWdodCApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0dmFyIHNoYWRvd01hcCA9IHNoYWRvdy5tYXA7XG4gICAgXHRcdFx0dmFyIHNoYWRvd01hdHJpeCA9IHNoYWRvdy5tYXRyaXg7XG5cbiAgICBcdFx0XHRfbGlnaHRQb3NpdGlvbldvcmxkLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQubWF0cml4V29ybGQgKTtcbiAgICBcdFx0XHRzaGFkb3dDYW1lcmEucG9zaXRpb24uY29weSggX2xpZ2h0UG9zaXRpb25Xb3JsZCApO1xuXG4gICAgXHRcdFx0X3JlbmRlcmVyLnNldFJlbmRlclRhcmdldCggc2hhZG93TWFwICk7XG4gICAgXHRcdFx0X3JlbmRlcmVyLmNsZWFyKCk7XG5cbiAgICBcdFx0XHQvLyByZW5kZXIgc2hhZG93IG1hcCBmb3IgZWFjaCBjdWJlIGZhY2UgKGlmIG9tbmktZGlyZWN0aW9uYWwpIG9yXG4gICAgXHRcdFx0Ly8gcnVuIGEgc2luZ2xlIHBhc3MgaWYgbm90XG5cbiAgICBcdFx0XHRmb3IgKCB2YXIgZmFjZSA9IDA7IGZhY2UgPCBmYWNlQ291bnQ7IGZhY2UgKysgKSB7XG5cbiAgICBcdFx0XHRcdGlmICggaXNQb2ludExpZ2h0ICkge1xuXG4gICAgXHRcdFx0XHRcdF9sb29rVGFyZ2V0LmNvcHkoIHNoYWRvd0NhbWVyYS5wb3NpdGlvbiApO1xuICAgIFx0XHRcdFx0XHRfbG9va1RhcmdldC5hZGQoIGN1YmVEaXJlY3Rpb25zWyBmYWNlIF0gKTtcbiAgICBcdFx0XHRcdFx0c2hhZG93Q2FtZXJhLnVwLmNvcHkoIGN1YmVVcHNbIGZhY2UgXSApO1xuICAgIFx0XHRcdFx0XHRzaGFkb3dDYW1lcmEubG9va0F0KCBfbG9va1RhcmdldCApO1xuXG4gICAgXHRcdFx0XHRcdHZhciB2cERpbWVuc2lvbnMgPSBjdWJlMkRWaWV3UG9ydHNbIGZhY2UgXTtcbiAgICBcdFx0XHRcdFx0X3N0YXRlLnZpZXdwb3J0KCB2cERpbWVuc2lvbnMgKTtcblxuICAgIFx0XHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0XHRfbG9va1RhcmdldC5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0LnRhcmdldC5tYXRyaXhXb3JsZCApO1xuICAgIFx0XHRcdFx0XHRzaGFkb3dDYW1lcmEubG9va0F0KCBfbG9va1RhcmdldCApO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdHNoYWRvd0NhbWVyYS51cGRhdGVNYXRyaXhXb3JsZCgpO1xuICAgIFx0XHRcdFx0c2hhZG93Q2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZS5nZXRJbnZlcnNlKCBzaGFkb3dDYW1lcmEubWF0cml4V29ybGQgKTtcblxuICAgIFx0XHRcdFx0Ly8gY29tcHV0ZSBzaGFkb3cgbWF0cml4XG5cbiAgICBcdFx0XHRcdHNoYWRvd01hdHJpeC5zZXQoXG4gICAgXHRcdFx0XHRcdDAuNSwgMC4wLCAwLjAsIDAuNSxcbiAgICBcdFx0XHRcdFx0MC4wLCAwLjUsIDAuMCwgMC41LFxuICAgIFx0XHRcdFx0XHQwLjAsIDAuMCwgMC41LCAwLjUsXG4gICAgXHRcdFx0XHRcdDAuMCwgMC4wLCAwLjAsIDEuMFxuICAgIFx0XHRcdFx0KTtcblxuICAgIFx0XHRcdFx0c2hhZG93TWF0cml4Lm11bHRpcGx5KCBzaGFkb3dDYW1lcmEucHJvamVjdGlvbk1hdHJpeCApO1xuICAgIFx0XHRcdFx0c2hhZG93TWF0cml4Lm11bHRpcGx5KCBzaGFkb3dDYW1lcmEubWF0cml4V29ybGRJbnZlcnNlICk7XG5cbiAgICBcdFx0XHRcdC8vIHVwZGF0ZSBjYW1lcmEgbWF0cmljZXMgYW5kIGZydXN0dW1cblxuICAgIFx0XHRcdFx0X3Byb2pTY3JlZW5NYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggc2hhZG93Q2FtZXJhLnByb2plY3Rpb25NYXRyaXgsIHNoYWRvd0NhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UgKTtcbiAgICBcdFx0XHRcdF9mcnVzdHVtLnNldEZyb21NYXRyaXgoIF9wcm9qU2NyZWVuTWF0cml4ICk7XG5cbiAgICBcdFx0XHRcdC8vIHNldCBvYmplY3QgbWF0cmljZXMgJiBmcnVzdHVtIGN1bGxpbmdcblxuICAgIFx0XHRcdFx0X3JlbmRlckxpc3QubGVuZ3RoID0gMDtcblxuICAgIFx0XHRcdFx0cHJvamVjdE9iamVjdCggc2NlbmUsIGNhbWVyYSwgc2hhZG93Q2FtZXJhICk7XG5cbiAgICBcdFx0XHRcdC8vIHJlbmRlciBzaGFkb3cgbWFwXG4gICAgXHRcdFx0XHQvLyByZW5kZXIgcmVndWxhciBvYmplY3RzXG5cbiAgICBcdFx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSBfcmVuZGVyTGlzdC5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuICAgIFx0XHRcdFx0XHR2YXIgb2JqZWN0ID0gX3JlbmRlckxpc3RbIGogXTtcbiAgICBcdFx0XHRcdFx0dmFyIGdlb21ldHJ5ID0gX29iamVjdHMudXBkYXRlKCBvYmplY3QgKTtcbiAgICBcdFx0XHRcdFx0dmFyIG1hdGVyaWFsID0gb2JqZWN0Lm1hdGVyaWFsO1xuXG4gICAgXHRcdFx0XHRcdGlmICggKG1hdGVyaWFsICYmIG1hdGVyaWFsLmlzTXVsdGlNYXRlcmlhbCkgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHR2YXIgZ3JvdXBzID0gZ2VvbWV0cnkuZ3JvdXBzO1xuICAgIFx0XHRcdFx0XHRcdHZhciBtYXRlcmlhbHMgPSBtYXRlcmlhbC5tYXRlcmlhbHM7XG5cbiAgICBcdFx0XHRcdFx0XHRmb3IgKCB2YXIgayA9IDAsIGtsID0gZ3JvdXBzLmxlbmd0aDsgayA8IGtsOyBrICsrICkge1xuXG4gICAgXHRcdFx0XHRcdFx0XHR2YXIgZ3JvdXAgPSBncm91cHNbIGsgXTtcbiAgICBcdFx0XHRcdFx0XHRcdHZhciBncm91cE1hdGVyaWFsID0gbWF0ZXJpYWxzWyBncm91cC5tYXRlcmlhbEluZGV4IF07XG5cbiAgICBcdFx0XHRcdFx0XHRcdGlmICggZ3JvdXBNYXRlcmlhbC52aXNpYmxlID09PSB0cnVlICkge1xuXG4gICAgXHRcdFx0XHRcdFx0XHRcdHZhciBkZXB0aE1hdGVyaWFsID0gZ2V0RGVwdGhNYXRlcmlhbCggb2JqZWN0LCBncm91cE1hdGVyaWFsLCBpc1BvaW50TGlnaHQsIF9saWdodFBvc2l0aW9uV29ybGQgKTtcbiAgICBcdFx0XHRcdFx0XHRcdFx0X3JlbmRlcmVyLnJlbmRlckJ1ZmZlckRpcmVjdCggc2hhZG93Q2FtZXJhLCBudWxsLCBnZW9tZXRyeSwgZGVwdGhNYXRlcmlhbCwgb2JqZWN0LCBncm91cCApO1xuXG4gICAgXHRcdFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0XHRcdHZhciBkZXB0aE1hdGVyaWFsID0gZ2V0RGVwdGhNYXRlcmlhbCggb2JqZWN0LCBtYXRlcmlhbCwgaXNQb2ludExpZ2h0LCBfbGlnaHRQb3NpdGlvbldvcmxkICk7XG4gICAgXHRcdFx0XHRcdFx0X3JlbmRlcmVyLnJlbmRlckJ1ZmZlckRpcmVjdCggc2hhZG93Q2FtZXJhLCBudWxsLCBnZW9tZXRyeSwgZGVwdGhNYXRlcmlhbCwgb2JqZWN0LCBudWxsICk7XG5cbiAgICBcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdC8vIFJlc3RvcmUgR0wgc3RhdGUuXG4gICAgXHRcdHZhciBjbGVhckNvbG9yID0gX3JlbmRlcmVyLmdldENsZWFyQ29sb3IoKSxcbiAgICBcdFx0Y2xlYXJBbHBoYSA9IF9yZW5kZXJlci5nZXRDbGVhckFscGhhKCk7XG4gICAgXHRcdF9yZW5kZXJlci5zZXRDbGVhckNvbG9yKCBjbGVhckNvbG9yLCBjbGVhckFscGhhICk7XG5cbiAgICBcdFx0c2NvcGUubmVlZHNVcGRhdGUgPSBmYWxzZTtcblxuICAgIFx0fTtcblxuICAgIFx0ZnVuY3Rpb24gZ2V0RGVwdGhNYXRlcmlhbCggb2JqZWN0LCBtYXRlcmlhbCwgaXNQb2ludExpZ2h0LCBsaWdodFBvc2l0aW9uV29ybGQgKSB7XG5cbiAgICBcdFx0dmFyIGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5O1xuXG4gICAgXHRcdHZhciByZXN1bHQgPSBudWxsO1xuXG4gICAgXHRcdHZhciBtYXRlcmlhbFZhcmlhbnRzID0gX2RlcHRoTWF0ZXJpYWxzO1xuICAgIFx0XHR2YXIgY3VzdG9tTWF0ZXJpYWwgPSBvYmplY3QuY3VzdG9tRGVwdGhNYXRlcmlhbDtcblxuICAgIFx0XHRpZiAoIGlzUG9pbnRMaWdodCApIHtcblxuICAgIFx0XHRcdG1hdGVyaWFsVmFyaWFudHMgPSBfZGlzdGFuY2VNYXRlcmlhbHM7XG4gICAgXHRcdFx0Y3VzdG9tTWF0ZXJpYWwgPSBvYmplY3QuY3VzdG9tRGlzdGFuY2VNYXRlcmlhbDtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0aWYgKCAhIGN1c3RvbU1hdGVyaWFsICkge1xuXG4gICAgXHRcdFx0dmFyIHVzZU1vcnBoaW5nID0gZmFsc2U7XG5cbiAgICBcdFx0XHRpZiAoIG1hdGVyaWFsLm1vcnBoVGFyZ2V0cyApIHtcblxuICAgIFx0XHRcdFx0aWYgKCAoZ2VvbWV0cnkgJiYgZ2VvbWV0cnkuaXNCdWZmZXJHZW9tZXRyeSkgKSB7XG5cbiAgICBcdFx0XHRcdFx0dXNlTW9ycGhpbmcgPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMgJiYgZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uICYmIGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbi5sZW5ndGggPiAwO1xuXG4gICAgXHRcdFx0XHR9IGVsc2UgaWYgKCAoZ2VvbWV0cnkgJiYgZ2VvbWV0cnkuaXNHZW9tZXRyeSkgKSB7XG5cbiAgICBcdFx0XHRcdFx0dXNlTW9ycGhpbmcgPSBnZW9tZXRyeS5tb3JwaFRhcmdldHMgJiYgZ2VvbWV0cnkubW9ycGhUYXJnZXRzLmxlbmd0aCA+IDA7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdHZhciB1c2VTa2lubmluZyA9IG9iamVjdC5pc1NraW5uZWRNZXNoICYmIG1hdGVyaWFsLnNraW5uaW5nO1xuXG4gICAgXHRcdFx0dmFyIHZhcmlhbnRJbmRleCA9IDA7XG5cbiAgICBcdFx0XHRpZiAoIHVzZU1vcnBoaW5nICkgdmFyaWFudEluZGV4IHw9IF9Nb3JwaGluZ0ZsYWc7XG4gICAgXHRcdFx0aWYgKCB1c2VTa2lubmluZyApIHZhcmlhbnRJbmRleCB8PSBfU2tpbm5pbmdGbGFnO1xuXG4gICAgXHRcdFx0cmVzdWx0ID0gbWF0ZXJpYWxWYXJpYW50c1sgdmFyaWFudEluZGV4IF07XG5cbiAgICBcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdHJlc3VsdCA9IGN1c3RvbU1hdGVyaWFsO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRpZiAoIF9yZW5kZXJlci5sb2NhbENsaXBwaW5nRW5hYmxlZCAmJlxuICAgIFx0XHRcdCBtYXRlcmlhbC5jbGlwU2hhZG93cyA9PT0gdHJ1ZSAmJlxuICAgIFx0XHRcdFx0bWF0ZXJpYWwuY2xpcHBpbmdQbGFuZXMubGVuZ3RoICE9PSAwICkge1xuXG4gICAgXHRcdFx0Ly8gaW4gdGhpcyBjYXNlIHdlIG5lZWQgYSB1bmlxdWUgbWF0ZXJpYWwgaW5zdGFuY2UgcmVmbGVjdGluZyB0aGVcbiAgICBcdFx0XHQvLyBhcHByb3ByaWF0ZSBzdGF0ZVxuXG4gICAgXHRcdFx0dmFyIGtleUEgPSByZXN1bHQudXVpZCwga2V5QiA9IG1hdGVyaWFsLnV1aWQ7XG5cbiAgICBcdFx0XHR2YXIgbWF0ZXJpYWxzRm9yVmFyaWFudCA9IF9tYXRlcmlhbENhY2hlWyBrZXlBIF07XG5cbiAgICBcdFx0XHRpZiAoIG1hdGVyaWFsc0ZvclZhcmlhbnQgPT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0bWF0ZXJpYWxzRm9yVmFyaWFudCA9IHt9O1xuICAgIFx0XHRcdFx0X21hdGVyaWFsQ2FjaGVbIGtleUEgXSA9IG1hdGVyaWFsc0ZvclZhcmlhbnQ7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHR2YXIgY2FjaGVkTWF0ZXJpYWwgPSBtYXRlcmlhbHNGb3JWYXJpYW50WyBrZXlCIF07XG5cbiAgICBcdFx0XHRpZiAoIGNhY2hlZE1hdGVyaWFsID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRcdGNhY2hlZE1hdGVyaWFsID0gcmVzdWx0LmNsb25lKCk7XG4gICAgXHRcdFx0XHRtYXRlcmlhbHNGb3JWYXJpYW50WyBrZXlCIF0gPSBjYWNoZWRNYXRlcmlhbDtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdHJlc3VsdCA9IGNhY2hlZE1hdGVyaWFsO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXN1bHQudmlzaWJsZSA9IG1hdGVyaWFsLnZpc2libGU7XG4gICAgXHRcdHJlc3VsdC53aXJlZnJhbWUgPSBtYXRlcmlhbC53aXJlZnJhbWU7XG5cbiAgICBcdFx0dmFyIHNpZGUgPSBtYXRlcmlhbC5zaWRlO1xuXG4gICAgXHRcdGlmICggc2NvcGUucmVuZGVyU2luZ2xlU2lkZWQgJiYgc2lkZSA9PSBEb3VibGVTaWRlICkge1xuXG4gICAgXHRcdFx0c2lkZSA9IEZyb250U2lkZTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0aWYgKCBzY29wZS5yZW5kZXJSZXZlcnNlU2lkZWQgKSB7XG5cbiAgICBcdFx0XHRpZiAoIHNpZGUgPT09IEZyb250U2lkZSApIHNpZGUgPSBCYWNrU2lkZTtcbiAgICBcdFx0XHRlbHNlIGlmICggc2lkZSA9PT0gQmFja1NpZGUgKSBzaWRlID0gRnJvbnRTaWRlO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXN1bHQuc2lkZSA9IHNpZGU7XG5cbiAgICBcdFx0cmVzdWx0LmNsaXBTaGFkb3dzID0gbWF0ZXJpYWwuY2xpcFNoYWRvd3M7XG4gICAgXHRcdHJlc3VsdC5jbGlwcGluZ1BsYW5lcyA9IG1hdGVyaWFsLmNsaXBwaW5nUGxhbmVzO1xuXG4gICAgXHRcdHJlc3VsdC53aXJlZnJhbWVMaW5ld2lkdGggPSBtYXRlcmlhbC53aXJlZnJhbWVMaW5ld2lkdGg7XG4gICAgXHRcdHJlc3VsdC5saW5ld2lkdGggPSBtYXRlcmlhbC5saW5ld2lkdGg7XG5cbiAgICBcdFx0aWYgKCBpc1BvaW50TGlnaHQgJiYgcmVzdWx0LnVuaWZvcm1zLmxpZ2h0UG9zICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRyZXN1bHQudW5pZm9ybXMubGlnaHRQb3MudmFsdWUuY29weSggbGlnaHRQb3NpdGlvbldvcmxkICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiByZXN1bHQ7XG5cbiAgICBcdH1cblxuICAgIFx0ZnVuY3Rpb24gcHJvamVjdE9iamVjdCggb2JqZWN0LCBjYW1lcmEsIHNoYWRvd0NhbWVyYSApIHtcblxuICAgIFx0XHRpZiAoIG9iamVjdC52aXNpYmxlID09PSBmYWxzZSApIHJldHVybjtcblxuICAgIFx0XHR2YXIgdmlzaWJsZSA9ICggb2JqZWN0LmxheWVycy5tYXNrICYgY2FtZXJhLmxheWVycy5tYXNrICkgIT09IDA7XG5cbiAgICBcdFx0aWYgKCB2aXNpYmxlICYmICggb2JqZWN0LmlzTWVzaCB8fCBvYmplY3QuaXNMaW5lIHx8IG9iamVjdC5pc1BvaW50cyApICkge1xuXG4gICAgXHRcdFx0aWYgKCBvYmplY3QuY2FzdFNoYWRvdyAmJiAoIG9iamVjdC5mcnVzdHVtQ3VsbGVkID09PSBmYWxzZSB8fCBfZnJ1c3R1bS5pbnRlcnNlY3RzT2JqZWN0KCBvYmplY3QgKSA9PT0gdHJ1ZSApICkge1xuXG4gICAgXHRcdFx0XHR2YXIgbWF0ZXJpYWwgPSBvYmplY3QubWF0ZXJpYWw7XG5cbiAgICBcdFx0XHRcdGlmICggbWF0ZXJpYWwudmlzaWJsZSA9PT0gdHJ1ZSApIHtcblxuICAgIFx0XHRcdFx0XHRvYmplY3QubW9kZWxWaWV3TWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIHNoYWRvd0NhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UsIG9iamVjdC5tYXRyaXhXb3JsZCApO1xuICAgIFx0XHRcdFx0XHRfcmVuZGVyTGlzdC5wdXNoKCBvYmplY3QgKTtcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHR2YXIgY2hpbGRyZW4gPSBvYmplY3QuY2hpbGRyZW47XG5cbiAgICBcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgIFx0XHRcdHByb2plY3RPYmplY3QoIGNoaWxkcmVuWyBpIF0sIGNhbWVyYSwgc2hhZG93Q2FtZXJhICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBSYXkoIG9yaWdpbiwgZGlyZWN0aW9uICkge1xuXG4gICAgXHR0aGlzLm9yaWdpbiA9ICggb3JpZ2luICE9PSB1bmRlZmluZWQgKSA/IG9yaWdpbiA6IG5ldyBWZWN0b3IzKCk7XG4gICAgXHR0aGlzLmRpcmVjdGlvbiA9ICggZGlyZWN0aW9uICE9PSB1bmRlZmluZWQgKSA/IGRpcmVjdGlvbiA6IG5ldyBWZWN0b3IzKCk7XG5cbiAgICB9XG5cbiAgICBSYXkucHJvdG90eXBlID0ge1xuXG4gICAgXHRjb25zdHJ1Y3RvcjogUmF5LFxuXG4gICAgXHRzZXQ6IGZ1bmN0aW9uICggb3JpZ2luLCBkaXJlY3Rpb24gKSB7XG5cbiAgICBcdFx0dGhpcy5vcmlnaW4uY29weSggb3JpZ2luICk7XG4gICAgXHRcdHRoaXMuZGlyZWN0aW9uLmNvcHkoIGRpcmVjdGlvbiApO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblxuICAgIFx0fSxcblxuICAgIFx0Y29weTogZnVuY3Rpb24gKCByYXkgKSB7XG5cbiAgICBcdFx0dGhpcy5vcmlnaW4uY29weSggcmF5Lm9yaWdpbiApO1xuICAgIFx0XHR0aGlzLmRpcmVjdGlvbi5jb3B5KCByYXkuZGlyZWN0aW9uICk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGF0OiBmdW5jdGlvbiAoIHQsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgXHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMygpO1xuXG4gICAgXHRcdHJldHVybiByZXN1bHQuY29weSggdGhpcy5kaXJlY3Rpb24gKS5tdWx0aXBseVNjYWxhciggdCApLmFkZCggdGhpcy5vcmlnaW4gKTtcblxuICAgIFx0fSxcblxuICAgIFx0bG9va0F0OiBmdW5jdGlvbiAoIHYgKSB7XG5cbiAgICBcdFx0dGhpcy5kaXJlY3Rpb24uY29weSggdiApLnN1YiggdGhpcy5vcmlnaW4gKS5ub3JtYWxpemUoKTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0cmVjYXN0OiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoKTtcblxuICAgIFx0XHRyZXR1cm4gZnVuY3Rpb24gcmVjYXN0KCB0ICkge1xuXG4gICAgXHRcdFx0dGhpcy5vcmlnaW4uY29weSggdGhpcy5hdCggdCwgdjEgKSApO1xuXG4gICAgXHRcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdFx0fTtcblxuICAgIFx0fSgpLFxuXG4gICAgXHRjbG9zZXN0UG9pbnRUb1BvaW50OiBmdW5jdGlvbiAoIHBvaW50LCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgIFx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjMoKTtcbiAgICBcdFx0cmVzdWx0LnN1YlZlY3RvcnMoIHBvaW50LCB0aGlzLm9yaWdpbiApO1xuICAgIFx0XHR2YXIgZGlyZWN0aW9uRGlzdGFuY2UgPSByZXN1bHQuZG90KCB0aGlzLmRpcmVjdGlvbiApO1xuXG4gICAgXHRcdGlmICggZGlyZWN0aW9uRGlzdGFuY2UgPCAwICkge1xuXG4gICAgXHRcdFx0cmV0dXJuIHJlc3VsdC5jb3B5KCB0aGlzLm9yaWdpbiApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gcmVzdWx0LmNvcHkoIHRoaXMuZGlyZWN0aW9uICkubXVsdGlwbHlTY2FsYXIoIGRpcmVjdGlvbkRpc3RhbmNlICkuYWRkKCB0aGlzLm9yaWdpbiApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRkaXN0YW5jZVRvUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XG5cbiAgICBcdFx0cmV0dXJuIE1hdGguc3FydCggdGhpcy5kaXN0YW5jZVNxVG9Qb2ludCggcG9pbnQgKSApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRkaXN0YW5jZVNxVG9Qb2ludDogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCk7XG5cbiAgICBcdFx0cmV0dXJuIGZ1bmN0aW9uIGRpc3RhbmNlU3FUb1BvaW50KCBwb2ludCApIHtcblxuICAgIFx0XHRcdHZhciBkaXJlY3Rpb25EaXN0YW5jZSA9IHYxLnN1YlZlY3RvcnMoIHBvaW50LCB0aGlzLm9yaWdpbiApLmRvdCggdGhpcy5kaXJlY3Rpb24gKTtcblxuICAgIFx0XHRcdC8vIHBvaW50IGJlaGluZCB0aGUgcmF5XG5cbiAgICBcdFx0XHRpZiAoIGRpcmVjdGlvbkRpc3RhbmNlIDwgMCApIHtcblxuICAgIFx0XHRcdFx0cmV0dXJuIHRoaXMub3JpZ2luLmRpc3RhbmNlVG9TcXVhcmVkKCBwb2ludCApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0djEuY29weSggdGhpcy5kaXJlY3Rpb24gKS5tdWx0aXBseVNjYWxhciggZGlyZWN0aW9uRGlzdGFuY2UgKS5hZGQoIHRoaXMub3JpZ2luICk7XG5cbiAgICBcdFx0XHRyZXR1cm4gdjEuZGlzdGFuY2VUb1NxdWFyZWQoIHBvaW50ICk7XG5cbiAgICBcdFx0fTtcblxuICAgIFx0fSgpLFxuXG4gICAgXHRkaXN0YW5jZVNxVG9TZWdtZW50OiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dmFyIHNlZ0NlbnRlciA9IG5ldyBWZWN0b3IzKCk7XG4gICAgXHRcdHZhciBzZWdEaXIgPSBuZXcgVmVjdG9yMygpO1xuICAgIFx0XHR2YXIgZGlmZiA9IG5ldyBWZWN0b3IzKCk7XG5cbiAgICBcdFx0cmV0dXJuIGZ1bmN0aW9uIGRpc3RhbmNlU3FUb1NlZ21lbnQoIHYwLCB2MSwgb3B0aW9uYWxQb2ludE9uUmF5LCBvcHRpb25hbFBvaW50T25TZWdtZW50ICkge1xuXG4gICAgXHRcdFx0Ly8gZnJvbSBodHRwOi8vd3d3Lmdlb21ldHJpY3Rvb2xzLmNvbS9HVEVuZ2luZS9JbmNsdWRlL01hdGhlbWF0aWNzL0d0ZURpc3RSYXlTZWdtZW50LmhcbiAgICBcdFx0XHQvLyBJdCByZXR1cm5zIHRoZSBtaW4gZGlzdGFuY2UgYmV0d2VlbiB0aGUgcmF5IGFuZCB0aGUgc2VnbWVudFxuICAgIFx0XHRcdC8vIGRlZmluZWQgYnkgdjAgYW5kIHYxXG4gICAgXHRcdFx0Ly8gSXQgY2FuIGFsc28gc2V0IHR3byBvcHRpb25hbCB0YXJnZXRzIDpcbiAgICBcdFx0XHQvLyAtIFRoZSBjbG9zZXN0IHBvaW50IG9uIHRoZSByYXlcbiAgICBcdFx0XHQvLyAtIFRoZSBjbG9zZXN0IHBvaW50IG9uIHRoZSBzZWdtZW50XG5cbiAgICBcdFx0XHRzZWdDZW50ZXIuY29weSggdjAgKS5hZGQoIHYxICkubXVsdGlwbHlTY2FsYXIoIDAuNSApO1xuICAgIFx0XHRcdHNlZ0Rpci5jb3B5KCB2MSApLnN1YiggdjAgKS5ub3JtYWxpemUoKTtcbiAgICBcdFx0XHRkaWZmLmNvcHkoIHRoaXMub3JpZ2luICkuc3ViKCBzZWdDZW50ZXIgKTtcblxuICAgIFx0XHRcdHZhciBzZWdFeHRlbnQgPSB2MC5kaXN0YW5jZVRvKCB2MSApICogMC41O1xuICAgIFx0XHRcdHZhciBhMDEgPSAtIHRoaXMuZGlyZWN0aW9uLmRvdCggc2VnRGlyICk7XG4gICAgXHRcdFx0dmFyIGIwID0gZGlmZi5kb3QoIHRoaXMuZGlyZWN0aW9uICk7XG4gICAgXHRcdFx0dmFyIGIxID0gLSBkaWZmLmRvdCggc2VnRGlyICk7XG4gICAgXHRcdFx0dmFyIGMgPSBkaWZmLmxlbmd0aFNxKCk7XG4gICAgXHRcdFx0dmFyIGRldCA9IE1hdGguYWJzKCAxIC0gYTAxICogYTAxICk7XG4gICAgXHRcdFx0dmFyIHMwLCBzMSwgc3FyRGlzdCwgZXh0RGV0O1xuXG4gICAgXHRcdFx0aWYgKCBkZXQgPiAwICkge1xuXG4gICAgXHRcdFx0XHQvLyBUaGUgcmF5IGFuZCBzZWdtZW50IGFyZSBub3QgcGFyYWxsZWwuXG5cbiAgICBcdFx0XHRcdHMwID0gYTAxICogYjEgLSBiMDtcbiAgICBcdFx0XHRcdHMxID0gYTAxICogYjAgLSBiMTtcbiAgICBcdFx0XHRcdGV4dERldCA9IHNlZ0V4dGVudCAqIGRldDtcblxuICAgIFx0XHRcdFx0aWYgKCBzMCA+PSAwICkge1xuXG4gICAgXHRcdFx0XHRcdGlmICggczEgPj0gLSBleHREZXQgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHRpZiAoIHMxIDw9IGV4dERldCApIHtcblxuICAgIFx0XHRcdFx0XHRcdFx0Ly8gcmVnaW9uIDBcbiAgICBcdFx0XHRcdFx0XHRcdC8vIE1pbmltdW0gYXQgaW50ZXJpb3IgcG9pbnRzIG9mIHJheSBhbmQgc2VnbWVudC5cblxuICAgIFx0XHRcdFx0XHRcdFx0dmFyIGludkRldCA9IDEgLyBkZXQ7XG4gICAgXHRcdFx0XHRcdFx0XHRzMCAqPSBpbnZEZXQ7XG4gICAgXHRcdFx0XHRcdFx0XHRzMSAqPSBpbnZEZXQ7XG4gICAgXHRcdFx0XHRcdFx0XHRzcXJEaXN0ID0gczAgKiAoIHMwICsgYTAxICogczEgKyAyICogYjAgKSArIHMxICogKCBhMDEgKiBzMCArIHMxICsgMiAqIGIxICkgKyBjO1xuXG4gICAgXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0XHRcdFx0Ly8gcmVnaW9uIDFcblxuICAgIFx0XHRcdFx0XHRcdFx0czEgPSBzZWdFeHRlbnQ7XG4gICAgXHRcdFx0XHRcdFx0XHRzMCA9IE1hdGgubWF4KCAwLCAtICggYTAxICogczEgKyBiMCApICk7XG4gICAgXHRcdFx0XHRcdFx0XHRzcXJEaXN0ID0gLSBzMCAqIHMwICsgczEgKiAoIHMxICsgMiAqIGIxICkgKyBjO1xuXG4gICAgXHRcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdFx0XHQvLyByZWdpb24gNVxuXG4gICAgXHRcdFx0XHRcdFx0czEgPSAtIHNlZ0V4dGVudDtcbiAgICBcdFx0XHRcdFx0XHRzMCA9IE1hdGgubWF4KCAwLCAtICggYTAxICogczEgKyBiMCApICk7XG4gICAgXHRcdFx0XHRcdFx0c3FyRGlzdCA9IC0gczAgKiBzMCArIHMxICogKCBzMSArIDIgKiBiMSApICsgYztcblxuICAgIFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdFx0aWYgKCBzMSA8PSAtIGV4dERldCApIHtcblxuICAgIFx0XHRcdFx0XHRcdC8vIHJlZ2lvbiA0XG5cbiAgICBcdFx0XHRcdFx0XHRzMCA9IE1hdGgubWF4KCAwLCAtICggLSBhMDEgKiBzZWdFeHRlbnQgKyBiMCApICk7XG4gICAgXHRcdFx0XHRcdFx0czEgPSAoIHMwID4gMCApID8gLSBzZWdFeHRlbnQgOiBNYXRoLm1pbiggTWF0aC5tYXgoIC0gc2VnRXh0ZW50LCAtIGIxICksIHNlZ0V4dGVudCApO1xuICAgIFx0XHRcdFx0XHRcdHNxckRpc3QgPSAtIHMwICogczAgKyBzMSAqICggczEgKyAyICogYjEgKSArIGM7XG5cbiAgICBcdFx0XHRcdFx0fSBlbHNlIGlmICggczEgPD0gZXh0RGV0ICkge1xuXG4gICAgXHRcdFx0XHRcdFx0Ly8gcmVnaW9uIDNcblxuICAgIFx0XHRcdFx0XHRcdHMwID0gMDtcbiAgICBcdFx0XHRcdFx0XHRzMSA9IE1hdGgubWluKCBNYXRoLm1heCggLSBzZWdFeHRlbnQsIC0gYjEgKSwgc2VnRXh0ZW50ICk7XG4gICAgXHRcdFx0XHRcdFx0c3FyRGlzdCA9IHMxICogKCBzMSArIDIgKiBiMSApICsgYztcblxuICAgIFx0XHRcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHRcdFx0Ly8gcmVnaW9uIDJcblxuICAgIFx0XHRcdFx0XHRcdHMwID0gTWF0aC5tYXgoIDAsIC0gKCBhMDEgKiBzZWdFeHRlbnQgKyBiMCApICk7XG4gICAgXHRcdFx0XHRcdFx0czEgPSAoIHMwID4gMCApID8gc2VnRXh0ZW50IDogTWF0aC5taW4oIE1hdGgubWF4KCAtIHNlZ0V4dGVudCwgLSBiMSApLCBzZWdFeHRlbnQgKTtcbiAgICBcdFx0XHRcdFx0XHRzcXJEaXN0ID0gLSBzMCAqIHMwICsgczEgKiAoIHMxICsgMiAqIGIxICkgKyBjO1xuXG4gICAgXHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0Ly8gUmF5IGFuZCBzZWdtZW50IGFyZSBwYXJhbGxlbC5cblxuICAgIFx0XHRcdFx0czEgPSAoIGEwMSA+IDAgKSA/IC0gc2VnRXh0ZW50IDogc2VnRXh0ZW50O1xuICAgIFx0XHRcdFx0czAgPSBNYXRoLm1heCggMCwgLSAoIGEwMSAqIHMxICsgYjAgKSApO1xuICAgIFx0XHRcdFx0c3FyRGlzdCA9IC0gczAgKiBzMCArIHMxICogKCBzMSArIDIgKiBiMSApICsgYztcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdGlmICggb3B0aW9uYWxQb2ludE9uUmF5ICkge1xuXG4gICAgXHRcdFx0XHRvcHRpb25hbFBvaW50T25SYXkuY29weSggdGhpcy5kaXJlY3Rpb24gKS5tdWx0aXBseVNjYWxhciggczAgKS5hZGQoIHRoaXMub3JpZ2luICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRpZiAoIG9wdGlvbmFsUG9pbnRPblNlZ21lbnQgKSB7XG5cbiAgICBcdFx0XHRcdG9wdGlvbmFsUG9pbnRPblNlZ21lbnQuY29weSggc2VnRGlyICkubXVsdGlwbHlTY2FsYXIoIHMxICkuYWRkKCBzZWdDZW50ZXIgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdHJldHVybiBzcXJEaXN0O1xuXG4gICAgXHRcdH07XG5cbiAgICBcdH0oKSxcblxuICAgIFx0aW50ZXJzZWN0U3BoZXJlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoKTtcblxuICAgIFx0XHRyZXR1cm4gZnVuY3Rpb24gaW50ZXJzZWN0U3BoZXJlKCBzcGhlcmUsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgXHRcdFx0djEuc3ViVmVjdG9ycyggc3BoZXJlLmNlbnRlciwgdGhpcy5vcmlnaW4gKTtcbiAgICBcdFx0XHR2YXIgdGNhID0gdjEuZG90KCB0aGlzLmRpcmVjdGlvbiApO1xuICAgIFx0XHRcdHZhciBkMiA9IHYxLmRvdCggdjEgKSAtIHRjYSAqIHRjYTtcbiAgICBcdFx0XHR2YXIgcmFkaXVzMiA9IHNwaGVyZS5yYWRpdXMgKiBzcGhlcmUucmFkaXVzO1xuXG4gICAgXHRcdFx0aWYgKCBkMiA+IHJhZGl1czIgKSByZXR1cm4gbnVsbDtcblxuICAgIFx0XHRcdHZhciB0aGMgPSBNYXRoLnNxcnQoIHJhZGl1czIgLSBkMiApO1xuXG4gICAgXHRcdFx0Ly8gdDAgPSBmaXJzdCBpbnRlcnNlY3QgcG9pbnQgLSBlbnRyYW5jZSBvbiBmcm9udCBvZiBzcGhlcmVcbiAgICBcdFx0XHR2YXIgdDAgPSB0Y2EgLSB0aGM7XG5cbiAgICBcdFx0XHQvLyB0MSA9IHNlY29uZCBpbnRlcnNlY3QgcG9pbnQgLSBleGl0IHBvaW50IG9uIGJhY2sgb2Ygc3BoZXJlXG4gICAgXHRcdFx0dmFyIHQxID0gdGNhICsgdGhjO1xuXG4gICAgXHRcdFx0Ly8gdGVzdCB0byBzZWUgaWYgYm90aCB0MCBhbmQgdDEgYXJlIGJlaGluZCB0aGUgcmF5IC0gaWYgc28sIHJldHVybiBudWxsXG4gICAgXHRcdFx0aWYgKCB0MCA8IDAgJiYgdDEgPCAwICkgcmV0dXJuIG51bGw7XG5cbiAgICBcdFx0XHQvLyB0ZXN0IHRvIHNlZSBpZiB0MCBpcyBiZWhpbmQgdGhlIHJheTpcbiAgICBcdFx0XHQvLyBpZiBpdCBpcywgdGhlIHJheSBpcyBpbnNpZGUgdGhlIHNwaGVyZSwgc28gcmV0dXJuIHRoZSBzZWNvbmQgZXhpdCBwb2ludCBzY2FsZWQgYnkgdDEsXG4gICAgXHRcdFx0Ly8gaW4gb3JkZXIgdG8gYWx3YXlzIHJldHVybiBhbiBpbnRlcnNlY3QgcG9pbnQgdGhhdCBpcyBpbiBmcm9udCBvZiB0aGUgcmF5LlxuICAgIFx0XHRcdGlmICggdDAgPCAwICkgcmV0dXJuIHRoaXMuYXQoIHQxLCBvcHRpb25hbFRhcmdldCApO1xuXG4gICAgXHRcdFx0Ly8gZWxzZSB0MCBpcyBpbiBmcm9udCBvZiB0aGUgcmF5LCBzbyByZXR1cm4gdGhlIGZpcnN0IGNvbGxpc2lvbiBwb2ludCBzY2FsZWQgYnkgdDBcbiAgICBcdFx0XHRyZXR1cm4gdGhpcy5hdCggdDAsIG9wdGlvbmFsVGFyZ2V0ICk7XG5cbiAgICBcdFx0fTtcblxuICAgIFx0fSgpLFxuXG4gICAgXHRpbnRlcnNlY3RzU3BoZXJlOiBmdW5jdGlvbiAoIHNwaGVyZSApIHtcblxuICAgIFx0XHRyZXR1cm4gdGhpcy5kaXN0YW5jZVRvUG9pbnQoIHNwaGVyZS5jZW50ZXIgKSA8PSBzcGhlcmUucmFkaXVzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRkaXN0YW5jZVRvUGxhbmU6IGZ1bmN0aW9uICggcGxhbmUgKSB7XG5cbiAgICBcdFx0dmFyIGRlbm9taW5hdG9yID0gcGxhbmUubm9ybWFsLmRvdCggdGhpcy5kaXJlY3Rpb24gKTtcblxuICAgIFx0XHRpZiAoIGRlbm9taW5hdG9yID09PSAwICkge1xuXG4gICAgXHRcdFx0Ly8gbGluZSBpcyBjb3BsYW5hciwgcmV0dXJuIG9yaWdpblxuICAgIFx0XHRcdGlmICggcGxhbmUuZGlzdGFuY2VUb1BvaW50KCB0aGlzLm9yaWdpbiApID09PSAwICkge1xuXG4gICAgXHRcdFx0XHRyZXR1cm4gMDtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdC8vIE51bGwgaXMgcHJlZmVyYWJsZSB0byB1bmRlZmluZWQgc2luY2UgdW5kZWZpbmVkIG1lYW5zLi4uLiBpdCBpcyB1bmRlZmluZWRcblxuICAgIFx0XHRcdHJldHVybiBudWxsO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHR2YXIgdCA9IC0gKCB0aGlzLm9yaWdpbi5kb3QoIHBsYW5lLm5vcm1hbCApICsgcGxhbmUuY29uc3RhbnQgKSAvIGRlbm9taW5hdG9yO1xuXG4gICAgXHRcdC8vIFJldHVybiBpZiB0aGUgcmF5IG5ldmVyIGludGVyc2VjdHMgdGhlIHBsYW5lXG5cbiAgICBcdFx0cmV0dXJuIHQgPj0gMCA/IHQgOiAgbnVsbDtcblxuICAgIFx0fSxcblxuICAgIFx0aW50ZXJzZWN0UGxhbmU6IGZ1bmN0aW9uICggcGxhbmUsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgXHRcdHZhciB0ID0gdGhpcy5kaXN0YW5jZVRvUGxhbmUoIHBsYW5lICk7XG5cbiAgICBcdFx0aWYgKCB0ID09PSBudWxsICkge1xuXG4gICAgXHRcdFx0cmV0dXJuIG51bGw7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiB0aGlzLmF0KCB0LCBvcHRpb25hbFRhcmdldCApO1xuXG4gICAgXHR9LFxuXG5cblxuICAgIFx0aW50ZXJzZWN0c1BsYW5lOiBmdW5jdGlvbiAoIHBsYW5lICkge1xuXG4gICAgXHRcdC8vIGNoZWNrIGlmIHRoZSByYXkgbGllcyBvbiB0aGUgcGxhbmUgZmlyc3RcblxuICAgIFx0XHR2YXIgZGlzdFRvUG9pbnQgPSBwbGFuZS5kaXN0YW5jZVRvUG9pbnQoIHRoaXMub3JpZ2luICk7XG5cbiAgICBcdFx0aWYgKCBkaXN0VG9Qb2ludCA9PT0gMCApIHtcblxuICAgIFx0XHRcdHJldHVybiB0cnVlO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHR2YXIgZGVub21pbmF0b3IgPSBwbGFuZS5ub3JtYWwuZG90KCB0aGlzLmRpcmVjdGlvbiApO1xuXG4gICAgXHRcdGlmICggZGVub21pbmF0b3IgKiBkaXN0VG9Qb2ludCA8IDAgKSB7XG5cbiAgICBcdFx0XHRyZXR1cm4gdHJ1ZTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0Ly8gcmF5IG9yaWdpbiBpcyBiZWhpbmQgdGhlIHBsYW5lIChhbmQgaXMgcG9pbnRpbmcgYmVoaW5kIGl0KVxuXG4gICAgXHRcdHJldHVybiBmYWxzZTtcblxuICAgIFx0fSxcblxuICAgIFx0aW50ZXJzZWN0Qm94OiBmdW5jdGlvbiAoIGJveCwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICBcdFx0dmFyIHRtaW4sIHRtYXgsIHR5bWluLCB0eW1heCwgdHptaW4sIHR6bWF4O1xuXG4gICAgXHRcdHZhciBpbnZkaXJ4ID0gMSAvIHRoaXMuZGlyZWN0aW9uLngsXG4gICAgXHRcdFx0aW52ZGlyeSA9IDEgLyB0aGlzLmRpcmVjdGlvbi55LFxuICAgIFx0XHRcdGludmRpcnogPSAxIC8gdGhpcy5kaXJlY3Rpb24uejtcblxuICAgIFx0XHR2YXIgb3JpZ2luID0gdGhpcy5vcmlnaW47XG5cbiAgICBcdFx0aWYgKCBpbnZkaXJ4ID49IDAgKSB7XG5cbiAgICBcdFx0XHR0bWluID0gKCBib3gubWluLnggLSBvcmlnaW4ueCApICogaW52ZGlyeDtcbiAgICBcdFx0XHR0bWF4ID0gKCBib3gubWF4LnggLSBvcmlnaW4ueCApICogaW52ZGlyeDtcblxuICAgIFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0dG1pbiA9ICggYm94Lm1heC54IC0gb3JpZ2luLnggKSAqIGludmRpcng7XG4gICAgXHRcdFx0dG1heCA9ICggYm94Lm1pbi54IC0gb3JpZ2luLnggKSAqIGludmRpcng7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGlmICggaW52ZGlyeSA+PSAwICkge1xuXG4gICAgXHRcdFx0dHltaW4gPSAoIGJveC5taW4ueSAtIG9yaWdpbi55ICkgKiBpbnZkaXJ5O1xuICAgIFx0XHRcdHR5bWF4ID0gKCBib3gubWF4LnkgLSBvcmlnaW4ueSApICogaW52ZGlyeTtcblxuICAgIFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0dHltaW4gPSAoIGJveC5tYXgueSAtIG9yaWdpbi55ICkgKiBpbnZkaXJ5O1xuICAgIFx0XHRcdHR5bWF4ID0gKCBib3gubWluLnkgLSBvcmlnaW4ueSApICogaW52ZGlyeTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0aWYgKCAoIHRtaW4gPiB0eW1heCApIHx8ICggdHltaW4gPiB0bWF4ICkgKSByZXR1cm4gbnVsbDtcblxuICAgIFx0XHQvLyBUaGVzZSBsaW5lcyBhbHNvIGhhbmRsZSB0aGUgY2FzZSB3aGVyZSB0bWluIG9yIHRtYXggaXMgTmFOXG4gICAgXHRcdC8vIChyZXN1bHQgb2YgMCAqIEluZmluaXR5KS4geCAhPT0geCByZXR1cm5zIHRydWUgaWYgeCBpcyBOYU5cblxuICAgIFx0XHRpZiAoIHR5bWluID4gdG1pbiB8fCB0bWluICE9PSB0bWluICkgdG1pbiA9IHR5bWluO1xuXG4gICAgXHRcdGlmICggdHltYXggPCB0bWF4IHx8IHRtYXggIT09IHRtYXggKSB0bWF4ID0gdHltYXg7XG5cbiAgICBcdFx0aWYgKCBpbnZkaXJ6ID49IDAgKSB7XG5cbiAgICBcdFx0XHR0em1pbiA9ICggYm94Lm1pbi56IC0gb3JpZ2luLnogKSAqIGludmRpcno7XG4gICAgXHRcdFx0dHptYXggPSAoIGJveC5tYXgueiAtIG9yaWdpbi56ICkgKiBpbnZkaXJ6O1xuXG4gICAgXHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHR0em1pbiA9ICggYm94Lm1heC56IC0gb3JpZ2luLnogKSAqIGludmRpcno7XG4gICAgXHRcdFx0dHptYXggPSAoIGJveC5taW4ueiAtIG9yaWdpbi56ICkgKiBpbnZkaXJ6O1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRpZiAoICggdG1pbiA+IHR6bWF4ICkgfHwgKCB0em1pbiA+IHRtYXggKSApIHJldHVybiBudWxsO1xuXG4gICAgXHRcdGlmICggdHptaW4gPiB0bWluIHx8IHRtaW4gIT09IHRtaW4gKSB0bWluID0gdHptaW47XG5cbiAgICBcdFx0aWYgKCB0em1heCA8IHRtYXggfHwgdG1heCAhPT0gdG1heCApIHRtYXggPSB0em1heDtcblxuICAgIFx0XHQvL3JldHVybiBwb2ludCBjbG9zZXN0IHRvIHRoZSByYXkgKHBvc2l0aXZlIHNpZGUpXG5cbiAgICBcdFx0aWYgKCB0bWF4IDwgMCApIHJldHVybiBudWxsO1xuXG4gICAgXHRcdHJldHVybiB0aGlzLmF0KCB0bWluID49IDAgPyB0bWluIDogdG1heCwgb3B0aW9uYWxUYXJnZXQgKTtcblxuICAgIFx0fSxcblxuICAgIFx0aW50ZXJzZWN0c0JveDogKCBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dmFyIHYgPSBuZXcgVmVjdG9yMygpO1xuXG4gICAgXHRcdHJldHVybiBmdW5jdGlvbiBpbnRlcnNlY3RzQm94KCBib3ggKSB7XG5cbiAgICBcdFx0XHRyZXR1cm4gdGhpcy5pbnRlcnNlY3RCb3goIGJveCwgdiApICE9PSBudWxsO1xuXG4gICAgXHRcdH07XG5cbiAgICBcdH0gKSgpLFxuXG4gICAgXHRpbnRlcnNlY3RUcmlhbmdsZTogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdC8vIENvbXB1dGUgdGhlIG9mZnNldCBvcmlnaW4sIGVkZ2VzLCBhbmQgbm9ybWFsLlxuICAgIFx0XHR2YXIgZGlmZiA9IG5ldyBWZWN0b3IzKCk7XG4gICAgXHRcdHZhciBlZGdlMSA9IG5ldyBWZWN0b3IzKCk7XG4gICAgXHRcdHZhciBlZGdlMiA9IG5ldyBWZWN0b3IzKCk7XG4gICAgXHRcdHZhciBub3JtYWwgPSBuZXcgVmVjdG9yMygpO1xuXG4gICAgXHRcdHJldHVybiBmdW5jdGlvbiBpbnRlcnNlY3RUcmlhbmdsZSggYSwgYiwgYywgYmFja2ZhY2VDdWxsaW5nLCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgIFx0XHRcdC8vIGZyb20gaHR0cDovL3d3dy5nZW9tZXRyaWN0b29scy5jb20vR1RFbmdpbmUvSW5jbHVkZS9NYXRoZW1hdGljcy9HdGVJbnRyUmF5M1RyaWFuZ2xlMy5oXG5cbiAgICBcdFx0XHRlZGdlMS5zdWJWZWN0b3JzKCBiLCBhICk7XG4gICAgXHRcdFx0ZWRnZTIuc3ViVmVjdG9ycyggYywgYSApO1xuICAgIFx0XHRcdG5vcm1hbC5jcm9zc1ZlY3RvcnMoIGVkZ2UxLCBlZGdlMiApO1xuXG4gICAgXHRcdFx0Ly8gU29sdmUgUSArIHQqRCA9IGIxKkUxICsgYjIqRTIgKFEgPSBrRGlmZiwgRCA9IHJheSBkaXJlY3Rpb24sXG4gICAgXHRcdFx0Ly8gRTEgPSBrRWRnZTEsIEUyID0ga0VkZ2UyLCBOID0gQ3Jvc3MoRTEsRTIpKSBieVxuICAgIFx0XHRcdC8vICAgfERvdChELE4pfCpiMSA9IHNpZ24oRG90KEQsTikpKkRvdChELENyb3NzKFEsRTIpKVxuICAgIFx0XHRcdC8vICAgfERvdChELE4pfCpiMiA9IHNpZ24oRG90KEQsTikpKkRvdChELENyb3NzKEUxLFEpKVxuICAgIFx0XHRcdC8vICAgfERvdChELE4pfCp0ID0gLXNpZ24oRG90KEQsTikpKkRvdChRLE4pXG4gICAgXHRcdFx0dmFyIERkTiA9IHRoaXMuZGlyZWN0aW9uLmRvdCggbm9ybWFsICk7XG4gICAgXHRcdFx0dmFyIHNpZ247XG5cbiAgICBcdFx0XHRpZiAoIERkTiA+IDAgKSB7XG5cbiAgICBcdFx0XHRcdGlmICggYmFja2ZhY2VDdWxsaW5nICkgcmV0dXJuIG51bGw7XG4gICAgXHRcdFx0XHRzaWduID0gMTtcblxuICAgIFx0XHRcdH0gZWxzZSBpZiAoIERkTiA8IDAgKSB7XG5cbiAgICBcdFx0XHRcdHNpZ24gPSAtIDE7XG4gICAgXHRcdFx0XHREZE4gPSAtIERkTjtcblxuICAgIFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdHJldHVybiBudWxsO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0ZGlmZi5zdWJWZWN0b3JzKCB0aGlzLm9yaWdpbiwgYSApO1xuICAgIFx0XHRcdHZhciBEZFF4RTIgPSBzaWduICogdGhpcy5kaXJlY3Rpb24uZG90KCBlZGdlMi5jcm9zc1ZlY3RvcnMoIGRpZmYsIGVkZ2UyICkgKTtcblxuICAgIFx0XHRcdC8vIGIxIDwgMCwgbm8gaW50ZXJzZWN0aW9uXG4gICAgXHRcdFx0aWYgKCBEZFF4RTIgPCAwICkge1xuXG4gICAgXHRcdFx0XHRyZXR1cm4gbnVsbDtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdHZhciBEZEUxeFEgPSBzaWduICogdGhpcy5kaXJlY3Rpb24uZG90KCBlZGdlMS5jcm9zcyggZGlmZiApICk7XG5cbiAgICBcdFx0XHQvLyBiMiA8IDAsIG5vIGludGVyc2VjdGlvblxuICAgIFx0XHRcdGlmICggRGRFMXhRIDwgMCApIHtcblxuICAgIFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHQvLyBiMStiMiA+IDEsIG5vIGludGVyc2VjdGlvblxuICAgIFx0XHRcdGlmICggRGRReEUyICsgRGRFMXhRID4gRGROICkge1xuXG4gICAgXHRcdFx0XHRyZXR1cm4gbnVsbDtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdC8vIExpbmUgaW50ZXJzZWN0cyB0cmlhbmdsZSwgY2hlY2sgaWYgcmF5IGRvZXMuXG4gICAgXHRcdFx0dmFyIFFkTiA9IC0gc2lnbiAqIGRpZmYuZG90KCBub3JtYWwgKTtcblxuICAgIFx0XHRcdC8vIHQgPCAwLCBubyBpbnRlcnNlY3Rpb25cbiAgICBcdFx0XHRpZiAoIFFkTiA8IDAgKSB7XG5cbiAgICBcdFx0XHRcdHJldHVybiBudWxsO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0Ly8gUmF5IGludGVyc2VjdHMgdHJpYW5nbGUuXG4gICAgXHRcdFx0cmV0dXJuIHRoaXMuYXQoIFFkTiAvIERkTiwgb3B0aW9uYWxUYXJnZXQgKTtcblxuICAgIFx0XHR9O1xuXG4gICAgXHR9KCksXG5cbiAgICBcdGFwcGx5TWF0cml4NDogZnVuY3Rpb24gKCBtYXRyaXg0ICkge1xuXG4gICAgXHRcdHRoaXMuZGlyZWN0aW9uLmFkZCggdGhpcy5vcmlnaW4gKS5hcHBseU1hdHJpeDQoIG1hdHJpeDQgKTtcbiAgICBcdFx0dGhpcy5vcmlnaW4uYXBwbHlNYXRyaXg0KCBtYXRyaXg0ICk7XG4gICAgXHRcdHRoaXMuZGlyZWN0aW9uLnN1YiggdGhpcy5vcmlnaW4gKTtcbiAgICBcdFx0dGhpcy5kaXJlY3Rpb24ubm9ybWFsaXplKCk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGVxdWFsczogZnVuY3Rpb24gKCByYXkgKSB7XG5cbiAgICBcdFx0cmV0dXJuIHJheS5vcmlnaW4uZXF1YWxzKCB0aGlzLm9yaWdpbiApICYmIHJheS5kaXJlY3Rpb24uZXF1YWxzKCB0aGlzLmRpcmVjdGlvbiApO1xuXG4gICAgXHR9XG5cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAgICAgKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAgICAgKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBFdWxlciggeCwgeSwgeiwgb3JkZXIgKSB7XG5cbiAgICBcdHRoaXMuX3ggPSB4IHx8IDA7XG4gICAgXHR0aGlzLl95ID0geSB8fCAwO1xuICAgIFx0dGhpcy5feiA9IHogfHwgMDtcbiAgICBcdHRoaXMuX29yZGVyID0gb3JkZXIgfHwgRXVsZXIuRGVmYXVsdE9yZGVyO1xuXG4gICAgfVxuXG4gICAgRXVsZXIuUm90YXRpb25PcmRlcnMgPSBbICdYWVonLCAnWVpYJywgJ1pYWScsICdYWlknLCAnWVhaJywgJ1pZWCcgXTtcblxuICAgIEV1bGVyLkRlZmF1bHRPcmRlciA9ICdYWVonO1xuXG4gICAgRXVsZXIucHJvdG90eXBlID0ge1xuXG4gICAgXHRjb25zdHJ1Y3RvcjogRXVsZXIsXG5cbiAgICBcdGlzRXVsZXI6IHRydWUsXG5cbiAgICBcdGdldCB4ICgpIHtcblxuICAgIFx0XHRyZXR1cm4gdGhpcy5feDtcblxuICAgIFx0fSxcblxuICAgIFx0c2V0IHggKCB2YWx1ZSApIHtcblxuICAgIFx0XHR0aGlzLl94ID0gdmFsdWU7XG4gICAgXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG4gICAgXHR9LFxuXG4gICAgXHRnZXQgeSAoKSB7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMuX3k7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldCB5ICggdmFsdWUgKSB7XG5cbiAgICBcdFx0dGhpcy5feSA9IHZhbHVlO1xuICAgIFx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuICAgIFx0fSxcblxuICAgIFx0Z2V0IHogKCkge1xuXG4gICAgXHRcdHJldHVybiB0aGlzLl96O1xuXG4gICAgXHR9LFxuXG4gICAgXHRzZXQgeiAoIHZhbHVlICkge1xuXG4gICAgXHRcdHRoaXMuX3ogPSB2YWx1ZTtcbiAgICBcdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGdldCBvcmRlciAoKSB7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMuX29yZGVyO1xuXG4gICAgXHR9LFxuXG4gICAgXHRzZXQgb3JkZXIgKCB2YWx1ZSApIHtcblxuICAgIFx0XHR0aGlzLl9vcmRlciA9IHZhbHVlO1xuICAgIFx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuICAgIFx0fSxcblxuICAgIFx0c2V0OiBmdW5jdGlvbiAoIHgsIHksIHosIG9yZGVyICkge1xuXG4gICAgXHRcdHRoaXMuX3ggPSB4O1xuICAgIFx0XHR0aGlzLl95ID0geTtcbiAgICBcdFx0dGhpcy5feiA9IHo7XG4gICAgXHRcdHRoaXMuX29yZGVyID0gb3JkZXIgfHwgdGhpcy5fb3JkZXI7XG5cbiAgICBcdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLl94LCB0aGlzLl95LCB0aGlzLl96LCB0aGlzLl9vcmRlciApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRjb3B5OiBmdW5jdGlvbiAoIGV1bGVyICkge1xuXG4gICAgXHRcdHRoaXMuX3ggPSBldWxlci5feDtcbiAgICBcdFx0dGhpcy5feSA9IGV1bGVyLl95O1xuICAgIFx0XHR0aGlzLl96ID0gZXVsZXIuX3o7XG4gICAgXHRcdHRoaXMuX29yZGVyID0gZXVsZXIuX29yZGVyO1xuXG4gICAgXHRcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRzZXRGcm9tUm90YXRpb25NYXRyaXg6IGZ1bmN0aW9uICggbSwgb3JkZXIsIHVwZGF0ZSApIHtcblxuICAgIFx0XHR2YXIgY2xhbXAgPSBleHBvcnRzLk1hdGguY2xhbXA7XG5cbiAgICBcdFx0Ly8gYXNzdW1lcyB0aGUgdXBwZXIgM3gzIG9mIG0gaXMgYSBwdXJlIHJvdGF0aW9uIG1hdHJpeCAoaS5lLCB1bnNjYWxlZClcblxuICAgIFx0XHR2YXIgdGUgPSBtLmVsZW1lbnRzO1xuICAgIFx0XHR2YXIgbTExID0gdGVbIDAgXSwgbTEyID0gdGVbIDQgXSwgbTEzID0gdGVbIDggXTtcbiAgICBcdFx0dmFyIG0yMSA9IHRlWyAxIF0sIG0yMiA9IHRlWyA1IF0sIG0yMyA9IHRlWyA5IF07XG4gICAgXHRcdHZhciBtMzEgPSB0ZVsgMiBdLCBtMzIgPSB0ZVsgNiBdLCBtMzMgPSB0ZVsgMTAgXTtcblxuICAgIFx0XHRvcmRlciA9IG9yZGVyIHx8IHRoaXMuX29yZGVyO1xuXG4gICAgXHRcdGlmICggb3JkZXIgPT09ICdYWVonICkge1xuXG4gICAgXHRcdFx0dGhpcy5feSA9IE1hdGguYXNpbiggY2xhbXAoIG0xMywgLSAxLCAxICkgKTtcblxuICAgIFx0XHRcdGlmICggTWF0aC5hYnMoIG0xMyApIDwgMC45OTk5OSApIHtcblxuICAgIFx0XHRcdFx0dGhpcy5feCA9IE1hdGguYXRhbjIoIC0gbTIzLCBtMzMgKTtcbiAgICBcdFx0XHRcdHRoaXMuX3ogPSBNYXRoLmF0YW4yKCAtIG0xMiwgbTExICk7XG5cbiAgICBcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHR0aGlzLl94ID0gTWF0aC5hdGFuMiggbTMyLCBtMjIgKTtcbiAgICBcdFx0XHRcdHRoaXMuX3ogPSAwO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWVhaJyApIHtcblxuICAgIFx0XHRcdHRoaXMuX3ggPSBNYXRoLmFzaW4oIC0gY2xhbXAoIG0yMywgLSAxLCAxICkgKTtcblxuICAgIFx0XHRcdGlmICggTWF0aC5hYnMoIG0yMyApIDwgMC45OTk5OSApIHtcblxuICAgIFx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXRhbjIoIG0xMywgbTMzICk7XG4gICAgXHRcdFx0XHR0aGlzLl96ID0gTWF0aC5hdGFuMiggbTIxLCBtMjIgKTtcblxuICAgIFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdHRoaXMuX3kgPSBNYXRoLmF0YW4yKCAtIG0zMSwgbTExICk7XG4gICAgXHRcdFx0XHR0aGlzLl96ID0gMDtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1pYWScgKSB7XG5cbiAgICBcdFx0XHR0aGlzLl94ID0gTWF0aC5hc2luKCBjbGFtcCggbTMyLCAtIDEsIDEgKSApO1xuXG4gICAgXHRcdFx0aWYgKCBNYXRoLmFicyggbTMyICkgPCAwLjk5OTk5ICkge1xuXG4gICAgXHRcdFx0XHR0aGlzLl95ID0gTWF0aC5hdGFuMiggLSBtMzEsIG0zMyApO1xuICAgIFx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXRhbjIoIC0gbTEyLCBtMjIgKTtcblxuICAgIFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdHRoaXMuX3kgPSAwO1xuICAgIFx0XHRcdFx0dGhpcy5feiA9IE1hdGguYXRhbjIoIG0yMSwgbTExICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdaWVgnICkge1xuXG4gICAgXHRcdFx0dGhpcy5feSA9IE1hdGguYXNpbiggLSBjbGFtcCggbTMxLCAtIDEsIDEgKSApO1xuXG4gICAgXHRcdFx0aWYgKCBNYXRoLmFicyggbTMxICkgPCAwLjk5OTk5ICkge1xuXG4gICAgXHRcdFx0XHR0aGlzLl94ID0gTWF0aC5hdGFuMiggbTMyLCBtMzMgKTtcbiAgICBcdFx0XHRcdHRoaXMuX3ogPSBNYXRoLmF0YW4yKCBtMjEsIG0xMSApO1xuXG4gICAgXHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0dGhpcy5feCA9IDA7XG4gICAgXHRcdFx0XHR0aGlzLl96ID0gTWF0aC5hdGFuMiggLSBtMTIsIG0yMiApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWVpYJyApIHtcblxuICAgIFx0XHRcdHRoaXMuX3ogPSBNYXRoLmFzaW4oIGNsYW1wKCBtMjEsIC0gMSwgMSApICk7XG5cbiAgICBcdFx0XHRpZiAoIE1hdGguYWJzKCBtMjEgKSA8IDAuOTk5OTkgKSB7XG5cbiAgICBcdFx0XHRcdHRoaXMuX3ggPSBNYXRoLmF0YW4yKCAtIG0yMywgbTIyICk7XG4gICAgXHRcdFx0XHR0aGlzLl95ID0gTWF0aC5hdGFuMiggLSBtMzEsIG0xMSApO1xuXG4gICAgXHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0dGhpcy5feCA9IDA7XG4gICAgXHRcdFx0XHR0aGlzLl95ID0gTWF0aC5hdGFuMiggbTEzLCBtMzMgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1haWScgKSB7XG5cbiAgICBcdFx0XHR0aGlzLl96ID0gTWF0aC5hc2luKCAtIGNsYW1wKCBtMTIsIC0gMSwgMSApICk7XG5cbiAgICBcdFx0XHRpZiAoIE1hdGguYWJzKCBtMTIgKSA8IDAuOTk5OTkgKSB7XG5cbiAgICBcdFx0XHRcdHRoaXMuX3ggPSBNYXRoLmF0YW4yKCBtMzIsIG0yMiApO1xuICAgIFx0XHRcdFx0dGhpcy5feSA9IE1hdGguYXRhbjIoIG0xMywgbTExICk7XG5cbiAgICBcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHR0aGlzLl94ID0gTWF0aC5hdGFuMiggLSBtMjMsIG0zMyApO1xuICAgIFx0XHRcdFx0dGhpcy5feSA9IDA7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkV1bGVyOiAuc2V0RnJvbVJvdGF0aW9uTWF0cml4KCkgZ2l2ZW4gdW5zdXBwb3J0ZWQgb3JkZXI6ICcgKyBvcmRlciApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHR0aGlzLl9vcmRlciA9IG9yZGVyO1xuXG4gICAgXHRcdGlmICggdXBkYXRlICE9PSBmYWxzZSApIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRzZXRGcm9tUXVhdGVybmlvbjogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHZhciBtYXRyaXg7XG5cbiAgICBcdFx0cmV0dXJuIGZ1bmN0aW9uIHNldEZyb21RdWF0ZXJuaW9uKCBxLCBvcmRlciwgdXBkYXRlICkge1xuXG4gICAgXHRcdFx0aWYgKCBtYXRyaXggPT09IHVuZGVmaW5lZCApIG1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XG5cbiAgICBcdFx0XHRtYXRyaXgubWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb24oIHEgKTtcblxuICAgIFx0XHRcdHJldHVybiB0aGlzLnNldEZyb21Sb3RhdGlvbk1hdHJpeCggbWF0cml4LCBvcmRlciwgdXBkYXRlICk7XG5cbiAgICBcdFx0fTtcblxuICAgIFx0fSgpLFxuXG4gICAgXHRzZXRGcm9tVmVjdG9yMzogZnVuY3Rpb24gKCB2LCBvcmRlciApIHtcblxuICAgIFx0XHRyZXR1cm4gdGhpcy5zZXQoIHYueCwgdi55LCB2LnosIG9yZGVyIHx8IHRoaXMuX29yZGVyICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdHJlb3JkZXI6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHQvLyBXQVJOSU5HOiB0aGlzIGRpc2NhcmRzIHJldm9sdXRpb24gaW5mb3JtYXRpb24gLWJob3VzdG9uXG5cbiAgICBcdFx0dmFyIHEgPSBuZXcgUXVhdGVybmlvbigpO1xuXG4gICAgXHRcdHJldHVybiBmdW5jdGlvbiByZW9yZGVyKCBuZXdPcmRlciApIHtcblxuICAgIFx0XHRcdHEuc2V0RnJvbUV1bGVyKCB0aGlzICk7XG5cbiAgICBcdFx0XHRyZXR1cm4gdGhpcy5zZXRGcm9tUXVhdGVybmlvbiggcSwgbmV3T3JkZXIgKTtcblxuICAgIFx0XHR9O1xuXG4gICAgXHR9KCksXG5cbiAgICBcdGVxdWFsczogZnVuY3Rpb24gKCBldWxlciApIHtcblxuICAgIFx0XHRyZXR1cm4gKCBldWxlci5feCA9PT0gdGhpcy5feCApICYmICggZXVsZXIuX3kgPT09IHRoaXMuX3kgKSAmJiAoIGV1bGVyLl96ID09PSB0aGlzLl96ICkgJiYgKCBldWxlci5fb3JkZXIgPT09IHRoaXMuX29yZGVyICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGZyb21BcnJheTogZnVuY3Rpb24gKCBhcnJheSApIHtcblxuICAgIFx0XHR0aGlzLl94ID0gYXJyYXlbIDAgXTtcbiAgICBcdFx0dGhpcy5feSA9IGFycmF5WyAxIF07XG4gICAgXHRcdHRoaXMuX3ogPSBhcnJheVsgMiBdO1xuICAgIFx0XHRpZiAoIGFycmF5WyAzIF0gIT09IHVuZGVmaW5lZCApIHRoaXMuX29yZGVyID0gYXJyYXlbIDMgXTtcblxuICAgIFx0XHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0dG9BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xuXG4gICAgXHRcdGlmICggYXJyYXkgPT09IHVuZGVmaW5lZCApIGFycmF5ID0gW107XG4gICAgXHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG4gICAgXHRcdGFycmF5WyBvZmZzZXQgXSA9IHRoaXMuX3g7XG4gICAgXHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0aGlzLl95O1xuICAgIFx0XHRhcnJheVsgb2Zmc2V0ICsgMiBdID0gdGhpcy5fejtcbiAgICBcdFx0YXJyYXlbIG9mZnNldCArIDMgXSA9IHRoaXMuX29yZGVyO1xuXG4gICAgXHRcdHJldHVybiBhcnJheTtcblxuICAgIFx0fSxcblxuICAgIFx0dG9WZWN0b3IzOiBmdW5jdGlvbiAoIG9wdGlvbmFsUmVzdWx0ICkge1xuXG4gICAgXHRcdGlmICggb3B0aW9uYWxSZXN1bHQgKSB7XG5cbiAgICBcdFx0XHRyZXR1cm4gb3B0aW9uYWxSZXN1bHQuc2V0KCB0aGlzLl94LCB0aGlzLl95LCB0aGlzLl96ICk7XG5cbiAgICBcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdHJldHVybiBuZXcgVmVjdG9yMyggdGhpcy5feCwgdGhpcy5feSwgdGhpcy5feiApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0fSxcblxuICAgIFx0b25DaGFuZ2U6IGZ1bmN0aW9uICggY2FsbGJhY2sgKSB7XG5cbiAgICBcdFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrID0gY2FsbGJhY2s7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdG9uQ2hhbmdlQ2FsbGJhY2s6IGZ1bmN0aW9uICgpIHt9XG5cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIExheWVycygpIHtcblxuICAgIFx0dGhpcy5tYXNrID0gMTtcblxuICAgIH1cblxuICAgIExheWVycy5wcm90b3R5cGUgPSB7XG5cbiAgICBcdGNvbnN0cnVjdG9yOiBMYXllcnMsXG5cbiAgICBcdHNldDogZnVuY3Rpb24gKCBjaGFubmVsICkge1xuXG4gICAgXHRcdHRoaXMubWFzayA9IDEgPDwgY2hhbm5lbDtcblxuICAgIFx0fSxcblxuICAgIFx0ZW5hYmxlOiBmdW5jdGlvbiAoIGNoYW5uZWwgKSB7XG5cbiAgICBcdFx0dGhpcy5tYXNrIHw9IDEgPDwgY2hhbm5lbDtcblxuICAgIFx0fSxcblxuICAgIFx0dG9nZ2xlOiBmdW5jdGlvbiAoIGNoYW5uZWwgKSB7XG5cbiAgICBcdFx0dGhpcy5tYXNrIF49IDEgPDwgY2hhbm5lbDtcblxuICAgIFx0fSxcblxuICAgIFx0ZGlzYWJsZTogZnVuY3Rpb24gKCBjaGFubmVsICkge1xuXG4gICAgXHRcdHRoaXMubWFzayAmPSB+ICggMSA8PCBjaGFubmVsICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdHRlc3Q6IGZ1bmN0aW9uICggbGF5ZXJzICkge1xuXG4gICAgXHRcdHJldHVybiAoIHRoaXMubWFzayAmIGxheWVycy5tYXNrICkgIT09IDA7XG5cbiAgICBcdH1cblxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICAgICAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG4gICAgICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAgICAgKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAgICAgKiBAYXV0aG9yIGVsZXBoYW50YXR3b3JrIC8gd3d3LmVsZXBoYW50YXR3b3JrLmNoXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBPYmplY3QzRCgpIHtcblxuICAgIFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCAnaWQnLCB7IHZhbHVlOiBPYmplY3QzRElkQ291bnQoKSB9ICk7XG5cbiAgICBcdHRoaXMudXVpZCA9IGV4cG9ydHMuTWF0aC5nZW5lcmF0ZVVVSUQoKTtcblxuICAgIFx0dGhpcy5uYW1lID0gJyc7XG4gICAgXHR0aGlzLnR5cGUgPSAnT2JqZWN0M0QnO1xuXG4gICAgXHR0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgXHR0aGlzLmNoaWxkcmVuID0gW107XG5cbiAgICBcdHRoaXMudXAgPSBPYmplY3QzRC5EZWZhdWx0VXAuY2xvbmUoKTtcblxuICAgIFx0dmFyIHBvc2l0aW9uID0gbmV3IFZlY3RvcjMoKTtcbiAgICBcdHZhciByb3RhdGlvbiA9IG5ldyBFdWxlcigpO1xuICAgIFx0dmFyIHF1YXRlcm5pb24gPSBuZXcgUXVhdGVybmlvbigpO1xuICAgIFx0dmFyIHNjYWxlID0gbmV3IFZlY3RvcjMoIDEsIDEsIDEgKTtcblxuICAgIFx0ZnVuY3Rpb24gb25Sb3RhdGlvbkNoYW5nZSgpIHtcblxuICAgIFx0XHRxdWF0ZXJuaW9uLnNldEZyb21FdWxlciggcm90YXRpb24sIGZhbHNlICk7XG5cbiAgICBcdH1cblxuICAgIFx0ZnVuY3Rpb24gb25RdWF0ZXJuaW9uQ2hhbmdlKCkge1xuXG4gICAgXHRcdHJvdGF0aW9uLnNldEZyb21RdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uLCB1bmRlZmluZWQsIGZhbHNlICk7XG5cbiAgICBcdH1cblxuICAgIFx0cm90YXRpb24ub25DaGFuZ2UoIG9uUm90YXRpb25DaGFuZ2UgKTtcbiAgICBcdHF1YXRlcm5pb24ub25DaGFuZ2UoIG9uUXVhdGVybmlvbkNoYW5nZSApO1xuXG4gICAgXHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyggdGhpcywge1xuICAgIFx0XHRwb3NpdGlvbjoge1xuICAgIFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gICAgXHRcdFx0dmFsdWU6IHBvc2l0aW9uXG4gICAgXHRcdH0sXG4gICAgXHRcdHJvdGF0aW9uOiB7XG4gICAgXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBcdFx0XHR2YWx1ZTogcm90YXRpb25cbiAgICBcdFx0fSxcbiAgICBcdFx0cXVhdGVybmlvbjoge1xuICAgIFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gICAgXHRcdFx0dmFsdWU6IHF1YXRlcm5pb25cbiAgICBcdFx0fSxcbiAgICBcdFx0c2NhbGU6IHtcbiAgICBcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuICAgIFx0XHRcdHZhbHVlOiBzY2FsZVxuICAgIFx0XHR9LFxuICAgIFx0XHRtb2RlbFZpZXdNYXRyaXg6IHtcbiAgICBcdFx0XHR2YWx1ZTogbmV3IE1hdHJpeDQoKVxuICAgIFx0XHR9LFxuICAgIFx0XHRub3JtYWxNYXRyaXg6IHtcbiAgICBcdFx0XHR2YWx1ZTogbmV3IE1hdHJpeDMoKVxuICAgIFx0XHR9XG4gICAgXHR9ICk7XG5cbiAgICBcdHRoaXMubWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcbiAgICBcdHRoaXMubWF0cml4V29ybGQgPSBuZXcgTWF0cml4NCgpO1xuXG4gICAgXHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBPYmplY3QzRC5EZWZhdWx0TWF0cml4QXV0b1VwZGF0ZTtcbiAgICBcdHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXG4gICAgXHR0aGlzLmxheWVycyA9IG5ldyBMYXllcnMoKTtcbiAgICBcdHRoaXMudmlzaWJsZSA9IHRydWU7XG5cbiAgICBcdHRoaXMuY2FzdFNoYWRvdyA9IGZhbHNlO1xuICAgIFx0dGhpcy5yZWNlaXZlU2hhZG93ID0gZmFsc2U7XG5cbiAgICBcdHRoaXMuZnJ1c3R1bUN1bGxlZCA9IHRydWU7XG4gICAgXHR0aGlzLnJlbmRlck9yZGVyID0gMDtcblxuICAgIFx0dGhpcy51c2VyRGF0YSA9IHt9O1xuXG4gICAgXHR0aGlzLm9uQmVmb3JlUmVuZGVyID0gbnVsbDtcblxuICAgIH1cblxuICAgIE9iamVjdDNELkRlZmF1bHRVcCA9IG5ldyBWZWN0b3IzKCAwLCAxLCAwICk7XG4gICAgT2JqZWN0M0QuRGVmYXVsdE1hdHJpeEF1dG9VcGRhdGUgPSB0cnVlO1xuXG4gICAgT2JqZWN0LmFzc2lnbiggT2JqZWN0M0QucHJvdG90eXBlLCBFdmVudERpc3BhdGNoZXIucHJvdG90eXBlLCB7XG5cbiAgICBcdGlzT2JqZWN0M0Q6IHRydWUsXG5cbiAgICBcdGFwcGx5TWF0cml4OiBmdW5jdGlvbiAoIG1hdHJpeCApIHtcblxuICAgIFx0XHR0aGlzLm1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBtYXRyaXgsIHRoaXMubWF0cml4ICk7XG5cbiAgICBcdFx0dGhpcy5tYXRyaXguZGVjb21wb3NlKCB0aGlzLnBvc2l0aW9uLCB0aGlzLnF1YXRlcm5pb24sIHRoaXMuc2NhbGUgKTtcblxuICAgIFx0fSxcblxuICAgIFx0c2V0Um90YXRpb25Gcm9tQXhpc0FuZ2xlOiBmdW5jdGlvbiAoIGF4aXMsIGFuZ2xlICkge1xuXG4gICAgXHRcdC8vIGFzc3VtZXMgYXhpcyBpcyBub3JtYWxpemVkXG5cbiAgICBcdFx0dGhpcy5xdWF0ZXJuaW9uLnNldEZyb21BeGlzQW5nbGUoIGF4aXMsIGFuZ2xlICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldFJvdGF0aW9uRnJvbUV1bGVyOiBmdW5jdGlvbiAoIGV1bGVyICkge1xuXG4gICAgXHRcdHRoaXMucXVhdGVybmlvbi5zZXRGcm9tRXVsZXIoIGV1bGVyLCB0cnVlICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldFJvdGF0aW9uRnJvbU1hdHJpeDogZnVuY3Rpb24gKCBtICkge1xuXG4gICAgXHRcdC8vIGFzc3VtZXMgdGhlIHVwcGVyIDN4MyBvZiBtIGlzIGEgcHVyZSByb3RhdGlvbiBtYXRyaXggKGkuZSwgdW5zY2FsZWQpXG5cbiAgICBcdFx0dGhpcy5xdWF0ZXJuaW9uLnNldEZyb21Sb3RhdGlvbk1hdHJpeCggbSApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRzZXRSb3RhdGlvbkZyb21RdWF0ZXJuaW9uOiBmdW5jdGlvbiAoIHEgKSB7XG5cbiAgICBcdFx0Ly8gYXNzdW1lcyBxIGlzIG5vcm1hbGl6ZWRcblxuICAgIFx0XHR0aGlzLnF1YXRlcm5pb24uY29weSggcSApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRyb3RhdGVPbkF4aXM6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHQvLyByb3RhdGUgb2JqZWN0IG9uIGF4aXMgaW4gb2JqZWN0IHNwYWNlXG4gICAgXHRcdC8vIGF4aXMgaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkXG5cbiAgICBcdFx0dmFyIHExID0gbmV3IFF1YXRlcm5pb24oKTtcblxuICAgIFx0XHRyZXR1cm4gZnVuY3Rpb24gcm90YXRlT25BeGlzKCBheGlzLCBhbmdsZSApIHtcblxuICAgIFx0XHRcdHExLnNldEZyb21BeGlzQW5nbGUoIGF4aXMsIGFuZ2xlICk7XG5cbiAgICBcdFx0XHR0aGlzLnF1YXRlcm5pb24ubXVsdGlwbHkoIHExICk7XG5cbiAgICBcdFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0XHR9O1xuXG4gICAgXHR9KCksXG5cbiAgICBcdHJvdGF0ZVg6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR2YXIgdjEgPSBuZXcgVmVjdG9yMyggMSwgMCwgMCApO1xuXG4gICAgXHRcdHJldHVybiBmdW5jdGlvbiByb3RhdGVYKCBhbmdsZSApIHtcblxuICAgIFx0XHRcdHJldHVybiB0aGlzLnJvdGF0ZU9uQXhpcyggdjEsIGFuZ2xlICk7XG5cbiAgICBcdFx0fTtcblxuICAgIFx0fSgpLFxuXG4gICAgXHRyb3RhdGVZOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoIDAsIDEsIDAgKTtcblxuICAgIFx0XHRyZXR1cm4gZnVuY3Rpb24gcm90YXRlWSggYW5nbGUgKSB7XG5cbiAgICBcdFx0XHRyZXR1cm4gdGhpcy5yb3RhdGVPbkF4aXMoIHYxLCBhbmdsZSApO1xuXG4gICAgXHRcdH07XG5cbiAgICBcdH0oKSxcblxuICAgIFx0cm90YXRlWjogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCAwLCAwLCAxICk7XG5cbiAgICBcdFx0cmV0dXJuIGZ1bmN0aW9uIHJvdGF0ZVooIGFuZ2xlICkge1xuXG4gICAgXHRcdFx0cmV0dXJuIHRoaXMucm90YXRlT25BeGlzKCB2MSwgYW5nbGUgKTtcblxuICAgIFx0XHR9O1xuXG4gICAgXHR9KCksXG5cbiAgICBcdHRyYW5zbGF0ZU9uQXhpczogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdC8vIHRyYW5zbGF0ZSBvYmplY3QgYnkgZGlzdGFuY2UgYWxvbmcgYXhpcyBpbiBvYmplY3Qgc3BhY2VcbiAgICBcdFx0Ly8gYXhpcyBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWRcblxuICAgIFx0XHR2YXIgdjEgPSBuZXcgVmVjdG9yMygpO1xuXG4gICAgXHRcdHJldHVybiBmdW5jdGlvbiB0cmFuc2xhdGVPbkF4aXMoIGF4aXMsIGRpc3RhbmNlICkge1xuXG4gICAgXHRcdFx0djEuY29weSggYXhpcyApLmFwcGx5UXVhdGVybmlvbiggdGhpcy5xdWF0ZXJuaW9uICk7XG5cbiAgICBcdFx0XHR0aGlzLnBvc2l0aW9uLmFkZCggdjEubXVsdGlwbHlTY2FsYXIoIGRpc3RhbmNlICkgKTtcblxuICAgIFx0XHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHRcdH07XG5cbiAgICBcdH0oKSxcblxuICAgIFx0dHJhbnNsYXRlWDogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCAxLCAwLCAwICk7XG5cbiAgICBcdFx0cmV0dXJuIGZ1bmN0aW9uIHRyYW5zbGF0ZVgoIGRpc3RhbmNlICkge1xuXG4gICAgXHRcdFx0cmV0dXJuIHRoaXMudHJhbnNsYXRlT25BeGlzKCB2MSwgZGlzdGFuY2UgKTtcblxuICAgIFx0XHR9O1xuXG4gICAgXHR9KCksXG5cbiAgICBcdHRyYW5zbGF0ZVk6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR2YXIgdjEgPSBuZXcgVmVjdG9yMyggMCwgMSwgMCApO1xuXG4gICAgXHRcdHJldHVybiBmdW5jdGlvbiB0cmFuc2xhdGVZKCBkaXN0YW5jZSApIHtcblxuICAgIFx0XHRcdHJldHVybiB0aGlzLnRyYW5zbGF0ZU9uQXhpcyggdjEsIGRpc3RhbmNlICk7XG5cbiAgICBcdFx0fTtcblxuICAgIFx0fSgpLFxuXG4gICAgXHR0cmFuc2xhdGVaOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoIDAsIDAsIDEgKTtcblxuICAgIFx0XHRyZXR1cm4gZnVuY3Rpb24gdHJhbnNsYXRlWiggZGlzdGFuY2UgKSB7XG5cbiAgICBcdFx0XHRyZXR1cm4gdGhpcy50cmFuc2xhdGVPbkF4aXMoIHYxLCBkaXN0YW5jZSApO1xuXG4gICAgXHRcdH07XG5cbiAgICBcdH0oKSxcblxuICAgIFx0bG9jYWxUb1dvcmxkOiBmdW5jdGlvbiAoIHZlY3RvciApIHtcblxuICAgIFx0XHRyZXR1cm4gdmVjdG9yLmFwcGx5TWF0cml4NCggdGhpcy5tYXRyaXhXb3JsZCApO1xuXG4gICAgXHR9LFxuXG4gICAgXHR3b3JsZFRvTG9jYWw6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR2YXIgbTEgPSBuZXcgTWF0cml4NCgpO1xuXG4gICAgXHRcdHJldHVybiBmdW5jdGlvbiB3b3JsZFRvTG9jYWwoIHZlY3RvciApIHtcblxuICAgIFx0XHRcdHJldHVybiB2ZWN0b3IuYXBwbHlNYXRyaXg0KCBtMS5nZXRJbnZlcnNlKCB0aGlzLm1hdHJpeFdvcmxkICkgKTtcblxuICAgIFx0XHR9O1xuXG4gICAgXHR9KCksXG5cbiAgICBcdGxvb2tBdDogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdC8vIFRoaXMgcm91dGluZSBkb2VzIG5vdCBzdXBwb3J0IG9iamVjdHMgd2l0aCByb3RhdGVkIGFuZC9vciB0cmFuc2xhdGVkIHBhcmVudChzKVxuXG4gICAgXHRcdHZhciBtMSA9IG5ldyBNYXRyaXg0KCk7XG5cbiAgICBcdFx0cmV0dXJuIGZ1bmN0aW9uIGxvb2tBdCggdmVjdG9yICkge1xuXG4gICAgXHRcdFx0bTEubG9va0F0KCB2ZWN0b3IsIHRoaXMucG9zaXRpb24sIHRoaXMudXAgKTtcblxuICAgIFx0XHRcdHRoaXMucXVhdGVybmlvbi5zZXRGcm9tUm90YXRpb25NYXRyaXgoIG0xICk7XG5cbiAgICBcdFx0fTtcblxuICAgIFx0fSgpLFxuXG4gICAgXHRhZGQ6IGZ1bmN0aW9uICggb2JqZWN0ICkge1xuXG4gICAgXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCA+IDEgKSB7XG5cbiAgICBcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpICsrICkge1xuXG4gICAgXHRcdFx0XHR0aGlzLmFkZCggYXJndW1lbnRzWyBpIF0gKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRpZiAoIG9iamVjdCA9PT0gdGhpcyApIHtcblxuICAgIFx0XHRcdGNvbnNvbGUuZXJyb3IoIFwiVEhSRUUuT2JqZWN0M0QuYWRkOiBvYmplY3QgY2FuJ3QgYmUgYWRkZWQgYXMgYSBjaGlsZCBvZiBpdHNlbGYuXCIsIG9iamVjdCApO1xuICAgIFx0XHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRpZiAoIChvYmplY3QgJiYgb2JqZWN0LmlzT2JqZWN0M0QpICkge1xuXG4gICAgXHRcdFx0aWYgKCBvYmplY3QucGFyZW50ICE9PSBudWxsICkge1xuXG4gICAgXHRcdFx0XHRvYmplY3QucGFyZW50LnJlbW92ZSggb2JqZWN0ICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRvYmplY3QucGFyZW50ID0gdGhpcztcbiAgICBcdFx0XHRvYmplY3QuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAnYWRkZWQnIH0gKTtcblxuICAgIFx0XHRcdHRoaXMuY2hpbGRyZW4ucHVzaCggb2JqZWN0ICk7XG5cbiAgICBcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdGNvbnNvbGUuZXJyb3IoIFwiVEhSRUUuT2JqZWN0M0QuYWRkOiBvYmplY3Qgbm90IGFuIGluc3RhbmNlIG9mIFRIUkVFLk9iamVjdDNELlwiLCBvYmplY3QgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdHJlbW92ZTogZnVuY3Rpb24gKCBvYmplY3QgKSB7XG5cbiAgICBcdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID4gMSApIHtcblxuICAgIFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkgKysgKSB7XG5cbiAgICBcdFx0XHRcdHRoaXMucmVtb3ZlKCBhcmd1bWVudHNbIGkgXSApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHR2YXIgaW5kZXggPSB0aGlzLmNoaWxkcmVuLmluZGV4T2YoIG9iamVjdCApO1xuXG4gICAgXHRcdGlmICggaW5kZXggIT09IC0gMSApIHtcblxuICAgIFx0XHRcdG9iamVjdC5wYXJlbnQgPSBudWxsO1xuXG4gICAgXHRcdFx0b2JqZWN0LmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ3JlbW92ZWQnIH0gKTtcblxuICAgIFx0XHRcdHRoaXMuY2hpbGRyZW4uc3BsaWNlKCBpbmRleCwgMSApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0fSxcblxuICAgIFx0Z2V0T2JqZWN0QnlJZDogZnVuY3Rpb24gKCBpZCApIHtcblxuICAgIFx0XHRyZXR1cm4gdGhpcy5nZXRPYmplY3RCeVByb3BlcnR5KCAnaWQnLCBpZCApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRnZXRPYmplY3RCeU5hbWU6IGZ1bmN0aW9uICggbmFtZSApIHtcblxuICAgIFx0XHRyZXR1cm4gdGhpcy5nZXRPYmplY3RCeVByb3BlcnR5KCAnbmFtZScsIG5hbWUgKTtcblxuICAgIFx0fSxcblxuICAgIFx0Z2V0T2JqZWN0QnlQcm9wZXJ0eTogZnVuY3Rpb24gKCBuYW1lLCB2YWx1ZSApIHtcblxuICAgIFx0XHRpZiAoIHRoaXNbIG5hbWUgXSA9PT0gdmFsdWUgKSByZXR1cm4gdGhpcztcblxuICAgIFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICBcdFx0XHR2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuWyBpIF07XG4gICAgXHRcdFx0dmFyIG9iamVjdCA9IGNoaWxkLmdldE9iamVjdEJ5UHJvcGVydHkoIG5hbWUsIHZhbHVlICk7XG5cbiAgICBcdFx0XHRpZiAoIG9iamVjdCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0XHRyZXR1cm4gb2JqZWN0O1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXG4gICAgXHR9LFxuXG4gICAgXHRnZXRXb3JsZFBvc2l0aW9uOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgXHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMygpO1xuXG4gICAgXHRcdHRoaXMudXBkYXRlTWF0cml4V29ybGQoIHRydWUgKTtcblxuICAgIFx0XHRyZXR1cm4gcmVzdWx0LnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5tYXRyaXhXb3JsZCApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRnZXRXb3JsZFF1YXRlcm5pb246IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR2YXIgcG9zaXRpb24gPSBuZXcgVmVjdG9yMygpO1xuICAgIFx0XHR2YXIgc2NhbGUgPSBuZXcgVmVjdG9yMygpO1xuXG4gICAgXHRcdHJldHVybiBmdW5jdGlvbiBnZXRXb3JsZFF1YXRlcm5pb24oIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgXHRcdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBRdWF0ZXJuaW9uKCk7XG5cbiAgICBcdFx0XHR0aGlzLnVwZGF0ZU1hdHJpeFdvcmxkKCB0cnVlICk7XG5cbiAgICBcdFx0XHR0aGlzLm1hdHJpeFdvcmxkLmRlY29tcG9zZSggcG9zaXRpb24sIHJlc3VsdCwgc2NhbGUgKTtcblxuICAgIFx0XHRcdHJldHVybiByZXN1bHQ7XG5cbiAgICBcdFx0fTtcblxuICAgIFx0fSgpLFxuXG4gICAgXHRnZXRXb3JsZFJvdGF0aW9uOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dmFyIHF1YXRlcm5pb24gPSBuZXcgUXVhdGVybmlvbigpO1xuXG4gICAgXHRcdHJldHVybiBmdW5jdGlvbiBnZXRXb3JsZFJvdGF0aW9uKCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgIFx0XHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgRXVsZXIoKTtcblxuICAgIFx0XHRcdHRoaXMuZ2V0V29ybGRRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uICk7XG5cbiAgICBcdFx0XHRyZXR1cm4gcmVzdWx0LnNldEZyb21RdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uLCB0aGlzLnJvdGF0aW9uLm9yZGVyLCBmYWxzZSApO1xuXG4gICAgXHRcdH07XG5cbiAgICBcdH0oKSxcblxuICAgIFx0Z2V0V29ybGRTY2FsZTogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHZhciBwb3NpdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG4gICAgXHRcdHZhciBxdWF0ZXJuaW9uID0gbmV3IFF1YXRlcm5pb24oKTtcblxuICAgIFx0XHRyZXR1cm4gZnVuY3Rpb24gZ2V0V29ybGRTY2FsZSggb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICBcdFx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjMoKTtcblxuICAgIFx0XHRcdHRoaXMudXBkYXRlTWF0cml4V29ybGQoIHRydWUgKTtcblxuICAgIFx0XHRcdHRoaXMubWF0cml4V29ybGQuZGVjb21wb3NlKCBwb3NpdGlvbiwgcXVhdGVybmlvbiwgcmVzdWx0ICk7XG5cbiAgICBcdFx0XHRyZXR1cm4gcmVzdWx0O1xuXG4gICAgXHRcdH07XG5cbiAgICBcdH0oKSxcblxuICAgIFx0Z2V0V29ybGREaXJlY3Rpb246IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR2YXIgcXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XG5cbiAgICBcdFx0cmV0dXJuIGZ1bmN0aW9uIGdldFdvcmxkRGlyZWN0aW9uKCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgIFx0XHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMygpO1xuXG4gICAgXHRcdFx0dGhpcy5nZXRXb3JsZFF1YXRlcm5pb24oIHF1YXRlcm5pb24gKTtcblxuICAgIFx0XHRcdHJldHVybiByZXN1bHQuc2V0KCAwLCAwLCAxICkuYXBwbHlRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uICk7XG5cbiAgICBcdFx0fTtcblxuICAgIFx0fSgpLFxuXG4gICAgXHRyYXljYXN0OiBmdW5jdGlvbiAoKSB7fSxcblxuICAgIFx0dHJhdmVyc2U6IGZ1bmN0aW9uICggY2FsbGJhY2sgKSB7XG5cbiAgICBcdFx0Y2FsbGJhY2soIHRoaXMgKTtcblxuICAgIFx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuXG4gICAgXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICBcdFx0XHRjaGlsZHJlblsgaSBdLnRyYXZlcnNlKCBjYWxsYmFjayApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0fSxcblxuICAgIFx0dHJhdmVyc2VWaXNpYmxlOiBmdW5jdGlvbiAoIGNhbGxiYWNrICkge1xuXG4gICAgXHRcdGlmICggdGhpcy52aXNpYmxlID09PSBmYWxzZSApIHJldHVybjtcblxuICAgIFx0XHRjYWxsYmFjayggdGhpcyApO1xuXG4gICAgXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG5cbiAgICBcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgIFx0XHRcdGNoaWxkcmVuWyBpIF0udHJhdmVyc2VWaXNpYmxlKCBjYWxsYmFjayApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0fSxcblxuICAgIFx0dHJhdmVyc2VBbmNlc3RvcnM6IGZ1bmN0aW9uICggY2FsbGJhY2sgKSB7XG5cbiAgICBcdFx0dmFyIHBhcmVudCA9IHRoaXMucGFyZW50O1xuXG4gICAgXHRcdGlmICggcGFyZW50ICE9PSBudWxsICkge1xuXG4gICAgXHRcdFx0Y2FsbGJhY2soIHBhcmVudCApO1xuXG4gICAgXHRcdFx0cGFyZW50LnRyYXZlcnNlQW5jZXN0b3JzKCBjYWxsYmFjayApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0fSxcblxuICAgIFx0dXBkYXRlTWF0cml4OiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dGhpcy5tYXRyaXguY29tcG9zZSggdGhpcy5wb3NpdGlvbiwgdGhpcy5xdWF0ZXJuaW9uLCB0aGlzLnNjYWxlICk7XG5cbiAgICBcdFx0dGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgIFx0fSxcblxuICAgIFx0dXBkYXRlTWF0cml4V29ybGQ6IGZ1bmN0aW9uICggZm9yY2UgKSB7XG5cbiAgICBcdFx0aWYgKCB0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPT09IHRydWUgKSB0aGlzLnVwZGF0ZU1hdHJpeCgpO1xuXG4gICAgXHRcdGlmICggdGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID09PSB0cnVlIHx8IGZvcmNlID09PSB0cnVlICkge1xuXG4gICAgXHRcdFx0aWYgKCB0aGlzLnBhcmVudCA9PT0gbnVsbCApIHtcblxuICAgIFx0XHRcdFx0dGhpcy5tYXRyaXhXb3JsZC5jb3B5KCB0aGlzLm1hdHJpeCApO1xuXG4gICAgXHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0dGhpcy5tYXRyaXhXb3JsZC5tdWx0aXBseU1hdHJpY2VzKCB0aGlzLnBhcmVudC5tYXRyaXhXb3JsZCwgdGhpcy5tYXRyaXggKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXG4gICAgXHRcdFx0Zm9yY2UgPSB0cnVlO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHQvLyB1cGRhdGUgY2hpbGRyZW5cblxuICAgIFx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuXG4gICAgXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICBcdFx0XHRjaGlsZHJlblsgaSBdLnVwZGF0ZU1hdHJpeFdvcmxkKCBmb3JjZSApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0fSxcblxuICAgIFx0dG9KU09OOiBmdW5jdGlvbiAoIG1ldGEgKSB7XG5cbiAgICBcdFx0Ly8gbWV0YSBpcyAnJyB3aGVuIGNhbGxlZCBmcm9tIEpTT04uc3RyaW5naWZ5XG4gICAgXHRcdHZhciBpc1Jvb3RPYmplY3QgPSAoIG1ldGEgPT09IHVuZGVmaW5lZCB8fCBtZXRhID09PSAnJyApO1xuXG4gICAgXHRcdHZhciBvdXRwdXQgPSB7fTtcblxuICAgIFx0XHQvLyBtZXRhIGlzIGEgaGFzaCB1c2VkIHRvIGNvbGxlY3QgZ2VvbWV0cmllcywgbWF0ZXJpYWxzLlxuICAgIFx0XHQvLyBub3QgcHJvdmlkaW5nIGl0IGltcGxpZXMgdGhhdCB0aGlzIGlzIHRoZSByb290IG9iamVjdFxuICAgIFx0XHQvLyBiZWluZyBzZXJpYWxpemVkLlxuICAgIFx0XHRpZiAoIGlzUm9vdE9iamVjdCApIHtcblxuICAgIFx0XHRcdC8vIGluaXRpYWxpemUgbWV0YSBvYmpcbiAgICBcdFx0XHRtZXRhID0ge1xuICAgIFx0XHRcdFx0Z2VvbWV0cmllczoge30sXG4gICAgXHRcdFx0XHRtYXRlcmlhbHM6IHt9LFxuICAgIFx0XHRcdFx0dGV4dHVyZXM6IHt9LFxuICAgIFx0XHRcdFx0aW1hZ2VzOiB7fVxuICAgIFx0XHRcdH07XG5cbiAgICBcdFx0XHRvdXRwdXQubWV0YWRhdGEgPSB7XG4gICAgXHRcdFx0XHR2ZXJzaW9uOiA0LjQsXG4gICAgXHRcdFx0XHR0eXBlOiAnT2JqZWN0JyxcbiAgICBcdFx0XHRcdGdlbmVyYXRvcjogJ09iamVjdDNELnRvSlNPTidcbiAgICBcdFx0XHR9O1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHQvLyBzdGFuZGFyZCBPYmplY3QzRCBzZXJpYWxpemF0aW9uXG5cbiAgICBcdFx0dmFyIG9iamVjdCA9IHt9O1xuXG4gICAgXHRcdG9iamVjdC51dWlkID0gdGhpcy51dWlkO1xuICAgIFx0XHRvYmplY3QudHlwZSA9IHRoaXMudHlwZTtcblxuICAgIFx0XHRpZiAoIHRoaXMubmFtZSAhPT0gJycgKSBvYmplY3QubmFtZSA9IHRoaXMubmFtZTtcbiAgICBcdFx0aWYgKCBKU09OLnN0cmluZ2lmeSggdGhpcy51c2VyRGF0YSApICE9PSAne30nICkgb2JqZWN0LnVzZXJEYXRhID0gdGhpcy51c2VyRGF0YTtcbiAgICBcdFx0aWYgKCB0aGlzLmNhc3RTaGFkb3cgPT09IHRydWUgKSBvYmplY3QuY2FzdFNoYWRvdyA9IHRydWU7XG4gICAgXHRcdGlmICggdGhpcy5yZWNlaXZlU2hhZG93ID09PSB0cnVlICkgb2JqZWN0LnJlY2VpdmVTaGFkb3cgPSB0cnVlO1xuICAgIFx0XHRpZiAoIHRoaXMudmlzaWJsZSA9PT0gZmFsc2UgKSBvYmplY3QudmlzaWJsZSA9IGZhbHNlO1xuXG4gICAgXHRcdG9iamVjdC5tYXRyaXggPSB0aGlzLm1hdHJpeC50b0FycmF5KCk7XG5cbiAgICBcdFx0Ly9cblxuICAgIFx0XHRpZiAoIHRoaXMuZ2VvbWV0cnkgIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdGlmICggbWV0YS5nZW9tZXRyaWVzWyB0aGlzLmdlb21ldHJ5LnV1aWQgXSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0XHRtZXRhLmdlb21ldHJpZXNbIHRoaXMuZ2VvbWV0cnkudXVpZCBdID0gdGhpcy5nZW9tZXRyeS50b0pTT04oIG1ldGEgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdG9iamVjdC5nZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnkudXVpZDtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0aWYgKCB0aGlzLm1hdGVyaWFsICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRpZiAoIG1ldGEubWF0ZXJpYWxzWyB0aGlzLm1hdGVyaWFsLnV1aWQgXSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0XHRtZXRhLm1hdGVyaWFsc1sgdGhpcy5tYXRlcmlhbC51dWlkIF0gPSB0aGlzLm1hdGVyaWFsLnRvSlNPTiggbWV0YSApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0b2JqZWN0Lm1hdGVyaWFsID0gdGhpcy5tYXRlcmlhbC51dWlkO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHQvL1xuXG4gICAgXHRcdGlmICggdGhpcy5jaGlsZHJlbi5sZW5ndGggPiAwICkge1xuXG4gICAgXHRcdFx0b2JqZWN0LmNoaWxkcmVuID0gW107XG5cbiAgICBcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSArKyApIHtcblxuICAgIFx0XHRcdFx0b2JqZWN0LmNoaWxkcmVuLnB1c2goIHRoaXMuY2hpbGRyZW5bIGkgXS50b0pTT04oIG1ldGEgKS5vYmplY3QgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdFx0aWYgKCBpc1Jvb3RPYmplY3QgKSB7XG5cbiAgICBcdFx0XHR2YXIgZ2VvbWV0cmllcyA9IGV4dHJhY3RGcm9tQ2FjaGUoIG1ldGEuZ2VvbWV0cmllcyApO1xuICAgIFx0XHRcdHZhciBtYXRlcmlhbHMgPSBleHRyYWN0RnJvbUNhY2hlKCBtZXRhLm1hdGVyaWFscyApO1xuICAgIFx0XHRcdHZhciB0ZXh0dXJlcyA9IGV4dHJhY3RGcm9tQ2FjaGUoIG1ldGEudGV4dHVyZXMgKTtcbiAgICBcdFx0XHR2YXIgaW1hZ2VzID0gZXh0cmFjdEZyb21DYWNoZSggbWV0YS5pbWFnZXMgKTtcblxuICAgIFx0XHRcdGlmICggZ2VvbWV0cmllcy5sZW5ndGggPiAwICkgb3V0cHV0Lmdlb21ldHJpZXMgPSBnZW9tZXRyaWVzO1xuICAgIFx0XHRcdGlmICggbWF0ZXJpYWxzLmxlbmd0aCA+IDAgKSBvdXRwdXQubWF0ZXJpYWxzID0gbWF0ZXJpYWxzO1xuICAgIFx0XHRcdGlmICggdGV4dHVyZXMubGVuZ3RoID4gMCApIG91dHB1dC50ZXh0dXJlcyA9IHRleHR1cmVzO1xuICAgIFx0XHRcdGlmICggaW1hZ2VzLmxlbmd0aCA+IDAgKSBvdXRwdXQuaW1hZ2VzID0gaW1hZ2VzO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRvdXRwdXQub2JqZWN0ID0gb2JqZWN0O1xuXG4gICAgXHRcdHJldHVybiBvdXRwdXQ7XG5cbiAgICBcdFx0Ly8gZXh0cmFjdCBkYXRhIGZyb20gdGhlIGNhY2hlIGhhc2hcbiAgICBcdFx0Ly8gcmVtb3ZlIG1ldGFkYXRhIG9uIGVhY2ggaXRlbVxuICAgIFx0XHQvLyBhbmQgcmV0dXJuIGFzIGFycmF5XG4gICAgXHRcdGZ1bmN0aW9uIGV4dHJhY3RGcm9tQ2FjaGUoIGNhY2hlICkge1xuXG4gICAgXHRcdFx0dmFyIHZhbHVlcyA9IFtdO1xuICAgIFx0XHRcdGZvciAoIHZhciBrZXkgaW4gY2FjaGUgKSB7XG5cbiAgICBcdFx0XHRcdHZhciBkYXRhID0gY2FjaGVbIGtleSBdO1xuICAgIFx0XHRcdFx0ZGVsZXRlIGRhdGEubWV0YWRhdGE7XG4gICAgXHRcdFx0XHR2YWx1ZXMucHVzaCggZGF0YSApO1xuXG4gICAgXHRcdFx0fVxuICAgIFx0XHRcdHJldHVybiB2YWx1ZXM7XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9LFxuXG4gICAgXHRjbG9uZTogZnVuY3Rpb24gKCByZWN1cnNpdmUgKSB7XG5cbiAgICBcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcywgcmVjdXJzaXZlICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGNvcHk6IGZ1bmN0aW9uICggc291cmNlLCByZWN1cnNpdmUgKSB7XG5cbiAgICBcdFx0aWYgKCByZWN1cnNpdmUgPT09IHVuZGVmaW5lZCApIHJlY3Vyc2l2ZSA9IHRydWU7XG5cbiAgICBcdFx0dGhpcy5uYW1lID0gc291cmNlLm5hbWU7XG5cbiAgICBcdFx0dGhpcy51cC5jb3B5KCBzb3VyY2UudXAgKTtcblxuICAgIFx0XHR0aGlzLnBvc2l0aW9uLmNvcHkoIHNvdXJjZS5wb3NpdGlvbiApO1xuICAgIFx0XHR0aGlzLnF1YXRlcm5pb24uY29weSggc291cmNlLnF1YXRlcm5pb24gKTtcbiAgICBcdFx0dGhpcy5zY2FsZS5jb3B5KCBzb3VyY2Uuc2NhbGUgKTtcblxuICAgIFx0XHR0aGlzLm1hdHJpeC5jb3B5KCBzb3VyY2UubWF0cml4ICk7XG4gICAgXHRcdHRoaXMubWF0cml4V29ybGQuY29weSggc291cmNlLm1hdHJpeFdvcmxkICk7XG5cbiAgICBcdFx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gc291cmNlLm1hdHJpeEF1dG9VcGRhdGU7XG4gICAgXHRcdHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IHNvdXJjZS5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlO1xuXG4gICAgXHRcdHRoaXMudmlzaWJsZSA9IHNvdXJjZS52aXNpYmxlO1xuXG4gICAgXHRcdHRoaXMuY2FzdFNoYWRvdyA9IHNvdXJjZS5jYXN0U2hhZG93O1xuICAgIFx0XHR0aGlzLnJlY2VpdmVTaGFkb3cgPSBzb3VyY2UucmVjZWl2ZVNoYWRvdztcblxuICAgIFx0XHR0aGlzLmZydXN0dW1DdWxsZWQgPSBzb3VyY2UuZnJ1c3R1bUN1bGxlZDtcbiAgICBcdFx0dGhpcy5yZW5kZXJPcmRlciA9IHNvdXJjZS5yZW5kZXJPcmRlcjtcblxuICAgIFx0XHR0aGlzLnVzZXJEYXRhID0gSlNPTi5wYXJzZSggSlNPTi5zdHJpbmdpZnkoIHNvdXJjZS51c2VyRGF0YSApICk7XG5cbiAgICBcdFx0aWYgKCByZWN1cnNpdmUgPT09IHRydWUgKSB7XG5cbiAgICBcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBzb3VyY2UuY2hpbGRyZW4ubGVuZ3RoOyBpICsrICkge1xuXG4gICAgXHRcdFx0XHR2YXIgY2hpbGQgPSBzb3VyY2UuY2hpbGRyZW5bIGkgXTtcbiAgICBcdFx0XHRcdHRoaXMuYWRkKCBjaGlsZC5jbG9uZSgpICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9XG5cbiAgICB9ICk7XG5cbiAgICB2YXIgY291bnQkMiA9IDA7XG4gICAgZnVuY3Rpb24gT2JqZWN0M0RJZENvdW50KCkgeyByZXR1cm4gY291bnQkMisrOyB9O1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pb1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gTGluZTMoIHN0YXJ0LCBlbmQgKSB7XG5cbiAgICBcdHRoaXMuc3RhcnQgPSAoIHN0YXJ0ICE9PSB1bmRlZmluZWQgKSA/IHN0YXJ0IDogbmV3IFZlY3RvcjMoKTtcbiAgICBcdHRoaXMuZW5kID0gKCBlbmQgIT09IHVuZGVmaW5lZCApID8gZW5kIDogbmV3IFZlY3RvcjMoKTtcblxuICAgIH1cblxuICAgIExpbmUzLnByb3RvdHlwZSA9IHtcblxuICAgIFx0Y29uc3RydWN0b3I6IExpbmUzLFxuXG4gICAgXHRzZXQ6IGZ1bmN0aW9uICggc3RhcnQsIGVuZCApIHtcblxuICAgIFx0XHR0aGlzLnN0YXJ0LmNvcHkoIHN0YXJ0ICk7XG4gICAgXHRcdHRoaXMuZW5kLmNvcHkoIGVuZCApO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblxuICAgIFx0fSxcblxuICAgIFx0Y29weTogZnVuY3Rpb24gKCBsaW5lICkge1xuXG4gICAgXHRcdHRoaXMuc3RhcnQuY29weSggbGluZS5zdGFydCApO1xuICAgIFx0XHR0aGlzLmVuZC5jb3B5KCBsaW5lLmVuZCApO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRnZXRDZW50ZXI6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICBcdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IzKCk7XG4gICAgXHRcdHJldHVybiByZXN1bHQuYWRkVmVjdG9ycyggdGhpcy5zdGFydCwgdGhpcy5lbmQgKS5tdWx0aXBseVNjYWxhciggMC41ICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGRlbHRhOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgXHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMygpO1xuICAgIFx0XHRyZXR1cm4gcmVzdWx0LnN1YlZlY3RvcnMoIHRoaXMuZW5kLCB0aGlzLnN0YXJ0ICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGRpc3RhbmNlU3E6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHRyZXR1cm4gdGhpcy5zdGFydC5kaXN0YW5jZVRvU3F1YXJlZCggdGhpcy5lbmQgKTtcblxuICAgIFx0fSxcblxuICAgIFx0ZGlzdGFuY2U6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHRyZXR1cm4gdGhpcy5zdGFydC5kaXN0YW5jZVRvKCB0aGlzLmVuZCApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRhdDogZnVuY3Rpb24gKCB0LCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgIFx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjMoKTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcy5kZWx0YSggcmVzdWx0ICkubXVsdGlwbHlTY2FsYXIoIHQgKS5hZGQoIHRoaXMuc3RhcnQgKTtcblxuICAgIFx0fSxcblxuICAgIFx0Y2xvc2VzdFBvaW50VG9Qb2ludFBhcmFtZXRlcjogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHZhciBzdGFydFAgPSBuZXcgVmVjdG9yMygpO1xuICAgIFx0XHR2YXIgc3RhcnRFbmQgPSBuZXcgVmVjdG9yMygpO1xuXG4gICAgXHRcdHJldHVybiBmdW5jdGlvbiBjbG9zZXN0UG9pbnRUb1BvaW50UGFyYW1ldGVyKCBwb2ludCwgY2xhbXBUb0xpbmUgKSB7XG5cbiAgICBcdFx0XHRzdGFydFAuc3ViVmVjdG9ycyggcG9pbnQsIHRoaXMuc3RhcnQgKTtcbiAgICBcdFx0XHRzdGFydEVuZC5zdWJWZWN0b3JzKCB0aGlzLmVuZCwgdGhpcy5zdGFydCApO1xuXG4gICAgXHRcdFx0dmFyIHN0YXJ0RW5kMiA9IHN0YXJ0RW5kLmRvdCggc3RhcnRFbmQgKTtcbiAgICBcdFx0XHR2YXIgc3RhcnRFbmRfc3RhcnRQID0gc3RhcnRFbmQuZG90KCBzdGFydFAgKTtcblxuICAgIFx0XHRcdHZhciB0ID0gc3RhcnRFbmRfc3RhcnRQIC8gc3RhcnRFbmQyO1xuXG4gICAgXHRcdFx0aWYgKCBjbGFtcFRvTGluZSApIHtcblxuICAgIFx0XHRcdFx0dCA9IGV4cG9ydHMuTWF0aC5jbGFtcCggdCwgMCwgMSApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0cmV0dXJuIHQ7XG5cbiAgICBcdFx0fTtcblxuICAgIFx0fSgpLFxuXG4gICAgXHRjbG9zZXN0UG9pbnRUb1BvaW50OiBmdW5jdGlvbiAoIHBvaW50LCBjbGFtcFRvTGluZSwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICBcdFx0dmFyIHQgPSB0aGlzLmNsb3Nlc3RQb2ludFRvUG9pbnRQYXJhbWV0ZXIoIHBvaW50LCBjbGFtcFRvTGluZSApO1xuXG4gICAgXHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMygpO1xuXG4gICAgXHRcdHJldHVybiB0aGlzLmRlbHRhKCByZXN1bHQgKS5tdWx0aXBseVNjYWxhciggdCApLmFkZCggdGhpcy5zdGFydCApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRhcHBseU1hdHJpeDQ6IGZ1bmN0aW9uICggbWF0cml4ICkge1xuXG4gICAgXHRcdHRoaXMuc3RhcnQuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTtcbiAgICBcdFx0dGhpcy5lbmQuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0ZXF1YWxzOiBmdW5jdGlvbiAoIGxpbmUgKSB7XG5cbiAgICBcdFx0cmV0dXJuIGxpbmUuc3RhcnQuZXF1YWxzKCB0aGlzLnN0YXJ0ICkgJiYgbGluZS5lbmQuZXF1YWxzKCB0aGlzLmVuZCApO1xuXG4gICAgXHR9XG5cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pb1xuICAgICAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBUcmlhbmdsZSggYSwgYiwgYyApIHtcblxuICAgIFx0dGhpcy5hID0gKCBhICE9PSB1bmRlZmluZWQgKSA/IGEgOiBuZXcgVmVjdG9yMygpO1xuICAgIFx0dGhpcy5iID0gKCBiICE9PSB1bmRlZmluZWQgKSA/IGIgOiBuZXcgVmVjdG9yMygpO1xuICAgIFx0dGhpcy5jID0gKCBjICE9PSB1bmRlZmluZWQgKSA/IGMgOiBuZXcgVmVjdG9yMygpO1xuXG4gICAgfVxuXG4gICAgVHJpYW5nbGUubm9ybWFsID0gZnVuY3Rpb24gKCkge1xuXG4gICAgXHR2YXIgdjAgPSBuZXcgVmVjdG9yMygpO1xuXG4gICAgXHRyZXR1cm4gZnVuY3Rpb24gbm9ybWFsKCBhLCBiLCBjLCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgIFx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjMoKTtcblxuICAgIFx0XHRyZXN1bHQuc3ViVmVjdG9ycyggYywgYiApO1xuICAgIFx0XHR2MC5zdWJWZWN0b3JzKCBhLCBiICk7XG4gICAgXHRcdHJlc3VsdC5jcm9zcyggdjAgKTtcblxuICAgIFx0XHR2YXIgcmVzdWx0TGVuZ3RoU3EgPSByZXN1bHQubGVuZ3RoU3EoKTtcbiAgICBcdFx0aWYgKCByZXN1bHRMZW5ndGhTcSA+IDAgKSB7XG5cbiAgICBcdFx0XHRyZXR1cm4gcmVzdWx0Lm11bHRpcGx5U2NhbGFyKCAxIC8gTWF0aC5zcXJ0KCByZXN1bHRMZW5ndGhTcSApICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiByZXN1bHQuc2V0KCAwLCAwLCAwICk7XG5cbiAgICBcdH07XG5cbiAgICB9KCk7XG5cbiAgICAvLyBzdGF0aWMvaW5zdGFuY2UgbWV0aG9kIHRvIGNhbGN1bGF0ZSBiYXJ5Y2VudHJpYyBjb29yZGluYXRlc1xuICAgIC8vIGJhc2VkIG9uOiBodHRwOi8vd3d3LmJsYWNrcGF3bi5jb20vdGV4dHMvcG9pbnRpbnBvbHkvZGVmYXVsdC5odG1sXG4gICAgVHJpYW5nbGUuYmFyeWNvb3JkRnJvbVBvaW50ID0gZnVuY3Rpb24gKCkge1xuXG4gICAgXHR2YXIgdjAgPSBuZXcgVmVjdG9yMygpO1xuICAgIFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoKTtcbiAgICBcdHZhciB2MiA9IG5ldyBWZWN0b3IzKCk7XG5cbiAgICBcdHJldHVybiBmdW5jdGlvbiBiYXJ5Y29vcmRGcm9tUG9pbnQoIHBvaW50LCBhLCBiLCBjLCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgIFx0XHR2MC5zdWJWZWN0b3JzKCBjLCBhICk7XG4gICAgXHRcdHYxLnN1YlZlY3RvcnMoIGIsIGEgKTtcbiAgICBcdFx0djIuc3ViVmVjdG9ycyggcG9pbnQsIGEgKTtcblxuICAgIFx0XHR2YXIgZG90MDAgPSB2MC5kb3QoIHYwICk7XG4gICAgXHRcdHZhciBkb3QwMSA9IHYwLmRvdCggdjEgKTtcbiAgICBcdFx0dmFyIGRvdDAyID0gdjAuZG90KCB2MiApO1xuICAgIFx0XHR2YXIgZG90MTEgPSB2MS5kb3QoIHYxICk7XG4gICAgXHRcdHZhciBkb3QxMiA9IHYxLmRvdCggdjIgKTtcblxuICAgIFx0XHR2YXIgZGVub20gPSAoIGRvdDAwICogZG90MTEgLSBkb3QwMSAqIGRvdDAxICk7XG5cbiAgICBcdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IzKCk7XG5cbiAgICBcdFx0Ly8gY29sbGluZWFyIG9yIHNpbmd1bGFyIHRyaWFuZ2xlXG4gICAgXHRcdGlmICggZGVub20gPT09IDAgKSB7XG5cbiAgICBcdFx0XHQvLyBhcmJpdHJhcnkgbG9jYXRpb24gb3V0c2lkZSBvZiB0cmlhbmdsZT9cbiAgICBcdFx0XHQvLyBub3Qgc3VyZSBpZiB0aGlzIGlzIHRoZSBiZXN0IGlkZWEsIG1heWJlIHNob3VsZCBiZSByZXR1cm5pbmcgdW5kZWZpbmVkXG4gICAgXHRcdFx0cmV0dXJuIHJlc3VsdC5zZXQoIC0gMiwgLSAxLCAtIDEgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0dmFyIGludkRlbm9tID0gMSAvIGRlbm9tO1xuICAgIFx0XHR2YXIgdSA9ICggZG90MTEgKiBkb3QwMiAtIGRvdDAxICogZG90MTIgKSAqIGludkRlbm9tO1xuICAgIFx0XHR2YXIgdiA9ICggZG90MDAgKiBkb3QxMiAtIGRvdDAxICogZG90MDIgKSAqIGludkRlbm9tO1xuXG4gICAgXHRcdC8vIGJhcnljZW50cmljIGNvb3JkaW5hdGVzIG11c3QgYWx3YXlzIHN1bSB0byAxXG4gICAgXHRcdHJldHVybiByZXN1bHQuc2V0KCAxIC0gdSAtIHYsIHYsIHUgKTtcblxuICAgIFx0fTtcblxuICAgIH0oKTtcblxuICAgIFRyaWFuZ2xlLmNvbnRhaW5zUG9pbnQgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCk7XG5cbiAgICBcdHJldHVybiBmdW5jdGlvbiBjb250YWluc1BvaW50KCBwb2ludCwgYSwgYiwgYyApIHtcblxuICAgIFx0XHR2YXIgcmVzdWx0ID0gVHJpYW5nbGUuYmFyeWNvb3JkRnJvbVBvaW50KCBwb2ludCwgYSwgYiwgYywgdjEgKTtcblxuICAgIFx0XHRyZXR1cm4gKCByZXN1bHQueCA+PSAwICkgJiYgKCByZXN1bHQueSA+PSAwICkgJiYgKCAoIHJlc3VsdC54ICsgcmVzdWx0LnkgKSA8PSAxICk7XG5cbiAgICBcdH07XG5cbiAgICB9KCk7XG5cbiAgICBUcmlhbmdsZS5wcm90b3R5cGUgPSB7XG5cbiAgICBcdGNvbnN0cnVjdG9yOiBUcmlhbmdsZSxcblxuICAgIFx0c2V0OiBmdW5jdGlvbiAoIGEsIGIsIGMgKSB7XG5cbiAgICBcdFx0dGhpcy5hLmNvcHkoIGEgKTtcbiAgICBcdFx0dGhpcy5iLmNvcHkoIGIgKTtcbiAgICBcdFx0dGhpcy5jLmNvcHkoIGMgKTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0c2V0RnJvbVBvaW50c0FuZEluZGljZXM6IGZ1bmN0aW9uICggcG9pbnRzLCBpMCwgaTEsIGkyICkge1xuXG4gICAgXHRcdHRoaXMuYS5jb3B5KCBwb2ludHNbIGkwIF0gKTtcbiAgICBcdFx0dGhpcy5iLmNvcHkoIHBvaW50c1sgaTEgXSApO1xuICAgIFx0XHR0aGlzLmMuY29weSggcG9pbnRzWyBpMiBdICk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRjb3B5OiBmdW5jdGlvbiAoIHRyaWFuZ2xlICkge1xuXG4gICAgXHRcdHRoaXMuYS5jb3B5KCB0cmlhbmdsZS5hICk7XG4gICAgXHRcdHRoaXMuYi5jb3B5KCB0cmlhbmdsZS5iICk7XG4gICAgXHRcdHRoaXMuYy5jb3B5KCB0cmlhbmdsZS5jICk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGFyZWE6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR2YXIgdjAgPSBuZXcgVmVjdG9yMygpO1xuICAgIFx0XHR2YXIgdjEgPSBuZXcgVmVjdG9yMygpO1xuXG4gICAgXHRcdHJldHVybiBmdW5jdGlvbiBhcmVhKCkge1xuXG4gICAgXHRcdFx0djAuc3ViVmVjdG9ycyggdGhpcy5jLCB0aGlzLmIgKTtcbiAgICBcdFx0XHR2MS5zdWJWZWN0b3JzKCB0aGlzLmEsIHRoaXMuYiApO1xuXG4gICAgXHRcdFx0cmV0dXJuIHYwLmNyb3NzKCB2MSApLmxlbmd0aCgpICogMC41O1xuXG4gICAgXHRcdH07XG5cbiAgICBcdH0oKSxcblxuICAgIFx0bWlkcG9pbnQ6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICBcdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IzKCk7XG4gICAgXHRcdHJldHVybiByZXN1bHQuYWRkVmVjdG9ycyggdGhpcy5hLCB0aGlzLmIgKS5hZGQoIHRoaXMuYyApLm11bHRpcGx5U2NhbGFyKCAxIC8gMyApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRub3JtYWw6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICBcdFx0cmV0dXJuIFRyaWFuZ2xlLm5vcm1hbCggdGhpcy5hLCB0aGlzLmIsIHRoaXMuYywgb3B0aW9uYWxUYXJnZXQgKTtcblxuICAgIFx0fSxcblxuICAgIFx0cGxhbmU6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICBcdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBQbGFuZSgpO1xuXG4gICAgXHRcdHJldHVybiByZXN1bHQuc2V0RnJvbUNvcGxhbmFyUG9pbnRzKCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5jICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGJhcnljb29yZEZyb21Qb2ludDogZnVuY3Rpb24gKCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICBcdFx0cmV0dXJuIFRyaWFuZ2xlLmJhcnljb29yZEZyb21Qb2ludCggcG9pbnQsIHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMsIG9wdGlvbmFsVGFyZ2V0ICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGNvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XG5cbiAgICBcdFx0cmV0dXJuIFRyaWFuZ2xlLmNvbnRhaW5zUG9pbnQoIHBvaW50LCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5jICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGNsb3Nlc3RQb2ludFRvUG9pbnQ6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR2YXIgcGxhbmUsIGVkZ2VMaXN0LCBwcm9qZWN0ZWRQb2ludCwgY2xvc2VzdFBvaW50O1xuXG4gICAgXHRcdHJldHVybiBmdW5jdGlvbiBjbG9zZXN0UG9pbnRUb1BvaW50KCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICBcdFx0XHRpZiAoIHBsYW5lID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRcdHBsYW5lID0gbmV3IFBsYW5lKCk7XG4gICAgXHRcdFx0XHRlZGdlTGlzdCA9IFsgbmV3IExpbmUzKCksIG5ldyBMaW5lMygpLCBuZXcgTGluZTMoKSBdO1xuICAgIFx0XHRcdFx0cHJvamVjdGVkUG9pbnQgPSBuZXcgVmVjdG9yMygpO1xuICAgIFx0XHRcdFx0Y2xvc2VzdFBvaW50ID0gbmV3IFZlY3RvcjMoKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMygpO1xuICAgIFx0XHRcdHZhciBtaW5EaXN0YW5jZSA9IEluZmluaXR5O1xuXG4gICAgXHRcdFx0Ly8gcHJvamVjdCB0aGUgcG9pbnQgb250byB0aGUgcGxhbmUgb2YgdGhlIHRyaWFuZ2xlXG5cbiAgICBcdFx0XHRwbGFuZS5zZXRGcm9tQ29wbGFuYXJQb2ludHMoIHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMgKTtcbiAgICBcdFx0XHRwbGFuZS5wcm9qZWN0UG9pbnQoIHBvaW50LCBwcm9qZWN0ZWRQb2ludCApO1xuXG4gICAgXHRcdFx0Ly8gY2hlY2sgaWYgdGhlIHByb2plY3Rpb24gbGllcyB3aXRoaW4gdGhlIHRyaWFuZ2xlXG5cbiAgICBcdFx0XHRpZiggdGhpcy5jb250YWluc1BvaW50KCBwcm9qZWN0ZWRQb2ludCApID09PSB0cnVlICkge1xuXG4gICAgXHRcdFx0XHQvLyBpZiBzbywgdGhpcyBpcyB0aGUgY2xvc2VzdCBwb2ludFxuXG4gICAgXHRcdFx0XHRyZXN1bHQuY29weSggcHJvamVjdGVkUG9pbnQgKTtcblxuICAgIFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdC8vIGlmIG5vdCwgdGhlIHBvaW50IGZhbGxzIG91dHNpZGUgdGhlIHRyaWFuZ2xlLiB0aGUgcmVzdWx0IGlzIHRoZSBjbG9zZXN0IHBvaW50IHRvIHRoZSB0cmlhbmdsZSdzIGVkZ2VzIG9yIHZlcnRpY2VzXG5cbiAgICBcdFx0XHRcdGVkZ2VMaXN0WyAwIF0uc2V0KCB0aGlzLmEsIHRoaXMuYiApO1xuICAgIFx0XHRcdFx0ZWRnZUxpc3RbIDEgXS5zZXQoIHRoaXMuYiwgdGhpcy5jICk7XG4gICAgXHRcdFx0XHRlZGdlTGlzdFsgMiBdLnNldCggdGhpcy5jLCB0aGlzLmEgKTtcblxuICAgIFx0XHRcdFx0Zm9yKCB2YXIgaSA9IDA7IGkgPCBlZGdlTGlzdC5sZW5ndGg7IGkgKysgKSB7XG5cbiAgICBcdFx0XHRcdFx0ZWRnZUxpc3RbIGkgXS5jbG9zZXN0UG9pbnRUb1BvaW50KCBwcm9qZWN0ZWRQb2ludCwgdHJ1ZSwgY2xvc2VzdFBvaW50ICk7XG5cbiAgICBcdFx0XHRcdFx0dmFyIGRpc3RhbmNlID0gcHJvamVjdGVkUG9pbnQuZGlzdGFuY2VUb1NxdWFyZWQoIGNsb3Nlc3RQb2ludCApO1xuXG4gICAgXHRcdFx0XHRcdGlmKCBkaXN0YW5jZSA8IG1pbkRpc3RhbmNlICkge1xuXG4gICAgXHRcdFx0XHRcdFx0bWluRGlzdGFuY2UgPSBkaXN0YW5jZTtcblxuICAgIFx0XHRcdFx0XHRcdHJlc3VsdC5jb3B5KCBjbG9zZXN0UG9pbnQgKTtcblxuICAgIFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdHJldHVybiByZXN1bHQ7XG5cbiAgICBcdFx0fTtcblxuICAgIFx0fSgpLFxuXG4gICAgXHRlcXVhbHM6IGZ1bmN0aW9uICggdHJpYW5nbGUgKSB7XG5cbiAgICBcdFx0cmV0dXJuIHRyaWFuZ2xlLmEuZXF1YWxzKCB0aGlzLmEgKSAmJiB0cmlhbmdsZS5iLmVxdWFscyggdGhpcy5iICkgJiYgdHJpYW5nbGUuYy5lcXVhbHMoIHRoaXMuYyApO1xuXG4gICAgXHR9XG5cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAgICAgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gRmFjZTMoIGEsIGIsIGMsIG5vcm1hbCwgY29sb3IsIG1hdGVyaWFsSW5kZXggKSB7XG5cbiAgICBcdHRoaXMuYSA9IGE7XG4gICAgXHR0aGlzLmIgPSBiO1xuICAgIFx0dGhpcy5jID0gYztcblxuICAgIFx0dGhpcy5ub3JtYWwgPSAobm9ybWFsICYmIG5vcm1hbC5pc1ZlY3RvcjMpID8gbm9ybWFsIDogbmV3IFZlY3RvcjMoKTtcbiAgICBcdHRoaXMudmVydGV4Tm9ybWFscyA9IEFycmF5LmlzQXJyYXkoIG5vcm1hbCApID8gbm9ybWFsIDogW107XG5cbiAgICBcdHRoaXMuY29sb3IgPSAoY29sb3IgJiYgY29sb3IuaXNDb2xvcikgPyBjb2xvciA6IG5ldyBDb2xvcigpO1xuICAgIFx0dGhpcy52ZXJ0ZXhDb2xvcnMgPSBBcnJheS5pc0FycmF5KCBjb2xvciApID8gY29sb3IgOiBbXTtcblxuICAgIFx0dGhpcy5tYXRlcmlhbEluZGV4ID0gbWF0ZXJpYWxJbmRleCAhPT0gdW5kZWZpbmVkID8gbWF0ZXJpYWxJbmRleCA6IDA7XG5cbiAgICB9XG5cbiAgICBGYWNlMy5wcm90b3R5cGUgPSB7XG5cbiAgICBcdGNvbnN0cnVjdG9yOiBGYWNlMyxcblxuICAgIFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xuXG4gICAgXHRcdHRoaXMuYSA9IHNvdXJjZS5hO1xuICAgIFx0XHR0aGlzLmIgPSBzb3VyY2UuYjtcbiAgICBcdFx0dGhpcy5jID0gc291cmNlLmM7XG5cbiAgICBcdFx0dGhpcy5ub3JtYWwuY29weSggc291cmNlLm5vcm1hbCApO1xuICAgIFx0XHR0aGlzLmNvbG9yLmNvcHkoIHNvdXJjZS5jb2xvciApO1xuXG4gICAgXHRcdHRoaXMubWF0ZXJpYWxJbmRleCA9IHNvdXJjZS5tYXRlcmlhbEluZGV4O1xuXG4gICAgXHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBzb3VyY2UudmVydGV4Tm9ybWFscy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuICAgIFx0XHRcdHRoaXMudmVydGV4Tm9ybWFsc1sgaSBdID0gc291cmNlLnZlcnRleE5vcm1hbHNbIGkgXS5jbG9uZSgpO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gc291cmNlLnZlcnRleENvbG9ycy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuICAgIFx0XHRcdHRoaXMudmVydGV4Q29sb3JzWyBpIF0gPSBzb3VyY2UudmVydGV4Q29sb3JzWyBpIF0uY2xvbmUoKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH1cblxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICAgICAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gICAgICpcbiAgICAgKiBwYXJhbWV0ZXJzID0ge1xuICAgICAqICBjb2xvcjogPGhleD4sXG4gICAgICogIG9wYWNpdHk6IDxmbG9hdD4sXG4gICAgICogIG1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAgICAgKlxuICAgICAqICBhb01hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAgICAgKiAgYW9NYXBJbnRlbnNpdHk6IDxmbG9hdD5cbiAgICAgKlxuICAgICAqICBzcGVjdWxhck1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAgICAgKlxuICAgICAqICBhbHBoYU1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAgICAgKlxuICAgICAqICBlbnZNYXA6IG5ldyBUSFJFRS5UZXh0dXJlQ3ViZSggW3Bvc3gsIG5lZ3gsIHBvc3ksIG5lZ3ksIHBvc3osIG5lZ3pdICksXG4gICAgICogIGNvbWJpbmU6IFRIUkVFLk11bHRpcGx5LFxuICAgICAqICByZWZsZWN0aXZpdHk6IDxmbG9hdD4sXG4gICAgICogIHJlZnJhY3Rpb25SYXRpbzogPGZsb2F0PixcbiAgICAgKlxuICAgICAqICBzaGFkaW5nOiBUSFJFRS5TbW9vdGhTaGFkaW5nLFxuICAgICAqICBkZXB0aFRlc3Q6IDxib29sPixcbiAgICAgKiAgZGVwdGhXcml0ZTogPGJvb2w+LFxuICAgICAqXG4gICAgICogIHdpcmVmcmFtZTogPGJvb2xlYW4+LFxuICAgICAqICB3aXJlZnJhbWVMaW5ld2lkdGg6IDxmbG9hdD4sXG4gICAgICpcbiAgICAgKiAgc2tpbm5pbmc6IDxib29sPixcbiAgICAgKiAgbW9ycGhUYXJnZXRzOiA8Ym9vbD5cbiAgICAgKiB9XG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBNZXNoQmFzaWNNYXRlcmlhbCggcGFyYW1ldGVycyApIHtcblxuICAgIFx0TWF0ZXJpYWwuY2FsbCggdGhpcyApO1xuXG4gICAgXHR0aGlzLnR5cGUgPSAnTWVzaEJhc2ljTWF0ZXJpYWwnO1xuXG4gICAgXHR0aGlzLmNvbG9yID0gbmV3IENvbG9yKCAweGZmZmZmZiApOyAvLyBlbWlzc2l2ZVxuXG4gICAgXHR0aGlzLm1hcCA9IG51bGw7XG5cbiAgICBcdHRoaXMuYW9NYXAgPSBudWxsO1xuICAgIFx0dGhpcy5hb01hcEludGVuc2l0eSA9IDEuMDtcblxuICAgIFx0dGhpcy5zcGVjdWxhck1hcCA9IG51bGw7XG5cbiAgICBcdHRoaXMuYWxwaGFNYXAgPSBudWxsO1xuXG4gICAgXHR0aGlzLmVudk1hcCA9IG51bGw7XG4gICAgXHR0aGlzLmNvbWJpbmUgPSBNdWx0aXBseU9wZXJhdGlvbjtcbiAgICBcdHRoaXMucmVmbGVjdGl2aXR5ID0gMTtcbiAgICBcdHRoaXMucmVmcmFjdGlvblJhdGlvID0gMC45ODtcblxuICAgIFx0dGhpcy53aXJlZnJhbWUgPSBmYWxzZTtcbiAgICBcdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMTtcbiAgICBcdHRoaXMud2lyZWZyYW1lTGluZWNhcCA9ICdyb3VuZCc7XG4gICAgXHR0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gJ3JvdW5kJztcblxuICAgIFx0dGhpcy5za2lubmluZyA9IGZhbHNlO1xuICAgIFx0dGhpcy5tb3JwaFRhcmdldHMgPSBmYWxzZTtcblxuICAgIFx0dGhpcy5saWdodHMgPSBmYWxzZTtcblxuICAgIFx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcblxuICAgIH1cblxuICAgIE1lc2hCYXNpY01hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE1hdGVyaWFsLnByb3RvdHlwZSApO1xuICAgIE1lc2hCYXNpY01hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1lc2hCYXNpY01hdGVyaWFsO1xuXG4gICAgTWVzaEJhc2ljTWF0ZXJpYWwucHJvdG90eXBlLmlzTWVzaEJhc2ljTWF0ZXJpYWwgPSB0cnVlO1xuXG4gICAgTWVzaEJhc2ljTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuICAgIFx0TWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XG5cbiAgICBcdHRoaXMuY29sb3IuY29weSggc291cmNlLmNvbG9yICk7XG5cbiAgICBcdHRoaXMubWFwID0gc291cmNlLm1hcDtcblxuICAgIFx0dGhpcy5hb01hcCA9IHNvdXJjZS5hb01hcDtcbiAgICBcdHRoaXMuYW9NYXBJbnRlbnNpdHkgPSBzb3VyY2UuYW9NYXBJbnRlbnNpdHk7XG5cbiAgICBcdHRoaXMuc3BlY3VsYXJNYXAgPSBzb3VyY2Uuc3BlY3VsYXJNYXA7XG5cbiAgICBcdHRoaXMuYWxwaGFNYXAgPSBzb3VyY2UuYWxwaGFNYXA7XG5cbiAgICBcdHRoaXMuZW52TWFwID0gc291cmNlLmVudk1hcDtcbiAgICBcdHRoaXMuY29tYmluZSA9IHNvdXJjZS5jb21iaW5lO1xuICAgIFx0dGhpcy5yZWZsZWN0aXZpdHkgPSBzb3VyY2UucmVmbGVjdGl2aXR5O1xuICAgIFx0dGhpcy5yZWZyYWN0aW9uUmF0aW8gPSBzb3VyY2UucmVmcmFjdGlvblJhdGlvO1xuXG4gICAgXHR0aGlzLndpcmVmcmFtZSA9IHNvdXJjZS53aXJlZnJhbWU7XG4gICAgXHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IHNvdXJjZS53aXJlZnJhbWVMaW5ld2lkdGg7XG4gICAgXHR0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSBzb3VyY2Uud2lyZWZyYW1lTGluZWNhcDtcbiAgICBcdHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSBzb3VyY2Uud2lyZWZyYW1lTGluZWpvaW47XG5cbiAgICBcdHRoaXMuc2tpbm5pbmcgPSBzb3VyY2Uuc2tpbm5pbmc7XG4gICAgXHR0aGlzLm1vcnBoVGFyZ2V0cyA9IHNvdXJjZS5tb3JwaFRhcmdldHM7XG5cbiAgICBcdHJldHVybiB0aGlzO1xuXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBCdWZmZXJBdHRyaWJ1dGUoIGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApIHtcblxuICAgIFx0aWYgKCBBcnJheS5pc0FycmF5KCBhcnJheSApICkge1xuXG4gICAgXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoICdUSFJFRS5CdWZmZXJBdHRyaWJ1dGU6IGFycmF5IHNob3VsZCBiZSBhIFR5cGVkIEFycmF5LicgKTtcblxuICAgIFx0fVxuXG4gICAgXHR0aGlzLnV1aWQgPSBleHBvcnRzLk1hdGguZ2VuZXJhdGVVVUlEKCk7XG5cbiAgICBcdHRoaXMuYXJyYXkgPSBhcnJheTtcbiAgICBcdHRoaXMuaXRlbVNpemUgPSBpdGVtU2l6ZTtcbiAgICBcdHRoaXMuY291bnQgPSBhcnJheSAhPT0gdW5kZWZpbmVkID8gYXJyYXkubGVuZ3RoIC8gaXRlbVNpemUgOiAwO1xuICAgIFx0dGhpcy5ub3JtYWxpemVkID0gbm9ybWFsaXplZCA9PT0gdHJ1ZTtcblxuICAgIFx0dGhpcy5keW5hbWljID0gZmFsc2U7XG4gICAgXHR0aGlzLnVwZGF0ZVJhbmdlID0geyBvZmZzZXQ6IDAsIGNvdW50OiAtIDEgfTtcblxuICAgIFx0dGhpcy52ZXJzaW9uID0gMDtcblxuICAgIH1cblxuICAgIEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUgPSB7XG5cbiAgICBcdGNvbnN0cnVjdG9yOiBCdWZmZXJBdHRyaWJ1dGUsXG5cbiAgICBcdGlzQnVmZmVyQXR0cmlidXRlOiB0cnVlLFxuXG4gICAgXHRzZXQgbmVlZHNVcGRhdGUoIHZhbHVlICkge1xuXG4gICAgXHRcdGlmICggdmFsdWUgPT09IHRydWUgKSB0aGlzLnZlcnNpb24gKys7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldER5bmFtaWM6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cbiAgICBcdFx0dGhpcy5keW5hbWljID0gdmFsdWU7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xuXG4gICAgXHRcdHRoaXMuYXJyYXkgPSBuZXcgc291cmNlLmFycmF5LmNvbnN0cnVjdG9yKCBzb3VyY2UuYXJyYXkgKTtcbiAgICBcdFx0dGhpcy5pdGVtU2l6ZSA9IHNvdXJjZS5pdGVtU2l6ZTtcbiAgICBcdFx0dGhpcy5jb3VudCA9IHNvdXJjZS5jb3VudDtcbiAgICBcdFx0dGhpcy5ub3JtYWxpemVkID0gc291cmNlLm5vcm1hbGl6ZWQ7XG5cbiAgICBcdFx0dGhpcy5keW5hbWljID0gc291cmNlLmR5bmFtaWM7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGNvcHlBdDogZnVuY3Rpb24gKCBpbmRleDEsIGF0dHJpYnV0ZSwgaW5kZXgyICkge1xuXG4gICAgXHRcdGluZGV4MSAqPSB0aGlzLml0ZW1TaXplO1xuICAgIFx0XHRpbmRleDIgKj0gYXR0cmlidXRlLml0ZW1TaXplO1xuXG4gICAgXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMuaXRlbVNpemU7IGkgPCBsOyBpICsrICkge1xuXG4gICAgXHRcdFx0dGhpcy5hcnJheVsgaW5kZXgxICsgaSBdID0gYXR0cmlidXRlLmFycmF5WyBpbmRleDIgKyBpIF07XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRjb3B5QXJyYXk6IGZ1bmN0aW9uICggYXJyYXkgKSB7XG5cbiAgICBcdFx0dGhpcy5hcnJheS5zZXQoIGFycmF5ICk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGNvcHlDb2xvcnNBcnJheTogZnVuY3Rpb24gKCBjb2xvcnMgKSB7XG5cbiAgICBcdFx0dmFyIGFycmF5ID0gdGhpcy5hcnJheSwgb2Zmc2V0ID0gMDtcblxuICAgIFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBjb2xvcnMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgIFx0XHRcdHZhciBjb2xvciA9IGNvbG9yc1sgaSBdO1xuXG4gICAgXHRcdFx0aWYgKCBjb2xvciA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJBdHRyaWJ1dGUuY29weUNvbG9yc0FycmF5KCk6IGNvbG9yIGlzIHVuZGVmaW5lZCcsIGkgKTtcbiAgICBcdFx0XHRcdGNvbG9yID0gbmV3IENvbG9yKCk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRhcnJheVsgb2Zmc2V0ICsrIF0gPSBjb2xvci5yO1xuICAgIFx0XHRcdGFycmF5WyBvZmZzZXQgKysgXSA9IGNvbG9yLmc7XG4gICAgXHRcdFx0YXJyYXlbIG9mZnNldCArKyBdID0gY29sb3IuYjtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGNvcHlJbmRpY2VzQXJyYXk6IGZ1bmN0aW9uICggaW5kaWNlcyApIHtcblxuICAgIFx0XHR2YXIgYXJyYXkgPSB0aGlzLmFycmF5LCBvZmZzZXQgPSAwO1xuXG4gICAgXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGluZGljZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgIFx0XHRcdHZhciBpbmRleCA9IGluZGljZXNbIGkgXTtcblxuICAgIFx0XHRcdGFycmF5WyBvZmZzZXQgKysgXSA9IGluZGV4LmE7XG4gICAgXHRcdFx0YXJyYXlbIG9mZnNldCArKyBdID0gaW5kZXguYjtcbiAgICBcdFx0XHRhcnJheVsgb2Zmc2V0ICsrIF0gPSBpbmRleC5jO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0Y29weVZlY3RvcjJzQXJyYXk6IGZ1bmN0aW9uICggdmVjdG9ycyApIHtcblxuICAgIFx0XHR2YXIgYXJyYXkgPSB0aGlzLmFycmF5LCBvZmZzZXQgPSAwO1xuXG4gICAgXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHZlY3RvcnMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgIFx0XHRcdHZhciB2ZWN0b3IgPSB2ZWN0b3JzWyBpIF07XG5cbiAgICBcdFx0XHRpZiAoIHZlY3RvciA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJBdHRyaWJ1dGUuY29weVZlY3RvcjJzQXJyYXkoKTogdmVjdG9yIGlzIHVuZGVmaW5lZCcsIGkgKTtcbiAgICBcdFx0XHRcdHZlY3RvciA9IG5ldyBWZWN0b3IyKCk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRhcnJheVsgb2Zmc2V0ICsrIF0gPSB2ZWN0b3IueDtcbiAgICBcdFx0XHRhcnJheVsgb2Zmc2V0ICsrIF0gPSB2ZWN0b3IueTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGNvcHlWZWN0b3Izc0FycmF5OiBmdW5jdGlvbiAoIHZlY3RvcnMgKSB7XG5cbiAgICBcdFx0dmFyIGFycmF5ID0gdGhpcy5hcnJheSwgb2Zmc2V0ID0gMDtcblxuICAgIFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB2ZWN0b3JzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICBcdFx0XHR2YXIgdmVjdG9yID0gdmVjdG9yc1sgaSBdO1xuXG4gICAgXHRcdFx0aWYgKCB2ZWN0b3IgPT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyQXR0cmlidXRlLmNvcHlWZWN0b3Izc0FycmF5KCk6IHZlY3RvciBpcyB1bmRlZmluZWQnLCBpICk7XG4gICAgXHRcdFx0XHR2ZWN0b3IgPSBuZXcgVmVjdG9yMygpO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0YXJyYXlbIG9mZnNldCArKyBdID0gdmVjdG9yLng7XG4gICAgXHRcdFx0YXJyYXlbIG9mZnNldCArKyBdID0gdmVjdG9yLnk7XG4gICAgXHRcdFx0YXJyYXlbIG9mZnNldCArKyBdID0gdmVjdG9yLno7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRjb3B5VmVjdG9yNHNBcnJheTogZnVuY3Rpb24gKCB2ZWN0b3JzICkge1xuXG4gICAgXHRcdHZhciBhcnJheSA9IHRoaXMuYXJyYXksIG9mZnNldCA9IDA7XG5cbiAgICBcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gdmVjdG9ycy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgXHRcdFx0dmFyIHZlY3RvciA9IHZlY3RvcnNbIGkgXTtcblxuICAgIFx0XHRcdGlmICggdmVjdG9yID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckF0dHJpYnV0ZS5jb3B5VmVjdG9yNHNBcnJheSgpOiB2ZWN0b3IgaXMgdW5kZWZpbmVkJywgaSApO1xuICAgIFx0XHRcdFx0dmVjdG9yID0gbmV3IFZlY3RvcjQoKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdGFycmF5WyBvZmZzZXQgKysgXSA9IHZlY3Rvci54O1xuICAgIFx0XHRcdGFycmF5WyBvZmZzZXQgKysgXSA9IHZlY3Rvci55O1xuICAgIFx0XHRcdGFycmF5WyBvZmZzZXQgKysgXSA9IHZlY3Rvci56O1xuICAgIFx0XHRcdGFycmF5WyBvZmZzZXQgKysgXSA9IHZlY3Rvci53O1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlLCBvZmZzZXQgKSB7XG5cbiAgICBcdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cbiAgICBcdFx0dGhpcy5hcnJheS5zZXQoIHZhbHVlLCBvZmZzZXQgKTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0Z2V0WDogZnVuY3Rpb24gKCBpbmRleCApIHtcblxuICAgIFx0XHRyZXR1cm4gdGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplIF07XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldFg6IGZ1bmN0aW9uICggaW5kZXgsIHggKSB7XG5cbiAgICBcdFx0dGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplIF0gPSB4O1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRnZXRZOiBmdW5jdGlvbiAoIGluZGV4ICkge1xuXG4gICAgXHRcdHJldHVybiB0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgKyAxIF07XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldFk6IGZ1bmN0aW9uICggaW5kZXgsIHkgKSB7XG5cbiAgICBcdFx0dGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMSBdID0geTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0Z2V0WjogZnVuY3Rpb24gKCBpbmRleCApIHtcblxuICAgIFx0XHRyZXR1cm4gdGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMiBdO1xuXG4gICAgXHR9LFxuXG4gICAgXHRzZXRaOiBmdW5jdGlvbiAoIGluZGV4LCB6ICkge1xuXG4gICAgXHRcdHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDIgXSA9IHo7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGdldFc6IGZ1bmN0aW9uICggaW5kZXggKSB7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDMgXTtcblxuICAgIFx0fSxcblxuICAgIFx0c2V0VzogZnVuY3Rpb24gKCBpbmRleCwgdyApIHtcblxuICAgIFx0XHR0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgKyAzIF0gPSB3O1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRzZXRYWTogZnVuY3Rpb24gKCBpbmRleCwgeCwgeSApIHtcblxuICAgIFx0XHRpbmRleCAqPSB0aGlzLml0ZW1TaXplO1xuXG4gICAgXHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMCBdID0geDtcbiAgICBcdFx0dGhpcy5hcnJheVsgaW5kZXggKyAxIF0gPSB5O1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRzZXRYWVo6IGZ1bmN0aW9uICggaW5kZXgsIHgsIHksIHogKSB7XG5cbiAgICBcdFx0aW5kZXggKj0gdGhpcy5pdGVtU2l6ZTtcblxuICAgIFx0XHR0aGlzLmFycmF5WyBpbmRleCArIDAgXSA9IHg7XG4gICAgXHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMSBdID0geTtcbiAgICBcdFx0dGhpcy5hcnJheVsgaW5kZXggKyAyIF0gPSB6O1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRzZXRYWVpXOiBmdW5jdGlvbiAoIGluZGV4LCB4LCB5LCB6LCB3ICkge1xuXG4gICAgXHRcdGluZGV4ICo9IHRoaXMuaXRlbVNpemU7XG5cbiAgICBcdFx0dGhpcy5hcnJheVsgaW5kZXggKyAwIF0gPSB4O1xuICAgIFx0XHR0aGlzLmFycmF5WyBpbmRleCArIDEgXSA9IHk7XG4gICAgXHRcdHRoaXMuYXJyYXlbIGluZGV4ICsgMiBdID0gejtcbiAgICBcdFx0dGhpcy5hcnJheVsgaW5kZXggKyAzIF0gPSB3O1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblxuICAgIFx0fVxuXG4gICAgfTtcblxuICAgIC8vXG5cbiAgICBmdW5jdGlvbiBJbnQ4QXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUgKSB7XG5cbiAgICBcdHJldHVybiBuZXcgQnVmZmVyQXR0cmlidXRlKCBuZXcgSW50OEFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSApO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gVWludDhBdHRyaWJ1dGUoIGFycmF5LCBpdGVtU2l6ZSApIHtcblxuICAgIFx0cmV0dXJuIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIG5ldyBVaW50OEFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSApO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gVWludDhDbGFtcGVkQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUgKSB7XG5cbiAgICBcdHJldHVybiBuZXcgQnVmZmVyQXR0cmlidXRlKCBuZXcgVWludDhDbGFtcGVkQXJyYXkoIGFycmF5ICksIGl0ZW1TaXplICk7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBJbnQxNkF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplICkge1xuXG4gICAgXHRyZXR1cm4gbmV3IEJ1ZmZlckF0dHJpYnV0ZSggbmV3IEludDE2QXJyYXkoIGFycmF5ICksIGl0ZW1TaXplICk7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBVaW50MTZBdHRyaWJ1dGUoIGFycmF5LCBpdGVtU2l6ZSApIHtcblxuICAgIFx0cmV0dXJuIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIG5ldyBVaW50MTZBcnJheSggYXJyYXkgKSwgaXRlbVNpemUgKTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIEludDMyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUgKSB7XG5cbiAgICBcdHJldHVybiBuZXcgQnVmZmVyQXR0cmlidXRlKCBuZXcgSW50MzJBcnJheSggYXJyYXkgKSwgaXRlbVNpemUgKTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIFVpbnQzMkF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplICkge1xuXG4gICAgXHRyZXR1cm4gbmV3IEJ1ZmZlckF0dHJpYnV0ZSggbmV3IFVpbnQzMkFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSApO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gRmxvYXQzMkF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplICkge1xuXG4gICAgXHRyZXR1cm4gbmV3IEJ1ZmZlckF0dHJpYnV0ZSggbmV3IEZsb2F0MzJBcnJheSggYXJyYXkgKSwgaXRlbVNpemUgKTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIEZsb2F0NjRBdHRyaWJ1dGUoIGFycmF5LCBpdGVtU2l6ZSApIHtcblxuICAgIFx0cmV0dXJuIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIG5ldyBGbG9hdDY0QXJyYXkoIGFycmF5ICksIGl0ZW1TaXplICk7XG5cbiAgICB9XG5cbiAgICAvLyBEZXByZWNhdGVkXG5cbiAgICBmdW5jdGlvbiBEeW5hbWljQnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUgKSB7XG5cbiAgICBcdGNvbnNvbGUud2FybiggJ1RIUkVFLkR5bmFtaWNCdWZmZXJBdHRyaWJ1dGUgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoKS5zZXREeW5hbWljKCB0cnVlICkgaW5zdGVhZC4nICk7XG4gICAgXHRyZXR1cm4gbmV3IEJ1ZmZlckF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplICkuc2V0RHluYW1pYyggdHJ1ZSApO1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAgICAgKiBAYXV0aG9yIGtpbGUgLyBodHRwOi8va2lsZS5zdHJhdmFnYW56YS5vcmcvXG4gICAgICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAgICAgKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICAgICAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcbiAgICAgKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBHZW9tZXRyeSgpIHtcblxuICAgIFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCAnaWQnLCB7IHZhbHVlOiBHZW9tZXRyeUlkQ291bnQoKSB9ICk7XG5cbiAgICBcdHRoaXMudXVpZCA9IGV4cG9ydHMuTWF0aC5nZW5lcmF0ZVVVSUQoKTtcblxuICAgIFx0dGhpcy5uYW1lID0gJyc7XG4gICAgXHR0aGlzLnR5cGUgPSAnR2VvbWV0cnknO1xuXG4gICAgXHR0aGlzLnZlcnRpY2VzID0gW107XG4gICAgXHR0aGlzLmNvbG9ycyA9IFtdO1xuICAgIFx0dGhpcy5mYWNlcyA9IFtdO1xuICAgIFx0dGhpcy5mYWNlVmVydGV4VXZzID0gWyBbXSBdO1xuXG4gICAgXHR0aGlzLm1vcnBoVGFyZ2V0cyA9IFtdO1xuICAgIFx0dGhpcy5tb3JwaE5vcm1hbHMgPSBbXTtcblxuICAgIFx0dGhpcy5za2luV2VpZ2h0cyA9IFtdO1xuICAgIFx0dGhpcy5za2luSW5kaWNlcyA9IFtdO1xuXG4gICAgXHR0aGlzLmxpbmVEaXN0YW5jZXMgPSBbXTtcblxuICAgIFx0dGhpcy5ib3VuZGluZ0JveCA9IG51bGw7XG4gICAgXHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gbnVsbDtcblxuICAgIFx0Ly8gdXBkYXRlIGZsYWdzXG5cbiAgICBcdHRoaXMuZWxlbWVudHNOZWVkVXBkYXRlID0gZmFsc2U7XG4gICAgXHR0aGlzLnZlcnRpY2VzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuICAgIFx0dGhpcy51dnNOZWVkVXBkYXRlID0gZmFsc2U7XG4gICAgXHR0aGlzLm5vcm1hbHNOZWVkVXBkYXRlID0gZmFsc2U7XG4gICAgXHR0aGlzLmNvbG9yc05lZWRVcGRhdGUgPSBmYWxzZTtcbiAgICBcdHRoaXMubGluZURpc3RhbmNlc05lZWRVcGRhdGUgPSBmYWxzZTtcbiAgICBcdHRoaXMuZ3JvdXBzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuXG4gICAgfVxuXG4gICAgT2JqZWN0LmFzc2lnbiggR2VvbWV0cnkucHJvdG90eXBlLCBFdmVudERpc3BhdGNoZXIucHJvdG90eXBlLCB7XG5cbiAgICBcdGlzR2VvbWV0cnk6IHRydWUsXG5cbiAgICBcdGFwcGx5TWF0cml4OiBmdW5jdGlvbiAoIG1hdHJpeCApIHtcblxuICAgIFx0XHR2YXIgbm9ybWFsTWF0cml4ID0gbmV3IE1hdHJpeDMoKS5nZXROb3JtYWxNYXRyaXgoIG1hdHJpeCApO1xuXG4gICAgXHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgXHRcdFx0dmFyIHZlcnRleCA9IHRoaXMudmVydGljZXNbIGkgXTtcbiAgICBcdFx0XHR2ZXJ0ZXguYXBwbHlNYXRyaXg0KCBtYXRyaXggKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICBcdFx0XHR2YXIgZmFjZSA9IHRoaXMuZmFjZXNbIGkgXTtcbiAgICBcdFx0XHRmYWNlLm5vcm1hbC5hcHBseU1hdHJpeDMoIG5vcm1hbE1hdHJpeCApLm5vcm1hbGl6ZSgpO1xuXG4gICAgXHRcdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IGZhY2UudmVydGV4Tm9ybWFscy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuICAgIFx0XHRcdFx0ZmFjZS52ZXJ0ZXhOb3JtYWxzWyBqIF0uYXBwbHlNYXRyaXgzKCBub3JtYWxNYXRyaXggKS5ub3JtYWxpemUoKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdFx0aWYgKCB0aGlzLmJvdW5kaW5nQm94ICE9PSBudWxsICkge1xuXG4gICAgXHRcdFx0dGhpcy5jb21wdXRlQm91bmRpbmdCb3goKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0aWYgKCB0aGlzLmJvdW5kaW5nU3BoZXJlICE9PSBudWxsICkge1xuXG4gICAgXHRcdFx0dGhpcy5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0dGhpcy52ZXJ0aWNlc05lZWRVcGRhdGUgPSB0cnVlO1xuICAgIFx0XHR0aGlzLm5vcm1hbHNOZWVkVXBkYXRlID0gdHJ1ZTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0cm90YXRlWDogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdC8vIHJvdGF0ZSBnZW9tZXRyeSBhcm91bmQgd29ybGQgeC1heGlzXG5cbiAgICBcdFx0dmFyIG0xO1xuXG4gICAgXHRcdHJldHVybiBmdW5jdGlvbiByb3RhdGVYKCBhbmdsZSApIHtcblxuICAgIFx0XHRcdGlmICggbTEgPT09IHVuZGVmaW5lZCApIG0xID0gbmV3IE1hdHJpeDQoKTtcblxuICAgIFx0XHRcdG0xLm1ha2VSb3RhdGlvblgoIGFuZ2xlICk7XG5cbiAgICBcdFx0XHR0aGlzLmFwcGx5TWF0cml4KCBtMSApO1xuXG4gICAgXHRcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdFx0fTtcblxuICAgIFx0fSgpLFxuXG4gICAgXHRyb3RhdGVZOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0Ly8gcm90YXRlIGdlb21ldHJ5IGFyb3VuZCB3b3JsZCB5LWF4aXNcblxuICAgIFx0XHR2YXIgbTE7XG5cbiAgICBcdFx0cmV0dXJuIGZ1bmN0aW9uIHJvdGF0ZVkoIGFuZ2xlICkge1xuXG4gICAgXHRcdFx0aWYgKCBtMSA9PT0gdW5kZWZpbmVkICkgbTEgPSBuZXcgTWF0cml4NCgpO1xuXG4gICAgXHRcdFx0bTEubWFrZVJvdGF0aW9uWSggYW5nbGUgKTtcblxuICAgIFx0XHRcdHRoaXMuYXBwbHlNYXRyaXgoIG0xICk7XG5cbiAgICBcdFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0XHR9O1xuXG4gICAgXHR9KCksXG5cbiAgICBcdHJvdGF0ZVo6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHQvLyByb3RhdGUgZ2VvbWV0cnkgYXJvdW5kIHdvcmxkIHotYXhpc1xuXG4gICAgXHRcdHZhciBtMTtcblxuICAgIFx0XHRyZXR1cm4gZnVuY3Rpb24gcm90YXRlWiggYW5nbGUgKSB7XG5cbiAgICBcdFx0XHRpZiAoIG0xID09PSB1bmRlZmluZWQgKSBtMSA9IG5ldyBNYXRyaXg0KCk7XG5cbiAgICBcdFx0XHRtMS5tYWtlUm90YXRpb25aKCBhbmdsZSApO1xuXG4gICAgXHRcdFx0dGhpcy5hcHBseU1hdHJpeCggbTEgKTtcblxuICAgIFx0XHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHRcdH07XG5cbiAgICBcdH0oKSxcblxuICAgIFx0dHJhbnNsYXRlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0Ly8gdHJhbnNsYXRlIGdlb21ldHJ5XG5cbiAgICBcdFx0dmFyIG0xO1xuXG4gICAgXHRcdHJldHVybiBmdW5jdGlvbiB0cmFuc2xhdGUoIHgsIHksIHogKSB7XG5cbiAgICBcdFx0XHRpZiAoIG0xID09PSB1bmRlZmluZWQgKSBtMSA9IG5ldyBNYXRyaXg0KCk7XG5cbiAgICBcdFx0XHRtMS5tYWtlVHJhbnNsYXRpb24oIHgsIHksIHogKTtcblxuICAgIFx0XHRcdHRoaXMuYXBwbHlNYXRyaXgoIG0xICk7XG5cbiAgICBcdFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0XHR9O1xuXG4gICAgXHR9KCksXG5cbiAgICBcdHNjYWxlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0Ly8gc2NhbGUgZ2VvbWV0cnlcblxuICAgIFx0XHR2YXIgbTE7XG5cbiAgICBcdFx0cmV0dXJuIGZ1bmN0aW9uIHNjYWxlKCB4LCB5LCB6ICkge1xuXG4gICAgXHRcdFx0aWYgKCBtMSA9PT0gdW5kZWZpbmVkICkgbTEgPSBuZXcgTWF0cml4NCgpO1xuXG4gICAgXHRcdFx0bTEubWFrZVNjYWxlKCB4LCB5LCB6ICk7XG5cbiAgICBcdFx0XHR0aGlzLmFwcGx5TWF0cml4KCBtMSApO1xuXG4gICAgXHRcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdFx0fTtcblxuICAgIFx0fSgpLFxuXG4gICAgXHRsb29rQXQ6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR2YXIgb2JqO1xuXG4gICAgXHRcdHJldHVybiBmdW5jdGlvbiBsb29rQXQoIHZlY3RvciApIHtcblxuICAgIFx0XHRcdGlmICggb2JqID09PSB1bmRlZmluZWQgKSBvYmogPSBuZXcgT2JqZWN0M0QoKTtcblxuICAgIFx0XHRcdG9iai5sb29rQXQoIHZlY3RvciApO1xuXG4gICAgXHRcdFx0b2JqLnVwZGF0ZU1hdHJpeCgpO1xuXG4gICAgXHRcdFx0dGhpcy5hcHBseU1hdHJpeCggb2JqLm1hdHJpeCApO1xuXG4gICAgXHRcdH07XG5cbiAgICBcdH0oKSxcblxuICAgIFx0ZnJvbUJ1ZmZlckdlb21ldHJ5OiBmdW5jdGlvbiAoIGdlb21ldHJ5ICkge1xuXG4gICAgXHRcdHZhciBzY29wZSA9IHRoaXM7XG5cbiAgICBcdFx0dmFyIGluZGljZXMgPSBnZW9tZXRyeS5pbmRleCAhPT0gbnVsbCA/IGdlb21ldHJ5LmluZGV4LmFycmF5IDogdW5kZWZpbmVkO1xuICAgIFx0XHR2YXIgYXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XG5cbiAgICBcdFx0dmFyIHBvc2l0aW9ucyA9IGF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XG4gICAgXHRcdHZhciBub3JtYWxzID0gYXR0cmlidXRlcy5ub3JtYWwgIT09IHVuZGVmaW5lZCA/IGF0dHJpYnV0ZXMubm9ybWFsLmFycmF5IDogdW5kZWZpbmVkO1xuICAgIFx0XHR2YXIgY29sb3JzID0gYXR0cmlidXRlcy5jb2xvciAhPT0gdW5kZWZpbmVkID8gYXR0cmlidXRlcy5jb2xvci5hcnJheSA6IHVuZGVmaW5lZDtcbiAgICBcdFx0dmFyIHV2cyA9IGF0dHJpYnV0ZXMudXYgIT09IHVuZGVmaW5lZCA/IGF0dHJpYnV0ZXMudXYuYXJyYXkgOiB1bmRlZmluZWQ7XG4gICAgXHRcdHZhciB1dnMyID0gYXR0cmlidXRlcy51djIgIT09IHVuZGVmaW5lZCA/IGF0dHJpYnV0ZXMudXYyLmFycmF5IDogdW5kZWZpbmVkO1xuXG4gICAgXHRcdGlmICggdXZzMiAhPT0gdW5kZWZpbmVkICkgdGhpcy5mYWNlVmVydGV4VXZzWyAxIF0gPSBbXTtcblxuICAgIFx0XHR2YXIgdGVtcE5vcm1hbHMgPSBbXTtcbiAgICBcdFx0dmFyIHRlbXBVVnMgPSBbXTtcbiAgICBcdFx0dmFyIHRlbXBVVnMyID0gW107XG5cbiAgICBcdFx0Zm9yICggdmFyIGkgPSAwLCBqID0gMDsgaSA8IHBvc2l0aW9ucy5sZW5ndGg7IGkgKz0gMywgaiArPSAyICkge1xuXG4gICAgXHRcdFx0c2NvcGUudmVydGljZXMucHVzaCggbmV3IFZlY3RvcjMoIHBvc2l0aW9uc1sgaSBdLCBwb3NpdGlvbnNbIGkgKyAxIF0sIHBvc2l0aW9uc1sgaSArIDIgXSApICk7XG5cbiAgICBcdFx0XHRpZiAoIG5vcm1hbHMgIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0dGVtcE5vcm1hbHMucHVzaCggbmV3IFZlY3RvcjMoIG5vcm1hbHNbIGkgXSwgbm9ybWFsc1sgaSArIDEgXSwgbm9ybWFsc1sgaSArIDIgXSApICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRpZiAoIGNvbG9ycyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0XHRzY29wZS5jb2xvcnMucHVzaCggbmV3IENvbG9yKCBjb2xvcnNbIGkgXSwgY29sb3JzWyBpICsgMSBdLCBjb2xvcnNbIGkgKyAyIF0gKSApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0aWYgKCB1dnMgIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0dGVtcFVWcy5wdXNoKCBuZXcgVmVjdG9yMiggdXZzWyBqIF0sIHV2c1sgaiArIDEgXSApICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRpZiAoIHV2czIgIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0dGVtcFVWczIucHVzaCggbmV3IFZlY3RvcjIoIHV2czJbIGogXSwgdXZzMlsgaiArIDEgXSApICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGZ1bmN0aW9uIGFkZEZhY2UoIGEsIGIsIGMsIG1hdGVyaWFsSW5kZXggKSB7XG5cbiAgICBcdFx0XHR2YXIgdmVydGV4Tm9ybWFscyA9IG5vcm1hbHMgIT09IHVuZGVmaW5lZCA/IFsgdGVtcE5vcm1hbHNbIGEgXS5jbG9uZSgpLCB0ZW1wTm9ybWFsc1sgYiBdLmNsb25lKCksIHRlbXBOb3JtYWxzWyBjIF0uY2xvbmUoKSBdIDogW107XG4gICAgXHRcdFx0dmFyIHZlcnRleENvbG9ycyA9IGNvbG9ycyAhPT0gdW5kZWZpbmVkID8gWyBzY29wZS5jb2xvcnNbIGEgXS5jbG9uZSgpLCBzY29wZS5jb2xvcnNbIGIgXS5jbG9uZSgpLCBzY29wZS5jb2xvcnNbIGMgXS5jbG9uZSgpIF0gOiBbXTtcblxuICAgIFx0XHRcdHZhciBmYWNlID0gbmV3IEZhY2UzKCBhLCBiLCBjLCB2ZXJ0ZXhOb3JtYWxzLCB2ZXJ0ZXhDb2xvcnMsIG1hdGVyaWFsSW5kZXggKTtcblxuICAgIFx0XHRcdHNjb3BlLmZhY2VzLnB1c2goIGZhY2UgKTtcblxuICAgIFx0XHRcdGlmICggdXZzICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRcdHNjb3BlLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHRlbXBVVnNbIGEgXS5jbG9uZSgpLCB0ZW1wVVZzWyBiIF0uY2xvbmUoKSwgdGVtcFVWc1sgYyBdLmNsb25lKCkgXSApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0aWYgKCB1dnMyICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRcdHNjb3BlLmZhY2VWZXJ0ZXhVdnNbIDEgXS5wdXNoKCBbIHRlbXBVVnMyWyBhIF0uY2xvbmUoKSwgdGVtcFVWczJbIGIgXS5jbG9uZSgpLCB0ZW1wVVZzMlsgYyBdLmNsb25lKCkgXSApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHRpZiAoIGluZGljZXMgIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdHZhciBncm91cHMgPSBnZW9tZXRyeS5ncm91cHM7XG5cbiAgICBcdFx0XHRpZiAoIGdyb3Vwcy5sZW5ndGggPiAwICkge1xuXG4gICAgXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpICsrICkge1xuXG4gICAgXHRcdFx0XHRcdHZhciBncm91cCA9IGdyb3Vwc1sgaSBdO1xuXG4gICAgXHRcdFx0XHRcdHZhciBzdGFydCA9IGdyb3VwLnN0YXJ0O1xuICAgIFx0XHRcdFx0XHR2YXIgY291bnQgPSBncm91cC5jb3VudDtcblxuICAgIFx0XHRcdFx0XHRmb3IgKCB2YXIgaiA9IHN0YXJ0LCBqbCA9IHN0YXJ0ICsgY291bnQ7IGogPCBqbDsgaiArPSAzICkge1xuXG4gICAgXHRcdFx0XHRcdFx0YWRkRmFjZSggaW5kaWNlc1sgaiBdLCBpbmRpY2VzWyBqICsgMSBdLCBpbmRpY2VzWyBqICsgMiBdLCBncm91cC5tYXRlcmlhbEluZGV4ICApO1xuXG4gICAgXHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgaW5kaWNlcy5sZW5ndGg7IGkgKz0gMyApIHtcblxuICAgIFx0XHRcdFx0XHRhZGRGYWNlKCBpbmRpY2VzWyBpIF0sIGluZGljZXNbIGkgKyAxIF0sIGluZGljZXNbIGkgKyAyIF0gKTtcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBwb3NpdGlvbnMubGVuZ3RoIC8gMzsgaSArPSAzICkge1xuXG4gICAgXHRcdFx0XHRhZGRGYWNlKCBpLCBpICsgMSwgaSArIDIgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdFx0dGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcblxuICAgIFx0XHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nQm94ICE9PSBudWxsICkge1xuXG4gICAgXHRcdFx0dGhpcy5ib3VuZGluZ0JveCA9IGdlb21ldHJ5LmJvdW5kaW5nQm94LmNsb25lKCk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGlmICggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgIT09IG51bGwgKSB7XG5cbiAgICBcdFx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUuY2xvbmUoKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGNlbnRlcjogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHRoaXMuY29tcHV0ZUJvdW5kaW5nQm94KCk7XG5cbiAgICBcdFx0dmFyIG9mZnNldCA9IHRoaXMuYm91bmRpbmdCb3guZ2V0Q2VudGVyKCkubmVnYXRlKCk7XG5cbiAgICBcdFx0dGhpcy50cmFuc2xhdGUoIG9mZnNldC54LCBvZmZzZXQueSwgb2Zmc2V0LnogKTtcblxuICAgIFx0XHRyZXR1cm4gb2Zmc2V0O1xuXG4gICAgXHR9LFxuXG4gICAgXHRub3JtYWxpemU6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR0aGlzLmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xuXG4gICAgXHRcdHZhciBjZW50ZXIgPSB0aGlzLmJvdW5kaW5nU3BoZXJlLmNlbnRlcjtcbiAgICBcdFx0dmFyIHJhZGl1cyA9IHRoaXMuYm91bmRpbmdTcGhlcmUucmFkaXVzO1xuXG4gICAgXHRcdHZhciBzID0gcmFkaXVzID09PSAwID8gMSA6IDEuMCAvIHJhZGl1cztcblxuICAgIFx0XHR2YXIgbWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcbiAgICBcdFx0bWF0cml4LnNldChcbiAgICBcdFx0XHRzLCAwLCAwLCAtIHMgKiBjZW50ZXIueCxcbiAgICBcdFx0XHQwLCBzLCAwLCAtIHMgKiBjZW50ZXIueSxcbiAgICBcdFx0XHQwLCAwLCBzLCAtIHMgKiBjZW50ZXIueixcbiAgICBcdFx0XHQwLCAwLCAwLCAxXG4gICAgXHRcdCk7XG5cbiAgICBcdFx0dGhpcy5hcHBseU1hdHJpeCggbWF0cml4ICk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGNvbXB1dGVGYWNlTm9ybWFsczogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHZhciBjYiA9IG5ldyBWZWN0b3IzKCksIGFiID0gbmV3IFZlY3RvcjMoKTtcblxuICAgIFx0XHRmb3IgKCB2YXIgZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcblxuICAgIFx0XHRcdHZhciBmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xuXG4gICAgXHRcdFx0dmFyIHZBID0gdGhpcy52ZXJ0aWNlc1sgZmFjZS5hIF07XG4gICAgXHRcdFx0dmFyIHZCID0gdGhpcy52ZXJ0aWNlc1sgZmFjZS5iIF07XG4gICAgXHRcdFx0dmFyIHZDID0gdGhpcy52ZXJ0aWNlc1sgZmFjZS5jIF07XG5cbiAgICBcdFx0XHRjYi5zdWJWZWN0b3JzKCB2QywgdkIgKTtcbiAgICBcdFx0XHRhYi5zdWJWZWN0b3JzKCB2QSwgdkIgKTtcbiAgICBcdFx0XHRjYi5jcm9zcyggYWIgKTtcblxuICAgIFx0XHRcdGNiLm5vcm1hbGl6ZSgpO1xuXG4gICAgXHRcdFx0ZmFjZS5ub3JtYWwuY29weSggY2IgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdH0sXG5cbiAgICBcdGNvbXB1dGVWZXJ0ZXhOb3JtYWxzOiBmdW5jdGlvbiAoIGFyZWFXZWlnaHRlZCApIHtcblxuICAgIFx0XHRpZiAoIGFyZWFXZWlnaHRlZCA9PT0gdW5kZWZpbmVkICkgYXJlYVdlaWdodGVkID0gdHJ1ZTtcblxuICAgIFx0XHR2YXIgdiwgdmwsIGYsIGZsLCBmYWNlLCB2ZXJ0aWNlcztcblxuICAgIFx0XHR2ZXJ0aWNlcyA9IG5ldyBBcnJheSggdGhpcy52ZXJ0aWNlcy5sZW5ndGggKTtcblxuICAgIFx0XHRmb3IgKCB2ID0gMCwgdmwgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgdiA8IHZsOyB2ICsrICkge1xuXG4gICAgXHRcdFx0dmVydGljZXNbIHYgXSA9IG5ldyBWZWN0b3IzKCk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGlmICggYXJlYVdlaWdodGVkICkge1xuXG4gICAgXHRcdFx0Ly8gdmVydGV4IG5vcm1hbHMgd2VpZ2h0ZWQgYnkgdHJpYW5nbGUgYXJlYXNcbiAgICBcdFx0XHQvLyBodHRwOi8vd3d3LmlxdWlsZXpsZXMub3JnL3d3dy9hcnRpY2xlcy9ub3JtYWxzL25vcm1hbHMuaHRtXG5cbiAgICBcdFx0XHR2YXIgdkEsIHZCLCB2QztcbiAgICBcdFx0XHR2YXIgY2IgPSBuZXcgVmVjdG9yMygpLCBhYiA9IG5ldyBWZWN0b3IzKCk7XG5cbiAgICBcdFx0XHRmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xuXG4gICAgXHRcdFx0XHRmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xuXG4gICAgXHRcdFx0XHR2QSA9IHRoaXMudmVydGljZXNbIGZhY2UuYSBdO1xuICAgIFx0XHRcdFx0dkIgPSB0aGlzLnZlcnRpY2VzWyBmYWNlLmIgXTtcbiAgICBcdFx0XHRcdHZDID0gdGhpcy52ZXJ0aWNlc1sgZmFjZS5jIF07XG5cbiAgICBcdFx0XHRcdGNiLnN1YlZlY3RvcnMoIHZDLCB2QiApO1xuICAgIFx0XHRcdFx0YWIuc3ViVmVjdG9ycyggdkEsIHZCICk7XG4gICAgXHRcdFx0XHRjYi5jcm9zcyggYWIgKTtcblxuICAgIFx0XHRcdFx0dmVydGljZXNbIGZhY2UuYSBdLmFkZCggY2IgKTtcbiAgICBcdFx0XHRcdHZlcnRpY2VzWyBmYWNlLmIgXS5hZGQoIGNiICk7XG4gICAgXHRcdFx0XHR2ZXJ0aWNlc1sgZmFjZS5jIF0uYWRkKCBjYiApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xuXG4gICAgXHRcdFx0XHRmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xuXG4gICAgXHRcdFx0XHR2ZXJ0aWNlc1sgZmFjZS5hIF0uYWRkKCBmYWNlLm5vcm1hbCApO1xuICAgIFx0XHRcdFx0dmVydGljZXNbIGZhY2UuYiBdLmFkZCggZmFjZS5ub3JtYWwgKTtcbiAgICBcdFx0XHRcdHZlcnRpY2VzWyBmYWNlLmMgXS5hZGQoIGZhY2Uubm9ybWFsICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGZvciAoIHYgPSAwLCB2bCA9IHRoaXMudmVydGljZXMubGVuZ3RoOyB2IDwgdmw7IHYgKysgKSB7XG5cbiAgICBcdFx0XHR2ZXJ0aWNlc1sgdiBdLm5vcm1hbGl6ZSgpO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xuXG4gICAgXHRcdFx0ZmFjZSA9IHRoaXMuZmFjZXNbIGYgXTtcblxuICAgIFx0XHRcdHZhciB2ZXJ0ZXhOb3JtYWxzID0gZmFjZS52ZXJ0ZXhOb3JtYWxzO1xuXG4gICAgXHRcdFx0aWYgKCB2ZXJ0ZXhOb3JtYWxzLmxlbmd0aCA9PT0gMyApIHtcblxuICAgIFx0XHRcdFx0dmVydGV4Tm9ybWFsc1sgMCBdLmNvcHkoIHZlcnRpY2VzWyBmYWNlLmEgXSApO1xuICAgIFx0XHRcdFx0dmVydGV4Tm9ybWFsc1sgMSBdLmNvcHkoIHZlcnRpY2VzWyBmYWNlLmIgXSApO1xuICAgIFx0XHRcdFx0dmVydGV4Tm9ybWFsc1sgMiBdLmNvcHkoIHZlcnRpY2VzWyBmYWNlLmMgXSApO1xuXG4gICAgXHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0dmVydGV4Tm9ybWFsc1sgMCBdID0gdmVydGljZXNbIGZhY2UuYSBdLmNsb25lKCk7XG4gICAgXHRcdFx0XHR2ZXJ0ZXhOb3JtYWxzWyAxIF0gPSB2ZXJ0aWNlc1sgZmFjZS5iIF0uY2xvbmUoKTtcbiAgICBcdFx0XHRcdHZlcnRleE5vcm1hbHNbIDIgXSA9IHZlcnRpY2VzWyBmYWNlLmMgXS5jbG9uZSgpO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHRpZiAoIHRoaXMuZmFjZXMubGVuZ3RoID4gMCApIHtcblxuICAgIFx0XHRcdHRoaXMubm9ybWFsc05lZWRVcGRhdGUgPSB0cnVlO1xuXG4gICAgXHRcdH1cblxuICAgIFx0fSxcblxuICAgIFx0Y29tcHV0ZU1vcnBoTm9ybWFsczogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHZhciBpLCBpbCwgZiwgZmwsIGZhY2U7XG5cbiAgICBcdFx0Ly8gc2F2ZSBvcmlnaW5hbCBub3JtYWxzXG4gICAgXHRcdC8vIC0gY3JlYXRlIHRlbXAgdmFyaWFibGVzIG9uIGZpcnN0IGFjY2Vzc1xuICAgIFx0XHQvLyAgIG90aGVyd2lzZSBqdXN0IGNvcHkgKGZvciBmYXN0ZXIgcmVwZWF0ZWQgY2FsbHMpXG5cbiAgICBcdFx0Zm9yICggZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcblxuICAgIFx0XHRcdGZhY2UgPSB0aGlzLmZhY2VzWyBmIF07XG5cbiAgICBcdFx0XHRpZiAoICEgZmFjZS5fX29yaWdpbmFsRmFjZU5vcm1hbCApIHtcblxuICAgIFx0XHRcdFx0ZmFjZS5fX29yaWdpbmFsRmFjZU5vcm1hbCA9IGZhY2Uubm9ybWFsLmNsb25lKCk7XG5cbiAgICBcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHRmYWNlLl9fb3JpZ2luYWxGYWNlTm9ybWFsLmNvcHkoIGZhY2Uubm9ybWFsICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRpZiAoICEgZmFjZS5fX29yaWdpbmFsVmVydGV4Tm9ybWFscyApIGZhY2UuX19vcmlnaW5hbFZlcnRleE5vcm1hbHMgPSBbXTtcblxuICAgIFx0XHRcdGZvciAoIGkgPSAwLCBpbCA9IGZhY2UudmVydGV4Tm9ybWFscy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuICAgIFx0XHRcdFx0aWYgKCAhIGZhY2UuX19vcmlnaW5hbFZlcnRleE5vcm1hbHNbIGkgXSApIHtcblxuICAgIFx0XHRcdFx0XHRmYWNlLl9fb3JpZ2luYWxWZXJ0ZXhOb3JtYWxzWyBpIF0gPSBmYWNlLnZlcnRleE5vcm1hbHNbIGkgXS5jbG9uZSgpO1xuXG4gICAgXHRcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHRcdGZhY2UuX19vcmlnaW5hbFZlcnRleE5vcm1hbHNbIGkgXS5jb3B5KCBmYWNlLnZlcnRleE5vcm1hbHNbIGkgXSApO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdC8vIHVzZSB0ZW1wIGdlb21ldHJ5IHRvIGNvbXB1dGUgZmFjZSBhbmQgdmVydGV4IG5vcm1hbHMgZm9yIGVhY2ggbW9ycGhcblxuICAgIFx0XHR2YXIgdG1wR2VvID0gbmV3IEdlb21ldHJ5KCk7XG4gICAgXHRcdHRtcEdlby5mYWNlcyA9IHRoaXMuZmFjZXM7XG5cbiAgICBcdFx0Zm9yICggaSA9IDAsIGlsID0gdGhpcy5tb3JwaFRhcmdldHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICBcdFx0XHQvLyBjcmVhdGUgb24gZmlyc3QgYWNjZXNzXG5cbiAgICBcdFx0XHRpZiAoICEgdGhpcy5tb3JwaE5vcm1hbHNbIGkgXSApIHtcblxuICAgIFx0XHRcdFx0dGhpcy5tb3JwaE5vcm1hbHNbIGkgXSA9IHt9O1xuICAgIFx0XHRcdFx0dGhpcy5tb3JwaE5vcm1hbHNbIGkgXS5mYWNlTm9ybWFscyA9IFtdO1xuICAgIFx0XHRcdFx0dGhpcy5tb3JwaE5vcm1hbHNbIGkgXS52ZXJ0ZXhOb3JtYWxzID0gW107XG5cbiAgICBcdFx0XHRcdHZhciBkc3ROb3JtYWxzRmFjZSA9IHRoaXMubW9ycGhOb3JtYWxzWyBpIF0uZmFjZU5vcm1hbHM7XG4gICAgXHRcdFx0XHR2YXIgZHN0Tm9ybWFsc1ZlcnRleCA9IHRoaXMubW9ycGhOb3JtYWxzWyBpIF0udmVydGV4Tm9ybWFscztcblxuICAgIFx0XHRcdFx0dmFyIGZhY2VOb3JtYWwsIHZlcnRleE5vcm1hbHM7XG5cbiAgICBcdFx0XHRcdGZvciAoIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XG5cbiAgICBcdFx0XHRcdFx0ZmFjZU5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XG4gICAgXHRcdFx0XHRcdHZlcnRleE5vcm1hbHMgPSB7IGE6IG5ldyBWZWN0b3IzKCksIGI6IG5ldyBWZWN0b3IzKCksIGM6IG5ldyBWZWN0b3IzKCkgfTtcblxuICAgIFx0XHRcdFx0XHRkc3ROb3JtYWxzRmFjZS5wdXNoKCBmYWNlTm9ybWFsICk7XG4gICAgXHRcdFx0XHRcdGRzdE5vcm1hbHNWZXJ0ZXgucHVzaCggdmVydGV4Tm9ybWFscyApO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHR2YXIgbW9ycGhOb3JtYWxzID0gdGhpcy5tb3JwaE5vcm1hbHNbIGkgXTtcblxuICAgIFx0XHRcdC8vIHNldCB2ZXJ0aWNlcyB0byBtb3JwaCB0YXJnZXRcblxuICAgIFx0XHRcdHRtcEdlby52ZXJ0aWNlcyA9IHRoaXMubW9ycGhUYXJnZXRzWyBpIF0udmVydGljZXM7XG5cbiAgICBcdFx0XHQvLyBjb21wdXRlIG1vcnBoIG5vcm1hbHNcblxuICAgIFx0XHRcdHRtcEdlby5jb21wdXRlRmFjZU5vcm1hbHMoKTtcbiAgICBcdFx0XHR0bXBHZW8uY29tcHV0ZVZlcnRleE5vcm1hbHMoKTtcblxuICAgIFx0XHRcdC8vIHN0b3JlIG1vcnBoIG5vcm1hbHNcblxuICAgIFx0XHRcdHZhciBmYWNlTm9ybWFsLCB2ZXJ0ZXhOb3JtYWxzO1xuXG4gICAgXHRcdFx0Zm9yICggZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcblxuICAgIFx0XHRcdFx0ZmFjZSA9IHRoaXMuZmFjZXNbIGYgXTtcblxuICAgIFx0XHRcdFx0ZmFjZU5vcm1hbCA9IG1vcnBoTm9ybWFscy5mYWNlTm9ybWFsc1sgZiBdO1xuICAgIFx0XHRcdFx0dmVydGV4Tm9ybWFscyA9IG1vcnBoTm9ybWFscy52ZXJ0ZXhOb3JtYWxzWyBmIF07XG5cbiAgICBcdFx0XHRcdGZhY2VOb3JtYWwuY29weSggZmFjZS5ub3JtYWwgKTtcblxuICAgIFx0XHRcdFx0dmVydGV4Tm9ybWFscy5hLmNvcHkoIGZhY2UudmVydGV4Tm9ybWFsc1sgMCBdICk7XG4gICAgXHRcdFx0XHR2ZXJ0ZXhOb3JtYWxzLmIuY29weSggZmFjZS52ZXJ0ZXhOb3JtYWxzWyAxIF0gKTtcbiAgICBcdFx0XHRcdHZlcnRleE5vcm1hbHMuYy5jb3B5KCBmYWNlLnZlcnRleE5vcm1hbHNbIDIgXSApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHQvLyByZXN0b3JlIG9yaWdpbmFsIG5vcm1hbHNcblxuICAgIFx0XHRmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xuXG4gICAgXHRcdFx0ZmFjZSA9IHRoaXMuZmFjZXNbIGYgXTtcblxuICAgIFx0XHRcdGZhY2Uubm9ybWFsID0gZmFjZS5fX29yaWdpbmFsRmFjZU5vcm1hbDtcbiAgICBcdFx0XHRmYWNlLnZlcnRleE5vcm1hbHMgPSBmYWNlLl9fb3JpZ2luYWxWZXJ0ZXhOb3JtYWxzO1xuXG4gICAgXHRcdH1cblxuICAgIFx0fSxcblxuICAgIFx0Y29tcHV0ZVRhbmdlbnRzOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuR2VvbWV0cnk6IC5jb21wdXRlVGFuZ2VudHMoKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcblxuICAgIFx0fSxcblxuICAgIFx0Y29tcHV0ZUxpbmVEaXN0YW5jZXM6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR2YXIgZCA9IDA7XG4gICAgXHRcdHZhciB2ZXJ0aWNlcyA9IHRoaXMudmVydGljZXM7XG5cbiAgICBcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHZlcnRpY2VzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgXHRcdFx0aWYgKCBpID4gMCApIHtcblxuICAgIFx0XHRcdFx0ZCArPSB2ZXJ0aWNlc1sgaSBdLmRpc3RhbmNlVG8oIHZlcnRpY2VzWyBpIC0gMSBdICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHR0aGlzLmxpbmVEaXN0YW5jZXNbIGkgXSA9IGQ7XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9LFxuXG4gICAgXHRjb21wdXRlQm91bmRpbmdCb3g6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHRpZiAoIHRoaXMuYm91bmRpbmdCb3ggPT09IG51bGwgKSB7XG5cbiAgICBcdFx0XHR0aGlzLmJvdW5kaW5nQm94ID0gbmV3IEJveDMoKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0dGhpcy5ib3VuZGluZ0JveC5zZXRGcm9tUG9pbnRzKCB0aGlzLnZlcnRpY2VzICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGNvbXB1dGVCb3VuZGluZ1NwaGVyZTogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdGlmICggdGhpcy5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCApIHtcblxuICAgIFx0XHRcdHRoaXMuYm91bmRpbmdTcGhlcmUgPSBuZXcgU3BoZXJlKCk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHRoaXMuYm91bmRpbmdTcGhlcmUuc2V0RnJvbVBvaW50cyggdGhpcy52ZXJ0aWNlcyApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRtZXJnZTogZnVuY3Rpb24gKCBnZW9tZXRyeSwgbWF0cml4LCBtYXRlcmlhbEluZGV4T2Zmc2V0ICkge1xuXG4gICAgXHRcdGlmICggKGdlb21ldHJ5ICYmIGdlb21ldHJ5LmlzR2VvbWV0cnkpID09PSBmYWxzZSApIHtcblxuICAgIFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5HZW9tZXRyeS5tZXJnZSgpOiBnZW9tZXRyeSBub3QgYW4gaW5zdGFuY2Ugb2YgVEhSRUUuR2VvbWV0cnkuJywgZ2VvbWV0cnkgKTtcbiAgICBcdFx0XHRyZXR1cm47XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHZhciBub3JtYWxNYXRyaXgsXG4gICAgXHRcdHZlcnRleE9mZnNldCA9IHRoaXMudmVydGljZXMubGVuZ3RoLFxuICAgIFx0XHR2ZXJ0aWNlczEgPSB0aGlzLnZlcnRpY2VzLFxuICAgIFx0XHR2ZXJ0aWNlczIgPSBnZW9tZXRyeS52ZXJ0aWNlcyxcbiAgICBcdFx0ZmFjZXMxID0gdGhpcy5mYWNlcyxcbiAgICBcdFx0ZmFjZXMyID0gZ2VvbWV0cnkuZmFjZXMsXG4gICAgXHRcdHV2czEgPSB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXSxcbiAgICBcdFx0dXZzMiA9IGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIDAgXSxcbiAgICBcdFx0Y29sb3JzMSA9IHRoaXMuY29sb3JzLFxuICAgIFx0XHRjb2xvcnMyID0gZ2VvbWV0cnkuY29sb3JzO1xuXG4gICAgXHRcdGlmICggbWF0ZXJpYWxJbmRleE9mZnNldCA9PT0gdW5kZWZpbmVkICkgbWF0ZXJpYWxJbmRleE9mZnNldCA9IDA7XG5cbiAgICBcdFx0aWYgKCBtYXRyaXggIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdG5vcm1hbE1hdHJpeCA9IG5ldyBNYXRyaXgzKCkuZ2V0Tm9ybWFsTWF0cml4KCBtYXRyaXggKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0Ly8gdmVydGljZXNcblxuICAgIFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gdmVydGljZXMyLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgXHRcdFx0dmFyIHZlcnRleCA9IHZlcnRpY2VzMlsgaSBdO1xuXG4gICAgXHRcdFx0dmFyIHZlcnRleENvcHkgPSB2ZXJ0ZXguY2xvbmUoKTtcblxuICAgIFx0XHRcdGlmICggbWF0cml4ICE9PSB1bmRlZmluZWQgKSB2ZXJ0ZXhDb3B5LmFwcGx5TWF0cml4NCggbWF0cml4ICk7XG5cbiAgICBcdFx0XHR2ZXJ0aWNlczEucHVzaCggdmVydGV4Q29weSApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHQvLyBjb2xvcnNcblxuICAgIFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gY29sb3JzMi5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuICAgIFx0XHRcdGNvbG9yczEucHVzaCggY29sb3JzMlsgaSBdLmNsb25lKCkgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0Ly8gZmFjZXNcblxuICAgIFx0XHRmb3IgKCBpID0gMCwgaWwgPSBmYWNlczIubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICBcdFx0XHR2YXIgZmFjZSA9IGZhY2VzMlsgaSBdLCBmYWNlQ29weSwgbm9ybWFsLCBjb2xvcixcbiAgICBcdFx0XHRmYWNlVmVydGV4Tm9ybWFscyA9IGZhY2UudmVydGV4Tm9ybWFscyxcbiAgICBcdFx0XHRmYWNlVmVydGV4Q29sb3JzID0gZmFjZS52ZXJ0ZXhDb2xvcnM7XG5cbiAgICBcdFx0XHRmYWNlQ29weSA9IG5ldyBGYWNlMyggZmFjZS5hICsgdmVydGV4T2Zmc2V0LCBmYWNlLmIgKyB2ZXJ0ZXhPZmZzZXQsIGZhY2UuYyArIHZlcnRleE9mZnNldCApO1xuICAgIFx0XHRcdGZhY2VDb3B5Lm5vcm1hbC5jb3B5KCBmYWNlLm5vcm1hbCApO1xuXG4gICAgXHRcdFx0aWYgKCBub3JtYWxNYXRyaXggIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0ZmFjZUNvcHkubm9ybWFsLmFwcGx5TWF0cml4Myggbm9ybWFsTWF0cml4ICkubm9ybWFsaXplKCk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gZmFjZVZlcnRleE5vcm1hbHMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XG5cbiAgICBcdFx0XHRcdG5vcm1hbCA9IGZhY2VWZXJ0ZXhOb3JtYWxzWyBqIF0uY2xvbmUoKTtcblxuICAgIFx0XHRcdFx0aWYgKCBub3JtYWxNYXRyaXggIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0XHRub3JtYWwuYXBwbHlNYXRyaXgzKCBub3JtYWxNYXRyaXggKS5ub3JtYWxpemUoKTtcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHRmYWNlQ29weS52ZXJ0ZXhOb3JtYWxzLnB1c2goIG5vcm1hbCApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0ZmFjZUNvcHkuY29sb3IuY29weSggZmFjZS5jb2xvciApO1xuXG4gICAgXHRcdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IGZhY2VWZXJ0ZXhDb2xvcnMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XG5cbiAgICBcdFx0XHRcdGNvbG9yID0gZmFjZVZlcnRleENvbG9yc1sgaiBdO1xuICAgIFx0XHRcdFx0ZmFjZUNvcHkudmVydGV4Q29sb3JzLnB1c2goIGNvbG9yLmNsb25lKCkgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdGZhY2VDb3B5Lm1hdGVyaWFsSW5kZXggPSBmYWNlLm1hdGVyaWFsSW5kZXggKyBtYXRlcmlhbEluZGV4T2Zmc2V0O1xuXG4gICAgXHRcdFx0ZmFjZXMxLnB1c2goIGZhY2VDb3B5ICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdC8vIHV2c1xuXG4gICAgXHRcdGZvciAoIGkgPSAwLCBpbCA9IHV2czIubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICBcdFx0XHR2YXIgdXYgPSB1dnMyWyBpIF0sIHV2Q29weSA9IFtdO1xuXG4gICAgXHRcdFx0aWYgKCB1diA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0XHRjb250aW51ZTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSB1di5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuICAgIFx0XHRcdFx0dXZDb3B5LnB1c2goIHV2WyBqIF0uY2xvbmUoKSApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0dXZzMS5wdXNoKCB1dkNvcHkgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdH0sXG5cbiAgICBcdG1lcmdlTWVzaDogZnVuY3Rpb24gKCBtZXNoICkge1xuXG4gICAgXHRcdGlmICggKG1lc2ggJiYgbWVzaC5pc01lc2gpID09PSBmYWxzZSApIHtcblxuICAgIFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5HZW9tZXRyeS5tZXJnZU1lc2goKTogbWVzaCBub3QgYW4gaW5zdGFuY2Ugb2YgVEhSRUUuTWVzaC4nLCBtZXNoICk7XG4gICAgXHRcdFx0cmV0dXJuO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRtZXNoLm1hdHJpeEF1dG9VcGRhdGUgJiYgbWVzaC51cGRhdGVNYXRyaXgoKTtcblxuICAgIFx0XHR0aGlzLm1lcmdlKCBtZXNoLmdlb21ldHJ5LCBtZXNoLm1hdHJpeCApO1xuXG4gICAgXHR9LFxuXG4gICAgXHQvKlxuICAgIFx0ICogQ2hlY2tzIGZvciBkdXBsaWNhdGUgdmVydGljZXMgd2l0aCBoYXNobWFwLlxuICAgIFx0ICogRHVwbGljYXRlZCB2ZXJ0aWNlcyBhcmUgcmVtb3ZlZFxuICAgIFx0ICogYW5kIGZhY2VzJyB2ZXJ0aWNlcyBhcmUgdXBkYXRlZC5cbiAgICBcdCAqL1xuXG4gICAgXHRtZXJnZVZlcnRpY2VzOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dmFyIHZlcnRpY2VzTWFwID0ge307IC8vIEhhc2htYXAgZm9yIGxvb2tpbmcgdXAgdmVydGljZXMgYnkgcG9zaXRpb24gY29vcmRpbmF0ZXMgKGFuZCBtYWtpbmcgc3VyZSB0aGV5IGFyZSB1bmlxdWUpXG4gICAgXHRcdHZhciB1bmlxdWUgPSBbXSwgY2hhbmdlcyA9IFtdO1xuXG4gICAgXHRcdHZhciB2LCBrZXk7XG4gICAgXHRcdHZhciBwcmVjaXNpb25Qb2ludHMgPSA0OyAvLyBudW1iZXIgb2YgZGVjaW1hbCBwb2ludHMsIGUuZy4gNCBmb3IgZXBzaWxvbiBvZiAwLjAwMDFcbiAgICBcdFx0dmFyIHByZWNpc2lvbiA9IE1hdGgucG93KCAxMCwgcHJlY2lzaW9uUG9pbnRzICk7XG4gICAgXHRcdHZhciBpLCBpbCwgZmFjZTtcbiAgICBcdFx0dmFyIGluZGljZXMsIGosIGpsO1xuXG4gICAgXHRcdGZvciAoIGkgPSAwLCBpbCA9IHRoaXMudmVydGljZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICBcdFx0XHR2ID0gdGhpcy52ZXJ0aWNlc1sgaSBdO1xuICAgIFx0XHRcdGtleSA9IE1hdGgucm91bmQoIHYueCAqIHByZWNpc2lvbiApICsgJ18nICsgTWF0aC5yb3VuZCggdi55ICogcHJlY2lzaW9uICkgKyAnXycgKyBNYXRoLnJvdW5kKCB2LnogKiBwcmVjaXNpb24gKTtcblxuICAgIFx0XHRcdGlmICggdmVydGljZXNNYXBbIGtleSBdID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRcdHZlcnRpY2VzTWFwWyBrZXkgXSA9IGk7XG4gICAgXHRcdFx0XHR1bmlxdWUucHVzaCggdGhpcy52ZXJ0aWNlc1sgaSBdICk7XG4gICAgXHRcdFx0XHRjaGFuZ2VzWyBpIF0gPSB1bmlxdWUubGVuZ3RoIC0gMTtcblxuICAgIFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdC8vY29uc29sZS5sb2coJ0R1cGxpY2F0ZSB2ZXJ0ZXggZm91bmQuICcsIGksICcgY291bGQgYmUgdXNpbmcgJywgdmVydGljZXNNYXBba2V5XSk7XG4gICAgXHRcdFx0XHRjaGFuZ2VzWyBpIF0gPSBjaGFuZ2VzWyB2ZXJ0aWNlc01hcFsga2V5IF0gXTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cblxuICAgIFx0XHQvLyBpZiBmYWNlcyBhcmUgY29tcGxldGVseSBkZWdlbmVyYXRlIGFmdGVyIG1lcmdpbmcgdmVydGljZXMsIHdlXG4gICAgXHRcdC8vIGhhdmUgdG8gcmVtb3ZlIHRoZW0gZnJvbSB0aGUgZ2VvbWV0cnkuXG4gICAgXHRcdHZhciBmYWNlSW5kaWNlc1RvUmVtb3ZlID0gW107XG5cbiAgICBcdFx0Zm9yICggaSA9IDAsIGlsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuICAgIFx0XHRcdGZhY2UgPSB0aGlzLmZhY2VzWyBpIF07XG5cbiAgICBcdFx0XHRmYWNlLmEgPSBjaGFuZ2VzWyBmYWNlLmEgXTtcbiAgICBcdFx0XHRmYWNlLmIgPSBjaGFuZ2VzWyBmYWNlLmIgXTtcbiAgICBcdFx0XHRmYWNlLmMgPSBjaGFuZ2VzWyBmYWNlLmMgXTtcblxuICAgIFx0XHRcdGluZGljZXMgPSBbIGZhY2UuYSwgZmFjZS5iLCBmYWNlLmMgXTtcblxuICAgIFx0XHRcdHZhciBkdXBJbmRleCA9IC0gMTtcblxuICAgIFx0XHRcdC8vIGlmIGFueSBkdXBsaWNhdGUgdmVydGljZXMgYXJlIGZvdW5kIGluIGEgRmFjZTNcbiAgICBcdFx0XHQvLyB3ZSBoYXZlIHRvIHJlbW92ZSB0aGUgZmFjZSBhcyBub3RoaW5nIGNhbiBiZSBzYXZlZFxuICAgIFx0XHRcdGZvciAoIHZhciBuID0gMDsgbiA8IDM7IG4gKysgKSB7XG5cbiAgICBcdFx0XHRcdGlmICggaW5kaWNlc1sgbiBdID09PSBpbmRpY2VzWyAoIG4gKyAxICkgJSAzIF0gKSB7XG5cbiAgICBcdFx0XHRcdFx0ZHVwSW5kZXggPSBuO1xuICAgIFx0XHRcdFx0XHRmYWNlSW5kaWNlc1RvUmVtb3ZlLnB1c2goIGkgKTtcbiAgICBcdFx0XHRcdFx0YnJlYWs7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdFx0Zm9yICggaSA9IGZhY2VJbmRpY2VzVG9SZW1vdmUubGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC0tICkge1xuXG4gICAgXHRcdFx0dmFyIGlkeCA9IGZhY2VJbmRpY2VzVG9SZW1vdmVbIGkgXTtcblxuICAgIFx0XHRcdHRoaXMuZmFjZXMuc3BsaWNlKCBpZHgsIDEgKTtcblxuICAgIFx0XHRcdGZvciAoIGogPSAwLCBqbCA9IHRoaXMuZmFjZVZlcnRleFV2cy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuICAgIFx0XHRcdFx0dGhpcy5mYWNlVmVydGV4VXZzWyBqIF0uc3BsaWNlKCBpZHgsIDEgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdFx0Ly8gVXNlIHVuaXF1ZSBzZXQgb2YgdmVydGljZXNcblxuICAgIFx0XHR2YXIgZGlmZiA9IHRoaXMudmVydGljZXMubGVuZ3RoIC0gdW5pcXVlLmxlbmd0aDtcbiAgICBcdFx0dGhpcy52ZXJ0aWNlcyA9IHVuaXF1ZTtcbiAgICBcdFx0cmV0dXJuIGRpZmY7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNvcnRGYWNlc0J5TWF0ZXJpYWxJbmRleDogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHZhciBmYWNlcyA9IHRoaXMuZmFjZXM7XG4gICAgXHRcdHZhciBsZW5ndGggPSBmYWNlcy5sZW5ndGg7XG5cbiAgICBcdFx0Ly8gdGFnIGZhY2VzXG5cbiAgICBcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICsrICkge1xuXG4gICAgXHRcdFx0ZmFjZXNbIGkgXS5faWQgPSBpO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHQvLyBzb3J0IGZhY2VzXG5cbiAgICBcdFx0ZnVuY3Rpb24gbWF0ZXJpYWxJbmRleFNvcnQoIGEsIGIgKSB7XG5cbiAgICBcdFx0XHRyZXR1cm4gYS5tYXRlcmlhbEluZGV4IC0gYi5tYXRlcmlhbEluZGV4O1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRmYWNlcy5zb3J0KCBtYXRlcmlhbEluZGV4U29ydCApO1xuXG4gICAgXHRcdC8vIHNvcnQgdXZzXG5cbiAgICBcdFx0dmFyIHV2czEgPSB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXTtcbiAgICBcdFx0dmFyIHV2czIgPSB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDEgXTtcblxuICAgIFx0XHR2YXIgbmV3VXZzMSwgbmV3VXZzMjtcblxuICAgIFx0XHRpZiAoIHV2czEgJiYgdXZzMS5sZW5ndGggPT09IGxlbmd0aCApIG5ld1V2czEgPSBbXTtcbiAgICBcdFx0aWYgKCB1dnMyICYmIHV2czIubGVuZ3RoID09PSBsZW5ndGggKSBuZXdVdnMyID0gW107XG5cbiAgICBcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICsrICkge1xuXG4gICAgXHRcdFx0dmFyIGlkID0gZmFjZXNbIGkgXS5faWQ7XG5cbiAgICBcdFx0XHRpZiAoIG5ld1V2czEgKSBuZXdVdnMxLnB1c2goIHV2czFbIGlkIF0gKTtcbiAgICBcdFx0XHRpZiAoIG5ld1V2czIgKSBuZXdVdnMyLnB1c2goIHV2czJbIGlkIF0gKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0aWYgKCBuZXdVdnMxICkgdGhpcy5mYWNlVmVydGV4VXZzWyAwIF0gPSBuZXdVdnMxO1xuICAgIFx0XHRpZiAoIG5ld1V2czIgKSB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDEgXSA9IG5ld1V2czI7XG5cbiAgICBcdH0sXG5cbiAgICBcdHRvSlNPTjogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHZhciBkYXRhID0ge1xuICAgIFx0XHRcdG1ldGFkYXRhOiB7XG4gICAgXHRcdFx0XHR2ZXJzaW9uOiA0LjQsXG4gICAgXHRcdFx0XHR0eXBlOiAnR2VvbWV0cnknLFxuICAgIFx0XHRcdFx0Z2VuZXJhdG9yOiAnR2VvbWV0cnkudG9KU09OJ1xuICAgIFx0XHRcdH1cbiAgICBcdFx0fTtcblxuICAgIFx0XHQvLyBzdGFuZGFyZCBHZW9tZXRyeSBzZXJpYWxpemF0aW9uXG5cbiAgICBcdFx0ZGF0YS51dWlkID0gdGhpcy51dWlkO1xuICAgIFx0XHRkYXRhLnR5cGUgPSB0aGlzLnR5cGU7XG4gICAgXHRcdGlmICggdGhpcy5uYW1lICE9PSAnJyApIGRhdGEubmFtZSA9IHRoaXMubmFtZTtcblxuICAgIFx0XHRpZiAoIHRoaXMucGFyYW1ldGVycyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0dmFyIHBhcmFtZXRlcnMgPSB0aGlzLnBhcmFtZXRlcnM7XG5cbiAgICBcdFx0XHRmb3IgKCB2YXIga2V5IGluIHBhcmFtZXRlcnMgKSB7XG5cbiAgICBcdFx0XHRcdGlmICggcGFyYW1ldGVyc1sga2V5IF0gIT09IHVuZGVmaW5lZCApIGRhdGFbIGtleSBdID0gcGFyYW1ldGVyc1sga2V5IF07XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRyZXR1cm4gZGF0YTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0dmFyIHZlcnRpY2VzID0gW107XG5cbiAgICBcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IGkgKysgKSB7XG5cbiAgICBcdFx0XHR2YXIgdmVydGV4ID0gdGhpcy52ZXJ0aWNlc1sgaSBdO1xuICAgIFx0XHRcdHZlcnRpY2VzLnB1c2goIHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnogKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0dmFyIGZhY2VzID0gW107XG4gICAgXHRcdHZhciBub3JtYWxzID0gW107XG4gICAgXHRcdHZhciBub3JtYWxzSGFzaCA9IHt9O1xuICAgIFx0XHR2YXIgY29sb3JzID0gW107XG4gICAgXHRcdHZhciBjb2xvcnNIYXNoID0ge307XG4gICAgXHRcdHZhciB1dnMgPSBbXTtcbiAgICBcdFx0dmFyIHV2c0hhc2ggPSB7fTtcblxuICAgIFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmZhY2VzLmxlbmd0aDsgaSArKyApIHtcblxuICAgIFx0XHRcdHZhciBmYWNlID0gdGhpcy5mYWNlc1sgaSBdO1xuXG4gICAgXHRcdFx0dmFyIGhhc01hdGVyaWFsID0gdHJ1ZTtcbiAgICBcdFx0XHR2YXIgaGFzRmFjZVV2ID0gZmFsc2U7IC8vIGRlcHJlY2F0ZWRcbiAgICBcdFx0XHR2YXIgaGFzRmFjZVZlcnRleFV2ID0gdGhpcy5mYWNlVmVydGV4VXZzWyAwIF1bIGkgXSAhPT0gdW5kZWZpbmVkO1xuICAgIFx0XHRcdHZhciBoYXNGYWNlTm9ybWFsID0gZmFjZS5ub3JtYWwubGVuZ3RoKCkgPiAwO1xuICAgIFx0XHRcdHZhciBoYXNGYWNlVmVydGV4Tm9ybWFsID0gZmFjZS52ZXJ0ZXhOb3JtYWxzLmxlbmd0aCA+IDA7XG4gICAgXHRcdFx0dmFyIGhhc0ZhY2VDb2xvciA9IGZhY2UuY29sb3IuciAhPT0gMSB8fCBmYWNlLmNvbG9yLmcgIT09IDEgfHwgZmFjZS5jb2xvci5iICE9PSAxO1xuICAgIFx0XHRcdHZhciBoYXNGYWNlVmVydGV4Q29sb3IgPSBmYWNlLnZlcnRleENvbG9ycy5sZW5ndGggPiAwO1xuXG4gICAgXHRcdFx0dmFyIGZhY2VUeXBlID0gMDtcblxuICAgIFx0XHRcdGZhY2VUeXBlID0gc2V0Qml0KCBmYWNlVHlwZSwgMCwgMCApOyAvLyBpc1F1YWRcbiAgICBcdFx0XHRmYWNlVHlwZSA9IHNldEJpdCggZmFjZVR5cGUsIDEsIGhhc01hdGVyaWFsICk7XG4gICAgXHRcdFx0ZmFjZVR5cGUgPSBzZXRCaXQoIGZhY2VUeXBlLCAyLCBoYXNGYWNlVXYgKTtcbiAgICBcdFx0XHRmYWNlVHlwZSA9IHNldEJpdCggZmFjZVR5cGUsIDMsIGhhc0ZhY2VWZXJ0ZXhVdiApO1xuICAgIFx0XHRcdGZhY2VUeXBlID0gc2V0Qml0KCBmYWNlVHlwZSwgNCwgaGFzRmFjZU5vcm1hbCApO1xuICAgIFx0XHRcdGZhY2VUeXBlID0gc2V0Qml0KCBmYWNlVHlwZSwgNSwgaGFzRmFjZVZlcnRleE5vcm1hbCApO1xuICAgIFx0XHRcdGZhY2VUeXBlID0gc2V0Qml0KCBmYWNlVHlwZSwgNiwgaGFzRmFjZUNvbG9yICk7XG4gICAgXHRcdFx0ZmFjZVR5cGUgPSBzZXRCaXQoIGZhY2VUeXBlLCA3LCBoYXNGYWNlVmVydGV4Q29sb3IgKTtcblxuICAgIFx0XHRcdGZhY2VzLnB1c2goIGZhY2VUeXBlICk7XG4gICAgXHRcdFx0ZmFjZXMucHVzaCggZmFjZS5hLCBmYWNlLmIsIGZhY2UuYyApO1xuICAgIFx0XHRcdGZhY2VzLnB1c2goIGZhY2UubWF0ZXJpYWxJbmRleCApO1xuXG4gICAgXHRcdFx0aWYgKCBoYXNGYWNlVmVydGV4VXYgKSB7XG5cbiAgICBcdFx0XHRcdHZhciBmYWNlVmVydGV4VXZzID0gdGhpcy5mYWNlVmVydGV4VXZzWyAwIF1bIGkgXTtcblxuICAgIFx0XHRcdFx0ZmFjZXMucHVzaChcbiAgICBcdFx0XHRcdFx0Z2V0VXZJbmRleCggZmFjZVZlcnRleFV2c1sgMCBdICksXG4gICAgXHRcdFx0XHRcdGdldFV2SW5kZXgoIGZhY2VWZXJ0ZXhVdnNbIDEgXSApLFxuICAgIFx0XHRcdFx0XHRnZXRVdkluZGV4KCBmYWNlVmVydGV4VXZzWyAyIF0gKVxuICAgIFx0XHRcdFx0KTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdGlmICggaGFzRmFjZU5vcm1hbCApIHtcblxuICAgIFx0XHRcdFx0ZmFjZXMucHVzaCggZ2V0Tm9ybWFsSW5kZXgoIGZhY2Uubm9ybWFsICkgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdGlmICggaGFzRmFjZVZlcnRleE5vcm1hbCApIHtcblxuICAgIFx0XHRcdFx0dmFyIHZlcnRleE5vcm1hbHMgPSBmYWNlLnZlcnRleE5vcm1hbHM7XG5cbiAgICBcdFx0XHRcdGZhY2VzLnB1c2goXG4gICAgXHRcdFx0XHRcdGdldE5vcm1hbEluZGV4KCB2ZXJ0ZXhOb3JtYWxzWyAwIF0gKSxcbiAgICBcdFx0XHRcdFx0Z2V0Tm9ybWFsSW5kZXgoIHZlcnRleE5vcm1hbHNbIDEgXSApLFxuICAgIFx0XHRcdFx0XHRnZXROb3JtYWxJbmRleCggdmVydGV4Tm9ybWFsc1sgMiBdIClcbiAgICBcdFx0XHRcdCk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRpZiAoIGhhc0ZhY2VDb2xvciApIHtcblxuICAgIFx0XHRcdFx0ZmFjZXMucHVzaCggZ2V0Q29sb3JJbmRleCggZmFjZS5jb2xvciApICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRpZiAoIGhhc0ZhY2VWZXJ0ZXhDb2xvciApIHtcblxuICAgIFx0XHRcdFx0dmFyIHZlcnRleENvbG9ycyA9IGZhY2UudmVydGV4Q29sb3JzO1xuXG4gICAgXHRcdFx0XHRmYWNlcy5wdXNoKFxuICAgIFx0XHRcdFx0XHRnZXRDb2xvckluZGV4KCB2ZXJ0ZXhDb2xvcnNbIDAgXSApLFxuICAgIFx0XHRcdFx0XHRnZXRDb2xvckluZGV4KCB2ZXJ0ZXhDb2xvcnNbIDEgXSApLFxuICAgIFx0XHRcdFx0XHRnZXRDb2xvckluZGV4KCB2ZXJ0ZXhDb2xvcnNbIDIgXSApXG4gICAgXHRcdFx0XHQpO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHRmdW5jdGlvbiBzZXRCaXQoIHZhbHVlLCBwb3NpdGlvbiwgZW5hYmxlZCApIHtcblxuICAgIFx0XHRcdHJldHVybiBlbmFibGVkID8gdmFsdWUgfCAoIDEgPDwgcG9zaXRpb24gKSA6IHZhbHVlICYgKCB+ICggMSA8PCBwb3NpdGlvbiApICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGZ1bmN0aW9uIGdldE5vcm1hbEluZGV4KCBub3JtYWwgKSB7XG5cbiAgICBcdFx0XHR2YXIgaGFzaCA9IG5vcm1hbC54LnRvU3RyaW5nKCkgKyBub3JtYWwueS50b1N0cmluZygpICsgbm9ybWFsLnoudG9TdHJpbmcoKTtcblxuICAgIFx0XHRcdGlmICggbm9ybWFsc0hhc2hbIGhhc2ggXSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0XHRyZXR1cm4gbm9ybWFsc0hhc2hbIGhhc2ggXTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdG5vcm1hbHNIYXNoWyBoYXNoIF0gPSBub3JtYWxzLmxlbmd0aCAvIDM7XG4gICAgXHRcdFx0bm9ybWFscy5wdXNoKCBub3JtYWwueCwgbm9ybWFsLnksIG5vcm1hbC56ICk7XG5cbiAgICBcdFx0XHRyZXR1cm4gbm9ybWFsc0hhc2hbIGhhc2ggXTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0ZnVuY3Rpb24gZ2V0Q29sb3JJbmRleCggY29sb3IgKSB7XG5cbiAgICBcdFx0XHR2YXIgaGFzaCA9IGNvbG9yLnIudG9TdHJpbmcoKSArIGNvbG9yLmcudG9TdHJpbmcoKSArIGNvbG9yLmIudG9TdHJpbmcoKTtcblxuICAgIFx0XHRcdGlmICggY29sb3JzSGFzaFsgaGFzaCBdICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRcdHJldHVybiBjb2xvcnNIYXNoWyBoYXNoIF07XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRjb2xvcnNIYXNoWyBoYXNoIF0gPSBjb2xvcnMubGVuZ3RoO1xuICAgIFx0XHRcdGNvbG9ycy5wdXNoKCBjb2xvci5nZXRIZXgoKSApO1xuXG4gICAgXHRcdFx0cmV0dXJuIGNvbG9yc0hhc2hbIGhhc2ggXTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0ZnVuY3Rpb24gZ2V0VXZJbmRleCggdXYgKSB7XG5cbiAgICBcdFx0XHR2YXIgaGFzaCA9IHV2LngudG9TdHJpbmcoKSArIHV2LnkudG9TdHJpbmcoKTtcblxuICAgIFx0XHRcdGlmICggdXZzSGFzaFsgaGFzaCBdICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRcdHJldHVybiB1dnNIYXNoWyBoYXNoIF07XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHR1dnNIYXNoWyBoYXNoIF0gPSB1dnMubGVuZ3RoIC8gMjtcbiAgICBcdFx0XHR1dnMucHVzaCggdXYueCwgdXYueSApO1xuXG4gICAgXHRcdFx0cmV0dXJuIHV2c0hhc2hbIGhhc2ggXTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0ZGF0YS5kYXRhID0ge307XG5cbiAgICBcdFx0ZGF0YS5kYXRhLnZlcnRpY2VzID0gdmVydGljZXM7XG4gICAgXHRcdGRhdGEuZGF0YS5ub3JtYWxzID0gbm9ybWFscztcbiAgICBcdFx0aWYgKCBjb2xvcnMubGVuZ3RoID4gMCApIGRhdGEuZGF0YS5jb2xvcnMgPSBjb2xvcnM7XG4gICAgXHRcdGlmICggdXZzLmxlbmd0aCA+IDAgKSBkYXRhLmRhdGEudXZzID0gWyB1dnMgXTsgLy8gdGVtcG9yYWwgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICAgIFx0XHRkYXRhLmRhdGEuZmFjZXMgPSBmYWNlcztcblxuICAgIFx0XHRyZXR1cm4gZGF0YTtcblxuICAgIFx0fSxcblxuICAgIFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHQvKlxuICAgIFx0XHQvLyBIYW5kbGUgcHJpbWl0aXZlc1xuXG4gICAgXHRcdHZhciBwYXJhbWV0ZXJzID0gdGhpcy5wYXJhbWV0ZXJzO1xuXG4gICAgXHRcdGlmICggcGFyYW1ldGVycyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0dmFyIHZhbHVlcyA9IFtdO1xuXG4gICAgXHRcdFx0Zm9yICggdmFyIGtleSBpbiBwYXJhbWV0ZXJzICkge1xuXG4gICAgXHRcdFx0XHR2YWx1ZXMucHVzaCggcGFyYW1ldGVyc1sga2V5IF0gKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdHZhciBnZW9tZXRyeSA9IE9iamVjdC5jcmVhdGUoIHRoaXMuY29uc3RydWN0b3IucHJvdG90eXBlICk7XG4gICAgXHRcdFx0dGhpcy5jb25zdHJ1Y3Rvci5hcHBseSggZ2VvbWV0cnksIHZhbHVlcyApO1xuICAgIFx0XHRcdHJldHVybiBnZW9tZXRyeTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xuICAgIFx0XHQqL1xuXG4gICAgXHRcdHJldHVybiBuZXcgR2VvbWV0cnkoKS5jb3B5KCB0aGlzICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xuXG4gICAgXHRcdHRoaXMudmVydGljZXMgPSBbXTtcbiAgICBcdFx0dGhpcy5mYWNlcyA9IFtdO1xuICAgIFx0XHR0aGlzLmZhY2VWZXJ0ZXhVdnMgPSBbIFtdIF07XG4gICAgXHRcdHRoaXMuY29sb3JzID0gW107XG5cbiAgICBcdFx0dmFyIHZlcnRpY2VzID0gc291cmNlLnZlcnRpY2VzO1xuXG4gICAgXHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSB2ZXJ0aWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuICAgIFx0XHRcdHRoaXMudmVydGljZXMucHVzaCggdmVydGljZXNbIGkgXS5jbG9uZSgpICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHZhciBjb2xvcnMgPSBzb3VyY2UuY29sb3JzO1xuXG4gICAgXHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBjb2xvcnMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICBcdFx0XHR0aGlzLmNvbG9ycy5wdXNoKCBjb2xvcnNbIGkgXS5jbG9uZSgpICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHZhciBmYWNlcyA9IHNvdXJjZS5mYWNlcztcblxuICAgIFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gZmFjZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICBcdFx0XHR0aGlzLmZhY2VzLnB1c2goIGZhY2VzWyBpIF0uY2xvbmUoKSApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gc291cmNlLmZhY2VWZXJ0ZXhVdnMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICBcdFx0XHR2YXIgZmFjZVZlcnRleFV2cyA9IHNvdXJjZS5mYWNlVmVydGV4VXZzWyBpIF07XG5cbiAgICBcdFx0XHRpZiAoIHRoaXMuZmFjZVZlcnRleFV2c1sgaSBdID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRcdHRoaXMuZmFjZVZlcnRleFV2c1sgaSBdID0gW107XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gZmFjZVZlcnRleFV2cy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuICAgIFx0XHRcdFx0dmFyIHV2cyA9IGZhY2VWZXJ0ZXhVdnNbIGogXSwgdXZzQ29weSA9IFtdO1xuXG4gICAgXHRcdFx0XHRmb3IgKCB2YXIgayA9IDAsIGtsID0gdXZzLmxlbmd0aDsgayA8IGtsOyBrICsrICkge1xuXG4gICAgXHRcdFx0XHRcdHZhciB1diA9IHV2c1sgayBdO1xuXG4gICAgXHRcdFx0XHRcdHV2c0NvcHkucHVzaCggdXYuY2xvbmUoKSApO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdHRoaXMuZmFjZVZlcnRleFV2c1sgaSBdLnB1c2goIHV2c0NvcHkgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2Rpc3Bvc2UnIH0gKTtcblxuICAgIFx0fVxuXG4gICAgfSApO1xuXG4gICAgdmFyIGNvdW50JDMgPSAwO1xuICAgIGZ1bmN0aW9uIEdlb21ldHJ5SWRDb3VudCgpIHsgcmV0dXJuIGNvdW50JDMrKzsgfTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBEaXJlY3RHZW9tZXRyeSgpIHtcblxuICAgIFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCAnaWQnLCB7IHZhbHVlOiBHZW9tZXRyeUlkQ291bnQoKSB9ICk7XG5cbiAgICBcdHRoaXMudXVpZCA9IGV4cG9ydHMuTWF0aC5nZW5lcmF0ZVVVSUQoKTtcblxuICAgIFx0dGhpcy5uYW1lID0gJyc7XG4gICAgXHR0aGlzLnR5cGUgPSAnRGlyZWN0R2VvbWV0cnknO1xuXG4gICAgXHR0aGlzLmluZGljZXMgPSBbXTtcbiAgICBcdHRoaXMudmVydGljZXMgPSBbXTtcbiAgICBcdHRoaXMubm9ybWFscyA9IFtdO1xuICAgIFx0dGhpcy5jb2xvcnMgPSBbXTtcbiAgICBcdHRoaXMudXZzID0gW107XG4gICAgXHR0aGlzLnV2czIgPSBbXTtcblxuICAgIFx0dGhpcy5ncm91cHMgPSBbXTtcblxuICAgIFx0dGhpcy5tb3JwaFRhcmdldHMgPSB7fTtcblxuICAgIFx0dGhpcy5za2luV2VpZ2h0cyA9IFtdO1xuICAgIFx0dGhpcy5za2luSW5kaWNlcyA9IFtdO1xuXG4gICAgXHQvLyB0aGlzLmxpbmVEaXN0YW5jZXMgPSBbXTtcblxuICAgIFx0dGhpcy5ib3VuZGluZ0JveCA9IG51bGw7XG4gICAgXHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gbnVsbDtcblxuICAgIFx0Ly8gdXBkYXRlIGZsYWdzXG5cbiAgICBcdHRoaXMudmVydGljZXNOZWVkVXBkYXRlID0gZmFsc2U7XG4gICAgXHR0aGlzLm5vcm1hbHNOZWVkVXBkYXRlID0gZmFsc2U7XG4gICAgXHR0aGlzLmNvbG9yc05lZWRVcGRhdGUgPSBmYWxzZTtcbiAgICBcdHRoaXMudXZzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuICAgIFx0dGhpcy5ncm91cHNOZWVkVXBkYXRlID0gZmFsc2U7XG5cbiAgICB9XG5cbiAgICBPYmplY3QuYXNzaWduKCBEaXJlY3RHZW9tZXRyeS5wcm90b3R5cGUsIEV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUsIHtcblxuICAgIFx0Y29tcHV0ZUJvdW5kaW5nQm94OiBHZW9tZXRyeS5wcm90b3R5cGUuY29tcHV0ZUJvdW5kaW5nQm94LFxuICAgIFx0Y29tcHV0ZUJvdW5kaW5nU3BoZXJlOiBHZW9tZXRyeS5wcm90b3R5cGUuY29tcHV0ZUJvdW5kaW5nU3BoZXJlLFxuXG4gICAgXHRjb21wdXRlRmFjZU5vcm1hbHM6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5EaXJlY3RHZW9tZXRyeTogY29tcHV0ZUZhY2VOb3JtYWxzKCkgaXMgbm90IGEgbWV0aG9kIG9mIHRoaXMgdHlwZSBvZiBnZW9tZXRyeS4nICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGNvbXB1dGVWZXJ0ZXhOb3JtYWxzOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuRGlyZWN0R2VvbWV0cnk6IGNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCkgaXMgbm90IGEgbWV0aG9kIG9mIHRoaXMgdHlwZSBvZiBnZW9tZXRyeS4nICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGNvbXB1dGVHcm91cHM6IGZ1bmN0aW9uICggZ2VvbWV0cnkgKSB7XG5cbiAgICBcdFx0dmFyIGdyb3VwO1xuICAgIFx0XHR2YXIgZ3JvdXBzID0gW107XG4gICAgXHRcdHZhciBtYXRlcmlhbEluZGV4O1xuXG4gICAgXHRcdHZhciBmYWNlcyA9IGdlb21ldHJ5LmZhY2VzO1xuXG4gICAgXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGZhY2VzLmxlbmd0aDsgaSArKyApIHtcblxuICAgIFx0XHRcdHZhciBmYWNlID0gZmFjZXNbIGkgXTtcblxuICAgIFx0XHRcdC8vIG1hdGVyaWFsc1xuXG4gICAgXHRcdFx0aWYgKCBmYWNlLm1hdGVyaWFsSW5kZXggIT09IG1hdGVyaWFsSW5kZXggKSB7XG5cbiAgICBcdFx0XHRcdG1hdGVyaWFsSW5kZXggPSBmYWNlLm1hdGVyaWFsSW5kZXg7XG5cbiAgICBcdFx0XHRcdGlmICggZ3JvdXAgIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0XHRncm91cC5jb3VudCA9ICggaSAqIDMgKSAtIGdyb3VwLnN0YXJ0O1xuICAgIFx0XHRcdFx0XHRncm91cHMucHVzaCggZ3JvdXAgKTtcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHRncm91cCA9IHtcbiAgICBcdFx0XHRcdFx0c3RhcnQ6IGkgKiAzLFxuICAgIFx0XHRcdFx0XHRtYXRlcmlhbEluZGV4OiBtYXRlcmlhbEluZGV4XG4gICAgXHRcdFx0XHR9O1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHRpZiAoIGdyb3VwICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRncm91cC5jb3VudCA9ICggaSAqIDMgKSAtIGdyb3VwLnN0YXJ0O1xuICAgIFx0XHRcdGdyb3Vwcy5wdXNoKCBncm91cCApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHR0aGlzLmdyb3VwcyA9IGdyb3VwcztcblxuICAgIFx0fSxcblxuICAgIFx0ZnJvbUdlb21ldHJ5OiBmdW5jdGlvbiAoIGdlb21ldHJ5ICkge1xuXG4gICAgXHRcdHZhciBmYWNlcyA9IGdlb21ldHJ5LmZhY2VzO1xuICAgIFx0XHR2YXIgdmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlcztcbiAgICBcdFx0dmFyIGZhY2VWZXJ0ZXhVdnMgPSBnZW9tZXRyeS5mYWNlVmVydGV4VXZzO1xuXG4gICAgXHRcdHZhciBoYXNGYWNlVmVydGV4VXYgPSBmYWNlVmVydGV4VXZzWyAwIF0gJiYgZmFjZVZlcnRleFV2c1sgMCBdLmxlbmd0aCA+IDA7XG4gICAgXHRcdHZhciBoYXNGYWNlVmVydGV4VXYyID0gZmFjZVZlcnRleFV2c1sgMSBdICYmIGZhY2VWZXJ0ZXhVdnNbIDEgXS5sZW5ndGggPiAwO1xuXG4gICAgXHRcdC8vIG1vcnBoc1xuXG4gICAgXHRcdHZhciBtb3JwaFRhcmdldHMgPSBnZW9tZXRyeS5tb3JwaFRhcmdldHM7XG4gICAgXHRcdHZhciBtb3JwaFRhcmdldHNMZW5ndGggPSBtb3JwaFRhcmdldHMubGVuZ3RoO1xuXG4gICAgXHRcdHZhciBtb3JwaFRhcmdldHNQb3NpdGlvbjtcblxuICAgIFx0XHRpZiAoIG1vcnBoVGFyZ2V0c0xlbmd0aCA+IDAgKSB7XG5cbiAgICBcdFx0XHRtb3JwaFRhcmdldHNQb3NpdGlvbiA9IFtdO1xuXG4gICAgXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbW9ycGhUYXJnZXRzTGVuZ3RoOyBpICsrICkge1xuXG4gICAgXHRcdFx0XHRtb3JwaFRhcmdldHNQb3NpdGlvblsgaSBdID0gW107XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHR0aGlzLm1vcnBoVGFyZ2V0cy5wb3NpdGlvbiA9IG1vcnBoVGFyZ2V0c1Bvc2l0aW9uO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHR2YXIgbW9ycGhOb3JtYWxzID0gZ2VvbWV0cnkubW9ycGhOb3JtYWxzO1xuICAgIFx0XHR2YXIgbW9ycGhOb3JtYWxzTGVuZ3RoID0gbW9ycGhOb3JtYWxzLmxlbmd0aDtcblxuICAgIFx0XHR2YXIgbW9ycGhUYXJnZXRzTm9ybWFsO1xuXG4gICAgXHRcdGlmICggbW9ycGhOb3JtYWxzTGVuZ3RoID4gMCApIHtcblxuICAgIFx0XHRcdG1vcnBoVGFyZ2V0c05vcm1hbCA9IFtdO1xuXG4gICAgXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbW9ycGhOb3JtYWxzTGVuZ3RoOyBpICsrICkge1xuXG4gICAgXHRcdFx0XHRtb3JwaFRhcmdldHNOb3JtYWxbIGkgXSA9IFtdO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0dGhpcy5tb3JwaFRhcmdldHMubm9ybWFsID0gbW9ycGhUYXJnZXRzTm9ybWFsO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHQvLyBza2luc1xuXG4gICAgXHRcdHZhciBza2luSW5kaWNlcyA9IGdlb21ldHJ5LnNraW5JbmRpY2VzO1xuICAgIFx0XHR2YXIgc2tpbldlaWdodHMgPSBnZW9tZXRyeS5za2luV2VpZ2h0cztcblxuICAgIFx0XHR2YXIgaGFzU2tpbkluZGljZXMgPSBza2luSW5kaWNlcy5sZW5ndGggPT09IHZlcnRpY2VzLmxlbmd0aDtcbiAgICBcdFx0dmFyIGhhc1NraW5XZWlnaHRzID0gc2tpbldlaWdodHMubGVuZ3RoID09PSB2ZXJ0aWNlcy5sZW5ndGg7XG5cbiAgICBcdFx0Ly9cblxuICAgIFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBmYWNlcy5sZW5ndGg7IGkgKysgKSB7XG5cbiAgICBcdFx0XHR2YXIgZmFjZSA9IGZhY2VzWyBpIF07XG5cbiAgICBcdFx0XHR0aGlzLnZlcnRpY2VzLnB1c2goIHZlcnRpY2VzWyBmYWNlLmEgXSwgdmVydGljZXNbIGZhY2UuYiBdLCB2ZXJ0aWNlc1sgZmFjZS5jIF0gKTtcblxuICAgIFx0XHRcdHZhciB2ZXJ0ZXhOb3JtYWxzID0gZmFjZS52ZXJ0ZXhOb3JtYWxzO1xuXG4gICAgXHRcdFx0aWYgKCB2ZXJ0ZXhOb3JtYWxzLmxlbmd0aCA9PT0gMyApIHtcblxuICAgIFx0XHRcdFx0dGhpcy5ub3JtYWxzLnB1c2goIHZlcnRleE5vcm1hbHNbIDAgXSwgdmVydGV4Tm9ybWFsc1sgMSBdLCB2ZXJ0ZXhOb3JtYWxzWyAyIF0gKTtcblxuICAgIFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdHZhciBub3JtYWwgPSBmYWNlLm5vcm1hbDtcblxuICAgIFx0XHRcdFx0dGhpcy5ub3JtYWxzLnB1c2goIG5vcm1hbCwgbm9ybWFsLCBub3JtYWwgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdHZhciB2ZXJ0ZXhDb2xvcnMgPSBmYWNlLnZlcnRleENvbG9ycztcblxuICAgIFx0XHRcdGlmICggdmVydGV4Q29sb3JzLmxlbmd0aCA9PT0gMyApIHtcblxuICAgIFx0XHRcdFx0dGhpcy5jb2xvcnMucHVzaCggdmVydGV4Q29sb3JzWyAwIF0sIHZlcnRleENvbG9yc1sgMSBdLCB2ZXJ0ZXhDb2xvcnNbIDIgXSApO1xuXG4gICAgXHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0dmFyIGNvbG9yID0gZmFjZS5jb2xvcjtcblxuICAgIFx0XHRcdFx0dGhpcy5jb2xvcnMucHVzaCggY29sb3IsIGNvbG9yLCBjb2xvciApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0aWYgKCBoYXNGYWNlVmVydGV4VXYgPT09IHRydWUgKSB7XG5cbiAgICBcdFx0XHRcdHZhciB2ZXJ0ZXhVdnMgPSBmYWNlVmVydGV4VXZzWyAwIF1bIGkgXTtcblxuICAgIFx0XHRcdFx0aWYgKCB2ZXJ0ZXhVdnMgIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0XHR0aGlzLnV2cy5wdXNoKCB2ZXJ0ZXhVdnNbIDAgXSwgdmVydGV4VXZzWyAxIF0sIHZlcnRleFV2c1sgMiBdICk7XG5cbiAgICBcdFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuRGlyZWN0R2VvbWV0cnkuZnJvbUdlb21ldHJ5KCk6IFVuZGVmaW5lZCB2ZXJ0ZXhVdiAnLCBpICk7XG5cbiAgICBcdFx0XHRcdFx0dGhpcy51dnMucHVzaCggbmV3IFZlY3RvcjIoKSwgbmV3IFZlY3RvcjIoKSwgbmV3IFZlY3RvcjIoKSApO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRpZiAoIGhhc0ZhY2VWZXJ0ZXhVdjIgPT09IHRydWUgKSB7XG5cbiAgICBcdFx0XHRcdHZhciB2ZXJ0ZXhVdnMgPSBmYWNlVmVydGV4VXZzWyAxIF1bIGkgXTtcblxuICAgIFx0XHRcdFx0aWYgKCB2ZXJ0ZXhVdnMgIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0XHR0aGlzLnV2czIucHVzaCggdmVydGV4VXZzWyAwIF0sIHZlcnRleFV2c1sgMSBdLCB2ZXJ0ZXhVdnNbIDIgXSApO1xuXG4gICAgXHRcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkRpcmVjdEdlb21ldHJ5LmZyb21HZW9tZXRyeSgpOiBVbmRlZmluZWQgdmVydGV4VXYyICcsIGkgKTtcblxuICAgIFx0XHRcdFx0XHR0aGlzLnV2czIucHVzaCggbmV3IFZlY3RvcjIoKSwgbmV3IFZlY3RvcjIoKSwgbmV3IFZlY3RvcjIoKSApO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHQvLyBtb3JwaHNcblxuICAgIFx0XHRcdGZvciAoIHZhciBqID0gMDsgaiA8IG1vcnBoVGFyZ2V0c0xlbmd0aDsgaiArKyApIHtcblxuICAgIFx0XHRcdFx0dmFyIG1vcnBoVGFyZ2V0ID0gbW9ycGhUYXJnZXRzWyBqIF0udmVydGljZXM7XG5cbiAgICBcdFx0XHRcdG1vcnBoVGFyZ2V0c1Bvc2l0aW9uWyBqIF0ucHVzaCggbW9ycGhUYXJnZXRbIGZhY2UuYSBdLCBtb3JwaFRhcmdldFsgZmFjZS5iIF0sIG1vcnBoVGFyZ2V0WyBmYWNlLmMgXSApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0Zm9yICggdmFyIGogPSAwOyBqIDwgbW9ycGhOb3JtYWxzTGVuZ3RoOyBqICsrICkge1xuXG4gICAgXHRcdFx0XHR2YXIgbW9ycGhOb3JtYWwgPSBtb3JwaE5vcm1hbHNbIGogXS52ZXJ0ZXhOb3JtYWxzWyBpIF07XG5cbiAgICBcdFx0XHRcdG1vcnBoVGFyZ2V0c05vcm1hbFsgaiBdLnB1c2goIG1vcnBoTm9ybWFsLmEsIG1vcnBoTm9ybWFsLmIsIG1vcnBoTm9ybWFsLmMgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdC8vIHNraW5zXG5cbiAgICBcdFx0XHRpZiAoIGhhc1NraW5JbmRpY2VzICkge1xuXG4gICAgXHRcdFx0XHR0aGlzLnNraW5JbmRpY2VzLnB1c2goIHNraW5JbmRpY2VzWyBmYWNlLmEgXSwgc2tpbkluZGljZXNbIGZhY2UuYiBdLCBza2luSW5kaWNlc1sgZmFjZS5jIF0gKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdGlmICggaGFzU2tpbldlaWdodHMgKSB7XG5cbiAgICBcdFx0XHRcdHRoaXMuc2tpbldlaWdodHMucHVzaCggc2tpbldlaWdodHNbIGZhY2UuYSBdLCBza2luV2VpZ2h0c1sgZmFjZS5iIF0sIHNraW5XZWlnaHRzWyBmYWNlLmMgXSApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHR0aGlzLmNvbXB1dGVHcm91cHMoIGdlb21ldHJ5ICk7XG5cbiAgICBcdFx0dGhpcy52ZXJ0aWNlc05lZWRVcGRhdGUgPSBnZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGU7XG4gICAgXHRcdHRoaXMubm9ybWFsc05lZWRVcGRhdGUgPSBnZW9tZXRyeS5ub3JtYWxzTmVlZFVwZGF0ZTtcbiAgICBcdFx0dGhpcy5jb2xvcnNOZWVkVXBkYXRlID0gZ2VvbWV0cnkuY29sb3JzTmVlZFVwZGF0ZTtcbiAgICBcdFx0dGhpcy51dnNOZWVkVXBkYXRlID0gZ2VvbWV0cnkudXZzTmVlZFVwZGF0ZTtcbiAgICBcdFx0dGhpcy5ncm91cHNOZWVkVXBkYXRlID0gZ2VvbWV0cnkuZ3JvdXBzTmVlZFVwZGF0ZTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0ZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHRoaXMuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAnZGlzcG9zZScgfSApO1xuXG4gICAgXHR9XG5cbiAgICB9ICk7XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICAgICAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBCdWZmZXJHZW9tZXRyeSgpIHtcblxuICAgIFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCAnaWQnLCB7IHZhbHVlOiBHZW9tZXRyeUlkQ291bnQoKSB9ICk7XG5cbiAgICBcdHRoaXMudXVpZCA9IGV4cG9ydHMuTWF0aC5nZW5lcmF0ZVVVSUQoKTtcblxuICAgIFx0dGhpcy5uYW1lID0gJyc7XG4gICAgXHR0aGlzLnR5cGUgPSAnQnVmZmVyR2VvbWV0cnknO1xuXG4gICAgXHR0aGlzLmluZGV4ID0gbnVsbDtcbiAgICBcdHRoaXMuYXR0cmlidXRlcyA9IHt9O1xuXG4gICAgXHR0aGlzLm1vcnBoQXR0cmlidXRlcyA9IHt9O1xuXG4gICAgXHR0aGlzLmdyb3VwcyA9IFtdO1xuXG4gICAgXHR0aGlzLmJvdW5kaW5nQm94ID0gbnVsbDtcbiAgICBcdHRoaXMuYm91bmRpbmdTcGhlcmUgPSBudWxsO1xuXG4gICAgXHR0aGlzLmRyYXdSYW5nZSA9IHsgc3RhcnQ6IDAsIGNvdW50OiBJbmZpbml0eSB9O1xuXG4gICAgfVxuXG4gICAgT2JqZWN0LmFzc2lnbiggQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLCBFdmVudERpc3BhdGNoZXIucHJvdG90eXBlLCB7XG5cbiAgICBcdGlzQnVmZmVyR2VvbWV0cnk6IHRydWUsXG5cbiAgICBcdGdldEluZGV4OiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMuaW5kZXg7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldEluZGV4OiBmdW5jdGlvbiAoIGluZGV4ICkge1xuXG4gICAgXHRcdHRoaXMuaW5kZXggPSBpbmRleDtcblxuICAgIFx0fSxcblxuICAgIFx0YWRkQXR0cmlidXRlOiBmdW5jdGlvbiAoIG5hbWUsIGF0dHJpYnV0ZSApIHtcblxuICAgIFx0XHRpZiAoIChhdHRyaWJ1dGUgJiYgYXR0cmlidXRlLmlzQnVmZmVyQXR0cmlidXRlKSA9PT0gZmFsc2UgJiYgKGF0dHJpYnV0ZSAmJiBhdHRyaWJ1dGUuaXNJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSkgPT09IGZhbHNlICkge1xuXG4gICAgXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnk6IC5hZGRBdHRyaWJ1dGUoKSBub3cgZXhwZWN0cyAoIG5hbWUsIGF0dHJpYnV0ZSApLicgKTtcblxuICAgIFx0XHRcdHRoaXMuYWRkQXR0cmlidXRlKCBuYW1lLCBuZXcgQnVmZmVyQXR0cmlidXRlKCBhcmd1bWVudHNbIDEgXSwgYXJndW1lbnRzWyAyIF0gKSApO1xuXG4gICAgXHRcdFx0cmV0dXJuO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRpZiAoIG5hbWUgPT09ICdpbmRleCcgKSB7XG5cbiAgICBcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJHZW9tZXRyeS5hZGRBdHRyaWJ1dGU6IFVzZSAuc2V0SW5kZXgoKSBmb3IgaW5kZXggYXR0cmlidXRlLicgKTtcbiAgICBcdFx0XHR0aGlzLnNldEluZGV4KCBhdHRyaWJ1dGUgKTtcblxuICAgIFx0XHRcdHJldHVybjtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0dGhpcy5hdHRyaWJ1dGVzWyBuYW1lIF0gPSBhdHRyaWJ1dGU7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGdldEF0dHJpYnV0ZTogZnVuY3Rpb24gKCBuYW1lICkge1xuXG4gICAgXHRcdHJldHVybiB0aGlzLmF0dHJpYnV0ZXNbIG5hbWUgXTtcblxuICAgIFx0fSxcblxuICAgIFx0cmVtb3ZlQXR0cmlidXRlOiBmdW5jdGlvbiAoIG5hbWUgKSB7XG5cbiAgICBcdFx0ZGVsZXRlIHRoaXMuYXR0cmlidXRlc1sgbmFtZSBdO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRhZGRHcm91cDogZnVuY3Rpb24gKCBzdGFydCwgY291bnQsIG1hdGVyaWFsSW5kZXggKSB7XG5cbiAgICBcdFx0dGhpcy5ncm91cHMucHVzaCgge1xuXG4gICAgXHRcdFx0c3RhcnQ6IHN0YXJ0LFxuICAgIFx0XHRcdGNvdW50OiBjb3VudCxcbiAgICBcdFx0XHRtYXRlcmlhbEluZGV4OiBtYXRlcmlhbEluZGV4ICE9PSB1bmRlZmluZWQgPyBtYXRlcmlhbEluZGV4IDogMFxuXG4gICAgXHRcdH0gKTtcblxuICAgIFx0fSxcblxuICAgIFx0Y2xlYXJHcm91cHM6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR0aGlzLmdyb3VwcyA9IFtdO1xuXG4gICAgXHR9LFxuXG4gICAgXHRzZXREcmF3UmFuZ2U6IGZ1bmN0aW9uICggc3RhcnQsIGNvdW50ICkge1xuXG4gICAgXHRcdHRoaXMuZHJhd1JhbmdlLnN0YXJ0ID0gc3RhcnQ7XG4gICAgXHRcdHRoaXMuZHJhd1JhbmdlLmNvdW50ID0gY291bnQ7XG5cbiAgICBcdH0sXG5cbiAgICBcdGFwcGx5TWF0cml4OiBmdW5jdGlvbiAoIG1hdHJpeCApIHtcblxuICAgIFx0XHR2YXIgcG9zaXRpb24gPSB0aGlzLmF0dHJpYnV0ZXMucG9zaXRpb247XG5cbiAgICBcdFx0aWYgKCBwb3NpdGlvbiAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0bWF0cml4LmFwcGx5VG9WZWN0b3IzQXJyYXkoIHBvc2l0aW9uLmFycmF5ICk7XG4gICAgXHRcdFx0cG9zaXRpb24ubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHR2YXIgbm9ybWFsID0gdGhpcy5hdHRyaWJ1dGVzLm5vcm1hbDtcblxuICAgIFx0XHRpZiAoIG5vcm1hbCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0dmFyIG5vcm1hbE1hdHJpeCA9IG5ldyBNYXRyaXgzKCkuZ2V0Tm9ybWFsTWF0cml4KCBtYXRyaXggKTtcblxuICAgIFx0XHRcdG5vcm1hbE1hdHJpeC5hcHBseVRvVmVjdG9yM0FycmF5KCBub3JtYWwuYXJyYXkgKTtcbiAgICBcdFx0XHRub3JtYWwubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRpZiAoIHRoaXMuYm91bmRpbmdCb3ggIT09IG51bGwgKSB7XG5cbiAgICBcdFx0XHR0aGlzLmNvbXB1dGVCb3VuZGluZ0JveCgpO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRpZiAoIHRoaXMuYm91bmRpbmdTcGhlcmUgIT09IG51bGwgKSB7XG5cbiAgICBcdFx0XHR0aGlzLmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0cm90YXRlWDogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdC8vIHJvdGF0ZSBnZW9tZXRyeSBhcm91bmQgd29ybGQgeC1heGlzXG5cbiAgICBcdFx0dmFyIG0xO1xuXG4gICAgXHRcdHJldHVybiBmdW5jdGlvbiByb3RhdGVYKCBhbmdsZSApIHtcblxuICAgIFx0XHRcdGlmICggbTEgPT09IHVuZGVmaW5lZCApIG0xID0gbmV3IE1hdHJpeDQoKTtcblxuICAgIFx0XHRcdG0xLm1ha2VSb3RhdGlvblgoIGFuZ2xlICk7XG5cbiAgICBcdFx0XHR0aGlzLmFwcGx5TWF0cml4KCBtMSApO1xuXG4gICAgXHRcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdFx0fTtcblxuICAgIFx0fSgpLFxuXG4gICAgXHRyb3RhdGVZOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0Ly8gcm90YXRlIGdlb21ldHJ5IGFyb3VuZCB3b3JsZCB5LWF4aXNcblxuICAgIFx0XHR2YXIgbTE7XG5cbiAgICBcdFx0cmV0dXJuIGZ1bmN0aW9uIHJvdGF0ZVkoIGFuZ2xlICkge1xuXG4gICAgXHRcdFx0aWYgKCBtMSA9PT0gdW5kZWZpbmVkICkgbTEgPSBuZXcgTWF0cml4NCgpO1xuXG4gICAgXHRcdFx0bTEubWFrZVJvdGF0aW9uWSggYW5nbGUgKTtcblxuICAgIFx0XHRcdHRoaXMuYXBwbHlNYXRyaXgoIG0xICk7XG5cbiAgICBcdFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0XHR9O1xuXG4gICAgXHR9KCksXG5cbiAgICBcdHJvdGF0ZVo6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHQvLyByb3RhdGUgZ2VvbWV0cnkgYXJvdW5kIHdvcmxkIHotYXhpc1xuXG4gICAgXHRcdHZhciBtMTtcblxuICAgIFx0XHRyZXR1cm4gZnVuY3Rpb24gcm90YXRlWiggYW5nbGUgKSB7XG5cbiAgICBcdFx0XHRpZiAoIG0xID09PSB1bmRlZmluZWQgKSBtMSA9IG5ldyBNYXRyaXg0KCk7XG5cbiAgICBcdFx0XHRtMS5tYWtlUm90YXRpb25aKCBhbmdsZSApO1xuXG4gICAgXHRcdFx0dGhpcy5hcHBseU1hdHJpeCggbTEgKTtcblxuICAgIFx0XHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHRcdH07XG5cbiAgICBcdH0oKSxcblxuICAgIFx0dHJhbnNsYXRlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0Ly8gdHJhbnNsYXRlIGdlb21ldHJ5XG5cbiAgICBcdFx0dmFyIG0xO1xuXG4gICAgXHRcdHJldHVybiBmdW5jdGlvbiB0cmFuc2xhdGUoIHgsIHksIHogKSB7XG5cbiAgICBcdFx0XHRpZiAoIG0xID09PSB1bmRlZmluZWQgKSBtMSA9IG5ldyBNYXRyaXg0KCk7XG5cbiAgICBcdFx0XHRtMS5tYWtlVHJhbnNsYXRpb24oIHgsIHksIHogKTtcblxuICAgIFx0XHRcdHRoaXMuYXBwbHlNYXRyaXgoIG0xICk7XG5cbiAgICBcdFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0XHR9O1xuXG4gICAgXHR9KCksXG5cbiAgICBcdHNjYWxlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0Ly8gc2NhbGUgZ2VvbWV0cnlcblxuICAgIFx0XHR2YXIgbTE7XG5cbiAgICBcdFx0cmV0dXJuIGZ1bmN0aW9uIHNjYWxlKCB4LCB5LCB6ICkge1xuXG4gICAgXHRcdFx0aWYgKCBtMSA9PT0gdW5kZWZpbmVkICkgbTEgPSBuZXcgTWF0cml4NCgpO1xuXG4gICAgXHRcdFx0bTEubWFrZVNjYWxlKCB4LCB5LCB6ICk7XG5cbiAgICBcdFx0XHR0aGlzLmFwcGx5TWF0cml4KCBtMSApO1xuXG4gICAgXHRcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdFx0fTtcblxuICAgIFx0fSgpLFxuXG4gICAgXHRsb29rQXQ6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR2YXIgb2JqO1xuXG4gICAgXHRcdHJldHVybiBmdW5jdGlvbiBsb29rQXQoIHZlY3RvciApIHtcblxuICAgIFx0XHRcdGlmICggb2JqID09PSB1bmRlZmluZWQgKSBvYmogPSBuZXcgT2JqZWN0M0QoKTtcblxuICAgIFx0XHRcdG9iai5sb29rQXQoIHZlY3RvciApO1xuXG4gICAgXHRcdFx0b2JqLnVwZGF0ZU1hdHJpeCgpO1xuXG4gICAgXHRcdFx0dGhpcy5hcHBseU1hdHJpeCggb2JqLm1hdHJpeCApO1xuXG4gICAgXHRcdH07XG5cbiAgICBcdH0oKSxcblxuICAgIFx0Y2VudGVyOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dGhpcy5jb21wdXRlQm91bmRpbmdCb3goKTtcblxuICAgIFx0XHR2YXIgb2Zmc2V0ID0gdGhpcy5ib3VuZGluZ0JveC5nZXRDZW50ZXIoKS5uZWdhdGUoKTtcblxuICAgIFx0XHR0aGlzLnRyYW5zbGF0ZSggb2Zmc2V0LngsIG9mZnNldC55LCBvZmZzZXQueiApO1xuXG4gICAgXHRcdHJldHVybiBvZmZzZXQ7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldEZyb21PYmplY3Q6IGZ1bmN0aW9uICggb2JqZWN0ICkge1xuXG4gICAgXHRcdC8vIGNvbnNvbGUubG9nKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnkuc2V0RnJvbU9iamVjdCgpLiBDb252ZXJ0aW5nJywgb2JqZWN0LCB0aGlzICk7XG5cbiAgICBcdFx0dmFyIGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5O1xuXG4gICAgXHRcdGlmICggKG9iamVjdCAmJiBvYmplY3QuaXNQb2ludHMpIHx8IChvYmplY3QgJiYgb2JqZWN0LmlzTGluZSkgKSB7XG5cbiAgICBcdFx0XHR2YXIgcG9zaXRpb25zID0gbmV3IEZsb2F0MzJBdHRyaWJ1dGUoIGdlb21ldHJ5LnZlcnRpY2VzLmxlbmd0aCAqIDMsIDMgKTtcbiAgICBcdFx0XHR2YXIgY29sb3JzID0gbmV3IEZsb2F0MzJBdHRyaWJ1dGUoIGdlb21ldHJ5LmNvbG9ycy5sZW5ndGggKiAzLCAzICk7XG5cbiAgICBcdFx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgcG9zaXRpb25zLmNvcHlWZWN0b3Izc0FycmF5KCBnZW9tZXRyeS52ZXJ0aWNlcyApICk7XG4gICAgXHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdjb2xvcicsIGNvbG9ycy5jb3B5Q29sb3JzQXJyYXkoIGdlb21ldHJ5LmNvbG9ycyApICk7XG5cbiAgICBcdFx0XHRpZiAoIGdlb21ldHJ5LmxpbmVEaXN0YW5jZXMgJiYgZ2VvbWV0cnkubGluZURpc3RhbmNlcy5sZW5ndGggPT09IGdlb21ldHJ5LnZlcnRpY2VzLmxlbmd0aCApIHtcblxuICAgIFx0XHRcdFx0dmFyIGxpbmVEaXN0YW5jZXMgPSBuZXcgRmxvYXQzMkF0dHJpYnV0ZSggZ2VvbWV0cnkubGluZURpc3RhbmNlcy5sZW5ndGgsIDEgKTtcblxuICAgIFx0XHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdsaW5lRGlzdGFuY2UnLCBsaW5lRGlzdGFuY2VzLmNvcHlBcnJheSggZ2VvbWV0cnkubGluZURpc3RhbmNlcyApICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlICE9PSBudWxsICkge1xuXG4gICAgXHRcdFx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUuY2xvbmUoKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdGlmICggZ2VvbWV0cnkuYm91bmRpbmdCb3ggIT09IG51bGwgKSB7XG5cbiAgICBcdFx0XHRcdHRoaXMuYm91bmRpbmdCb3ggPSBnZW9tZXRyeS5ib3VuZGluZ0JveC5jbG9uZSgpO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH0gZWxzZSBpZiAoIChvYmplY3QgJiYgb2JqZWN0LmlzTWVzaCkgKSB7XG5cbiAgICBcdFx0XHRpZiAoIChnZW9tZXRyeSAmJiBnZW9tZXRyeS5pc0dlb21ldHJ5KSApIHtcblxuICAgIFx0XHRcdFx0dGhpcy5mcm9tR2VvbWV0cnkoIGdlb21ldHJ5ICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHR1cGRhdGVGcm9tT2JqZWN0OiBmdW5jdGlvbiAoIG9iamVjdCApIHtcblxuICAgIFx0XHR2YXIgZ2VvbWV0cnkgPSBvYmplY3QuZ2VvbWV0cnk7XG5cbiAgICBcdFx0aWYgKCAob2JqZWN0ICYmIG9iamVjdC5pc01lc2gpICkge1xuXG4gICAgXHRcdFx0dmFyIGRpcmVjdCA9IGdlb21ldHJ5Ll9fZGlyZWN0R2VvbWV0cnk7XG5cbiAgICBcdFx0XHRpZiAoIGdlb21ldHJ5LmVsZW1lbnRzTmVlZFVwZGF0ZSA9PT0gdHJ1ZSApIHtcblxuICAgIFx0XHRcdFx0ZGlyZWN0ID0gdW5kZWZpbmVkO1xuICAgIFx0XHRcdFx0Z2VvbWV0cnkuZWxlbWVudHNOZWVkVXBkYXRlID0gZmFsc2U7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRpZiAoIGRpcmVjdCA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0XHRyZXR1cm4gdGhpcy5mcm9tR2VvbWV0cnkoIGdlb21ldHJ5ICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRkaXJlY3QudmVydGljZXNOZWVkVXBkYXRlID0gZ2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlO1xuICAgIFx0XHRcdGRpcmVjdC5ub3JtYWxzTmVlZFVwZGF0ZSA9IGdlb21ldHJ5Lm5vcm1hbHNOZWVkVXBkYXRlO1xuICAgIFx0XHRcdGRpcmVjdC5jb2xvcnNOZWVkVXBkYXRlID0gZ2VvbWV0cnkuY29sb3JzTmVlZFVwZGF0ZTtcbiAgICBcdFx0XHRkaXJlY3QudXZzTmVlZFVwZGF0ZSA9IGdlb21ldHJ5LnV2c05lZWRVcGRhdGU7XG4gICAgXHRcdFx0ZGlyZWN0Lmdyb3Vwc05lZWRVcGRhdGUgPSBnZW9tZXRyeS5ncm91cHNOZWVkVXBkYXRlO1xuXG4gICAgXHRcdFx0Z2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlID0gZmFsc2U7XG4gICAgXHRcdFx0Z2VvbWV0cnkubm9ybWFsc05lZWRVcGRhdGUgPSBmYWxzZTtcbiAgICBcdFx0XHRnZW9tZXRyeS5jb2xvcnNOZWVkVXBkYXRlID0gZmFsc2U7XG4gICAgXHRcdFx0Z2VvbWV0cnkudXZzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuICAgIFx0XHRcdGdlb21ldHJ5Lmdyb3Vwc05lZWRVcGRhdGUgPSBmYWxzZTtcblxuICAgIFx0XHRcdGdlb21ldHJ5ID0gZGlyZWN0O1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHR2YXIgYXR0cmlidXRlO1xuXG4gICAgXHRcdGlmICggZ2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlID09PSB0cnVlICkge1xuXG4gICAgXHRcdFx0YXR0cmlidXRlID0gdGhpcy5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXG4gICAgXHRcdFx0aWYgKCBhdHRyaWJ1dGUgIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0YXR0cmlidXRlLmNvcHlWZWN0b3Izc0FycmF5KCBnZW9tZXRyeS52ZXJ0aWNlcyApO1xuICAgIFx0XHRcdFx0YXR0cmlidXRlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdGdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRpZiAoIGdlb21ldHJ5Lm5vcm1hbHNOZWVkVXBkYXRlID09PSB0cnVlICkge1xuXG4gICAgXHRcdFx0YXR0cmlidXRlID0gdGhpcy5hdHRyaWJ1dGVzLm5vcm1hbDtcblxuICAgIFx0XHRcdGlmICggYXR0cmlidXRlICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRcdGF0dHJpYnV0ZS5jb3B5VmVjdG9yM3NBcnJheSggZ2VvbWV0cnkubm9ybWFscyApO1xuICAgIFx0XHRcdFx0YXR0cmlidXRlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdGdlb21ldHJ5Lm5vcm1hbHNOZWVkVXBkYXRlID0gZmFsc2U7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGlmICggZ2VvbWV0cnkuY29sb3JzTmVlZFVwZGF0ZSA9PT0gdHJ1ZSApIHtcblxuICAgIFx0XHRcdGF0dHJpYnV0ZSA9IHRoaXMuYXR0cmlidXRlcy5jb2xvcjtcblxuICAgIFx0XHRcdGlmICggYXR0cmlidXRlICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRcdGF0dHJpYnV0ZS5jb3B5Q29sb3JzQXJyYXkoIGdlb21ldHJ5LmNvbG9ycyApO1xuICAgIFx0XHRcdFx0YXR0cmlidXRlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdGdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGUgPSBmYWxzZTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0aWYgKCBnZW9tZXRyeS51dnNOZWVkVXBkYXRlICkge1xuXG4gICAgXHRcdFx0YXR0cmlidXRlID0gdGhpcy5hdHRyaWJ1dGVzLnV2O1xuXG4gICAgXHRcdFx0aWYgKCBhdHRyaWJ1dGUgIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0YXR0cmlidXRlLmNvcHlWZWN0b3Iyc0FycmF5KCBnZW9tZXRyeS51dnMgKTtcbiAgICBcdFx0XHRcdGF0dHJpYnV0ZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRnZW9tZXRyeS51dnNOZWVkVXBkYXRlID0gZmFsc2U7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGlmICggZ2VvbWV0cnkubGluZURpc3RhbmNlc05lZWRVcGRhdGUgKSB7XG5cbiAgICBcdFx0XHRhdHRyaWJ1dGUgPSB0aGlzLmF0dHJpYnV0ZXMubGluZURpc3RhbmNlO1xuXG4gICAgXHRcdFx0aWYgKCBhdHRyaWJ1dGUgIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0YXR0cmlidXRlLmNvcHlBcnJheSggZ2VvbWV0cnkubGluZURpc3RhbmNlcyApO1xuICAgIFx0XHRcdFx0YXR0cmlidXRlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdGdlb21ldHJ5LmxpbmVEaXN0YW5jZXNOZWVkVXBkYXRlID0gZmFsc2U7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGlmICggZ2VvbWV0cnkuZ3JvdXBzTmVlZFVwZGF0ZSApIHtcblxuICAgIFx0XHRcdGdlb21ldHJ5LmNvbXB1dGVHcm91cHMoIG9iamVjdC5nZW9tZXRyeSApO1xuICAgIFx0XHRcdHRoaXMuZ3JvdXBzID0gZ2VvbWV0cnkuZ3JvdXBzO1xuXG4gICAgXHRcdFx0Z2VvbWV0cnkuZ3JvdXBzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0ZnJvbUdlb21ldHJ5OiBmdW5jdGlvbiAoIGdlb21ldHJ5ICkge1xuXG4gICAgXHRcdGdlb21ldHJ5Ll9fZGlyZWN0R2VvbWV0cnkgPSBuZXcgRGlyZWN0R2VvbWV0cnkoKS5mcm9tR2VvbWV0cnkoIGdlb21ldHJ5ICk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMuZnJvbURpcmVjdEdlb21ldHJ5KCBnZW9tZXRyeS5fX2RpcmVjdEdlb21ldHJ5ICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGZyb21EaXJlY3RHZW9tZXRyeTogZnVuY3Rpb24gKCBnZW9tZXRyeSApIHtcblxuICAgIFx0XHR2YXIgcG9zaXRpb25zID0gbmV3IEZsb2F0MzJBcnJheSggZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoICogMyApO1xuICAgIFx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25zLCAzICkuY29weVZlY3RvcjNzQXJyYXkoIGdlb21ldHJ5LnZlcnRpY2VzICkgKTtcblxuICAgIFx0XHRpZiAoIGdlb21ldHJ5Lm5vcm1hbHMubGVuZ3RoID4gMCApIHtcblxuICAgIFx0XHRcdHZhciBub3JtYWxzID0gbmV3IEZsb2F0MzJBcnJheSggZ2VvbWV0cnkubm9ybWFscy5sZW5ndGggKiAzICk7XG4gICAgXHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgQnVmZmVyQXR0cmlidXRlKCBub3JtYWxzLCAzICkuY29weVZlY3RvcjNzQXJyYXkoIGdlb21ldHJ5Lm5vcm1hbHMgKSApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRpZiAoIGdlb21ldHJ5LmNvbG9ycy5sZW5ndGggPiAwICkge1xuXG4gICAgXHRcdFx0dmFyIGNvbG9ycyA9IG5ldyBGbG9hdDMyQXJyYXkoIGdlb21ldHJ5LmNvbG9ycy5sZW5ndGggKiAzICk7XG4gICAgXHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdjb2xvcicsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIGNvbG9ycywgMyApLmNvcHlDb2xvcnNBcnJheSggZ2VvbWV0cnkuY29sb3JzICkgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0aWYgKCBnZW9tZXRyeS51dnMubGVuZ3RoID4gMCApIHtcblxuICAgIFx0XHRcdHZhciB1dnMgPSBuZXcgRmxvYXQzMkFycmF5KCBnZW9tZXRyeS51dnMubGVuZ3RoICogMiApO1xuICAgIFx0XHRcdHRoaXMuYWRkQXR0cmlidXRlKCAndXYnLCBuZXcgQnVmZmVyQXR0cmlidXRlKCB1dnMsIDIgKS5jb3B5VmVjdG9yMnNBcnJheSggZ2VvbWV0cnkudXZzICkgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0aWYgKCBnZW9tZXRyeS51dnMyLmxlbmd0aCA+IDAgKSB7XG5cbiAgICBcdFx0XHR2YXIgdXZzMiA9IG5ldyBGbG9hdDMyQXJyYXkoIGdlb21ldHJ5LnV2czIubGVuZ3RoICogMiApO1xuICAgIFx0XHRcdHRoaXMuYWRkQXR0cmlidXRlKCAndXYyJywgbmV3IEJ1ZmZlckF0dHJpYnV0ZSggdXZzMiwgMiApLmNvcHlWZWN0b3Iyc0FycmF5KCBnZW9tZXRyeS51dnMyICkgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0aWYgKCBnZW9tZXRyeS5pbmRpY2VzLmxlbmd0aCA+IDAgKSB7XG5cbiAgICBcdFx0XHR2YXIgVHlwZUFycmF5ID0gZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoID4gNjU1MzUgPyBVaW50MzJBcnJheSA6IFVpbnQxNkFycmF5O1xuICAgIFx0XHRcdHZhciBpbmRpY2VzID0gbmV3IFR5cGVBcnJheSggZ2VvbWV0cnkuaW5kaWNlcy5sZW5ndGggKiAzICk7XG4gICAgXHRcdFx0dGhpcy5zZXRJbmRleCggbmV3IEJ1ZmZlckF0dHJpYnV0ZSggaW5kaWNlcywgMSApLmNvcHlJbmRpY2VzQXJyYXkoIGdlb21ldHJ5LmluZGljZXMgKSApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHQvLyBncm91cHNcblxuICAgIFx0XHR0aGlzLmdyb3VwcyA9IGdlb21ldHJ5Lmdyb3VwcztcblxuICAgIFx0XHQvLyBtb3JwaHNcblxuICAgIFx0XHRmb3IgKCB2YXIgbmFtZSBpbiBnZW9tZXRyeS5tb3JwaFRhcmdldHMgKSB7XG5cbiAgICBcdFx0XHR2YXIgYXJyYXkgPSBbXTtcbiAgICBcdFx0XHR2YXIgbW9ycGhUYXJnZXRzID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzWyBuYW1lIF07XG5cbiAgICBcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBtb3JwaFRhcmdldHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgIFx0XHRcdFx0dmFyIG1vcnBoVGFyZ2V0ID0gbW9ycGhUYXJnZXRzWyBpIF07XG5cbiAgICBcdFx0XHRcdHZhciBhdHRyaWJ1dGUgPSBuZXcgRmxvYXQzMkF0dHJpYnV0ZSggbW9ycGhUYXJnZXQubGVuZ3RoICogMywgMyApO1xuXG4gICAgXHRcdFx0XHRhcnJheS5wdXNoKCBhdHRyaWJ1dGUuY29weVZlY3RvcjNzQXJyYXkoIG1vcnBoVGFyZ2V0ICkgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdHRoaXMubW9ycGhBdHRyaWJ1dGVzWyBuYW1lIF0gPSBhcnJheTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0Ly8gc2tpbm5pbmdcblxuICAgIFx0XHRpZiAoIGdlb21ldHJ5LnNraW5JbmRpY2VzLmxlbmd0aCA+IDAgKSB7XG5cbiAgICBcdFx0XHR2YXIgc2tpbkluZGljZXMgPSBuZXcgRmxvYXQzMkF0dHJpYnV0ZSggZ2VvbWV0cnkuc2tpbkluZGljZXMubGVuZ3RoICogNCwgNCApO1xuICAgIFx0XHRcdHRoaXMuYWRkQXR0cmlidXRlKCAnc2tpbkluZGV4Jywgc2tpbkluZGljZXMuY29weVZlY3RvcjRzQXJyYXkoIGdlb21ldHJ5LnNraW5JbmRpY2VzICkgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0aWYgKCBnZW9tZXRyeS5za2luV2VpZ2h0cy5sZW5ndGggPiAwICkge1xuXG4gICAgXHRcdFx0dmFyIHNraW5XZWlnaHRzID0gbmV3IEZsb2F0MzJBdHRyaWJ1dGUoIGdlb21ldHJ5LnNraW5XZWlnaHRzLmxlbmd0aCAqIDQsIDQgKTtcbiAgICBcdFx0XHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3NraW5XZWlnaHQnLCBza2luV2VpZ2h0cy5jb3B5VmVjdG9yNHNBcnJheSggZ2VvbWV0cnkuc2tpbldlaWdodHMgKSApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHQvL1xuXG4gICAgXHRcdGlmICggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgIT09IG51bGwgKSB7XG5cbiAgICBcdFx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUuY2xvbmUoKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0aWYgKCBnZW9tZXRyeS5ib3VuZGluZ0JveCAhPT0gbnVsbCApIHtcblxuICAgIFx0XHRcdHRoaXMuYm91bmRpbmdCb3ggPSBnZW9tZXRyeS5ib3VuZGluZ0JveC5jbG9uZSgpO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0Y29tcHV0ZUJvdW5kaW5nQm94OiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0aWYgKCB0aGlzLmJvdW5kaW5nQm94ID09PSBudWxsICkge1xuXG4gICAgXHRcdFx0dGhpcy5ib3VuZGluZ0JveCA9IG5ldyBCb3gzKCk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHZhciBwb3NpdGlvbnMgPSB0aGlzLmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XG5cbiAgICBcdFx0aWYgKCBwb3NpdGlvbnMgIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdHRoaXMuYm91bmRpbmdCb3guc2V0RnJvbUFycmF5KCBwb3NpdGlvbnMgKTtcblxuICAgIFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0dGhpcy5ib3VuZGluZ0JveC5tYWtlRW1wdHkoKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0aWYgKCBpc05hTiggdGhpcy5ib3VuZGluZ0JveC5taW4ueCApIHx8IGlzTmFOKCB0aGlzLmJvdW5kaW5nQm94Lm1pbi55ICkgfHwgaXNOYU4oIHRoaXMuYm91bmRpbmdCb3gubWluLnogKSApIHtcblxuICAgIFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5CdWZmZXJHZW9tZXRyeS5jb21wdXRlQm91bmRpbmdCb3g6IENvbXB1dGVkIG1pbi9tYXggaGF2ZSBOYU4gdmFsdWVzLiBUaGUgXCJwb3NpdGlvblwiIGF0dHJpYnV0ZSBpcyBsaWtlbHkgdG8gaGF2ZSBOYU4gdmFsdWVzLicsIHRoaXMgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdH0sXG5cbiAgICBcdGNvbXB1dGVCb3VuZGluZ1NwaGVyZTogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHZhciBib3ggPSBuZXcgQm94MygpO1xuICAgIFx0XHR2YXIgdmVjdG9yID0gbmV3IFZlY3RvcjMoKTtcblxuICAgIFx0XHRyZXR1cm4gZnVuY3Rpb24gY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCkge1xuXG4gICAgXHRcdFx0aWYgKCB0aGlzLmJvdW5kaW5nU3BoZXJlID09PSBudWxsICkge1xuXG4gICAgXHRcdFx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gbmV3IFNwaGVyZSgpO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0dmFyIHBvc2l0aW9ucyA9IHRoaXMuYXR0cmlidXRlcy5wb3NpdGlvbjtcblxuICAgIFx0XHRcdGlmICggcG9zaXRpb25zICkge1xuXG4gICAgXHRcdFx0XHR2YXIgYXJyYXkgPSBwb3NpdGlvbnMuYXJyYXk7XG4gICAgXHRcdFx0XHR2YXIgY2VudGVyID0gdGhpcy5ib3VuZGluZ1NwaGVyZS5jZW50ZXI7XG5cbiAgICBcdFx0XHRcdGJveC5zZXRGcm9tQXJyYXkoIGFycmF5ICk7XG4gICAgXHRcdFx0XHRib3guZ2V0Q2VudGVyKCBjZW50ZXIgKTtcblxuICAgIFx0XHRcdFx0Ly8gaG9waW5nIHRvIGZpbmQgYSBib3VuZGluZ1NwaGVyZSB3aXRoIGEgcmFkaXVzIHNtYWxsZXIgdGhhbiB0aGVcbiAgICBcdFx0XHRcdC8vIGJvdW5kaW5nU3BoZXJlIG9mIHRoZSBib3VuZGluZ0JveDogc3FydCgzKSBzbWFsbGVyIGluIHRoZSBiZXN0IGNhc2VcblxuICAgIFx0XHRcdFx0dmFyIG1heFJhZGl1c1NxID0gMDtcblxuICAgIFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGlsOyBpICs9IDMgKSB7XG5cbiAgICBcdFx0XHRcdFx0dmVjdG9yLmZyb21BcnJheSggYXJyYXksIGkgKTtcbiAgICBcdFx0XHRcdFx0bWF4UmFkaXVzU3EgPSBNYXRoLm1heCggbWF4UmFkaXVzU3EsIGNlbnRlci5kaXN0YW5jZVRvU3F1YXJlZCggdmVjdG9yICkgKTtcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlLnJhZGl1cyA9IE1hdGguc3FydCggbWF4UmFkaXVzU3EgKTtcblxuICAgIFx0XHRcdFx0aWYgKCBpc05hTiggdGhpcy5ib3VuZGluZ1NwaGVyZS5yYWRpdXMgKSApIHtcblxuICAgIFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk6IENvbXB1dGVkIHJhZGl1cyBpcyBOYU4uIFRoZSBcInBvc2l0aW9uXCIgYXR0cmlidXRlIGlzIGxpa2VseSB0byBoYXZlIE5hTiB2YWx1ZXMuJywgdGhpcyApO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fTtcblxuICAgIFx0fSgpLFxuXG4gICAgXHRjb21wdXRlRmFjZU5vcm1hbHM6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHQvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuXG4gICAgXHR9LFxuXG4gICAgXHRjb21wdXRlVmVydGV4Tm9ybWFsczogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHZhciBpbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgXHRcdHZhciBhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzO1xuICAgIFx0XHR2YXIgZ3JvdXBzID0gdGhpcy5ncm91cHM7XG5cbiAgICBcdFx0aWYgKCBhdHRyaWJ1dGVzLnBvc2l0aW9uICkge1xuXG4gICAgXHRcdFx0dmFyIHBvc2l0aW9ucyA9IGF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XG5cbiAgICBcdFx0XHRpZiAoIGF0dHJpYnV0ZXMubm9ybWFsID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRcdHRoaXMuYWRkQXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IEJ1ZmZlckF0dHJpYnV0ZSggbmV3IEZsb2F0MzJBcnJheSggcG9zaXRpb25zLmxlbmd0aCApLCAzICkgKTtcblxuICAgIFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdC8vIHJlc2V0IGV4aXN0aW5nIG5vcm1hbHMgdG8gemVyb1xuXG4gICAgXHRcdFx0XHR2YXIgYXJyYXkgPSBhdHRyaWJ1dGVzLm5vcm1hbC5hcnJheTtcblxuICAgIFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgXHRcdFx0XHRcdGFycmF5WyBpIF0gPSAwO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHR2YXIgbm9ybWFscyA9IGF0dHJpYnV0ZXMubm9ybWFsLmFycmF5O1xuXG4gICAgXHRcdFx0dmFyIHZBLCB2QiwgdkMsXG5cbiAgICBcdFx0XHRwQSA9IG5ldyBWZWN0b3IzKCksXG4gICAgXHRcdFx0cEIgPSBuZXcgVmVjdG9yMygpLFxuICAgIFx0XHRcdHBDID0gbmV3IFZlY3RvcjMoKSxcblxuICAgIFx0XHRcdGNiID0gbmV3IFZlY3RvcjMoKSxcbiAgICBcdFx0XHRhYiA9IG5ldyBWZWN0b3IzKCk7XG5cbiAgICBcdFx0XHQvLyBpbmRleGVkIGVsZW1lbnRzXG5cbiAgICBcdFx0XHRpZiAoIGluZGV4ICkge1xuXG4gICAgXHRcdFx0XHR2YXIgaW5kaWNlcyA9IGluZGV4LmFycmF5O1xuXG4gICAgXHRcdFx0XHRpZiAoIGdyb3Vwcy5sZW5ndGggPT09IDAgKSB7XG5cbiAgICBcdFx0XHRcdFx0dGhpcy5hZGRHcm91cCggMCwgaW5kaWNlcy5sZW5ndGggKTtcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gZ3JvdXBzLmxlbmd0aDsgaiA8IGpsOyArKyBqICkge1xuXG4gICAgXHRcdFx0XHRcdHZhciBncm91cCA9IGdyb3Vwc1sgaiBdO1xuXG4gICAgXHRcdFx0XHRcdHZhciBzdGFydCA9IGdyb3VwLnN0YXJ0O1xuICAgIFx0XHRcdFx0XHR2YXIgY291bnQgPSBncm91cC5jb3VudDtcblxuICAgIFx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IHN0YXJ0LCBpbCA9IHN0YXJ0ICsgY291bnQ7IGkgPCBpbDsgaSArPSAzICkge1xuXG4gICAgXHRcdFx0XHRcdFx0dkEgPSBpbmRpY2VzWyBpICsgMCBdICogMztcbiAgICBcdFx0XHRcdFx0XHR2QiA9IGluZGljZXNbIGkgKyAxIF0gKiAzO1xuICAgIFx0XHRcdFx0XHRcdHZDID0gaW5kaWNlc1sgaSArIDIgXSAqIDM7XG5cbiAgICBcdFx0XHRcdFx0XHRwQS5mcm9tQXJyYXkoIHBvc2l0aW9ucywgdkEgKTtcbiAgICBcdFx0XHRcdFx0XHRwQi5mcm9tQXJyYXkoIHBvc2l0aW9ucywgdkIgKTtcbiAgICBcdFx0XHRcdFx0XHRwQy5mcm9tQXJyYXkoIHBvc2l0aW9ucywgdkMgKTtcblxuICAgIFx0XHRcdFx0XHRcdGNiLnN1YlZlY3RvcnMoIHBDLCBwQiApO1xuICAgIFx0XHRcdFx0XHRcdGFiLnN1YlZlY3RvcnMoIHBBLCBwQiApO1xuICAgIFx0XHRcdFx0XHRcdGNiLmNyb3NzKCBhYiApO1xuXG4gICAgXHRcdFx0XHRcdFx0bm9ybWFsc1sgdkEgXSArPSBjYi54O1xuICAgIFx0XHRcdFx0XHRcdG5vcm1hbHNbIHZBICsgMSBdICs9IGNiLnk7XG4gICAgXHRcdFx0XHRcdFx0bm9ybWFsc1sgdkEgKyAyIF0gKz0gY2IuejtcblxuICAgIFx0XHRcdFx0XHRcdG5vcm1hbHNbIHZCIF0gKz0gY2IueDtcbiAgICBcdFx0XHRcdFx0XHRub3JtYWxzWyB2QiArIDEgXSArPSBjYi55O1xuICAgIFx0XHRcdFx0XHRcdG5vcm1hbHNbIHZCICsgMiBdICs9IGNiLno7XG5cbiAgICBcdFx0XHRcdFx0XHRub3JtYWxzWyB2QyBdICs9IGNiLng7XG4gICAgXHRcdFx0XHRcdFx0bm9ybWFsc1sgdkMgKyAxIF0gKz0gY2IueTtcbiAgICBcdFx0XHRcdFx0XHRub3JtYWxzWyB2QyArIDIgXSArPSBjYi56O1xuXG4gICAgXHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0Ly8gbm9uLWluZGV4ZWQgZWxlbWVudHMgKHVuY29ubmVjdGVkIHRyaWFuZ2xlIHNvdXApXG5cbiAgICBcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBwb3NpdGlvbnMubGVuZ3RoOyBpIDwgaWw7IGkgKz0gOSApIHtcblxuICAgIFx0XHRcdFx0XHRwQS5mcm9tQXJyYXkoIHBvc2l0aW9ucywgaSApO1xuICAgIFx0XHRcdFx0XHRwQi5mcm9tQXJyYXkoIHBvc2l0aW9ucywgaSArIDMgKTtcbiAgICBcdFx0XHRcdFx0cEMuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGkgKyA2ICk7XG5cbiAgICBcdFx0XHRcdFx0Y2Iuc3ViVmVjdG9ycyggcEMsIHBCICk7XG4gICAgXHRcdFx0XHRcdGFiLnN1YlZlY3RvcnMoIHBBLCBwQiApO1xuICAgIFx0XHRcdFx0XHRjYi5jcm9zcyggYWIgKTtcblxuICAgIFx0XHRcdFx0XHRub3JtYWxzWyBpIF0gPSBjYi54O1xuICAgIFx0XHRcdFx0XHRub3JtYWxzWyBpICsgMSBdID0gY2IueTtcbiAgICBcdFx0XHRcdFx0bm9ybWFsc1sgaSArIDIgXSA9IGNiLno7XG5cbiAgICBcdFx0XHRcdFx0bm9ybWFsc1sgaSArIDMgXSA9IGNiLng7XG4gICAgXHRcdFx0XHRcdG5vcm1hbHNbIGkgKyA0IF0gPSBjYi55O1xuICAgIFx0XHRcdFx0XHRub3JtYWxzWyBpICsgNSBdID0gY2IuejtcblxuICAgIFx0XHRcdFx0XHRub3JtYWxzWyBpICsgNiBdID0gY2IueDtcbiAgICBcdFx0XHRcdFx0bm9ybWFsc1sgaSArIDcgXSA9IGNiLnk7XG4gICAgXHRcdFx0XHRcdG5vcm1hbHNbIGkgKyA4IF0gPSBjYi56O1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHR0aGlzLm5vcm1hbGl6ZU5vcm1hbHMoKTtcblxuICAgIFx0XHRcdGF0dHJpYnV0ZXMubm9ybWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgIFx0XHR9XG5cbiAgICBcdH0sXG5cbiAgICBcdG1lcmdlOiBmdW5jdGlvbiAoIGdlb21ldHJ5LCBvZmZzZXQgKSB7XG5cbiAgICBcdFx0aWYgKCAoZ2VvbWV0cnkgJiYgZ2VvbWV0cnkuaXNCdWZmZXJHZW9tZXRyeSkgPT09IGZhbHNlICkge1xuXG4gICAgXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5Lm1lcmdlKCk6IGdlb21ldHJ5IG5vdCBhbiBpbnN0YW5jZSBvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeS4nLCBnZW9tZXRyeSApO1xuICAgIFx0XHRcdHJldHVybjtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cbiAgICBcdFx0dmFyIGF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXM7XG5cbiAgICBcdFx0Zm9yICggdmFyIGtleSBpbiBhdHRyaWJ1dGVzICkge1xuXG4gICAgXHRcdFx0aWYgKCBnZW9tZXRyeS5hdHRyaWJ1dGVzWyBrZXkgXSA9PT0gdW5kZWZpbmVkICkgY29udGludWU7XG5cbiAgICBcdFx0XHR2YXIgYXR0cmlidXRlMSA9IGF0dHJpYnV0ZXNbIGtleSBdO1xuICAgIFx0XHRcdHZhciBhdHRyaWJ1dGVBcnJheTEgPSBhdHRyaWJ1dGUxLmFycmF5O1xuXG4gICAgXHRcdFx0dmFyIGF0dHJpYnV0ZTIgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzWyBrZXkgXTtcbiAgICBcdFx0XHR2YXIgYXR0cmlidXRlQXJyYXkyID0gYXR0cmlidXRlMi5hcnJheTtcblxuICAgIFx0XHRcdHZhciBhdHRyaWJ1dGVTaXplID0gYXR0cmlidXRlMi5pdGVtU2l6ZTtcblxuICAgIFx0XHRcdGZvciAoIHZhciBpID0gMCwgaiA9IGF0dHJpYnV0ZVNpemUgKiBvZmZzZXQ7IGkgPCBhdHRyaWJ1dGVBcnJheTIubGVuZ3RoOyBpICsrLCBqICsrICkge1xuXG4gICAgXHRcdFx0XHRhdHRyaWJ1dGVBcnJheTFbIGogXSA9IGF0dHJpYnV0ZUFycmF5MlsgaSBdO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0bm9ybWFsaXplTm9ybWFsczogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHZhciBub3JtYWxzID0gdGhpcy5hdHRyaWJ1dGVzLm5vcm1hbC5hcnJheTtcblxuICAgIFx0XHR2YXIgeCwgeSwgeiwgbjtcblxuICAgIFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gbm9ybWFscy5sZW5ndGg7IGkgPCBpbDsgaSArPSAzICkge1xuXG4gICAgXHRcdFx0eCA9IG5vcm1hbHNbIGkgXTtcbiAgICBcdFx0XHR5ID0gbm9ybWFsc1sgaSArIDEgXTtcbiAgICBcdFx0XHR6ID0gbm9ybWFsc1sgaSArIDIgXTtcblxuICAgIFx0XHRcdG4gPSAxLjAgLyBNYXRoLnNxcnQoIHggKiB4ICsgeSAqIHkgKyB6ICogeiApO1xuXG4gICAgXHRcdFx0bm9ybWFsc1sgaSBdICo9IG47XG4gICAgXHRcdFx0bm9ybWFsc1sgaSArIDEgXSAqPSBuO1xuICAgIFx0XHRcdG5vcm1hbHNbIGkgKyAyIF0gKj0gbjtcblxuICAgIFx0XHR9XG5cbiAgICBcdH0sXG5cbiAgICBcdHRvTm9uSW5kZXhlZDogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdGlmICggdGhpcy5pbmRleCA9PT0gbnVsbCApIHtcblxuICAgIFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5LnRvTm9uSW5kZXhlZCgpOiBHZW9tZXRyeSBpcyBhbHJlYWR5IG5vbi1pbmRleGVkLicgKTtcbiAgICBcdFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0dmFyIGdlb21ldHJ5MiA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuXG4gICAgXHRcdHZhciBpbmRpY2VzID0gdGhpcy5pbmRleC5hcnJheTtcbiAgICBcdFx0dmFyIGF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXM7XG5cbiAgICBcdFx0Zm9yICggdmFyIG5hbWUgaW4gYXR0cmlidXRlcyApIHtcblxuICAgIFx0XHRcdHZhciBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzWyBuYW1lIF07XG5cbiAgICBcdFx0XHR2YXIgYXJyYXkgPSBhdHRyaWJ1dGUuYXJyYXk7XG4gICAgXHRcdFx0dmFyIGl0ZW1TaXplID0gYXR0cmlidXRlLml0ZW1TaXplO1xuXG4gICAgXHRcdFx0dmFyIGFycmF5MiA9IG5ldyBhcnJheS5jb25zdHJ1Y3RvciggaW5kaWNlcy5sZW5ndGggKiBpdGVtU2l6ZSApO1xuXG4gICAgXHRcdFx0dmFyIGluZGV4ID0gMCwgaW5kZXgyID0gMDtcblxuICAgIFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGluZGljZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgIFx0XHRcdFx0aW5kZXggPSBpbmRpY2VzWyBpIF0gKiBpdGVtU2l6ZTtcblxuICAgIFx0XHRcdFx0Zm9yICggdmFyIGogPSAwOyBqIDwgaXRlbVNpemU7IGogKysgKSB7XG5cbiAgICBcdFx0XHRcdFx0YXJyYXkyWyBpbmRleDIgKysgXSA9IGFycmF5WyBpbmRleCArKyBdO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRnZW9tZXRyeTIuYWRkQXR0cmlidXRlKCBuYW1lLCBuZXcgQnVmZmVyQXR0cmlidXRlKCBhcnJheTIsIGl0ZW1TaXplICkgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIGdlb21ldHJ5MjtcblxuICAgIFx0fSxcblxuICAgIFx0dG9KU09OOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dmFyIGRhdGEgPSB7XG4gICAgXHRcdFx0bWV0YWRhdGE6IHtcbiAgICBcdFx0XHRcdHZlcnNpb246IDQuNCxcbiAgICBcdFx0XHRcdHR5cGU6ICdCdWZmZXJHZW9tZXRyeScsXG4gICAgXHRcdFx0XHRnZW5lcmF0b3I6ICdCdWZmZXJHZW9tZXRyeS50b0pTT04nXG4gICAgXHRcdFx0fVxuICAgIFx0XHR9O1xuXG4gICAgXHRcdC8vIHN0YW5kYXJkIEJ1ZmZlckdlb21ldHJ5IHNlcmlhbGl6YXRpb25cblxuICAgIFx0XHRkYXRhLnV1aWQgPSB0aGlzLnV1aWQ7XG4gICAgXHRcdGRhdGEudHlwZSA9IHRoaXMudHlwZTtcbiAgICBcdFx0aWYgKCB0aGlzLm5hbWUgIT09ICcnICkgZGF0YS5uYW1lID0gdGhpcy5uYW1lO1xuXG4gICAgXHRcdGlmICggdGhpcy5wYXJhbWV0ZXJzICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHR2YXIgcGFyYW1ldGVycyA9IHRoaXMucGFyYW1ldGVycztcblxuICAgIFx0XHRcdGZvciAoIHZhciBrZXkgaW4gcGFyYW1ldGVycyApIHtcblxuICAgIFx0XHRcdFx0aWYgKCBwYXJhbWV0ZXJzWyBrZXkgXSAhPT0gdW5kZWZpbmVkICkgZGF0YVsga2V5IF0gPSBwYXJhbWV0ZXJzWyBrZXkgXTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdHJldHVybiBkYXRhO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRkYXRhLmRhdGEgPSB7IGF0dHJpYnV0ZXM6IHt9IH07XG5cbiAgICBcdFx0dmFyIGluZGV4ID0gdGhpcy5pbmRleDtcblxuICAgIFx0XHRpZiAoIGluZGV4ICE9PSBudWxsICkge1xuXG4gICAgXHRcdFx0dmFyIGFycmF5ID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGluZGV4LmFycmF5ICk7XG5cbiAgICBcdFx0XHRkYXRhLmRhdGEuaW5kZXggPSB7XG4gICAgXHRcdFx0XHR0eXBlOiBpbmRleC5hcnJheS5jb25zdHJ1Y3Rvci5uYW1lLFxuICAgIFx0XHRcdFx0YXJyYXk6IGFycmF5XG4gICAgXHRcdFx0fTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0dmFyIGF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXM7XG5cbiAgICBcdFx0Zm9yICggdmFyIGtleSBpbiBhdHRyaWJ1dGVzICkge1xuXG4gICAgXHRcdFx0dmFyIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbIGtleSBdO1xuXG4gICAgXHRcdFx0dmFyIGFycmF5ID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGF0dHJpYnV0ZS5hcnJheSApO1xuXG4gICAgXHRcdFx0ZGF0YS5kYXRhLmF0dHJpYnV0ZXNbIGtleSBdID0ge1xuICAgIFx0XHRcdFx0aXRlbVNpemU6IGF0dHJpYnV0ZS5pdGVtU2l6ZSxcbiAgICBcdFx0XHRcdHR5cGU6IGF0dHJpYnV0ZS5hcnJheS5jb25zdHJ1Y3Rvci5uYW1lLFxuICAgIFx0XHRcdFx0YXJyYXk6IGFycmF5LFxuICAgIFx0XHRcdFx0bm9ybWFsaXplZDogYXR0cmlidXRlLm5vcm1hbGl6ZWRcbiAgICBcdFx0XHR9O1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHR2YXIgZ3JvdXBzID0gdGhpcy5ncm91cHM7XG5cbiAgICBcdFx0aWYgKCBncm91cHMubGVuZ3RoID4gMCApIHtcblxuICAgIFx0XHRcdGRhdGEuZGF0YS5ncm91cHMgPSBKU09OLnBhcnNlKCBKU09OLnN0cmluZ2lmeSggZ3JvdXBzICkgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0dmFyIGJvdW5kaW5nU3BoZXJlID0gdGhpcy5ib3VuZGluZ1NwaGVyZTtcblxuICAgIFx0XHRpZiAoIGJvdW5kaW5nU3BoZXJlICE9PSBudWxsICkge1xuXG4gICAgXHRcdFx0ZGF0YS5kYXRhLmJvdW5kaW5nU3BoZXJlID0ge1xuICAgIFx0XHRcdFx0Y2VudGVyOiBib3VuZGluZ1NwaGVyZS5jZW50ZXIudG9BcnJheSgpLFxuICAgIFx0XHRcdFx0cmFkaXVzOiBib3VuZGluZ1NwaGVyZS5yYWRpdXNcbiAgICBcdFx0XHR9O1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gZGF0YTtcblxuICAgIFx0fSxcblxuICAgIFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHQvKlxuICAgIFx0XHQvLyBIYW5kbGUgcHJpbWl0aXZlc1xuXG4gICAgXHRcdHZhciBwYXJhbWV0ZXJzID0gdGhpcy5wYXJhbWV0ZXJzO1xuXG4gICAgXHRcdGlmICggcGFyYW1ldGVycyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0dmFyIHZhbHVlcyA9IFtdO1xuXG4gICAgXHRcdFx0Zm9yICggdmFyIGtleSBpbiBwYXJhbWV0ZXJzICkge1xuXG4gICAgXHRcdFx0XHR2YWx1ZXMucHVzaCggcGFyYW1ldGVyc1sga2V5IF0gKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdHZhciBnZW9tZXRyeSA9IE9iamVjdC5jcmVhdGUoIHRoaXMuY29uc3RydWN0b3IucHJvdG90eXBlICk7XG4gICAgXHRcdFx0dGhpcy5jb25zdHJ1Y3Rvci5hcHBseSggZ2VvbWV0cnksIHZhbHVlcyApO1xuICAgIFx0XHRcdHJldHVybiBnZW9tZXRyeTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xuICAgIFx0XHQqL1xuXG4gICAgXHRcdHJldHVybiBuZXcgQnVmZmVyR2VvbWV0cnkoKS5jb3B5KCB0aGlzICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xuXG4gICAgXHRcdHZhciBpbmRleCA9IHNvdXJjZS5pbmRleDtcblxuICAgIFx0XHRpZiAoIGluZGV4ICE9PSBudWxsICkge1xuXG4gICAgXHRcdFx0dGhpcy5zZXRJbmRleCggaW5kZXguY2xvbmUoKSApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHR2YXIgYXR0cmlidXRlcyA9IHNvdXJjZS5hdHRyaWJ1dGVzO1xuXG4gICAgXHRcdGZvciAoIHZhciBuYW1lIGluIGF0dHJpYnV0ZXMgKSB7XG5cbiAgICBcdFx0XHR2YXIgYXR0cmlidXRlID0gYXR0cmlidXRlc1sgbmFtZSBdO1xuICAgIFx0XHRcdHRoaXMuYWRkQXR0cmlidXRlKCBuYW1lLCBhdHRyaWJ1dGUuY2xvbmUoKSApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHR2YXIgZ3JvdXBzID0gc291cmNlLmdyb3VwcztcblxuICAgIFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBncm91cHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgIFx0XHRcdHZhciBncm91cCA9IGdyb3Vwc1sgaSBdO1xuICAgIFx0XHRcdHRoaXMuYWRkR3JvdXAoIGdyb3VwLnN0YXJ0LCBncm91cC5jb3VudCwgZ3JvdXAubWF0ZXJpYWxJbmRleCApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0ZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHRoaXMuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAnZGlzcG9zZScgfSApO1xuXG4gICAgXHR9XG5cbiAgICB9ICk7XG5cbiAgICBCdWZmZXJHZW9tZXRyeS5NYXhJbmRleCA9IDY1NTM1O1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAgICAgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICAgICAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG4gICAgICogQGF1dGhvciBqb25vYnIxIC8gaHR0cDovL2pvbm9icjEuY29tL1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gTWVzaCggZ2VvbWV0cnksIG1hdGVyaWFsICkge1xuXG4gICAgXHRPYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cbiAgICBcdHRoaXMudHlwZSA9ICdNZXNoJztcblxuICAgIFx0dGhpcy5nZW9tZXRyeSA9IGdlb21ldHJ5ICE9PSB1bmRlZmluZWQgPyBnZW9tZXRyeSA6IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuICAgIFx0dGhpcy5tYXRlcmlhbCA9IG1hdGVyaWFsICE9PSB1bmRlZmluZWQgPyBtYXRlcmlhbCA6IG5ldyBNZXNoQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmIH0gKTtcblxuICAgIFx0dGhpcy5kcmF3TW9kZSA9IFRyaWFuZ2xlc0RyYXdNb2RlO1xuXG4gICAgXHR0aGlzLnVwZGF0ZU1vcnBoVGFyZ2V0cygpO1xuXG4gICAgfVxuXG4gICAgTWVzaC5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBPYmplY3QzRC5wcm90b3R5cGUgKSwge1xuXG4gICAgXHRjb25zdHJ1Y3RvcjogTWVzaCxcblxuICAgIFx0aXNNZXNoOiB0cnVlLFxuXG4gICAgXHRzZXREcmF3TW9kZTogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuICAgIFx0XHR0aGlzLmRyYXdNb2RlID0gdmFsdWU7XG5cbiAgICBcdH0sXG5cbiAgICBcdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xuXG4gICAgXHRcdE9iamVjdDNELnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG4gICAgXHRcdHRoaXMuZHJhd01vZGUgPSBzb3VyY2UuZHJhd01vZGU7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdHVwZGF0ZU1vcnBoVGFyZ2V0czogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHZhciBtb3JwaFRhcmdldHMgPSB0aGlzLmdlb21ldHJ5Lm1vcnBoVGFyZ2V0cztcblxuICAgIFx0XHRpZiAoIG1vcnBoVGFyZ2V0cyAhPT0gdW5kZWZpbmVkICYmIG1vcnBoVGFyZ2V0cy5sZW5ndGggPiAwICkge1xuXG4gICAgXHRcdFx0dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXMgPSBbXTtcbiAgICBcdFx0XHR0aGlzLm1vcnBoVGFyZ2V0RGljdGlvbmFyeSA9IHt9O1xuXG4gICAgXHRcdFx0Zm9yICggdmFyIG0gPSAwLCBtbCA9IG1vcnBoVGFyZ2V0cy5sZW5ndGg7IG0gPCBtbDsgbSArKyApIHtcblxuICAgIFx0XHRcdFx0dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXMucHVzaCggMCApO1xuICAgIFx0XHRcdFx0dGhpcy5tb3JwaFRhcmdldERpY3Rpb25hcnlbIG1vcnBoVGFyZ2V0c1sgbSBdLm5hbWUgXSA9IG07XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9LFxuXG4gICAgXHRyYXljYXN0OiAoIGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR2YXIgaW52ZXJzZU1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XG4gICAgXHRcdHZhciByYXkgPSBuZXcgUmF5KCk7XG4gICAgXHRcdHZhciBzcGhlcmUgPSBuZXcgU3BoZXJlKCk7XG5cbiAgICBcdFx0dmFyIHZBID0gbmV3IFZlY3RvcjMoKTtcbiAgICBcdFx0dmFyIHZCID0gbmV3IFZlY3RvcjMoKTtcbiAgICBcdFx0dmFyIHZDID0gbmV3IFZlY3RvcjMoKTtcblxuICAgIFx0XHR2YXIgdGVtcEEgPSBuZXcgVmVjdG9yMygpO1xuICAgIFx0XHR2YXIgdGVtcEIgPSBuZXcgVmVjdG9yMygpO1xuICAgIFx0XHR2YXIgdGVtcEMgPSBuZXcgVmVjdG9yMygpO1xuXG4gICAgXHRcdHZhciB1dkEgPSBuZXcgVmVjdG9yMigpO1xuICAgIFx0XHR2YXIgdXZCID0gbmV3IFZlY3RvcjIoKTtcbiAgICBcdFx0dmFyIHV2QyA9IG5ldyBWZWN0b3IyKCk7XG5cbiAgICBcdFx0dmFyIGJhcnljb29yZCA9IG5ldyBWZWN0b3IzKCk7XG5cbiAgICBcdFx0dmFyIGludGVyc2VjdGlvblBvaW50ID0gbmV3IFZlY3RvcjMoKTtcbiAgICBcdFx0dmFyIGludGVyc2VjdGlvblBvaW50V29ybGQgPSBuZXcgVmVjdG9yMygpO1xuXG4gICAgXHRcdGZ1bmN0aW9uIHV2SW50ZXJzZWN0aW9uKCBwb2ludCwgcDEsIHAyLCBwMywgdXYxLCB1djIsIHV2MyApIHtcblxuICAgIFx0XHRcdFRyaWFuZ2xlLmJhcnljb29yZEZyb21Qb2ludCggcG9pbnQsIHAxLCBwMiwgcDMsIGJhcnljb29yZCApO1xuXG4gICAgXHRcdFx0dXYxLm11bHRpcGx5U2NhbGFyKCBiYXJ5Y29vcmQueCApO1xuICAgIFx0XHRcdHV2Mi5tdWx0aXBseVNjYWxhciggYmFyeWNvb3JkLnkgKTtcbiAgICBcdFx0XHR1djMubXVsdGlwbHlTY2FsYXIoIGJhcnljb29yZC56ICk7XG5cbiAgICBcdFx0XHR1djEuYWRkKCB1djIgKS5hZGQoIHV2MyApO1xuXG4gICAgXHRcdFx0cmV0dXJuIHV2MS5jbG9uZSgpO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRmdW5jdGlvbiBjaGVja0ludGVyc2VjdGlvbiggb2JqZWN0LCByYXljYXN0ZXIsIHJheSwgcEEsIHBCLCBwQywgcG9pbnQgKSB7XG5cbiAgICBcdFx0XHR2YXIgaW50ZXJzZWN0O1xuICAgIFx0XHRcdHZhciBtYXRlcmlhbCA9IG9iamVjdC5tYXRlcmlhbDtcblxuICAgIFx0XHRcdGlmICggbWF0ZXJpYWwuc2lkZSA9PT0gQmFja1NpZGUgKSB7XG5cbiAgICBcdFx0XHRcdGludGVyc2VjdCA9IHJheS5pbnRlcnNlY3RUcmlhbmdsZSggcEMsIHBCLCBwQSwgdHJ1ZSwgcG9pbnQgKTtcblxuICAgIFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdGludGVyc2VjdCA9IHJheS5pbnRlcnNlY3RUcmlhbmdsZSggcEEsIHBCLCBwQywgbWF0ZXJpYWwuc2lkZSAhPT0gRG91YmxlU2lkZSwgcG9pbnQgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdGlmICggaW50ZXJzZWN0ID09PSBudWxsICkgcmV0dXJuIG51bGw7XG5cbiAgICBcdFx0XHRpbnRlcnNlY3Rpb25Qb2ludFdvcmxkLmNvcHkoIHBvaW50ICk7XG4gICAgXHRcdFx0aW50ZXJzZWN0aW9uUG9pbnRXb3JsZC5hcHBseU1hdHJpeDQoIG9iamVjdC5tYXRyaXhXb3JsZCApO1xuXG4gICAgXHRcdFx0dmFyIGRpc3RhbmNlID0gcmF5Y2FzdGVyLnJheS5vcmlnaW4uZGlzdGFuY2VUbyggaW50ZXJzZWN0aW9uUG9pbnRXb3JsZCApO1xuXG4gICAgXHRcdFx0aWYgKCBkaXN0YW5jZSA8IHJheWNhc3Rlci5uZWFyIHx8IGRpc3RhbmNlID4gcmF5Y2FzdGVyLmZhciApIHJldHVybiBudWxsO1xuXG4gICAgXHRcdFx0cmV0dXJuIHtcbiAgICBcdFx0XHRcdGRpc3RhbmNlOiBkaXN0YW5jZSxcbiAgICBcdFx0XHRcdHBvaW50OiBpbnRlcnNlY3Rpb25Qb2ludFdvcmxkLmNsb25lKCksXG4gICAgXHRcdFx0XHRvYmplY3Q6IG9iamVjdFxuICAgIFx0XHRcdH07XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGZ1bmN0aW9uIGNoZWNrQnVmZmVyR2VvbWV0cnlJbnRlcnNlY3Rpb24oIG9iamVjdCwgcmF5Y2FzdGVyLCByYXksIHBvc2l0aW9ucywgdXZzLCBhLCBiLCBjICkge1xuXG4gICAgXHRcdFx0dkEuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGEgKiAzICk7XG4gICAgXHRcdFx0dkIuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGIgKiAzICk7XG4gICAgXHRcdFx0dkMuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGMgKiAzICk7XG5cbiAgICBcdFx0XHR2YXIgaW50ZXJzZWN0aW9uID0gY2hlY2tJbnRlcnNlY3Rpb24oIG9iamVjdCwgcmF5Y2FzdGVyLCByYXksIHZBLCB2QiwgdkMsIGludGVyc2VjdGlvblBvaW50ICk7XG5cbiAgICBcdFx0XHRpZiAoIGludGVyc2VjdGlvbiApIHtcblxuICAgIFx0XHRcdFx0aWYgKCB1dnMgKSB7XG5cbiAgICBcdFx0XHRcdFx0dXZBLmZyb21BcnJheSggdXZzLCBhICogMiApO1xuICAgIFx0XHRcdFx0XHR1dkIuZnJvbUFycmF5KCB1dnMsIGIgKiAyICk7XG4gICAgXHRcdFx0XHRcdHV2Qy5mcm9tQXJyYXkoIHV2cywgYyAqIDIgKTtcblxuICAgIFx0XHRcdFx0XHRpbnRlcnNlY3Rpb24udXYgPSB1dkludGVyc2VjdGlvbiggaW50ZXJzZWN0aW9uUG9pbnQsICB2QSwgdkIsIHZDLCAgdXZBLCB1dkIsIHV2QyApO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdGludGVyc2VjdGlvbi5mYWNlID0gbmV3IEZhY2UzKCBhLCBiLCBjLCBUcmlhbmdsZS5ub3JtYWwoIHZBLCB2QiwgdkMgKSApO1xuICAgIFx0XHRcdFx0aW50ZXJzZWN0aW9uLmZhY2VJbmRleCA9IGE7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRyZXR1cm4gaW50ZXJzZWN0aW9uO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gZnVuY3Rpb24gcmF5Y2FzdCggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICkge1xuXG4gICAgXHRcdFx0dmFyIGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcbiAgICBcdFx0XHR2YXIgbWF0ZXJpYWwgPSB0aGlzLm1hdGVyaWFsO1xuICAgIFx0XHRcdHZhciBtYXRyaXhXb3JsZCA9IHRoaXMubWF0cml4V29ybGQ7XG5cbiAgICBcdFx0XHRpZiAoIG1hdGVyaWFsID09PSB1bmRlZmluZWQgKSByZXR1cm47XG5cbiAgICBcdFx0XHQvLyBDaGVja2luZyBib3VuZGluZ1NwaGVyZSBkaXN0YW5jZSB0byByYXlcblxuICAgIFx0XHRcdGlmICggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgPT09IG51bGwgKSBnZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcblxuICAgIFx0XHRcdHNwaGVyZS5jb3B5KCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSApO1xuICAgIFx0XHRcdHNwaGVyZS5hcHBseU1hdHJpeDQoIG1hdHJpeFdvcmxkICk7XG5cbiAgICBcdFx0XHRpZiAoIHJheWNhc3Rlci5yYXkuaW50ZXJzZWN0c1NwaGVyZSggc3BoZXJlICkgPT09IGZhbHNlICkgcmV0dXJuO1xuXG4gICAgXHRcdFx0Ly9cblxuICAgIFx0XHRcdGludmVyc2VNYXRyaXguZ2V0SW52ZXJzZSggbWF0cml4V29ybGQgKTtcbiAgICBcdFx0XHRyYXkuY29weSggcmF5Y2FzdGVyLnJheSApLmFwcGx5TWF0cml4NCggaW52ZXJzZU1hdHJpeCApO1xuXG4gICAgXHRcdFx0Ly8gQ2hlY2sgYm91bmRpbmdCb3ggYmVmb3JlIGNvbnRpbnVpbmdcblxuICAgIFx0XHRcdGlmICggZ2VvbWV0cnkuYm91bmRpbmdCb3ggIT09IG51bGwgKSB7XG5cbiAgICBcdFx0XHRcdGlmICggcmF5LmludGVyc2VjdHNCb3goIGdlb21ldHJ5LmJvdW5kaW5nQm94ICkgPT09IGZhbHNlICkgcmV0dXJuO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0dmFyIHV2cywgaW50ZXJzZWN0aW9uO1xuXG4gICAgXHRcdFx0aWYgKCAoZ2VvbWV0cnkgJiYgZ2VvbWV0cnkuaXNCdWZmZXJHZW9tZXRyeSkgKSB7XG5cbiAgICBcdFx0XHRcdHZhciBhLCBiLCBjO1xuICAgIFx0XHRcdFx0dmFyIGluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XG4gICAgXHRcdFx0XHR2YXIgYXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XG4gICAgXHRcdFx0XHR2YXIgcG9zaXRpb25zID0gYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcblxuICAgIFx0XHRcdFx0aWYgKCBhdHRyaWJ1dGVzLnV2ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRcdFx0dXZzID0gYXR0cmlidXRlcy51di5hcnJheTtcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHRpZiAoIGluZGV4ICE9PSBudWxsICkge1xuXG4gICAgXHRcdFx0XHRcdHZhciBpbmRpY2VzID0gaW5kZXguYXJyYXk7XG5cbiAgICBcdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gaW5kaWNlcy5sZW5ndGg7IGkgPCBsOyBpICs9IDMgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHRhID0gaW5kaWNlc1sgaSBdO1xuICAgIFx0XHRcdFx0XHRcdGIgPSBpbmRpY2VzWyBpICsgMSBdO1xuICAgIFx0XHRcdFx0XHRcdGMgPSBpbmRpY2VzWyBpICsgMiBdO1xuXG4gICAgXHRcdFx0XHRcdFx0aW50ZXJzZWN0aW9uID0gY2hlY2tCdWZmZXJHZW9tZXRyeUludGVyc2VjdGlvbiggdGhpcywgcmF5Y2FzdGVyLCByYXksIHBvc2l0aW9ucywgdXZzLCBhLCBiLCBjICk7XG5cbiAgICBcdFx0XHRcdFx0XHRpZiAoIGludGVyc2VjdGlvbiApIHtcblxuICAgIFx0XHRcdFx0XHRcdFx0aW50ZXJzZWN0aW9uLmZhY2VJbmRleCA9IE1hdGguZmxvb3IoIGkgLyAzICk7IC8vIHRyaWFuZ2xlIG51bWJlciBpbiBpbmRpY2VzIGJ1ZmZlciBzZW1hbnRpY3NcbiAgICBcdFx0XHRcdFx0XHRcdGludGVyc2VjdHMucHVzaCggaW50ZXJzZWN0aW9uICk7XG5cbiAgICBcdFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHR9IGVsc2Uge1xuXG5cbiAgICBcdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gcG9zaXRpb25zLmxlbmd0aDsgaSA8IGw7IGkgKz0gOSApIHtcblxuICAgIFx0XHRcdFx0XHRcdGEgPSBpIC8gMztcbiAgICBcdFx0XHRcdFx0XHRiID0gYSArIDE7XG4gICAgXHRcdFx0XHRcdFx0YyA9IGEgKyAyO1xuXG4gICAgXHRcdFx0XHRcdFx0aW50ZXJzZWN0aW9uID0gY2hlY2tCdWZmZXJHZW9tZXRyeUludGVyc2VjdGlvbiggdGhpcywgcmF5Y2FzdGVyLCByYXksIHBvc2l0aW9ucywgdXZzLCBhLCBiLCBjICk7XG5cbiAgICBcdFx0XHRcdFx0XHRpZiAoIGludGVyc2VjdGlvbiApIHtcblxuICAgIFx0XHRcdFx0XHRcdFx0aW50ZXJzZWN0aW9uLmluZGV4ID0gYTsgLy8gdHJpYW5nbGUgbnVtYmVyIGluIHBvc2l0aW9ucyBidWZmZXIgc2VtYW50aWNzXG4gICAgXHRcdFx0XHRcdFx0XHRpbnRlcnNlY3RzLnB1c2goIGludGVyc2VjdGlvbiApO1xuXG4gICAgXHRcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0fSBlbHNlIGlmICggKGdlb21ldHJ5ICYmIGdlb21ldHJ5LmlzR2VvbWV0cnkpICkge1xuXG4gICAgXHRcdFx0XHR2YXIgZnZBLCBmdkIsIGZ2QztcbiAgICBcdFx0XHRcdHZhciBpc0ZhY2VNYXRlcmlhbCA9IChtYXRlcmlhbCAmJiBtYXRlcmlhbC5pc011bHRpTWF0ZXJpYWwpO1xuICAgIFx0XHRcdFx0dmFyIG1hdGVyaWFscyA9IGlzRmFjZU1hdGVyaWFsID09PSB0cnVlID8gbWF0ZXJpYWwubWF0ZXJpYWxzIDogbnVsbDtcblxuICAgIFx0XHRcdFx0dmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXM7XG4gICAgXHRcdFx0XHR2YXIgZmFjZXMgPSBnZW9tZXRyeS5mYWNlcztcbiAgICBcdFx0XHRcdHZhciBmYWNlVmVydGV4VXZzID0gZ2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgMCBdO1xuICAgIFx0XHRcdFx0aWYgKCBmYWNlVmVydGV4VXZzLmxlbmd0aCA+IDAgKSB1dnMgPSBmYWNlVmVydGV4VXZzO1xuXG4gICAgXHRcdFx0XHRmb3IgKCB2YXIgZiA9IDAsIGZsID0gZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XG5cbiAgICBcdFx0XHRcdFx0dmFyIGZhY2UgPSBmYWNlc1sgZiBdO1xuICAgIFx0XHRcdFx0XHR2YXIgZmFjZU1hdGVyaWFsID0gaXNGYWNlTWF0ZXJpYWwgPT09IHRydWUgPyBtYXRlcmlhbHNbIGZhY2UubWF0ZXJpYWxJbmRleCBdIDogbWF0ZXJpYWw7XG5cbiAgICBcdFx0XHRcdFx0aWYgKCBmYWNlTWF0ZXJpYWwgPT09IHVuZGVmaW5lZCApIGNvbnRpbnVlO1xuXG4gICAgXHRcdFx0XHRcdGZ2QSA9IHZlcnRpY2VzWyBmYWNlLmEgXTtcbiAgICBcdFx0XHRcdFx0ZnZCID0gdmVydGljZXNbIGZhY2UuYiBdO1xuICAgIFx0XHRcdFx0XHRmdkMgPSB2ZXJ0aWNlc1sgZmFjZS5jIF07XG5cbiAgICBcdFx0XHRcdFx0aWYgKCBmYWNlTWF0ZXJpYWwubW9ycGhUYXJnZXRzID09PSB0cnVlICkge1xuXG4gICAgXHRcdFx0XHRcdFx0dmFyIG1vcnBoVGFyZ2V0cyA9IGdlb21ldHJ5Lm1vcnBoVGFyZ2V0cztcbiAgICBcdFx0XHRcdFx0XHR2YXIgbW9ycGhJbmZsdWVuY2VzID0gdGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXM7XG5cbiAgICBcdFx0XHRcdFx0XHR2QS5zZXQoIDAsIDAsIDAgKTtcbiAgICBcdFx0XHRcdFx0XHR2Qi5zZXQoIDAsIDAsIDAgKTtcbiAgICBcdFx0XHRcdFx0XHR2Qy5zZXQoIDAsIDAsIDAgKTtcblxuICAgIFx0XHRcdFx0XHRcdGZvciAoIHZhciB0ID0gMCwgdGwgPSBtb3JwaFRhcmdldHMubGVuZ3RoOyB0IDwgdGw7IHQgKysgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHRcdHZhciBpbmZsdWVuY2UgPSBtb3JwaEluZmx1ZW5jZXNbIHQgXTtcblxuICAgIFx0XHRcdFx0XHRcdFx0aWYgKCBpbmZsdWVuY2UgPT09IDAgKSBjb250aW51ZTtcblxuICAgIFx0XHRcdFx0XHRcdFx0dmFyIHRhcmdldHMgPSBtb3JwaFRhcmdldHNbIHQgXS52ZXJ0aWNlcztcblxuICAgIFx0XHRcdFx0XHRcdFx0dkEuYWRkU2NhbGVkVmVjdG9yKCB0ZW1wQS5zdWJWZWN0b3JzKCB0YXJnZXRzWyBmYWNlLmEgXSwgZnZBICksIGluZmx1ZW5jZSApO1xuICAgIFx0XHRcdFx0XHRcdFx0dkIuYWRkU2NhbGVkVmVjdG9yKCB0ZW1wQi5zdWJWZWN0b3JzKCB0YXJnZXRzWyBmYWNlLmIgXSwgZnZCICksIGluZmx1ZW5jZSApO1xuICAgIFx0XHRcdFx0XHRcdFx0dkMuYWRkU2NhbGVkVmVjdG9yKCB0ZW1wQy5zdWJWZWN0b3JzKCB0YXJnZXRzWyBmYWNlLmMgXSwgZnZDICksIGluZmx1ZW5jZSApO1xuXG4gICAgXHRcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHRcdFx0dkEuYWRkKCBmdkEgKTtcbiAgICBcdFx0XHRcdFx0XHR2Qi5hZGQoIGZ2QiApO1xuICAgIFx0XHRcdFx0XHRcdHZDLmFkZCggZnZDICk7XG5cbiAgICBcdFx0XHRcdFx0XHRmdkEgPSB2QTtcbiAgICBcdFx0XHRcdFx0XHRmdkIgPSB2QjtcbiAgICBcdFx0XHRcdFx0XHRmdkMgPSB2QztcblxuICAgIFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdFx0aW50ZXJzZWN0aW9uID0gY2hlY2tJbnRlcnNlY3Rpb24oIHRoaXMsIHJheWNhc3RlciwgcmF5LCBmdkEsIGZ2QiwgZnZDLCBpbnRlcnNlY3Rpb25Qb2ludCApO1xuXG4gICAgXHRcdFx0XHRcdGlmICggaW50ZXJzZWN0aW9uICkge1xuXG4gICAgXHRcdFx0XHRcdFx0aWYgKCB1dnMgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHRcdHZhciB1dnNfZiA9IHV2c1sgZiBdO1xuICAgIFx0XHRcdFx0XHRcdFx0dXZBLmNvcHkoIHV2c19mWyAwIF0gKTtcbiAgICBcdFx0XHRcdFx0XHRcdHV2Qi5jb3B5KCB1dnNfZlsgMSBdICk7XG4gICAgXHRcdFx0XHRcdFx0XHR1dkMuY29weSggdXZzX2ZbIDIgXSApO1xuXG4gICAgXHRcdFx0XHRcdFx0XHRpbnRlcnNlY3Rpb24udXYgPSB1dkludGVyc2VjdGlvbiggaW50ZXJzZWN0aW9uUG9pbnQsIGZ2QSwgZnZCLCBmdkMsIHV2QSwgdXZCLCB1dkMgKTtcblxuICAgIFx0XHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0XHRcdGludGVyc2VjdGlvbi5mYWNlID0gZmFjZTtcbiAgICBcdFx0XHRcdFx0XHRpbnRlcnNlY3Rpb24uZmFjZUluZGV4ID0gZjtcbiAgICBcdFx0XHRcdFx0XHRpbnRlcnNlY3RzLnB1c2goIGludGVyc2VjdGlvbiApO1xuXG4gICAgXHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH07XG5cbiAgICBcdH0oKSApLFxuXG4gICAgXHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy5nZW9tZXRyeSwgdGhpcy5tYXRlcmlhbCApLmNvcHkoIHRoaXMgKTtcblxuICAgIFx0fVxuXG4gICAgfSApO1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBNdWdlbjg3IC8gaHR0cHM6Ly9naXRodWIuY29tL011Z2VuODdcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIEJveEJ1ZmZlckdlb21ldHJ5KCB3aWR0aCwgaGVpZ2h0LCBkZXB0aCwgd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIGRlcHRoU2VnbWVudHMgKSB7XG5cbiAgICBcdEJ1ZmZlckdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuICAgIFx0dGhpcy50eXBlID0gJ0JveEJ1ZmZlckdlb21ldHJ5JztcblxuICAgIFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuICAgIFx0XHR3aWR0aDogd2lkdGgsXG4gICAgXHRcdGhlaWdodDogaGVpZ2h0LFxuICAgIFx0XHRkZXB0aDogZGVwdGgsXG4gICAgXHRcdHdpZHRoU2VnbWVudHM6IHdpZHRoU2VnbWVudHMsXG4gICAgXHRcdGhlaWdodFNlZ21lbnRzOiBoZWlnaHRTZWdtZW50cyxcbiAgICBcdFx0ZGVwdGhTZWdtZW50czogZGVwdGhTZWdtZW50c1xuICAgIFx0fTtcblxuICAgIFx0dmFyIHNjb3BlID0gdGhpcztcblxuICAgIFx0Ly8gc2VnbWVudHNcbiAgICBcdHdpZHRoU2VnbWVudHMgPSBNYXRoLmZsb29yKCB3aWR0aFNlZ21lbnRzICkgfHwgMTtcbiAgICBcdGhlaWdodFNlZ21lbnRzID0gTWF0aC5mbG9vciggaGVpZ2h0U2VnbWVudHMgKSB8fCAxO1xuICAgIFx0ZGVwdGhTZWdtZW50cyA9IE1hdGguZmxvb3IoIGRlcHRoU2VnbWVudHMgKSB8fCAxO1xuXG4gICAgXHQvLyB0aGVzZSBhcmUgdXNlZCB0byBjYWxjdWxhdGUgYnVmZmVyIGxlbmd0aFxuICAgIFx0dmFyIHZlcnRleENvdW50ID0gY2FsY3VsYXRlVmVydGV4Q291bnQoIHdpZHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCBkZXB0aFNlZ21lbnRzICk7XG4gICAgXHR2YXIgaW5kZXhDb3VudCA9IGNhbGN1bGF0ZUluZGV4Q291bnQoIHdpZHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCBkZXB0aFNlZ21lbnRzICk7XG5cbiAgICBcdC8vIGJ1ZmZlcnNcbiAgICBcdHZhciBpbmRpY2VzID0gbmV3ICggaW5kZXhDb3VudCA+IDY1NTM1ID8gVWludDMyQXJyYXkgOiBVaW50MTZBcnJheSApKCBpbmRleENvdW50ICk7XG4gICAgXHR2YXIgdmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KCB2ZXJ0ZXhDb3VudCAqIDMgKTtcbiAgICBcdHZhciBub3JtYWxzID0gbmV3IEZsb2F0MzJBcnJheSggdmVydGV4Q291bnQgKiAzICk7XG4gICAgXHR2YXIgdXZzID0gbmV3IEZsb2F0MzJBcnJheSggdmVydGV4Q291bnQgKiAyICk7XG5cbiAgICBcdC8vIG9mZnNldCB2YXJpYWJsZXNcbiAgICBcdHZhciB2ZXJ0ZXhCdWZmZXJPZmZzZXQgPSAwO1xuICAgIFx0dmFyIHV2QnVmZmVyT2Zmc2V0ID0gMDtcbiAgICBcdHZhciBpbmRleEJ1ZmZlck9mZnNldCA9IDA7XG4gICAgXHR2YXIgbnVtYmVyT2ZWZXJ0aWNlcyA9IDA7XG5cbiAgICBcdC8vIGdyb3VwIHZhcmlhYmxlc1xuICAgIFx0dmFyIGdyb3VwU3RhcnQgPSAwO1xuXG4gICAgXHQvLyBidWlsZCBlYWNoIHNpZGUgb2YgdGhlIGJveCBnZW9tZXRyeVxuICAgIFx0YnVpbGRQbGFuZSggJ3onLCAneScsICd4JywgLSAxLCAtIDEsIGRlcHRoLCBoZWlnaHQsICAgd2lkdGgsICBkZXB0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgMCApOyAvLyBweFxuICAgIFx0YnVpbGRQbGFuZSggJ3onLCAneScsICd4JywgICAxLCAtIDEsIGRlcHRoLCBoZWlnaHQsIC0gd2lkdGgsICBkZXB0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgMSApOyAvLyBueFxuICAgIFx0YnVpbGRQbGFuZSggJ3gnLCAneicsICd5JywgICAxLCAgIDEsIHdpZHRoLCBkZXB0aCwgICAgaGVpZ2h0LCB3aWR0aFNlZ21lbnRzLCBkZXB0aFNlZ21lbnRzLCAgMiApOyAvLyBweVxuICAgIFx0YnVpbGRQbGFuZSggJ3gnLCAneicsICd5JywgICAxLCAtIDEsIHdpZHRoLCBkZXB0aCwgIC0gaGVpZ2h0LCB3aWR0aFNlZ21lbnRzLCBkZXB0aFNlZ21lbnRzLCAgMyApOyAvLyBueVxuICAgIFx0YnVpbGRQbGFuZSggJ3gnLCAneScsICd6JywgICAxLCAtIDEsIHdpZHRoLCBoZWlnaHQsICAgZGVwdGgsICB3aWR0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgNCApOyAvLyBwelxuICAgIFx0YnVpbGRQbGFuZSggJ3gnLCAneScsICd6JywgLSAxLCAtIDEsIHdpZHRoLCBoZWlnaHQsIC0gZGVwdGgsICB3aWR0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgNSApOyAvLyBuelxuXG4gICAgXHQvLyBidWlsZCBnZW9tZXRyeVxuICAgIFx0dGhpcy5zZXRJbmRleCggbmV3IEJ1ZmZlckF0dHJpYnV0ZSggaW5kaWNlcywgMSApICk7XG4gICAgXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xuICAgIFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgQnVmZmVyQXR0cmlidXRlKCBub3JtYWxzLCAzICkgKTtcbiAgICBcdHRoaXMuYWRkQXR0cmlidXRlKCAndXYnLCBuZXcgQnVmZmVyQXR0cmlidXRlKCB1dnMsIDIgKSApO1xuXG4gICAgXHQvLyBoZWxwZXIgZnVuY3Rpb25zXG5cbiAgICBcdGZ1bmN0aW9uIGNhbGN1bGF0ZVZlcnRleENvdW50KCB3LCBoLCBkICkge1xuXG4gICAgXHRcdHZhciB2ZXJ0aWNlcyA9IDA7XG5cbiAgICBcdFx0Ly8gY2FsY3VsYXRlIHRoZSBhbW91bnQgb2YgdmVydGljZXMgZm9yIGVhY2ggc2lkZSAocGxhbmUpXG4gICAgXHRcdHZlcnRpY2VzICs9ICh3ICsgMSkgKiAoaCArIDEpICogMjsgLy8geHlcbiAgICBcdFx0dmVydGljZXMgKz0gKHcgKyAxKSAqIChkICsgMSkgKiAyOyAvLyB4elxuICAgIFx0XHR2ZXJ0aWNlcyArPSAoZCArIDEpICogKGggKyAxKSAqIDI7IC8vIHp5XG5cbiAgICBcdFx0cmV0dXJuIHZlcnRpY2VzO1xuXG4gICAgXHR9XG5cbiAgICBcdGZ1bmN0aW9uIGNhbGN1bGF0ZUluZGV4Q291bnQoIHcsIGgsIGQgKSB7XG5cbiAgICBcdFx0dmFyIGluZGV4ID0gMDtcblxuICAgIFx0XHQvLyBjYWxjdWxhdGUgdGhlIGFtb3VudCBvZiBzcXVhcmVzIGZvciBlYWNoIHNpZGVcbiAgICBcdFx0aW5kZXggKz0gdyAqIGggKiAyOyAvLyB4eVxuICAgIFx0XHRpbmRleCArPSB3ICogZCAqIDI7IC8vIHh6XG4gICAgXHRcdGluZGV4ICs9IGQgKiBoICogMjsgLy8genlcblxuICAgIFx0XHRyZXR1cm4gaW5kZXggKiA2OyAvLyB0d28gdHJpYW5nbGVzIHBlciBzcXVhcmUgPT4gc2l4IHZlcnRpY2VzIHBlciBzcXVhcmVcblxuICAgIFx0fVxuXG4gICAgXHRmdW5jdGlvbiBidWlsZFBsYW5lKCB1LCB2LCB3LCB1ZGlyLCB2ZGlyLCB3aWR0aCwgaGVpZ2h0LCBkZXB0aCwgZ3JpZFgsIGdyaWRZLCBtYXRlcmlhbEluZGV4ICkge1xuXG4gICAgXHRcdHZhciBzZWdtZW50V2lkdGhcdD0gd2lkdGggLyBncmlkWDtcbiAgICBcdFx0dmFyIHNlZ21lbnRIZWlnaHQgPSBoZWlnaHQgLyBncmlkWTtcblxuICAgIFx0XHR2YXIgd2lkdGhIYWxmID0gd2lkdGggLyAyO1xuICAgIFx0XHR2YXIgaGVpZ2h0SGFsZiA9IGhlaWdodCAvIDI7XG4gICAgXHRcdHZhciBkZXB0aEhhbGYgPSBkZXB0aCAvIDI7XG5cbiAgICBcdFx0dmFyIGdyaWRYMSA9IGdyaWRYICsgMTtcbiAgICBcdFx0dmFyIGdyaWRZMSA9IGdyaWRZICsgMTtcblxuICAgIFx0XHR2YXIgdmVydGV4Q291bnRlciA9IDA7XG4gICAgXHRcdHZhciBncm91cENvdW50ID0gMDtcblxuICAgIFx0XHR2YXIgdmVjdG9yID0gbmV3IFZlY3RvcjMoKTtcblxuICAgIFx0XHQvLyBnZW5lcmF0ZSB2ZXJ0aWNlcywgbm9ybWFscyBhbmQgdXZzXG5cbiAgICBcdFx0Zm9yICggdmFyIGl5ID0gMDsgaXkgPCBncmlkWTE7IGl5ICsrICkge1xuXG4gICAgXHRcdFx0dmFyIHkgPSBpeSAqIHNlZ21lbnRIZWlnaHQgLSBoZWlnaHRIYWxmO1xuXG4gICAgXHRcdFx0Zm9yICggdmFyIGl4ID0gMDsgaXggPCBncmlkWDE7IGl4ICsrICkge1xuXG4gICAgXHRcdFx0XHR2YXIgeCA9IGl4ICogc2VnbWVudFdpZHRoIC0gd2lkdGhIYWxmO1xuXG4gICAgXHRcdFx0XHQvLyBzZXQgdmFsdWVzIHRvIGNvcnJlY3QgdmVjdG9yIGNvbXBvbmVudFxuICAgIFx0XHRcdFx0dmVjdG9yWyB1IF0gPSB4ICogdWRpcjtcbiAgICBcdFx0XHRcdHZlY3RvclsgdiBdID0geSAqIHZkaXI7XG4gICAgXHRcdFx0XHR2ZWN0b3JbIHcgXSA9IGRlcHRoSGFsZjtcblxuICAgIFx0XHRcdFx0Ly8gbm93IGFwcGx5IHZlY3RvciB0byB2ZXJ0ZXggYnVmZmVyXG4gICAgXHRcdFx0XHR2ZXJ0aWNlc1sgdmVydGV4QnVmZmVyT2Zmc2V0IF0gPSB2ZWN0b3IueDtcbiAgICBcdFx0XHRcdHZlcnRpY2VzWyB2ZXJ0ZXhCdWZmZXJPZmZzZXQgKyAxIF0gPSB2ZWN0b3IueTtcbiAgICBcdFx0XHRcdHZlcnRpY2VzWyB2ZXJ0ZXhCdWZmZXJPZmZzZXQgKyAyIF0gPSB2ZWN0b3IuejtcblxuICAgIFx0XHRcdFx0Ly8gc2V0IHZhbHVlcyB0byBjb3JyZWN0IHZlY3RvciBjb21wb25lbnRcbiAgICBcdFx0XHRcdHZlY3RvclsgdSBdID0gMDtcbiAgICBcdFx0XHRcdHZlY3RvclsgdiBdID0gMDtcbiAgICBcdFx0XHRcdHZlY3RvclsgdyBdID0gZGVwdGggPiAwID8gMSA6IC0gMTtcblxuICAgIFx0XHRcdFx0Ly8gbm93IGFwcGx5IHZlY3RvciB0byBub3JtYWwgYnVmZmVyXG4gICAgXHRcdFx0XHRub3JtYWxzWyB2ZXJ0ZXhCdWZmZXJPZmZzZXQgXSA9IHZlY3Rvci54O1xuICAgIFx0XHRcdFx0bm9ybWFsc1sgdmVydGV4QnVmZmVyT2Zmc2V0ICsgMSBdID0gdmVjdG9yLnk7XG4gICAgXHRcdFx0XHRub3JtYWxzWyB2ZXJ0ZXhCdWZmZXJPZmZzZXQgKyAyIF0gPSB2ZWN0b3IuejtcblxuICAgIFx0XHRcdFx0Ly8gdXZzXG4gICAgXHRcdFx0XHR1dnNbIHV2QnVmZmVyT2Zmc2V0IF0gPSBpeCAvIGdyaWRYO1xuICAgIFx0XHRcdFx0dXZzWyB1dkJ1ZmZlck9mZnNldCArIDEgXSA9IDEgLSAoIGl5IC8gZ3JpZFkgKTtcblxuICAgIFx0XHRcdFx0Ly8gdXBkYXRlIG9mZnNldHMgYW5kIGNvdW50ZXJzXG4gICAgXHRcdFx0XHR2ZXJ0ZXhCdWZmZXJPZmZzZXQgKz0gMztcbiAgICBcdFx0XHRcdHV2QnVmZmVyT2Zmc2V0ICs9IDI7XG4gICAgXHRcdFx0XHR2ZXJ0ZXhDb3VudGVyICs9IDE7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdC8vIDEuIHlvdSBuZWVkIHRocmVlIGluZGljZXMgdG8gZHJhdyBhIHNpbmdsZSBmYWNlXG4gICAgXHRcdC8vIDIuIGEgc2luZ2xlIHNlZ21lbnQgY29uc2lzdHMgb2YgdHdvIGZhY2VzXG4gICAgXHRcdC8vIDMuIHNvIHdlIG5lZWQgdG8gZ2VuZXJhdGUgc2l4ICgyKjMpIGluZGljZXMgcGVyIHNlZ21lbnRcblxuICAgIFx0XHRmb3IgKCBpeSA9IDA7IGl5IDwgZ3JpZFk7IGl5ICsrICkge1xuXG4gICAgXHRcdFx0Zm9yICggaXggPSAwOyBpeCA8IGdyaWRYOyBpeCArKyApIHtcblxuICAgIFx0XHRcdFx0Ly8gaW5kaWNlc1xuICAgIFx0XHRcdFx0dmFyIGEgPSBudW1iZXJPZlZlcnRpY2VzICsgaXggKyBncmlkWDEgKiBpeTtcbiAgICBcdFx0XHRcdHZhciBiID0gbnVtYmVyT2ZWZXJ0aWNlcyArIGl4ICsgZ3JpZFgxICogKCBpeSArIDEgKTtcbiAgICBcdFx0XHRcdHZhciBjID0gbnVtYmVyT2ZWZXJ0aWNlcyArICggaXggKyAxICkgKyBncmlkWDEgKiAoIGl5ICsgMSApO1xuICAgIFx0XHRcdFx0dmFyIGQgPSBudW1iZXJPZlZlcnRpY2VzICsgKCBpeCArIDEgKSArIGdyaWRYMSAqIGl5O1xuXG4gICAgXHRcdFx0XHQvLyBmYWNlIG9uZVxuICAgIFx0XHRcdFx0aW5kaWNlc1sgaW5kZXhCdWZmZXJPZmZzZXQgXSA9IGE7XG4gICAgXHRcdFx0XHRpbmRpY2VzWyBpbmRleEJ1ZmZlck9mZnNldCArIDEgXSA9IGI7XG4gICAgXHRcdFx0XHRpbmRpY2VzWyBpbmRleEJ1ZmZlck9mZnNldCArIDIgXSA9IGQ7XG5cbiAgICBcdFx0XHRcdC8vIGZhY2UgdHdvXG4gICAgXHRcdFx0XHRpbmRpY2VzWyBpbmRleEJ1ZmZlck9mZnNldCArIDMgXSA9IGI7XG4gICAgXHRcdFx0XHRpbmRpY2VzWyBpbmRleEJ1ZmZlck9mZnNldCArIDQgXSA9IGM7XG4gICAgXHRcdFx0XHRpbmRpY2VzWyBpbmRleEJ1ZmZlck9mZnNldCArIDUgXSA9IGQ7XG5cbiAgICBcdFx0XHRcdC8vIHVwZGF0ZSBvZmZzZXRzIGFuZCBjb3VudGVyc1xuICAgIFx0XHRcdFx0aW5kZXhCdWZmZXJPZmZzZXQgKz0gNjtcbiAgICBcdFx0XHRcdGdyb3VwQ291bnQgKz0gNjtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdFx0Ly8gYWRkIGEgZ3JvdXAgdG8gdGhlIGdlb21ldHJ5LiB0aGlzIHdpbGwgZW5zdXJlIG11bHRpIG1hdGVyaWFsIHN1cHBvcnRcbiAgICBcdFx0c2NvcGUuYWRkR3JvdXAoIGdyb3VwU3RhcnQsIGdyb3VwQ291bnQsIG1hdGVyaWFsSW5kZXggKTtcblxuICAgIFx0XHQvLyBjYWxjdWxhdGUgbmV3IHN0YXJ0IHZhbHVlIGZvciBncm91cHNcbiAgICBcdFx0Z3JvdXBTdGFydCArPSBncm91cENvdW50O1xuXG4gICAgXHRcdC8vIHVwZGF0ZSB0b3RhbCBudW1iZXIgb2YgdmVydGljZXNcbiAgICBcdFx0bnVtYmVyT2ZWZXJ0aWNlcyArPSB2ZXJ0ZXhDb3VudGVyO1xuXG4gICAgXHR9XG5cbiAgICB9XG5cbiAgICBCb3hCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcbiAgICBCb3hCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBCb3hCdWZmZXJHZW9tZXRyeTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gICAgICogYmFzZWQgb24gaHR0cDovL3BhcGVydmlzaW9uM2QuZ29vZ2xlY29kZS5jb20vc3ZuL3RydW5rL2FzMy90cnVuay9zcmMvb3JnL3BhcGVydmlzaW9uM2Qvb2JqZWN0cy9wcmltaXRpdmVzL1BsYW5lLmFzXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBQbGFuZUJ1ZmZlckdlb21ldHJ5KCB3aWR0aCwgaGVpZ2h0LCB3aWR0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cyApIHtcblxuICAgIFx0QnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG4gICAgXHR0aGlzLnR5cGUgPSAnUGxhbmVCdWZmZXJHZW9tZXRyeSc7XG5cbiAgICBcdHRoaXMucGFyYW1ldGVycyA9IHtcbiAgICBcdFx0d2lkdGg6IHdpZHRoLFxuICAgIFx0XHRoZWlnaHQ6IGhlaWdodCxcbiAgICBcdFx0d2lkdGhTZWdtZW50czogd2lkdGhTZWdtZW50cyxcbiAgICBcdFx0aGVpZ2h0U2VnbWVudHM6IGhlaWdodFNlZ21lbnRzXG4gICAgXHR9O1xuXG4gICAgXHR2YXIgd2lkdGhfaGFsZiA9IHdpZHRoIC8gMjtcbiAgICBcdHZhciBoZWlnaHRfaGFsZiA9IGhlaWdodCAvIDI7XG5cbiAgICBcdHZhciBncmlkWCA9IE1hdGguZmxvb3IoIHdpZHRoU2VnbWVudHMgKSB8fCAxO1xuICAgIFx0dmFyIGdyaWRZID0gTWF0aC5mbG9vciggaGVpZ2h0U2VnbWVudHMgKSB8fCAxO1xuXG4gICAgXHR2YXIgZ3JpZFgxID0gZ3JpZFggKyAxO1xuICAgIFx0dmFyIGdyaWRZMSA9IGdyaWRZICsgMTtcblxuICAgIFx0dmFyIHNlZ21lbnRfd2lkdGggPSB3aWR0aCAvIGdyaWRYO1xuICAgIFx0dmFyIHNlZ21lbnRfaGVpZ2h0ID0gaGVpZ2h0IC8gZ3JpZFk7XG5cbiAgICBcdHZhciB2ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIGdyaWRYMSAqIGdyaWRZMSAqIDMgKTtcbiAgICBcdHZhciBub3JtYWxzID0gbmV3IEZsb2F0MzJBcnJheSggZ3JpZFgxICogZ3JpZFkxICogMyApO1xuICAgIFx0dmFyIHV2cyA9IG5ldyBGbG9hdDMyQXJyYXkoIGdyaWRYMSAqIGdyaWRZMSAqIDIgKTtcblxuICAgIFx0dmFyIG9mZnNldCA9IDA7XG4gICAgXHR2YXIgb2Zmc2V0MiA9IDA7XG5cbiAgICBcdGZvciAoIHZhciBpeSA9IDA7IGl5IDwgZ3JpZFkxOyBpeSArKyApIHtcblxuICAgIFx0XHR2YXIgeSA9IGl5ICogc2VnbWVudF9oZWlnaHQgLSBoZWlnaHRfaGFsZjtcblxuICAgIFx0XHRmb3IgKCB2YXIgaXggPSAwOyBpeCA8IGdyaWRYMTsgaXggKysgKSB7XG5cbiAgICBcdFx0XHR2YXIgeCA9IGl4ICogc2VnbWVudF93aWR0aCAtIHdpZHRoX2hhbGY7XG5cbiAgICBcdFx0XHR2ZXJ0aWNlc1sgb2Zmc2V0IF0gPSB4O1xuICAgIFx0XHRcdHZlcnRpY2VzWyBvZmZzZXQgKyAxIF0gPSAtIHk7XG5cbiAgICBcdFx0XHRub3JtYWxzWyBvZmZzZXQgKyAyIF0gPSAxO1xuXG4gICAgXHRcdFx0dXZzWyBvZmZzZXQyIF0gPSBpeCAvIGdyaWRYO1xuICAgIFx0XHRcdHV2c1sgb2Zmc2V0MiArIDEgXSA9IDEgLSAoIGl5IC8gZ3JpZFkgKTtcblxuICAgIFx0XHRcdG9mZnNldCArPSAzO1xuICAgIFx0XHRcdG9mZnNldDIgKz0gMjtcblxuICAgIFx0XHR9XG5cbiAgICBcdH1cblxuICAgIFx0b2Zmc2V0ID0gMDtcblxuICAgIFx0dmFyIGluZGljZXMgPSBuZXcgKCAoIHZlcnRpY2VzLmxlbmd0aCAvIDMgKSA+IDY1NTM1ID8gVWludDMyQXJyYXkgOiBVaW50MTZBcnJheSApKCBncmlkWCAqIGdyaWRZICogNiApO1xuXG4gICAgXHRmb3IgKCB2YXIgaXkgPSAwOyBpeSA8IGdyaWRZOyBpeSArKyApIHtcblxuICAgIFx0XHRmb3IgKCB2YXIgaXggPSAwOyBpeCA8IGdyaWRYOyBpeCArKyApIHtcblxuICAgIFx0XHRcdHZhciBhID0gaXggKyBncmlkWDEgKiBpeTtcbiAgICBcdFx0XHR2YXIgYiA9IGl4ICsgZ3JpZFgxICogKCBpeSArIDEgKTtcbiAgICBcdFx0XHR2YXIgYyA9ICggaXggKyAxICkgKyBncmlkWDEgKiAoIGl5ICsgMSApO1xuICAgIFx0XHRcdHZhciBkID0gKCBpeCArIDEgKSArIGdyaWRYMSAqIGl5O1xuXG4gICAgXHRcdFx0aW5kaWNlc1sgb2Zmc2V0IF0gPSBhO1xuICAgIFx0XHRcdGluZGljZXNbIG9mZnNldCArIDEgXSA9IGI7XG4gICAgXHRcdFx0aW5kaWNlc1sgb2Zmc2V0ICsgMiBdID0gZDtcblxuICAgIFx0XHRcdGluZGljZXNbIG9mZnNldCArIDMgXSA9IGI7XG4gICAgXHRcdFx0aW5kaWNlc1sgb2Zmc2V0ICsgNCBdID0gYztcbiAgICBcdFx0XHRpbmRpY2VzWyBvZmZzZXQgKyA1IF0gPSBkO1xuXG4gICAgXHRcdFx0b2Zmc2V0ICs9IDY7XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9XG5cbiAgICBcdHRoaXMuc2V0SW5kZXgoIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIGluZGljZXMsIDEgKSApO1xuICAgIFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcbiAgICBcdHRoaXMuYWRkQXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IEJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFscywgMyApICk7XG4gICAgXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3V2JywgbmV3IEJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkgKTtcblxuICAgIH1cblxuICAgIFBsYW5lQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XG4gICAgUGxhbmVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQbGFuZUJ1ZmZlckdlb21ldHJ5O1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAgICAgKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICAgICAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuICAgICovXG5cbiAgICBmdW5jdGlvbiBDYW1lcmEoKSB7XG5cbiAgICBcdE9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuICAgIFx0dGhpcy50eXBlID0gJ0NhbWVyYSc7XG5cbiAgICBcdHRoaXMubWF0cml4V29ybGRJbnZlcnNlID0gbmV3IE1hdHJpeDQoKTtcbiAgICBcdHRoaXMucHJvamVjdGlvbk1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XG5cbiAgICB9XG5cbiAgICBDYW1lcmEucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggT2JqZWN0M0QucHJvdG90eXBlICk7XG4gICAgQ2FtZXJhLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENhbWVyYTtcblxuICAgIENhbWVyYS5wcm90b3R5cGUuaXNDYW1lcmEgPSB0cnVlO1xuXG4gICAgQ2FtZXJhLnByb3RvdHlwZS5nZXRXb3JsZERpcmVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0dmFyIHF1YXRlcm5pb24gPSBuZXcgUXVhdGVybmlvbigpO1xuXG4gICAgXHRyZXR1cm4gZnVuY3Rpb24gZ2V0V29ybGREaXJlY3Rpb24oIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgXHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMygpO1xuXG4gICAgXHRcdHRoaXMuZ2V0V29ybGRRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uICk7XG5cbiAgICBcdFx0cmV0dXJuIHJlc3VsdC5zZXQoIDAsIDAsIC0gMSApLmFwcGx5UXVhdGVybmlvbiggcXVhdGVybmlvbiApO1xuXG4gICAgXHR9O1xuXG4gICAgfSgpO1xuXG4gICAgQ2FtZXJhLnByb3RvdHlwZS5sb29rQXQgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdC8vIFRoaXMgcm91dGluZSBkb2VzIG5vdCBzdXBwb3J0IGNhbWVyYXMgd2l0aCByb3RhdGVkIGFuZC9vciB0cmFuc2xhdGVkIHBhcmVudChzKVxuXG4gICAgXHR2YXIgbTEgPSBuZXcgTWF0cml4NCgpO1xuXG4gICAgXHRyZXR1cm4gZnVuY3Rpb24gbG9va0F0KCB2ZWN0b3IgKSB7XG5cbiAgICBcdFx0bTEubG9va0F0KCB0aGlzLnBvc2l0aW9uLCB2ZWN0b3IsIHRoaXMudXAgKTtcblxuICAgIFx0XHR0aGlzLnF1YXRlcm5pb24uc2V0RnJvbVJvdGF0aW9uTWF0cml4KCBtMSApO1xuXG4gICAgXHR9O1xuXG4gICAgfSgpO1xuXG4gICAgQ2FtZXJhLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xuXG4gICAgfTtcblxuICAgIENhbWVyYS5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xuXG4gICAgXHRPYmplY3QzRC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuICAgIFx0dGhpcy5tYXRyaXhXb3JsZEludmVyc2UuY29weSggc291cmNlLm1hdHJpeFdvcmxkSW52ZXJzZSApO1xuICAgIFx0dGhpcy5wcm9qZWN0aW9uTWF0cml4LmNvcHkoIHNvdXJjZS5wcm9qZWN0aW9uTWF0cml4ICk7XG5cbiAgICBcdHJldHVybiB0aGlzO1xuXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gICAgICogQGF1dGhvciBncmVnZ21hbiAvIGh0dHA6Ly9nYW1lcy5ncmVnZ21hbi5jb20vXG4gICAgICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xuICAgICAqIEBhdXRob3IgdHNjaHdcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIFBlcnNwZWN0aXZlQ2FtZXJhKCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyICkge1xuXG4gICAgXHRDYW1lcmEuY2FsbCggdGhpcyApO1xuXG4gICAgXHR0aGlzLnR5cGUgPSAnUGVyc3BlY3RpdmVDYW1lcmEnO1xuXG4gICAgXHR0aGlzLmZvdiA9IGZvdiAhPT0gdW5kZWZpbmVkID8gZm92IDogNTA7XG4gICAgXHR0aGlzLnpvb20gPSAxO1xuXG4gICAgXHR0aGlzLm5lYXIgPSBuZWFyICE9PSB1bmRlZmluZWQgPyBuZWFyIDogMC4xO1xuICAgIFx0dGhpcy5mYXIgPSBmYXIgIT09IHVuZGVmaW5lZCA/IGZhciA6IDIwMDA7XG4gICAgXHR0aGlzLmZvY3VzID0gMTA7XG5cbiAgICBcdHRoaXMuYXNwZWN0ID0gYXNwZWN0ICE9PSB1bmRlZmluZWQgPyBhc3BlY3QgOiAxO1xuICAgIFx0dGhpcy52aWV3ID0gbnVsbDtcblxuICAgIFx0dGhpcy5maWxtR2F1Z2UgPSAzNTtcdC8vIHdpZHRoIG9mIHRoZSBmaWxtIChkZWZhdWx0IGluIG1pbGxpbWV0ZXJzKVxuICAgIFx0dGhpcy5maWxtT2Zmc2V0ID0gMDtcdC8vIGhvcml6b250YWwgZmlsbSBvZmZzZXQgKHNhbWUgdW5pdCBhcyBnYXVnZSlcblxuICAgIFx0dGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG5cbiAgICB9XG5cbiAgICBQZXJzcGVjdGl2ZUNhbWVyYS5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBDYW1lcmEucHJvdG90eXBlICksIHtcblxuICAgIFx0Y29uc3RydWN0b3I6IFBlcnNwZWN0aXZlQ2FtZXJhLFxuXG4gICAgXHRpc1BlcnNwZWN0aXZlQ2FtZXJhOiB0cnVlLFxuXG4gICAgXHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuICAgIFx0XHRDYW1lcmEucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XG5cbiAgICBcdFx0dGhpcy5mb3YgPSBzb3VyY2UuZm92O1xuICAgIFx0XHR0aGlzLnpvb20gPSBzb3VyY2Uuem9vbTtcblxuICAgIFx0XHR0aGlzLm5lYXIgPSBzb3VyY2UubmVhcjtcbiAgICBcdFx0dGhpcy5mYXIgPSBzb3VyY2UuZmFyO1xuICAgIFx0XHR0aGlzLmZvY3VzID0gc291cmNlLmZvY3VzO1xuXG4gICAgXHRcdHRoaXMuYXNwZWN0ID0gc291cmNlLmFzcGVjdDtcbiAgICBcdFx0dGhpcy52aWV3ID0gc291cmNlLnZpZXcgPT09IG51bGwgPyBudWxsIDogT2JqZWN0LmFzc2lnbigge30sIHNvdXJjZS52aWV3ICk7XG5cbiAgICBcdFx0dGhpcy5maWxtR2F1Z2UgPSBzb3VyY2UuZmlsbUdhdWdlO1xuICAgIFx0XHR0aGlzLmZpbG1PZmZzZXQgPSBzb3VyY2UuZmlsbU9mZnNldDtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0LyoqXG4gICAgXHQgKiBTZXRzIHRoZSBGT1YgYnkgZm9jYWwgbGVuZ3RoIGluIHJlc3BlY3QgdG8gdGhlIGN1cnJlbnQgLmZpbG1HYXVnZS5cbiAgICBcdCAqXG4gICAgXHQgKiBUaGUgZGVmYXVsdCBmaWxtIGdhdWdlIGlzIDM1LCBzbyB0aGF0IHRoZSBmb2NhbCBsZW5ndGggY2FuIGJlIHNwZWNpZmllZCBmb3JcbiAgICBcdCAqIGEgMzVtbSAoZnVsbCBmcmFtZSkgY2FtZXJhLlxuICAgIFx0ICpcbiAgICBcdCAqIFZhbHVlcyBmb3IgZm9jYWwgbGVuZ3RoIGFuZCBmaWxtIGdhdWdlIG11c3QgaGF2ZSB0aGUgc2FtZSB1bml0LlxuICAgIFx0ICovXG4gICAgXHRzZXRGb2NhbExlbmd0aDogZnVuY3Rpb24gKCBmb2NhbExlbmd0aCApIHtcblxuICAgIFx0XHQvLyBzZWUgaHR0cDovL3d3dy5ib2JhdGtpbnMuY29tL3Bob3RvZ3JhcGh5L3RlY2huaWNhbC9maWVsZF9vZl92aWV3Lmh0bWxcbiAgICBcdFx0dmFyIHZFeHRlbnRTbG9wZSA9IDAuNSAqIHRoaXMuZ2V0RmlsbUhlaWdodCgpIC8gZm9jYWxMZW5ndGg7XG5cbiAgICBcdFx0dGhpcy5mb3YgPSBleHBvcnRzLk1hdGguUkFEMkRFRyAqIDIgKiBNYXRoLmF0YW4oIHZFeHRlbnRTbG9wZSApO1xuICAgIFx0XHR0aGlzLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcblxuICAgIFx0fSxcblxuICAgIFx0LyoqXG4gICAgXHQgKiBDYWxjdWxhdGVzIHRoZSBmb2NhbCBsZW5ndGggZnJvbSB0aGUgY3VycmVudCAuZm92IGFuZCAuZmlsbUdhdWdlLlxuICAgIFx0ICovXG4gICAgXHRnZXRGb2NhbExlbmd0aDogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHZhciB2RXh0ZW50U2xvcGUgPSBNYXRoLnRhbiggZXhwb3J0cy5NYXRoLkRFRzJSQUQgKiAwLjUgKiB0aGlzLmZvdiApO1xuXG4gICAgXHRcdHJldHVybiAwLjUgKiB0aGlzLmdldEZpbG1IZWlnaHQoKSAvIHZFeHRlbnRTbG9wZTtcblxuICAgIFx0fSxcblxuICAgIFx0Z2V0RWZmZWN0aXZlRk9WOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0cmV0dXJuIGV4cG9ydHMuTWF0aC5SQUQyREVHICogMiAqIE1hdGguYXRhbihcbiAgICBcdFx0XHRcdE1hdGgudGFuKCBleHBvcnRzLk1hdGguREVHMlJBRCAqIDAuNSAqIHRoaXMuZm92ICkgLyB0aGlzLnpvb20gKTtcblxuICAgIFx0fSxcblxuICAgIFx0Z2V0RmlsbVdpZHRoOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0Ly8gZmlsbSBub3QgY29tcGxldGVseSBjb3ZlcmVkIGluIHBvcnRyYWl0IGZvcm1hdCAoYXNwZWN0IDwgMSlcbiAgICBcdFx0cmV0dXJuIHRoaXMuZmlsbUdhdWdlICogTWF0aC5taW4oIHRoaXMuYXNwZWN0LCAxICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGdldEZpbG1IZWlnaHQ6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHQvLyBmaWxtIG5vdCBjb21wbGV0ZWx5IGNvdmVyZWQgaW4gbGFuZHNjYXBlIGZvcm1hdCAoYXNwZWN0ID4gMSlcbiAgICBcdFx0cmV0dXJuIHRoaXMuZmlsbUdhdWdlIC8gTWF0aC5tYXgoIHRoaXMuYXNwZWN0LCAxICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdC8qKlxuICAgIFx0ICogU2V0cyBhbiBvZmZzZXQgaW4gYSBsYXJnZXIgZnJ1c3R1bS4gVGhpcyBpcyB1c2VmdWwgZm9yIG11bHRpLXdpbmRvdyBvclxuICAgIFx0ICogbXVsdGktbW9uaXRvci9tdWx0aS1tYWNoaW5lIHNldHVwcy5cbiAgICBcdCAqXG4gICAgXHQgKiBGb3IgZXhhbXBsZSwgaWYgeW91IGhhdmUgM3gyIG1vbml0b3JzIGFuZCBlYWNoIG1vbml0b3IgaXMgMTkyMHgxMDgwIGFuZFxuICAgIFx0ICogdGhlIG1vbml0b3JzIGFyZSBpbiBncmlkIGxpa2UgdGhpc1xuICAgIFx0ICpcbiAgICBcdCAqICAgKy0tLSstLS0rLS0tK1xuICAgIFx0ICogICB8IEEgfCBCIHwgQyB8XG4gICAgXHQgKiAgICstLS0rLS0tKy0tLStcbiAgICBcdCAqICAgfCBEIHwgRSB8IEYgfFxuICAgIFx0ICogICArLS0tKy0tLSstLS0rXG4gICAgXHQgKlxuICAgIFx0ICogdGhlbiBmb3IgZWFjaCBtb25pdG9yIHlvdSB3b3VsZCBjYWxsIGl0IGxpa2UgdGhpc1xuICAgIFx0ICpcbiAgICBcdCAqICAgdmFyIHcgPSAxOTIwO1xuICAgIFx0ICogICB2YXIgaCA9IDEwODA7XG4gICAgXHQgKiAgIHZhciBmdWxsV2lkdGggPSB3ICogMztcbiAgICBcdCAqICAgdmFyIGZ1bGxIZWlnaHQgPSBoICogMjtcbiAgICBcdCAqXG4gICAgXHQgKiAgIC0tQS0tXG4gICAgXHQgKiAgIGNhbWVyYS5zZXRPZmZzZXQoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgdyAqIDAsIGggKiAwLCB3LCBoICk7XG4gICAgXHQgKiAgIC0tQi0tXG4gICAgXHQgKiAgIGNhbWVyYS5zZXRPZmZzZXQoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgdyAqIDEsIGggKiAwLCB3LCBoICk7XG4gICAgXHQgKiAgIC0tQy0tXG4gICAgXHQgKiAgIGNhbWVyYS5zZXRPZmZzZXQoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgdyAqIDIsIGggKiAwLCB3LCBoICk7XG4gICAgXHQgKiAgIC0tRC0tXG4gICAgXHQgKiAgIGNhbWVyYS5zZXRPZmZzZXQoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgdyAqIDAsIGggKiAxLCB3LCBoICk7XG4gICAgXHQgKiAgIC0tRS0tXG4gICAgXHQgKiAgIGNhbWVyYS5zZXRPZmZzZXQoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgdyAqIDEsIGggKiAxLCB3LCBoICk7XG4gICAgXHQgKiAgIC0tRi0tXG4gICAgXHQgKiAgIGNhbWVyYS5zZXRPZmZzZXQoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgdyAqIDIsIGggKiAxLCB3LCBoICk7XG4gICAgXHQgKlxuICAgIFx0ICogICBOb3RlIHRoZXJlIGlzIG5vIHJlYXNvbiBtb25pdG9ycyBoYXZlIHRvIGJlIHRoZSBzYW1lIHNpemUgb3IgaW4gYSBncmlkLlxuICAgIFx0ICovXG4gICAgXHRzZXRWaWV3T2Zmc2V0OiBmdW5jdGlvbiAoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgeCwgeSwgd2lkdGgsIGhlaWdodCApIHtcblxuICAgIFx0XHR0aGlzLmFzcGVjdCA9IGZ1bGxXaWR0aCAvIGZ1bGxIZWlnaHQ7XG5cbiAgICBcdFx0dGhpcy52aWV3ID0ge1xuICAgIFx0XHRcdGZ1bGxXaWR0aDogZnVsbFdpZHRoLFxuICAgIFx0XHRcdGZ1bGxIZWlnaHQ6IGZ1bGxIZWlnaHQsXG4gICAgXHRcdFx0b2Zmc2V0WDogeCxcbiAgICBcdFx0XHRvZmZzZXRZOiB5LFxuICAgIFx0XHRcdHdpZHRoOiB3aWR0aCxcbiAgICBcdFx0XHRoZWlnaHQ6IGhlaWdodFxuICAgIFx0XHR9O1xuXG4gICAgXHRcdHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuXG4gICAgXHR9LFxuXG4gICAgXHRjbGVhclZpZXdPZmZzZXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgXHRcdHRoaXMudmlldyA9IG51bGw7XG4gICAgXHRcdHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuXG4gICAgXHR9LFxuXG4gICAgXHR1cGRhdGVQcm9qZWN0aW9uTWF0cml4OiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dmFyIG5lYXIgPSB0aGlzLm5lYXIsXG4gICAgXHRcdFx0dG9wID0gbmVhciAqIE1hdGgudGFuKFxuICAgIFx0XHRcdFx0XHRleHBvcnRzLk1hdGguREVHMlJBRCAqIDAuNSAqIHRoaXMuZm92ICkgLyB0aGlzLnpvb20sXG4gICAgXHRcdFx0aGVpZ2h0ID0gMiAqIHRvcCxcbiAgICBcdFx0XHR3aWR0aCA9IHRoaXMuYXNwZWN0ICogaGVpZ2h0LFxuICAgIFx0XHRcdGxlZnQgPSAtIDAuNSAqIHdpZHRoLFxuICAgIFx0XHRcdHZpZXcgPSB0aGlzLnZpZXc7XG5cbiAgICBcdFx0aWYgKCB2aWV3ICE9PSBudWxsICkge1xuXG4gICAgXHRcdFx0dmFyIGZ1bGxXaWR0aCA9IHZpZXcuZnVsbFdpZHRoLFxuICAgIFx0XHRcdFx0ZnVsbEhlaWdodCA9IHZpZXcuZnVsbEhlaWdodDtcblxuICAgIFx0XHRcdGxlZnQgKz0gdmlldy5vZmZzZXRYICogd2lkdGggLyBmdWxsV2lkdGg7XG4gICAgXHRcdFx0dG9wIC09IHZpZXcub2Zmc2V0WSAqIGhlaWdodCAvIGZ1bGxIZWlnaHQ7XG4gICAgXHRcdFx0d2lkdGggKj0gdmlldy53aWR0aCAvIGZ1bGxXaWR0aDtcbiAgICBcdFx0XHRoZWlnaHQgKj0gdmlldy5oZWlnaHQgLyBmdWxsSGVpZ2h0O1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHR2YXIgc2tldyA9IHRoaXMuZmlsbU9mZnNldDtcbiAgICBcdFx0aWYgKCBza2V3ICE9PSAwICkgbGVmdCArPSBuZWFyICogc2tldyAvIHRoaXMuZ2V0RmlsbVdpZHRoKCk7XG5cbiAgICBcdFx0dGhpcy5wcm9qZWN0aW9uTWF0cml4Lm1ha2VGcnVzdHVtKFxuICAgIFx0XHRcdFx0bGVmdCwgbGVmdCArIHdpZHRoLCB0b3AgLSBoZWlnaHQsIHRvcCwgbmVhciwgdGhpcy5mYXIgKTtcblxuICAgIFx0fSxcblxuICAgIFx0dG9KU09OOiBmdW5jdGlvbiAoIG1ldGEgKSB7XG5cbiAgICBcdFx0dmFyIGRhdGEgPSBPYmplY3QzRC5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMsIG1ldGEgKTtcblxuICAgIFx0XHRkYXRhLm9iamVjdC5mb3YgPSB0aGlzLmZvdjtcbiAgICBcdFx0ZGF0YS5vYmplY3Quem9vbSA9IHRoaXMuem9vbTtcblxuICAgIFx0XHRkYXRhLm9iamVjdC5uZWFyID0gdGhpcy5uZWFyO1xuICAgIFx0XHRkYXRhLm9iamVjdC5mYXIgPSB0aGlzLmZhcjtcbiAgICBcdFx0ZGF0YS5vYmplY3QuZm9jdXMgPSB0aGlzLmZvY3VzO1xuXG4gICAgXHRcdGRhdGEub2JqZWN0LmFzcGVjdCA9IHRoaXMuYXNwZWN0O1xuXG4gICAgXHRcdGlmICggdGhpcy52aWV3ICE9PSBudWxsICkgZGF0YS5vYmplY3QudmlldyA9IE9iamVjdC5hc3NpZ24oIHt9LCB0aGlzLnZpZXcgKTtcblxuICAgIFx0XHRkYXRhLm9iamVjdC5maWxtR2F1Z2UgPSB0aGlzLmZpbG1HYXVnZTtcbiAgICBcdFx0ZGF0YS5vYmplY3QuZmlsbU9mZnNldCA9IHRoaXMuZmlsbU9mZnNldDtcblxuICAgIFx0XHRyZXR1cm4gZGF0YTtcblxuICAgIFx0fVxuXG4gICAgfSApO1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAgICAgKiBAYXV0aG9yIGFyb3NlIC8gaHR0cDovL2dpdGh1Yi5jb20vYXJvc2VcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIE9ydGhvZ3JhcGhpY0NhbWVyYSggbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tLCBuZWFyLCBmYXIgKSB7XG5cbiAgICBcdENhbWVyYS5jYWxsKCB0aGlzICk7XG5cbiAgICBcdHRoaXMudHlwZSA9ICdPcnRob2dyYXBoaWNDYW1lcmEnO1xuXG4gICAgXHR0aGlzLnpvb20gPSAxO1xuICAgIFx0dGhpcy52aWV3ID0gbnVsbDtcblxuICAgIFx0dGhpcy5sZWZ0ID0gbGVmdDtcbiAgICBcdHRoaXMucmlnaHQgPSByaWdodDtcbiAgICBcdHRoaXMudG9wID0gdG9wO1xuICAgIFx0dGhpcy5ib3R0b20gPSBib3R0b207XG5cbiAgICBcdHRoaXMubmVhciA9ICggbmVhciAhPT0gdW5kZWZpbmVkICkgPyBuZWFyIDogMC4xO1xuICAgIFx0dGhpcy5mYXIgPSAoIGZhciAhPT0gdW5kZWZpbmVkICkgPyBmYXIgOiAyMDAwO1xuXG4gICAgXHR0aGlzLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcblxuICAgIH1cblxuICAgIE9ydGhvZ3JhcGhpY0NhbWVyYS5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBDYW1lcmEucHJvdG90eXBlICksIHtcblxuICAgIFx0Y29uc3RydWN0b3I6IE9ydGhvZ3JhcGhpY0NhbWVyYSxcblxuICAgIFx0aXNPcnRob2dyYXBoaWNDYW1lcmE6IHRydWUsXG5cbiAgICBcdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xuXG4gICAgXHRcdENhbWVyYS5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuICAgIFx0XHR0aGlzLmxlZnQgPSBzb3VyY2UubGVmdDtcbiAgICBcdFx0dGhpcy5yaWdodCA9IHNvdXJjZS5yaWdodDtcbiAgICBcdFx0dGhpcy50b3AgPSBzb3VyY2UudG9wO1xuICAgIFx0XHR0aGlzLmJvdHRvbSA9IHNvdXJjZS5ib3R0b207XG4gICAgXHRcdHRoaXMubmVhciA9IHNvdXJjZS5uZWFyO1xuICAgIFx0XHR0aGlzLmZhciA9IHNvdXJjZS5mYXI7XG5cbiAgICBcdFx0dGhpcy56b29tID0gc291cmNlLnpvb207XG4gICAgXHRcdHRoaXMudmlldyA9IHNvdXJjZS52aWV3ID09PSBudWxsID8gbnVsbCA6IE9iamVjdC5hc3NpZ24oIHt9LCBzb3VyY2UudmlldyApO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRzZXRWaWV3T2Zmc2V0OiBmdW5jdGlvbiggZnVsbFdpZHRoLCBmdWxsSGVpZ2h0LCB4LCB5LCB3aWR0aCwgaGVpZ2h0ICkge1xuXG4gICAgXHRcdHRoaXMudmlldyA9IHtcbiAgICBcdFx0XHRmdWxsV2lkdGg6IGZ1bGxXaWR0aCxcbiAgICBcdFx0XHRmdWxsSGVpZ2h0OiBmdWxsSGVpZ2h0LFxuICAgIFx0XHRcdG9mZnNldFg6IHgsXG4gICAgXHRcdFx0b2Zmc2V0WTogeSxcbiAgICBcdFx0XHR3aWR0aDogd2lkdGgsXG4gICAgXHRcdFx0aGVpZ2h0OiBoZWlnaHRcbiAgICBcdFx0fTtcblxuICAgIFx0XHR0aGlzLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcblxuICAgIFx0fSxcblxuICAgIFx0Y2xlYXJWaWV3T2Zmc2V0OiBmdW5jdGlvbigpIHtcblxuICAgIFx0XHR0aGlzLnZpZXcgPSBudWxsO1xuICAgIFx0XHR0aGlzLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcblxuICAgIFx0fSxcblxuICAgIFx0dXBkYXRlUHJvamVjdGlvbk1hdHJpeDogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHZhciBkeCA9ICggdGhpcy5yaWdodCAtIHRoaXMubGVmdCApIC8gKCAyICogdGhpcy56b29tICk7XG4gICAgXHRcdHZhciBkeSA9ICggdGhpcy50b3AgLSB0aGlzLmJvdHRvbSApIC8gKCAyICogdGhpcy56b29tICk7XG4gICAgXHRcdHZhciBjeCA9ICggdGhpcy5yaWdodCArIHRoaXMubGVmdCApIC8gMjtcbiAgICBcdFx0dmFyIGN5ID0gKCB0aGlzLnRvcCArIHRoaXMuYm90dG9tICkgLyAyO1xuXG4gICAgXHRcdHZhciBsZWZ0ID0gY3ggLSBkeDtcbiAgICBcdFx0dmFyIHJpZ2h0ID0gY3ggKyBkeDtcbiAgICBcdFx0dmFyIHRvcCA9IGN5ICsgZHk7XG4gICAgXHRcdHZhciBib3R0b20gPSBjeSAtIGR5O1xuXG4gICAgXHRcdGlmICggdGhpcy52aWV3ICE9PSBudWxsICkge1xuXG4gICAgXHRcdFx0dmFyIHpvb21XID0gdGhpcy56b29tIC8gKCB0aGlzLnZpZXcud2lkdGggLyB0aGlzLnZpZXcuZnVsbFdpZHRoICk7XG4gICAgXHRcdFx0dmFyIHpvb21IID0gdGhpcy56b29tIC8gKCB0aGlzLnZpZXcuaGVpZ2h0IC8gdGhpcy52aWV3LmZ1bGxIZWlnaHQgKTtcbiAgICBcdFx0XHR2YXIgc2NhbGVXID0gKCB0aGlzLnJpZ2h0IC0gdGhpcy5sZWZ0ICkgLyB0aGlzLnZpZXcud2lkdGg7XG4gICAgXHRcdFx0dmFyIHNjYWxlSCA9ICggdGhpcy50b3AgLSB0aGlzLmJvdHRvbSApIC8gdGhpcy52aWV3LmhlaWdodDtcblxuICAgIFx0XHRcdGxlZnQgKz0gc2NhbGVXICogKCB0aGlzLnZpZXcub2Zmc2V0WCAvIHpvb21XICk7XG4gICAgXHRcdFx0cmlnaHQgPSBsZWZ0ICsgc2NhbGVXICogKCB0aGlzLnZpZXcud2lkdGggLyB6b29tVyApO1xuICAgIFx0XHRcdHRvcCAtPSBzY2FsZUggKiAoIHRoaXMudmlldy5vZmZzZXRZIC8gem9vbUggKTtcbiAgICBcdFx0XHRib3R0b20gPSB0b3AgLSBzY2FsZUggKiAoIHRoaXMudmlldy5oZWlnaHQgLyB6b29tSCApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHR0aGlzLnByb2plY3Rpb25NYXRyaXgubWFrZU9ydGhvZ3JhcGhpYyggbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tLCB0aGlzLm5lYXIsIHRoaXMuZmFyICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdHRvSlNPTjogZnVuY3Rpb24gKCBtZXRhICkge1xuXG4gICAgXHRcdHZhciBkYXRhID0gT2JqZWN0M0QucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzLCBtZXRhICk7XG5cbiAgICBcdFx0ZGF0YS5vYmplY3Quem9vbSA9IHRoaXMuem9vbTtcbiAgICBcdFx0ZGF0YS5vYmplY3QubGVmdCA9IHRoaXMubGVmdDtcbiAgICBcdFx0ZGF0YS5vYmplY3QucmlnaHQgPSB0aGlzLnJpZ2h0O1xuICAgIFx0XHRkYXRhLm9iamVjdC50b3AgPSB0aGlzLnRvcDtcbiAgICBcdFx0ZGF0YS5vYmplY3QuYm90dG9tID0gdGhpcy5ib3R0b207XG4gICAgXHRcdGRhdGEub2JqZWN0Lm5lYXIgPSB0aGlzLm5lYXI7XG4gICAgXHRcdGRhdGEub2JqZWN0LmZhciA9IHRoaXMuZmFyO1xuXG4gICAgXHRcdGlmICggdGhpcy52aWV3ICE9PSBudWxsICkgZGF0YS5vYmplY3QudmlldyA9IE9iamVjdC5hc3NpZ24oIHt9LCB0aGlzLnZpZXcgKTtcblxuICAgIFx0XHRyZXR1cm4gZGF0YTtcblxuICAgIFx0fVxuXG4gICAgfSApO1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIFdlYkdMSW5kZXhlZEJ1ZmZlclJlbmRlcmVyKCBnbCwgZXh0ZW5zaW9ucywgaW5mb1JlbmRlciApIHtcblxuICAgIFx0dmFyIG1vZGU7XG5cbiAgICBcdGZ1bmN0aW9uIHNldE1vZGUoIHZhbHVlICkge1xuXG4gICAgXHRcdG1vZGUgPSB2YWx1ZTtcblxuICAgIFx0fVxuXG4gICAgXHR2YXIgdHlwZSwgc2l6ZTtcblxuICAgIFx0ZnVuY3Rpb24gc2V0SW5kZXgoIGluZGV4ICkge1xuXG4gICAgXHRcdGlmICggaW5kZXguYXJyYXkgaW5zdGFuY2VvZiBVaW50MzJBcnJheSAmJiBleHRlbnNpb25zLmdldCggJ09FU19lbGVtZW50X2luZGV4X3VpbnQnICkgKSB7XG5cbiAgICBcdFx0XHR0eXBlID0gZ2wuVU5TSUdORURfSU5UO1xuICAgIFx0XHRcdHNpemUgPSA0O1xuXG4gICAgXHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHR0eXBlID0gZ2wuVU5TSUdORURfU0hPUlQ7XG4gICAgXHRcdFx0c2l6ZSA9IDI7XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9XG5cbiAgICBcdGZ1bmN0aW9uIHJlbmRlciggc3RhcnQsIGNvdW50ICkge1xuXG4gICAgXHRcdGdsLmRyYXdFbGVtZW50cyggbW9kZSwgY291bnQsIHR5cGUsIHN0YXJ0ICogc2l6ZSApO1xuXG4gICAgXHRcdGluZm9SZW5kZXIuY2FsbHMgKys7XG4gICAgXHRcdGluZm9SZW5kZXIudmVydGljZXMgKz0gY291bnQ7XG5cbiAgICBcdFx0aWYgKCBtb2RlID09PSBnbC5UUklBTkdMRVMgKSBpbmZvUmVuZGVyLmZhY2VzICs9IGNvdW50IC8gMztcblxuICAgIFx0fVxuXG4gICAgXHRmdW5jdGlvbiByZW5kZXJJbnN0YW5jZXMoIGdlb21ldHJ5LCBzdGFydCwgY291bnQgKSB7XG5cbiAgICBcdFx0dmFyIGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnQU5HTEVfaW5zdGFuY2VkX2FycmF5cycgKTtcblxuICAgIFx0XHRpZiAoIGV4dGVuc2lvbiA9PT0gbnVsbCApIHtcblxuICAgIFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTEJ1ZmZlclJlbmRlcmVyOiB1c2luZyBUSFJFRS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSBidXQgaGFyZHdhcmUgZG9lcyBub3Qgc3VwcG9ydCBleHRlbnNpb24gQU5HTEVfaW5zdGFuY2VkX2FycmF5cy4nICk7XG4gICAgXHRcdFx0cmV0dXJuO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRleHRlbnNpb24uZHJhd0VsZW1lbnRzSW5zdGFuY2VkQU5HTEUoIG1vZGUsIGNvdW50LCB0eXBlLCBzdGFydCAqIHNpemUsIGdlb21ldHJ5Lm1heEluc3RhbmNlZENvdW50ICk7XG5cbiAgICBcdFx0aW5mb1JlbmRlci5jYWxscyArKztcbiAgICBcdFx0aW5mb1JlbmRlci52ZXJ0aWNlcyArPSBjb3VudCAqIGdlb21ldHJ5Lm1heEluc3RhbmNlZENvdW50O1xuXG4gICAgXHRcdGlmICggbW9kZSA9PT0gZ2wuVFJJQU5HTEVTICkgaW5mb1JlbmRlci5mYWNlcyArPSBnZW9tZXRyeS5tYXhJbnN0YW5jZWRDb3VudCAqIGNvdW50IC8gMztcblxuICAgIFx0fVxuXG4gICAgXHRyZXR1cm4ge1xuXG4gICAgXHRcdHNldE1vZGU6IHNldE1vZGUsXG4gICAgXHRcdHNldEluZGV4OiBzZXRJbmRleCxcbiAgICBcdFx0cmVuZGVyOiByZW5kZXIsXG4gICAgXHRcdHJlbmRlckluc3RhbmNlczogcmVuZGVySW5zdGFuY2VzXG5cbiAgICBcdH07XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gV2ViR0xCdWZmZXJSZW5kZXJlciggZ2wsIGV4dGVuc2lvbnMsIGluZm9SZW5kZXIgKSB7XG5cbiAgICBcdHZhciBtb2RlO1xuXG4gICAgXHRmdW5jdGlvbiBzZXRNb2RlKCB2YWx1ZSApIHtcblxuICAgIFx0XHRtb2RlID0gdmFsdWU7XG5cbiAgICBcdH1cblxuICAgIFx0ZnVuY3Rpb24gcmVuZGVyKCBzdGFydCwgY291bnQgKSB7XG5cbiAgICBcdFx0Z2wuZHJhd0FycmF5cyggbW9kZSwgc3RhcnQsIGNvdW50ICk7XG5cbiAgICBcdFx0aW5mb1JlbmRlci5jYWxscyArKztcbiAgICBcdFx0aW5mb1JlbmRlci52ZXJ0aWNlcyArPSBjb3VudDtcblxuICAgIFx0XHRpZiAoIG1vZGUgPT09IGdsLlRSSUFOR0xFUyApIGluZm9SZW5kZXIuZmFjZXMgKz0gY291bnQgLyAzO1xuXG4gICAgXHR9XG5cbiAgICBcdGZ1bmN0aW9uIHJlbmRlckluc3RhbmNlcyggZ2VvbWV0cnkgKSB7XG5cbiAgICBcdFx0dmFyIGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnQU5HTEVfaW5zdGFuY2VkX2FycmF5cycgKTtcblxuICAgIFx0XHRpZiAoIGV4dGVuc2lvbiA9PT0gbnVsbCApIHtcblxuICAgIFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTEJ1ZmZlclJlbmRlcmVyOiB1c2luZyBUSFJFRS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSBidXQgaGFyZHdhcmUgZG9lcyBub3Qgc3VwcG9ydCBleHRlbnNpb24gQU5HTEVfaW5zdGFuY2VkX2FycmF5cy4nICk7XG4gICAgXHRcdFx0cmV0dXJuO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHR2YXIgcG9zaXRpb24gPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXG4gICAgXHRcdHZhciBjb3VudCA9IDA7XG5cbiAgICBcdFx0aWYgKCAocG9zaXRpb24gJiYgcG9zaXRpb24uaXNJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSkgKSB7XG5cbiAgICBcdFx0XHRjb3VudCA9IHBvc2l0aW9uLmRhdGEuY291bnQ7XG5cbiAgICBcdFx0XHRleHRlbnNpb24uZHJhd0FycmF5c0luc3RhbmNlZEFOR0xFKCBtb2RlLCAwLCBjb3VudCwgZ2VvbWV0cnkubWF4SW5zdGFuY2VkQ291bnQgKTtcblxuICAgIFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0Y291bnQgPSBwb3NpdGlvbi5jb3VudDtcblxuICAgIFx0XHRcdGV4dGVuc2lvbi5kcmF3QXJyYXlzSW5zdGFuY2VkQU5HTEUoIG1vZGUsIDAsIGNvdW50LCBnZW9tZXRyeS5tYXhJbnN0YW5jZWRDb3VudCApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRpbmZvUmVuZGVyLmNhbGxzICsrO1xuICAgIFx0XHRpbmZvUmVuZGVyLnZlcnRpY2VzICs9IGNvdW50ICogZ2VvbWV0cnkubWF4SW5zdGFuY2VkQ291bnQ7XG5cbiAgICBcdFx0aWYgKCBtb2RlID09PSBnbC5UUklBTkdMRVMgKSBpbmZvUmVuZGVyLmZhY2VzICs9IGdlb21ldHJ5Lm1heEluc3RhbmNlZENvdW50ICogY291bnQgLyAzO1xuXG4gICAgXHR9XG5cbiAgICBcdHJldHVybiB7XG4gICAgXHRcdHNldE1vZGU6IHNldE1vZGUsXG4gICAgXHRcdHJlbmRlcjogcmVuZGVyLFxuICAgIFx0XHRyZW5kZXJJbnN0YW5jZXM6IHJlbmRlckluc3RhbmNlc1xuICAgIFx0fTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIFdlYkdMTGlnaHRzKCkge1xuXG4gICAgXHR2YXIgbGlnaHRzID0ge307XG5cbiAgICBcdHJldHVybiB7XG5cbiAgICBcdFx0Z2V0OiBmdW5jdGlvbiAoIGxpZ2h0ICkge1xuXG4gICAgXHRcdFx0aWYgKCBsaWdodHNbIGxpZ2h0LmlkIF0gIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0cmV0dXJuIGxpZ2h0c1sgbGlnaHQuaWQgXTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdHZhciB1bmlmb3JtcztcblxuICAgIFx0XHRcdHN3aXRjaCAoIGxpZ2h0LnR5cGUgKSB7XG5cbiAgICBcdFx0XHRcdGNhc2UgJ0RpcmVjdGlvbmFsTGlnaHQnOlxuICAgIFx0XHRcdFx0XHR1bmlmb3JtcyA9IHtcbiAgICBcdFx0XHRcdFx0XHRkaXJlY3Rpb246IG5ldyBWZWN0b3IzKCksXG4gICAgXHRcdFx0XHRcdFx0Y29sb3I6IG5ldyBDb2xvcigpLFxuXG4gICAgXHRcdFx0XHRcdFx0c2hhZG93OiBmYWxzZSxcbiAgICBcdFx0XHRcdFx0XHRzaGFkb3dCaWFzOiAwLFxuICAgIFx0XHRcdFx0XHRcdHNoYWRvd1JhZGl1czogMSxcbiAgICBcdFx0XHRcdFx0XHRzaGFkb3dNYXBTaXplOiBuZXcgVmVjdG9yMigpXG4gICAgXHRcdFx0XHRcdH07XG4gICAgXHRcdFx0XHRcdGJyZWFrO1xuXG4gICAgXHRcdFx0XHRjYXNlICdTcG90TGlnaHQnOlxuICAgIFx0XHRcdFx0XHR1bmlmb3JtcyA9IHtcbiAgICBcdFx0XHRcdFx0XHRwb3NpdGlvbjogbmV3IFZlY3RvcjMoKSxcbiAgICBcdFx0XHRcdFx0XHRkaXJlY3Rpb246IG5ldyBWZWN0b3IzKCksXG4gICAgXHRcdFx0XHRcdFx0Y29sb3I6IG5ldyBDb2xvcigpLFxuICAgIFx0XHRcdFx0XHRcdGRpc3RhbmNlOiAwLFxuICAgIFx0XHRcdFx0XHRcdGNvbmVDb3M6IDAsXG4gICAgXHRcdFx0XHRcdFx0cGVudW1icmFDb3M6IDAsXG4gICAgXHRcdFx0XHRcdFx0ZGVjYXk6IDAsXG5cbiAgICBcdFx0XHRcdFx0XHRzaGFkb3c6IGZhbHNlLFxuICAgIFx0XHRcdFx0XHRcdHNoYWRvd0JpYXM6IDAsXG4gICAgXHRcdFx0XHRcdFx0c2hhZG93UmFkaXVzOiAxLFxuICAgIFx0XHRcdFx0XHRcdHNoYWRvd01hcFNpemU6IG5ldyBWZWN0b3IyKClcbiAgICBcdFx0XHRcdFx0fTtcbiAgICBcdFx0XHRcdFx0YnJlYWs7XG5cbiAgICBcdFx0XHRcdGNhc2UgJ1BvaW50TGlnaHQnOlxuICAgIFx0XHRcdFx0XHR1bmlmb3JtcyA9IHtcbiAgICBcdFx0XHRcdFx0XHRwb3NpdGlvbjogbmV3IFZlY3RvcjMoKSxcbiAgICBcdFx0XHRcdFx0XHRjb2xvcjogbmV3IENvbG9yKCksXG4gICAgXHRcdFx0XHRcdFx0ZGlzdGFuY2U6IDAsXG4gICAgXHRcdFx0XHRcdFx0ZGVjYXk6IDAsXG5cbiAgICBcdFx0XHRcdFx0XHRzaGFkb3c6IGZhbHNlLFxuICAgIFx0XHRcdFx0XHRcdHNoYWRvd0JpYXM6IDAsXG4gICAgXHRcdFx0XHRcdFx0c2hhZG93UmFkaXVzOiAxLFxuICAgIFx0XHRcdFx0XHRcdHNoYWRvd01hcFNpemU6IG5ldyBWZWN0b3IyKClcbiAgICBcdFx0XHRcdFx0fTtcbiAgICBcdFx0XHRcdFx0YnJlYWs7XG5cbiAgICBcdFx0XHRcdGNhc2UgJ0hlbWlzcGhlcmVMaWdodCc6XG4gICAgXHRcdFx0XHRcdHVuaWZvcm1zID0ge1xuICAgIFx0XHRcdFx0XHRcdGRpcmVjdGlvbjogbmV3IFZlY3RvcjMoKSxcbiAgICBcdFx0XHRcdFx0XHRza3lDb2xvcjogbmV3IENvbG9yKCksXG4gICAgXHRcdFx0XHRcdFx0Z3JvdW5kQ29sb3I6IG5ldyBDb2xvcigpXG4gICAgXHRcdFx0XHRcdH07XG4gICAgXHRcdFx0XHRcdGJyZWFrO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0bGlnaHRzWyBsaWdodC5pZCBdID0gdW5pZm9ybXM7XG5cbiAgICBcdFx0XHRyZXR1cm4gdW5pZm9ybXM7XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9O1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIGFkZExpbmVOdW1iZXJzKCBzdHJpbmcgKSB7XG5cbiAgICBcdHZhciBsaW5lcyA9IHN0cmluZy5zcGxpdCggJ1xcbicgKTtcblxuICAgIFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpICsrICkge1xuXG4gICAgXHRcdGxpbmVzWyBpIF0gPSAoIGkgKyAxICkgKyAnOiAnICsgbGluZXNbIGkgXTtcblxuICAgIFx0fVxuXG4gICAgXHRyZXR1cm4gbGluZXMuam9pbiggJ1xcbicgKTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIFdlYkdMU2hhZGVyKCBnbCwgdHlwZSwgc3RyaW5nICkge1xuXG4gICAgXHR2YXIgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKCB0eXBlICk7XG5cbiAgICBcdGdsLnNoYWRlclNvdXJjZSggc2hhZGVyLCBzdHJpbmcgKTtcbiAgICBcdGdsLmNvbXBpbGVTaGFkZXIoIHNoYWRlciApO1xuXG4gICAgXHRpZiAoIGdsLmdldFNoYWRlclBhcmFtZXRlciggc2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUyApID09PSBmYWxzZSApIHtcblxuICAgIFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xTaGFkZXI6IFNoYWRlciBjb3VsZG5cXCd0IGNvbXBpbGUuJyApO1xuXG4gICAgXHR9XG5cbiAgICBcdGlmICggZ2wuZ2V0U2hhZGVySW5mb0xvZyggc2hhZGVyICkgIT09ICcnICkge1xuXG4gICAgXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMU2hhZGVyOiBnbC5nZXRTaGFkZXJJbmZvTG9nKCknLCB0eXBlID09PSBnbC5WRVJURVhfU0hBREVSID8gJ3ZlcnRleCcgOiAnZnJhZ21lbnQnLCBnbC5nZXRTaGFkZXJJbmZvTG9nKCBzaGFkZXIgKSwgYWRkTGluZU51bWJlcnMoIHN0cmluZyApICk7XG5cbiAgICBcdH1cblxuICAgIFx0Ly8gLS1lbmFibGUtcHJpdmlsZWdlZC13ZWJnbC1leHRlbnNpb25cbiAgICBcdC8vIGNvbnNvbGUubG9nKCB0eXBlLCBnbC5nZXRFeHRlbnNpb24oICdXRUJHTF9kZWJ1Z19zaGFkZXJzJyApLmdldFRyYW5zbGF0ZWRTaGFkZXJTb3VyY2UoIHNoYWRlciApICk7XG5cbiAgICBcdHJldHVybiBzaGFkZXI7XG5cbiAgICB9XG5cbiAgICB2YXIgcHJvZ3JhbUlkQ291bnQgPSAwO1xuXG4gICAgZnVuY3Rpb24gZ2V0RW5jb2RpbmdDb21wb25lbnRzKCBlbmNvZGluZyApIHtcblxuICAgIFx0c3dpdGNoICggZW5jb2RpbmcgKSB7XG5cbiAgICBcdFx0Y2FzZSBMaW5lYXJFbmNvZGluZzpcbiAgICBcdFx0XHRyZXR1cm4gWyAnTGluZWFyJywnKCB2YWx1ZSApJyBdO1xuICAgIFx0XHRjYXNlIHNSR0JFbmNvZGluZzpcbiAgICBcdFx0XHRyZXR1cm4gWyAnc1JHQicsJyggdmFsdWUgKScgXTtcbiAgICBcdFx0Y2FzZSBSR0JFRW5jb2Rpbmc6XG4gICAgXHRcdFx0cmV0dXJuIFsgJ1JHQkUnLCcoIHZhbHVlICknIF07XG4gICAgXHRcdGNhc2UgUkdCTTdFbmNvZGluZzpcbiAgICBcdFx0XHRyZXR1cm4gWyAnUkdCTScsJyggdmFsdWUsIDcuMCApJyBdO1xuICAgIFx0XHRjYXNlIFJHQk0xNkVuY29kaW5nOlxuICAgIFx0XHRcdHJldHVybiBbICdSR0JNJywnKCB2YWx1ZSwgMTYuMCApJyBdO1xuICAgIFx0XHRjYXNlIFJHQkRFbmNvZGluZzpcbiAgICBcdFx0XHRyZXR1cm4gWyAnUkdCRCcsJyggdmFsdWUsIDI1Ni4wICknIF07XG4gICAgXHRcdGNhc2UgR2FtbWFFbmNvZGluZzpcbiAgICBcdFx0XHRyZXR1cm4gWyAnR2FtbWEnLCcoIHZhbHVlLCBmbG9hdCggR0FNTUFfRkFDVE9SICkgKScgXTtcbiAgICBcdFx0ZGVmYXVsdDpcbiAgICBcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICd1bnN1cHBvcnRlZCBlbmNvZGluZzogJyArIGVuY29kaW5nICk7XG5cbiAgICBcdH1cblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFRleGVsRGVjb2RpbmdGdW5jdGlvbiggZnVuY3Rpb25OYW1lLCBlbmNvZGluZyApIHtcblxuICAgIFx0dmFyIGNvbXBvbmVudHMgPSBnZXRFbmNvZGluZ0NvbXBvbmVudHMoIGVuY29kaW5nICk7XG4gICAgXHRyZXR1cm4gXCJ2ZWM0IFwiICsgZnVuY3Rpb25OYW1lICsgXCIoIHZlYzQgdmFsdWUgKSB7IHJldHVybiBcIiArIGNvbXBvbmVudHNbIDAgXSArIFwiVG9MaW5lYXJcIiArIGNvbXBvbmVudHNbIDEgXSArIFwiOyB9XCI7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRUZXhlbEVuY29kaW5nRnVuY3Rpb24oIGZ1bmN0aW9uTmFtZSwgZW5jb2RpbmcgKSB7XG5cbiAgICBcdHZhciBjb21wb25lbnRzID0gZ2V0RW5jb2RpbmdDb21wb25lbnRzKCBlbmNvZGluZyApO1xuICAgIFx0cmV0dXJuIFwidmVjNCBcIiArIGZ1bmN0aW9uTmFtZSArIFwiKCB2ZWM0IHZhbHVlICkgeyByZXR1cm4gTGluZWFyVG9cIiArIGNvbXBvbmVudHNbIDAgXSArIGNvbXBvbmVudHNbIDEgXSArIFwiOyB9XCI7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRUb25lTWFwcGluZ0Z1bmN0aW9uKCBmdW5jdGlvbk5hbWUsIHRvbmVNYXBwaW5nICkge1xuXG4gICAgXHR2YXIgdG9uZU1hcHBpbmdOYW1lO1xuXG4gICAgXHRzd2l0Y2ggKCB0b25lTWFwcGluZyApIHtcblxuICAgIFx0XHRjYXNlIExpbmVhclRvbmVNYXBwaW5nOlxuICAgIFx0XHRcdHRvbmVNYXBwaW5nTmFtZSA9IFwiTGluZWFyXCI7XG4gICAgXHRcdFx0YnJlYWs7XG5cbiAgICBcdFx0Y2FzZSBSZWluaGFyZFRvbmVNYXBwaW5nOlxuICAgIFx0XHRcdHRvbmVNYXBwaW5nTmFtZSA9IFwiUmVpbmhhcmRcIjtcbiAgICBcdFx0XHRicmVhaztcblxuICAgIFx0XHRjYXNlIFVuY2hhcnRlZDJUb25lTWFwcGluZzpcbiAgICBcdFx0XHR0b25lTWFwcGluZ05hbWUgPSBcIlVuY2hhcnRlZDJcIjtcbiAgICBcdFx0XHRicmVhaztcblxuICAgIFx0XHRjYXNlIENpbmVvblRvbmVNYXBwaW5nOlxuICAgIFx0XHRcdHRvbmVNYXBwaW5nTmFtZSA9IFwiT3B0aW1pemVkQ2luZW9uXCI7XG4gICAgXHRcdFx0YnJlYWs7XG5cbiAgICBcdFx0ZGVmYXVsdDpcbiAgICBcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICd1bnN1cHBvcnRlZCB0b25lTWFwcGluZzogJyArIHRvbmVNYXBwaW5nICk7XG5cbiAgICBcdH1cblxuICAgIFx0cmV0dXJuIFwidmVjMyBcIiArIGZ1bmN0aW9uTmFtZSArIFwiKCB2ZWMzIGNvbG9yICkgeyByZXR1cm4gXCIgKyB0b25lTWFwcGluZ05hbWUgKyBcIlRvbmVNYXBwaW5nKCBjb2xvciApOyB9XCI7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZUV4dGVuc2lvbnMoIGV4dGVuc2lvbnMsIHBhcmFtZXRlcnMsIHJlbmRlcmVyRXh0ZW5zaW9ucyApIHtcblxuICAgIFx0ZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnMgfHwge307XG5cbiAgICBcdHZhciBjaHVua3MgPSBbXG4gICAgXHRcdCggZXh0ZW5zaW9ucy5kZXJpdmF0aXZlcyB8fCBwYXJhbWV0ZXJzLmVudk1hcEN1YmVVViB8fCBwYXJhbWV0ZXJzLmJ1bXBNYXAgfHwgcGFyYW1ldGVycy5ub3JtYWxNYXAgfHwgcGFyYW1ldGVycy5mbGF0U2hhZGluZyApID8gJyNleHRlbnNpb24gR0xfT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzIDogZW5hYmxlJyA6ICcnLFxuICAgIFx0XHQoIGV4dGVuc2lvbnMuZnJhZ0RlcHRoIHx8IHBhcmFtZXRlcnMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciApICYmIHJlbmRlcmVyRXh0ZW5zaW9ucy5nZXQoICdFWFRfZnJhZ19kZXB0aCcgKSA/ICcjZXh0ZW5zaW9uIEdMX0VYVF9mcmFnX2RlcHRoIDogZW5hYmxlJyA6ICcnLFxuICAgIFx0XHQoIGV4dGVuc2lvbnMuZHJhd0J1ZmZlcnMgKSAmJiByZW5kZXJlckV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfZHJhd19idWZmZXJzJyApID8gJyNleHRlbnNpb24gR0xfRVhUX2RyYXdfYnVmZmVycyA6IHJlcXVpcmUnIDogJycsXG4gICAgXHRcdCggZXh0ZW5zaW9ucy5zaGFkZXJUZXh0dXJlTE9EIHx8IHBhcmFtZXRlcnMuZW52TWFwICkgJiYgcmVuZGVyZXJFeHRlbnNpb25zLmdldCggJ0VYVF9zaGFkZXJfdGV4dHVyZV9sb2QnICkgPyAnI2V4dGVuc2lvbiBHTF9FWFRfc2hhZGVyX3RleHR1cmVfbG9kIDogZW5hYmxlJyA6ICcnLFxuICAgIFx0XTtcblxuICAgIFx0cmV0dXJuIGNodW5rcy5maWx0ZXIoIGZpbHRlckVtcHR5TGluZSApLmpvaW4oICdcXG4nICk7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZURlZmluZXMoIGRlZmluZXMgKSB7XG5cbiAgICBcdHZhciBjaHVua3MgPSBbXTtcblxuICAgIFx0Zm9yICggdmFyIG5hbWUgaW4gZGVmaW5lcyApIHtcblxuICAgIFx0XHR2YXIgdmFsdWUgPSBkZWZpbmVzWyBuYW1lIF07XG5cbiAgICBcdFx0aWYgKCB2YWx1ZSA9PT0gZmFsc2UgKSBjb250aW51ZTtcblxuICAgIFx0XHRjaHVua3MucHVzaCggJyNkZWZpbmUgJyArIG5hbWUgKyAnICcgKyB2YWx1ZSApO1xuXG4gICAgXHR9XG5cbiAgICBcdHJldHVybiBjaHVua3Muam9pbiggJ1xcbicgKTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZldGNoQXR0cmlidXRlTG9jYXRpb25zKCBnbCwgcHJvZ3JhbSwgaWRlbnRpZmllcnMgKSB7XG5cbiAgICBcdHZhciBhdHRyaWJ1dGVzID0ge307XG5cbiAgICBcdHZhciBuID0gZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlciggcHJvZ3JhbSwgZ2wuQUNUSVZFX0FUVFJJQlVURVMgKTtcblxuICAgIFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbjsgaSArKyApIHtcblxuICAgIFx0XHR2YXIgaW5mbyA9IGdsLmdldEFjdGl2ZUF0dHJpYiggcHJvZ3JhbSwgaSApO1xuICAgIFx0XHR2YXIgbmFtZSA9IGluZm8ubmFtZTtcblxuICAgIFx0XHQvLyBjb25zb2xlLmxvZyhcIlRIUkVFLldlYkdMUHJvZ3JhbTogQUNUSVZFIFZFUlRFWCBBVFRSSUJVVEU6XCIsIG5hbWUsIGkgKTtcblxuICAgIFx0XHRhdHRyaWJ1dGVzWyBuYW1lIF0gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbiggcHJvZ3JhbSwgbmFtZSApO1xuXG4gICAgXHR9XG5cbiAgICBcdHJldHVybiBhdHRyaWJ1dGVzO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmlsdGVyRW1wdHlMaW5lKCBzdHJpbmcgKSB7XG5cbiAgICBcdHJldHVybiBzdHJpbmcgIT09ICcnO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVwbGFjZUxpZ2h0TnVtcyggc3RyaW5nLCBwYXJhbWV0ZXJzICkge1xuXG4gICAgXHRyZXR1cm4gc3RyaW5nXG4gICAgXHRcdC5yZXBsYWNlKCAvTlVNX0RJUl9MSUdIVFMvZywgcGFyYW1ldGVycy5udW1EaXJMaWdodHMgKVxuICAgIFx0XHQucmVwbGFjZSggL05VTV9TUE9UX0xJR0hUUy9nLCBwYXJhbWV0ZXJzLm51bVNwb3RMaWdodHMgKVxuICAgIFx0XHQucmVwbGFjZSggL05VTV9QT0lOVF9MSUdIVFMvZywgcGFyYW1ldGVycy5udW1Qb2ludExpZ2h0cyApXG4gICAgXHRcdC5yZXBsYWNlKCAvTlVNX0hFTUlfTElHSFRTL2csIHBhcmFtZXRlcnMubnVtSGVtaUxpZ2h0cyApO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VJbmNsdWRlcyggc3RyaW5nICkge1xuXG4gICAgXHR2YXIgcGF0dGVybiA9IC8jaW5jbHVkZSArPChbXFx3XFxkLl0rKT4vZztcblxuICAgIFx0ZnVuY3Rpb24gcmVwbGFjZSggbWF0Y2gsIGluY2x1ZGUgKSB7XG5cbiAgICBcdFx0dmFyIHJlcGxhY2UgPSBTaGFkZXJDaHVua1sgaW5jbHVkZSBdO1xuXG4gICAgXHRcdGlmICggcmVwbGFjZSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnQ2FuIG5vdCByZXNvbHZlICNpbmNsdWRlIDwnICsgaW5jbHVkZSArICc+JyApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gcGFyc2VJbmNsdWRlcyggcmVwbGFjZSApO1xuXG4gICAgXHR9XG5cbiAgICBcdHJldHVybiBzdHJpbmcucmVwbGFjZSggcGF0dGVybiwgcmVwbGFjZSApO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdW5yb2xsTG9vcHMoIHN0cmluZyApIHtcblxuICAgIFx0dmFyIHBhdHRlcm4gPSAvZm9yIFxcKCBpbnQgaSBcXD0gKFxcZCspXFw7IGkgPCAoXFxkKylcXDsgaSBcXCtcXCsgXFwpIFxceyhbXFxzXFxTXSs/KSg/PVxcfSlcXH0vZztcblxuICAgIFx0ZnVuY3Rpb24gcmVwbGFjZSggbWF0Y2gsIHN0YXJ0LCBlbmQsIHNuaXBwZXQgKSB7XG5cbiAgICBcdFx0dmFyIHVucm9sbCA9ICcnO1xuXG4gICAgXHRcdGZvciAoIHZhciBpID0gcGFyc2VJbnQoIHN0YXJ0ICk7IGkgPCBwYXJzZUludCggZW5kICk7IGkgKysgKSB7XG5cbiAgICBcdFx0XHR1bnJvbGwgKz0gc25pcHBldC5yZXBsYWNlKCAvXFxbIGkgXFxdL2csICdbICcgKyBpICsgJyBdJyApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gdW5yb2xsO1xuXG4gICAgXHR9XG5cbiAgICBcdHJldHVybiBzdHJpbmcucmVwbGFjZSggcGF0dGVybiwgcmVwbGFjZSApO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gV2ViR0xQcm9ncmFtKCByZW5kZXJlciwgY29kZSwgbWF0ZXJpYWwsIHBhcmFtZXRlcnMgKSB7XG5cbiAgICBcdHZhciBnbCA9IHJlbmRlcmVyLmNvbnRleHQ7XG5cbiAgICBcdHZhciBleHRlbnNpb25zID0gbWF0ZXJpYWwuZXh0ZW5zaW9ucztcbiAgICBcdHZhciBkZWZpbmVzID0gbWF0ZXJpYWwuZGVmaW5lcztcblxuICAgIFx0dmFyIHZlcnRleFNoYWRlciA9IG1hdGVyaWFsLl9fd2ViZ2xTaGFkZXIudmVydGV4U2hhZGVyO1xuICAgIFx0dmFyIGZyYWdtZW50U2hhZGVyID0gbWF0ZXJpYWwuX193ZWJnbFNoYWRlci5mcmFnbWVudFNoYWRlcjtcblxuICAgIFx0dmFyIHNoYWRvd01hcFR5cGVEZWZpbmUgPSAnU0hBRE9XTUFQX1RZUEVfQkFTSUMnO1xuXG4gICAgXHRpZiAoIHBhcmFtZXRlcnMuc2hhZG93TWFwVHlwZSA9PT0gUENGU2hhZG93TWFwICkge1xuXG4gICAgXHRcdHNoYWRvd01hcFR5cGVEZWZpbmUgPSAnU0hBRE9XTUFQX1RZUEVfUENGJztcblxuICAgIFx0fSBlbHNlIGlmICggcGFyYW1ldGVycy5zaGFkb3dNYXBUeXBlID09PSBQQ0ZTb2Z0U2hhZG93TWFwICkge1xuXG4gICAgXHRcdHNoYWRvd01hcFR5cGVEZWZpbmUgPSAnU0hBRE9XTUFQX1RZUEVfUENGX1NPRlQnO1xuXG4gICAgXHR9XG5cbiAgICBcdHZhciBlbnZNYXBUeXBlRGVmaW5lID0gJ0VOVk1BUF9UWVBFX0NVQkUnO1xuICAgIFx0dmFyIGVudk1hcE1vZGVEZWZpbmUgPSAnRU5WTUFQX01PREVfUkVGTEVDVElPTic7XG4gICAgXHR2YXIgZW52TWFwQmxlbmRpbmdEZWZpbmUgPSAnRU5WTUFQX0JMRU5ESU5HX01VTFRJUExZJztcblxuICAgIFx0aWYgKCBwYXJhbWV0ZXJzLmVudk1hcCApIHtcblxuICAgIFx0XHRzd2l0Y2ggKCBtYXRlcmlhbC5lbnZNYXAubWFwcGluZyApIHtcblxuICAgIFx0XHRcdGNhc2UgQ3ViZVJlZmxlY3Rpb25NYXBwaW5nOlxuICAgIFx0XHRcdGNhc2UgQ3ViZVJlZnJhY3Rpb25NYXBwaW5nOlxuICAgIFx0XHRcdFx0ZW52TWFwVHlwZURlZmluZSA9ICdFTlZNQVBfVFlQRV9DVUJFJztcbiAgICBcdFx0XHRcdGJyZWFrO1xuXG4gICAgXHRcdFx0Y2FzZSBDdWJlVVZSZWZsZWN0aW9uTWFwcGluZzpcbiAgICBcdFx0XHRjYXNlIEN1YmVVVlJlZnJhY3Rpb25NYXBwaW5nOlxuICAgIFx0XHRcdFx0ZW52TWFwVHlwZURlZmluZSA9ICdFTlZNQVBfVFlQRV9DVUJFX1VWJztcbiAgICBcdFx0XHRcdGJyZWFrO1xuXG4gICAgXHRcdFx0Y2FzZSBFcXVpcmVjdGFuZ3VsYXJSZWZsZWN0aW9uTWFwcGluZzpcbiAgICBcdFx0XHRjYXNlIEVxdWlyZWN0YW5ndWxhclJlZnJhY3Rpb25NYXBwaW5nOlxuICAgIFx0XHRcdFx0ZW52TWFwVHlwZURlZmluZSA9ICdFTlZNQVBfVFlQRV9FUVVJUkVDJztcbiAgICBcdFx0XHRcdGJyZWFrO1xuXG4gICAgXHRcdFx0Y2FzZSBTcGhlcmljYWxSZWZsZWN0aW9uTWFwcGluZzpcbiAgICBcdFx0XHRcdGVudk1hcFR5cGVEZWZpbmUgPSAnRU5WTUFQX1RZUEVfU1BIRVJFJztcbiAgICBcdFx0XHRcdGJyZWFrO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRzd2l0Y2ggKCBtYXRlcmlhbC5lbnZNYXAubWFwcGluZyApIHtcblxuICAgIFx0XHRcdGNhc2UgQ3ViZVJlZnJhY3Rpb25NYXBwaW5nOlxuICAgIFx0XHRcdGNhc2UgRXF1aXJlY3Rhbmd1bGFyUmVmcmFjdGlvbk1hcHBpbmc6XG4gICAgXHRcdFx0XHRlbnZNYXBNb2RlRGVmaW5lID0gJ0VOVk1BUF9NT0RFX1JFRlJBQ1RJT04nO1xuICAgIFx0XHRcdFx0YnJlYWs7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHN3aXRjaCAoIG1hdGVyaWFsLmNvbWJpbmUgKSB7XG5cbiAgICBcdFx0XHRjYXNlIE11bHRpcGx5T3BlcmF0aW9uOlxuICAgIFx0XHRcdFx0ZW52TWFwQmxlbmRpbmdEZWZpbmUgPSAnRU5WTUFQX0JMRU5ESU5HX01VTFRJUExZJztcbiAgICBcdFx0XHRcdGJyZWFrO1xuXG4gICAgXHRcdFx0Y2FzZSBNaXhPcGVyYXRpb246XG4gICAgXHRcdFx0XHRlbnZNYXBCbGVuZGluZ0RlZmluZSA9ICdFTlZNQVBfQkxFTkRJTkdfTUlYJztcbiAgICBcdFx0XHRcdGJyZWFrO1xuXG4gICAgXHRcdFx0Y2FzZSBBZGRPcGVyYXRpb246XG4gICAgXHRcdFx0XHRlbnZNYXBCbGVuZGluZ0RlZmluZSA9ICdFTlZNQVBfQkxFTkRJTkdfQUREJztcbiAgICBcdFx0XHRcdGJyZWFrO1xuXG4gICAgXHRcdH1cblxuICAgIFx0fVxuXG4gICAgXHR2YXIgZ2FtbWFGYWN0b3JEZWZpbmUgPSAoIHJlbmRlcmVyLmdhbW1hRmFjdG9yID4gMCApID8gcmVuZGVyZXIuZ2FtbWFGYWN0b3IgOiAxLjA7XG5cbiAgICBcdC8vIGNvbnNvbGUubG9nKCAnYnVpbGRpbmcgbmV3IHByb2dyYW0gJyApO1xuXG4gICAgXHQvL1xuXG4gICAgXHR2YXIgY3VzdG9tRXh0ZW5zaW9ucyA9IGdlbmVyYXRlRXh0ZW5zaW9ucyggZXh0ZW5zaW9ucywgcGFyYW1ldGVycywgcmVuZGVyZXIuZXh0ZW5zaW9ucyApO1xuXG4gICAgXHR2YXIgY3VzdG9tRGVmaW5lcyA9IGdlbmVyYXRlRGVmaW5lcyggZGVmaW5lcyApO1xuXG4gICAgXHQvL1xuXG4gICAgXHR2YXIgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcblxuICAgIFx0dmFyIHByZWZpeFZlcnRleCwgcHJlZml4RnJhZ21lbnQ7XG5cbiAgICBcdGlmICggbWF0ZXJpYWwuaXNSYXdTaGFkZXJNYXRlcmlhbCApIHtcblxuICAgIFx0XHRwcmVmaXhWZXJ0ZXggPSBbXG5cbiAgICBcdFx0XHRjdXN0b21EZWZpbmVzLFxuXG4gICAgXHRcdFx0J1xcbidcblxuICAgIFx0XHRdLmZpbHRlciggZmlsdGVyRW1wdHlMaW5lICkuam9pbiggJ1xcbicgKTtcblxuICAgIFx0XHRwcmVmaXhGcmFnbWVudCA9IFtcblxuICAgIFx0XHRcdGN1c3RvbUV4dGVuc2lvbnMsXG4gICAgXHRcdFx0Y3VzdG9tRGVmaW5lcyxcblxuICAgIFx0XHRcdCdcXG4nXG5cbiAgICBcdFx0XS5maWx0ZXIoIGZpbHRlckVtcHR5TGluZSApLmpvaW4oICdcXG4nICk7XG5cbiAgICBcdH0gZWxzZSB7XG5cbiAgICBcdFx0cHJlZml4VmVydGV4ID0gW1xuXG4gICAgXHRcdFx0J3ByZWNpc2lvbiAnICsgcGFyYW1ldGVycy5wcmVjaXNpb24gKyAnIGZsb2F0OycsXG4gICAgXHRcdFx0J3ByZWNpc2lvbiAnICsgcGFyYW1ldGVycy5wcmVjaXNpb24gKyAnIGludDsnLFxuXG4gICAgXHRcdFx0JyNkZWZpbmUgU0hBREVSX05BTUUgJyArIG1hdGVyaWFsLl9fd2ViZ2xTaGFkZXIubmFtZSxcblxuICAgIFx0XHRcdGN1c3RvbURlZmluZXMsXG5cbiAgICBcdFx0XHRwYXJhbWV0ZXJzLnN1cHBvcnRzVmVydGV4VGV4dHVyZXMgPyAnI2RlZmluZSBWRVJURVhfVEVYVFVSRVMnIDogJycsXG5cbiAgICBcdFx0XHQnI2RlZmluZSBHQU1NQV9GQUNUT1IgJyArIGdhbW1hRmFjdG9yRGVmaW5lLFxuXG4gICAgXHRcdFx0JyNkZWZpbmUgTUFYX0JPTkVTICcgKyBwYXJhbWV0ZXJzLm1heEJvbmVzLFxuXG4gICAgXHRcdFx0cGFyYW1ldGVycy5tYXAgPyAnI2RlZmluZSBVU0VfTUFQJyA6ICcnLFxuICAgIFx0XHRcdHBhcmFtZXRlcnMuZW52TWFwID8gJyNkZWZpbmUgVVNFX0VOVk1BUCcgOiAnJyxcbiAgICBcdFx0XHRwYXJhbWV0ZXJzLmVudk1hcCA/ICcjZGVmaW5lICcgKyBlbnZNYXBNb2RlRGVmaW5lIDogJycsXG4gICAgXHRcdFx0cGFyYW1ldGVycy5saWdodE1hcCA/ICcjZGVmaW5lIFVTRV9MSUdIVE1BUCcgOiAnJyxcbiAgICBcdFx0XHRwYXJhbWV0ZXJzLmFvTWFwID8gJyNkZWZpbmUgVVNFX0FPTUFQJyA6ICcnLFxuICAgIFx0XHRcdHBhcmFtZXRlcnMuZW1pc3NpdmVNYXAgPyAnI2RlZmluZSBVU0VfRU1JU1NJVkVNQVAnIDogJycsXG4gICAgXHRcdFx0cGFyYW1ldGVycy5idW1wTWFwID8gJyNkZWZpbmUgVVNFX0JVTVBNQVAnIDogJycsXG4gICAgXHRcdFx0cGFyYW1ldGVycy5ub3JtYWxNYXAgPyAnI2RlZmluZSBVU0VfTk9STUFMTUFQJyA6ICcnLFxuICAgIFx0XHRcdHBhcmFtZXRlcnMuZGlzcGxhY2VtZW50TWFwICYmIHBhcmFtZXRlcnMuc3VwcG9ydHNWZXJ0ZXhUZXh0dXJlcyA/ICcjZGVmaW5lIFVTRV9ESVNQTEFDRU1FTlRNQVAnIDogJycsXG4gICAgXHRcdFx0cGFyYW1ldGVycy5zcGVjdWxhck1hcCA/ICcjZGVmaW5lIFVTRV9TUEVDVUxBUk1BUCcgOiAnJyxcbiAgICBcdFx0XHRwYXJhbWV0ZXJzLnJvdWdobmVzc01hcCA/ICcjZGVmaW5lIFVTRV9ST1VHSE5FU1NNQVAnIDogJycsXG4gICAgXHRcdFx0cGFyYW1ldGVycy5tZXRhbG5lc3NNYXAgPyAnI2RlZmluZSBVU0VfTUVUQUxORVNTTUFQJyA6ICcnLFxuICAgIFx0XHRcdHBhcmFtZXRlcnMuYWxwaGFNYXAgPyAnI2RlZmluZSBVU0VfQUxQSEFNQVAnIDogJycsXG4gICAgXHRcdFx0cGFyYW1ldGVycy52ZXJ0ZXhDb2xvcnMgPyAnI2RlZmluZSBVU0VfQ09MT1InIDogJycsXG5cbiAgICBcdFx0XHRwYXJhbWV0ZXJzLmZsYXRTaGFkaW5nID8gJyNkZWZpbmUgRkxBVF9TSEFERUQnIDogJycsXG5cbiAgICBcdFx0XHRwYXJhbWV0ZXJzLnNraW5uaW5nID8gJyNkZWZpbmUgVVNFX1NLSU5OSU5HJyA6ICcnLFxuICAgIFx0XHRcdHBhcmFtZXRlcnMudXNlVmVydGV4VGV4dHVyZSA/ICcjZGVmaW5lIEJPTkVfVEVYVFVSRScgOiAnJyxcblxuICAgIFx0XHRcdHBhcmFtZXRlcnMubW9ycGhUYXJnZXRzID8gJyNkZWZpbmUgVVNFX01PUlBIVEFSR0VUUycgOiAnJyxcbiAgICBcdFx0XHRwYXJhbWV0ZXJzLm1vcnBoTm9ybWFscyAmJiBwYXJhbWV0ZXJzLmZsYXRTaGFkaW5nID09PSBmYWxzZSA/ICcjZGVmaW5lIFVTRV9NT1JQSE5PUk1BTFMnIDogJycsXG4gICAgXHRcdFx0cGFyYW1ldGVycy5kb3VibGVTaWRlZCA/ICcjZGVmaW5lIERPVUJMRV9TSURFRCcgOiAnJyxcbiAgICBcdFx0XHRwYXJhbWV0ZXJzLmZsaXBTaWRlZCA/ICcjZGVmaW5lIEZMSVBfU0lERUQnIDogJycsXG5cbiAgICBcdFx0XHQnI2RlZmluZSBOVU1fQ0xJUFBJTkdfUExBTkVTICcgKyBwYXJhbWV0ZXJzLm51bUNsaXBwaW5nUGxhbmVzLFxuXG4gICAgXHRcdFx0cGFyYW1ldGVycy5zaGFkb3dNYXBFbmFibGVkID8gJyNkZWZpbmUgVVNFX1NIQURPV01BUCcgOiAnJyxcbiAgICBcdFx0XHRwYXJhbWV0ZXJzLnNoYWRvd01hcEVuYWJsZWQgPyAnI2RlZmluZSAnICsgc2hhZG93TWFwVHlwZURlZmluZSA6ICcnLFxuXG4gICAgXHRcdFx0cGFyYW1ldGVycy5zaXplQXR0ZW51YXRpb24gPyAnI2RlZmluZSBVU0VfU0laRUFUVEVOVUFUSU9OJyA6ICcnLFxuXG4gICAgXHRcdFx0cGFyYW1ldGVycy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyID8gJyNkZWZpbmUgVVNFX0xPR0RFUFRIQlVGJyA6ICcnLFxuICAgIFx0XHRcdHBhcmFtZXRlcnMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciAmJiByZW5kZXJlci5leHRlbnNpb25zLmdldCggJ0VYVF9mcmFnX2RlcHRoJyApID8gJyNkZWZpbmUgVVNFX0xPR0RFUFRIQlVGX0VYVCcgOiAnJyxcblxuICAgIFx0XHRcdCd1bmlmb3JtIG1hdDQgbW9kZWxNYXRyaXg7JyxcbiAgICBcdFx0XHQndW5pZm9ybSBtYXQ0IG1vZGVsVmlld01hdHJpeDsnLFxuICAgIFx0XHRcdCd1bmlmb3JtIG1hdDQgcHJvamVjdGlvbk1hdHJpeDsnLFxuICAgIFx0XHRcdCd1bmlmb3JtIG1hdDQgdmlld01hdHJpeDsnLFxuICAgIFx0XHRcdCd1bmlmb3JtIG1hdDMgbm9ybWFsTWF0cml4OycsXG4gICAgXHRcdFx0J3VuaWZvcm0gdmVjMyBjYW1lcmFQb3NpdGlvbjsnLFxuXG4gICAgXHRcdFx0J2F0dHJpYnV0ZSB2ZWMzIHBvc2l0aW9uOycsXG4gICAgXHRcdFx0J2F0dHJpYnV0ZSB2ZWMzIG5vcm1hbDsnLFxuICAgIFx0XHRcdCdhdHRyaWJ1dGUgdmVjMiB1djsnLFxuXG4gICAgXHRcdFx0JyNpZmRlZiBVU0VfQ09MT1InLFxuXG4gICAgXHRcdFx0J1x0YXR0cmlidXRlIHZlYzMgY29sb3I7JyxcblxuICAgIFx0XHRcdCcjZW5kaWYnLFxuXG4gICAgXHRcdFx0JyNpZmRlZiBVU0VfTU9SUEhUQVJHRVRTJyxcblxuICAgIFx0XHRcdCdcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0MDsnLFxuICAgIFx0XHRcdCdcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0MTsnLFxuICAgIFx0XHRcdCdcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0MjsnLFxuICAgIFx0XHRcdCdcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0MzsnLFxuXG4gICAgXHRcdFx0J1x0I2lmZGVmIFVTRV9NT1JQSE5PUk1BTFMnLFxuXG4gICAgXHRcdFx0J1x0XHRhdHRyaWJ1dGUgdmVjMyBtb3JwaE5vcm1hbDA7JyxcbiAgICBcdFx0XHQnXHRcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoTm9ybWFsMTsnLFxuICAgIFx0XHRcdCdcdFx0YXR0cmlidXRlIHZlYzMgbW9ycGhOb3JtYWwyOycsXG4gICAgXHRcdFx0J1x0XHRhdHRyaWJ1dGUgdmVjMyBtb3JwaE5vcm1hbDM7JyxcblxuICAgIFx0XHRcdCdcdCNlbHNlJyxcblxuICAgIFx0XHRcdCdcdFx0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQ0OycsXG4gICAgXHRcdFx0J1x0XHRhdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDU7JyxcbiAgICBcdFx0XHQnXHRcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0NjsnLFxuICAgIFx0XHRcdCdcdFx0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQ3OycsXG5cbiAgICBcdFx0XHQnXHQjZW5kaWYnLFxuXG4gICAgXHRcdFx0JyNlbmRpZicsXG5cbiAgICBcdFx0XHQnI2lmZGVmIFVTRV9TS0lOTklORycsXG5cbiAgICBcdFx0XHQnXHRhdHRyaWJ1dGUgdmVjNCBza2luSW5kZXg7JyxcbiAgICBcdFx0XHQnXHRhdHRyaWJ1dGUgdmVjNCBza2luV2VpZ2h0OycsXG5cbiAgICBcdFx0XHQnI2VuZGlmJyxcblxuICAgIFx0XHRcdCdcXG4nXG5cbiAgICBcdFx0XS5maWx0ZXIoIGZpbHRlckVtcHR5TGluZSApLmpvaW4oICdcXG4nICk7XG5cbiAgICBcdFx0cHJlZml4RnJhZ21lbnQgPSBbXG5cbiAgICBcdFx0XHRjdXN0b21FeHRlbnNpb25zLFxuXG4gICAgXHRcdFx0J3ByZWNpc2lvbiAnICsgcGFyYW1ldGVycy5wcmVjaXNpb24gKyAnIGZsb2F0OycsXG4gICAgXHRcdFx0J3ByZWNpc2lvbiAnICsgcGFyYW1ldGVycy5wcmVjaXNpb24gKyAnIGludDsnLFxuXG4gICAgXHRcdFx0JyNkZWZpbmUgU0hBREVSX05BTUUgJyArIG1hdGVyaWFsLl9fd2ViZ2xTaGFkZXIubmFtZSxcblxuICAgIFx0XHRcdGN1c3RvbURlZmluZXMsXG5cbiAgICBcdFx0XHRwYXJhbWV0ZXJzLmFscGhhVGVzdCA/ICcjZGVmaW5lIEFMUEhBVEVTVCAnICsgcGFyYW1ldGVycy5hbHBoYVRlc3QgOiAnJyxcblxuICAgIFx0XHRcdCcjZGVmaW5lIEdBTU1BX0ZBQ1RPUiAnICsgZ2FtbWFGYWN0b3JEZWZpbmUsXG5cbiAgICBcdFx0XHQoIHBhcmFtZXRlcnMudXNlRm9nICYmIHBhcmFtZXRlcnMuZm9nICkgPyAnI2RlZmluZSBVU0VfRk9HJyA6ICcnLFxuICAgIFx0XHRcdCggcGFyYW1ldGVycy51c2VGb2cgJiYgcGFyYW1ldGVycy5mb2dFeHAgKSA/ICcjZGVmaW5lIEZPR19FWFAyJyA6ICcnLFxuXG4gICAgXHRcdFx0cGFyYW1ldGVycy5tYXAgPyAnI2RlZmluZSBVU0VfTUFQJyA6ICcnLFxuICAgIFx0XHRcdHBhcmFtZXRlcnMuZW52TWFwID8gJyNkZWZpbmUgVVNFX0VOVk1BUCcgOiAnJyxcbiAgICBcdFx0XHRwYXJhbWV0ZXJzLmVudk1hcCA/ICcjZGVmaW5lICcgKyBlbnZNYXBUeXBlRGVmaW5lIDogJycsXG4gICAgXHRcdFx0cGFyYW1ldGVycy5lbnZNYXAgPyAnI2RlZmluZSAnICsgZW52TWFwTW9kZURlZmluZSA6ICcnLFxuICAgIFx0XHRcdHBhcmFtZXRlcnMuZW52TWFwID8gJyNkZWZpbmUgJyArIGVudk1hcEJsZW5kaW5nRGVmaW5lIDogJycsXG4gICAgXHRcdFx0cGFyYW1ldGVycy5saWdodE1hcCA/ICcjZGVmaW5lIFVTRV9MSUdIVE1BUCcgOiAnJyxcbiAgICBcdFx0XHRwYXJhbWV0ZXJzLmFvTWFwID8gJyNkZWZpbmUgVVNFX0FPTUFQJyA6ICcnLFxuICAgIFx0XHRcdHBhcmFtZXRlcnMuZW1pc3NpdmVNYXAgPyAnI2RlZmluZSBVU0VfRU1JU1NJVkVNQVAnIDogJycsXG4gICAgXHRcdFx0cGFyYW1ldGVycy5idW1wTWFwID8gJyNkZWZpbmUgVVNFX0JVTVBNQVAnIDogJycsXG4gICAgXHRcdFx0cGFyYW1ldGVycy5ub3JtYWxNYXAgPyAnI2RlZmluZSBVU0VfTk9STUFMTUFQJyA6ICcnLFxuICAgIFx0XHRcdHBhcmFtZXRlcnMuc3BlY3VsYXJNYXAgPyAnI2RlZmluZSBVU0VfU1BFQ1VMQVJNQVAnIDogJycsXG4gICAgXHRcdFx0cGFyYW1ldGVycy5yb3VnaG5lc3NNYXAgPyAnI2RlZmluZSBVU0VfUk9VR0hORVNTTUFQJyA6ICcnLFxuICAgIFx0XHRcdHBhcmFtZXRlcnMubWV0YWxuZXNzTWFwID8gJyNkZWZpbmUgVVNFX01FVEFMTkVTU01BUCcgOiAnJyxcbiAgICBcdFx0XHRwYXJhbWV0ZXJzLmFscGhhTWFwID8gJyNkZWZpbmUgVVNFX0FMUEhBTUFQJyA6ICcnLFxuICAgIFx0XHRcdHBhcmFtZXRlcnMudmVydGV4Q29sb3JzID8gJyNkZWZpbmUgVVNFX0NPTE9SJyA6ICcnLFxuXG4gICAgXHRcdFx0cGFyYW1ldGVycy5mbGF0U2hhZGluZyA/ICcjZGVmaW5lIEZMQVRfU0hBREVEJyA6ICcnLFxuXG4gICAgXHRcdFx0cGFyYW1ldGVycy5kb3VibGVTaWRlZCA/ICcjZGVmaW5lIERPVUJMRV9TSURFRCcgOiAnJyxcbiAgICBcdFx0XHRwYXJhbWV0ZXJzLmZsaXBTaWRlZCA/ICcjZGVmaW5lIEZMSVBfU0lERUQnIDogJycsXG5cbiAgICBcdFx0XHQnI2RlZmluZSBOVU1fQ0xJUFBJTkdfUExBTkVTICcgKyBwYXJhbWV0ZXJzLm51bUNsaXBwaW5nUGxhbmVzLFxuXG4gICAgXHRcdFx0cGFyYW1ldGVycy5zaGFkb3dNYXBFbmFibGVkID8gJyNkZWZpbmUgVVNFX1NIQURPV01BUCcgOiAnJyxcbiAgICBcdFx0XHRwYXJhbWV0ZXJzLnNoYWRvd01hcEVuYWJsZWQgPyAnI2RlZmluZSAnICsgc2hhZG93TWFwVHlwZURlZmluZSA6ICcnLFxuXG4gICAgXHRcdFx0cGFyYW1ldGVycy5wcmVtdWx0aXBsaWVkQWxwaGEgPyBcIiNkZWZpbmUgUFJFTVVMVElQTElFRF9BTFBIQVwiIDogJycsXG5cbiAgICBcdFx0XHRwYXJhbWV0ZXJzLnBoeXNpY2FsbHlDb3JyZWN0TGlnaHRzID8gXCIjZGVmaW5lIFBIWVNJQ0FMTFlfQ09SUkVDVF9MSUdIVFNcIiA6ICcnLFxuXG4gICAgXHRcdFx0cGFyYW1ldGVycy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyID8gJyNkZWZpbmUgVVNFX0xPR0RFUFRIQlVGJyA6ICcnLFxuICAgIFx0XHRcdHBhcmFtZXRlcnMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciAmJiByZW5kZXJlci5leHRlbnNpb25zLmdldCggJ0VYVF9mcmFnX2RlcHRoJyApID8gJyNkZWZpbmUgVVNFX0xPR0RFUFRIQlVGX0VYVCcgOiAnJyxcblxuICAgIFx0XHRcdHBhcmFtZXRlcnMuZW52TWFwICYmIHJlbmRlcmVyLmV4dGVuc2lvbnMuZ2V0KCAnRVhUX3NoYWRlcl90ZXh0dXJlX2xvZCcgKSA/ICcjZGVmaW5lIFRFWFRVUkVfTE9EX0VYVCcgOiAnJyxcblxuICAgIFx0XHRcdCd1bmlmb3JtIG1hdDQgdmlld01hdHJpeDsnLFxuICAgIFx0XHRcdCd1bmlmb3JtIHZlYzMgY2FtZXJhUG9zaXRpb247JyxcblxuICAgIFx0XHRcdCggcGFyYW1ldGVycy50b25lTWFwcGluZyAhPT0gTm9Ub25lTWFwcGluZyApID8gXCIjZGVmaW5lIFRPTkVfTUFQUElOR1wiIDogJycsXG4gICAgXHRcdFx0KCBwYXJhbWV0ZXJzLnRvbmVNYXBwaW5nICE9PSBOb1RvbmVNYXBwaW5nICkgPyBTaGFkZXJDaHVua1sgJ3RvbmVtYXBwaW5nX3BhcnNfZnJhZ21lbnQnIF0gOiAnJywgIC8vIHRoaXMgY29kZSBpcyByZXF1aXJlZCBoZXJlIGJlY2F1c2UgaXQgaXMgdXNlZCBieSB0aGUgdG9uZU1hcHBpbmcoKSBmdW5jdGlvbiBkZWZpbmVkIGJlbG93XG4gICAgXHRcdFx0KCBwYXJhbWV0ZXJzLnRvbmVNYXBwaW5nICE9PSBOb1RvbmVNYXBwaW5nICkgPyBnZXRUb25lTWFwcGluZ0Z1bmN0aW9uKCBcInRvbmVNYXBwaW5nXCIsIHBhcmFtZXRlcnMudG9uZU1hcHBpbmcgKSA6ICcnLFxuXG4gICAgXHRcdFx0KCBwYXJhbWV0ZXJzLm91dHB1dEVuY29kaW5nIHx8IHBhcmFtZXRlcnMubWFwRW5jb2RpbmcgfHwgcGFyYW1ldGVycy5lbnZNYXBFbmNvZGluZyB8fCBwYXJhbWV0ZXJzLmVtaXNzaXZlTWFwRW5jb2RpbmcgKSA/IFNoYWRlckNodW5rWyAnZW5jb2RpbmdzX3BhcnNfZnJhZ21lbnQnIF0gOiAnJywgLy8gdGhpcyBjb2RlIGlzIHJlcXVpcmVkIGhlcmUgYmVjYXVzZSBpdCBpcyB1c2VkIGJ5IHRoZSB2YXJpb3VzIGVuY29kaW5nL2RlY29kaW5nIGZ1bmN0aW9uIGRlZmluZWQgYmVsb3dcbiAgICBcdFx0XHRwYXJhbWV0ZXJzLm1hcEVuY29kaW5nID8gZ2V0VGV4ZWxEZWNvZGluZ0Z1bmN0aW9uKCAnbWFwVGV4ZWxUb0xpbmVhcicsIHBhcmFtZXRlcnMubWFwRW5jb2RpbmcgKSA6ICcnLFxuICAgIFx0XHRcdHBhcmFtZXRlcnMuZW52TWFwRW5jb2RpbmcgPyBnZXRUZXhlbERlY29kaW5nRnVuY3Rpb24oICdlbnZNYXBUZXhlbFRvTGluZWFyJywgcGFyYW1ldGVycy5lbnZNYXBFbmNvZGluZyApIDogJycsXG4gICAgXHRcdFx0cGFyYW1ldGVycy5lbWlzc2l2ZU1hcEVuY29kaW5nID8gZ2V0VGV4ZWxEZWNvZGluZ0Z1bmN0aW9uKCAnZW1pc3NpdmVNYXBUZXhlbFRvTGluZWFyJywgcGFyYW1ldGVycy5lbWlzc2l2ZU1hcEVuY29kaW5nICkgOiAnJyxcbiAgICBcdFx0XHRwYXJhbWV0ZXJzLm91dHB1dEVuY29kaW5nID8gZ2V0VGV4ZWxFbmNvZGluZ0Z1bmN0aW9uKCBcImxpbmVhclRvT3V0cHV0VGV4ZWxcIiwgcGFyYW1ldGVycy5vdXRwdXRFbmNvZGluZyApIDogJycsXG5cbiAgICBcdFx0XHRwYXJhbWV0ZXJzLmRlcHRoUGFja2luZyA/IFwiI2RlZmluZSBERVBUSF9QQUNLSU5HIFwiICsgbWF0ZXJpYWwuZGVwdGhQYWNraW5nIDogJycsXG5cbiAgICBcdFx0XHQnXFxuJ1xuXG4gICAgXHRcdF0uZmlsdGVyKCBmaWx0ZXJFbXB0eUxpbmUgKS5qb2luKCAnXFxuJyApO1xuXG4gICAgXHR9XG5cbiAgICBcdHZlcnRleFNoYWRlciA9IHBhcnNlSW5jbHVkZXMoIHZlcnRleFNoYWRlciwgcGFyYW1ldGVycyApO1xuICAgIFx0dmVydGV4U2hhZGVyID0gcmVwbGFjZUxpZ2h0TnVtcyggdmVydGV4U2hhZGVyLCBwYXJhbWV0ZXJzICk7XG5cbiAgICBcdGZyYWdtZW50U2hhZGVyID0gcGFyc2VJbmNsdWRlcyggZnJhZ21lbnRTaGFkZXIsIHBhcmFtZXRlcnMgKTtcbiAgICBcdGZyYWdtZW50U2hhZGVyID0gcmVwbGFjZUxpZ2h0TnVtcyggZnJhZ21lbnRTaGFkZXIsIHBhcmFtZXRlcnMgKTtcblxuICAgIFx0aWYgKCAhIG1hdGVyaWFsLmlzU2hhZGVyTWF0ZXJpYWwgKSB7XG5cbiAgICBcdFx0dmVydGV4U2hhZGVyID0gdW5yb2xsTG9vcHMoIHZlcnRleFNoYWRlciApO1xuICAgIFx0XHRmcmFnbWVudFNoYWRlciA9IHVucm9sbExvb3BzKCBmcmFnbWVudFNoYWRlciApO1xuXG4gICAgXHR9XG5cbiAgICBcdHZhciB2ZXJ0ZXhHbHNsID0gcHJlZml4VmVydGV4ICsgdmVydGV4U2hhZGVyO1xuICAgIFx0dmFyIGZyYWdtZW50R2xzbCA9IHByZWZpeEZyYWdtZW50ICsgZnJhZ21lbnRTaGFkZXI7XG5cbiAgICBcdC8vIGNvbnNvbGUubG9nKCAnKlZFUlRFWConLCB2ZXJ0ZXhHbHNsICk7XG4gICAgXHQvLyBjb25zb2xlLmxvZyggJypGUkFHTUVOVConLCBmcmFnbWVudEdsc2wgKTtcblxuICAgIFx0dmFyIGdsVmVydGV4U2hhZGVyID0gV2ViR0xTaGFkZXIoIGdsLCBnbC5WRVJURVhfU0hBREVSLCB2ZXJ0ZXhHbHNsICk7XG4gICAgXHR2YXIgZ2xGcmFnbWVudFNoYWRlciA9IFdlYkdMU2hhZGVyKCBnbCwgZ2wuRlJBR01FTlRfU0hBREVSLCBmcmFnbWVudEdsc2wgKTtcblxuICAgIFx0Z2wuYXR0YWNoU2hhZGVyKCBwcm9ncmFtLCBnbFZlcnRleFNoYWRlciApO1xuICAgIFx0Z2wuYXR0YWNoU2hhZGVyKCBwcm9ncmFtLCBnbEZyYWdtZW50U2hhZGVyICk7XG5cbiAgICBcdC8vIEZvcmNlIGEgcGFydGljdWxhciBhdHRyaWJ1dGUgdG8gaW5kZXggMC5cblxuICAgIFx0aWYgKCBtYXRlcmlhbC5pbmRleDBBdHRyaWJ1dGVOYW1lICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0Z2wuYmluZEF0dHJpYkxvY2F0aW9uKCBwcm9ncmFtLCAwLCBtYXRlcmlhbC5pbmRleDBBdHRyaWJ1dGVOYW1lICk7XG5cbiAgICBcdH0gZWxzZSBpZiAoIHBhcmFtZXRlcnMubW9ycGhUYXJnZXRzID09PSB0cnVlICkge1xuXG4gICAgXHRcdC8vIHByb2dyYW1zIHdpdGggbW9ycGhUYXJnZXRzIGRpc3BsYWNlIHBvc2l0aW9uIG91dCBvZiBhdHRyaWJ1dGUgMFxuICAgIFx0XHRnbC5iaW5kQXR0cmliTG9jYXRpb24oIHByb2dyYW0sIDAsICdwb3NpdGlvbicgKTtcblxuICAgIFx0fVxuXG4gICAgXHRnbC5saW5rUHJvZ3JhbSggcHJvZ3JhbSApO1xuXG4gICAgXHR2YXIgcHJvZ3JhbUxvZyA9IGdsLmdldFByb2dyYW1JbmZvTG9nKCBwcm9ncmFtICk7XG4gICAgXHR2YXIgdmVydGV4TG9nID0gZ2wuZ2V0U2hhZGVySW5mb0xvZyggZ2xWZXJ0ZXhTaGFkZXIgKTtcbiAgICBcdHZhciBmcmFnbWVudExvZyA9IGdsLmdldFNoYWRlckluZm9Mb2coIGdsRnJhZ21lbnRTaGFkZXIgKTtcblxuICAgIFx0dmFyIHJ1bm5hYmxlID0gdHJ1ZTtcbiAgICBcdHZhciBoYXZlRGlhZ25vc3RpY3MgPSB0cnVlO1xuXG4gICAgXHQvLyBjb25zb2xlLmxvZyggJyoqVkVSVEVYKionLCBnbC5nZXRFeHRlbnNpb24oICdXRUJHTF9kZWJ1Z19zaGFkZXJzJyApLmdldFRyYW5zbGF0ZWRTaGFkZXJTb3VyY2UoIGdsVmVydGV4U2hhZGVyICkgKTtcbiAgICBcdC8vIGNvbnNvbGUubG9nKCAnKipGUkFHTUVOVCoqJywgZ2wuZ2V0RXh0ZW5zaW9uKCAnV0VCR0xfZGVidWdfc2hhZGVycycgKS5nZXRUcmFuc2xhdGVkU2hhZGVyU291cmNlKCBnbEZyYWdtZW50U2hhZGVyICkgKTtcblxuICAgIFx0aWYgKCBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKCBwcm9ncmFtLCBnbC5MSU5LX1NUQVRVUyApID09PSBmYWxzZSApIHtcblxuICAgIFx0XHRydW5uYWJsZSA9IGZhbHNlO1xuXG4gICAgXHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFByb2dyYW06IHNoYWRlciBlcnJvcjogJywgZ2wuZ2V0RXJyb3IoKSwgJ2dsLlZBTElEQVRFX1NUQVRVUycsIGdsLmdldFByb2dyYW1QYXJhbWV0ZXIoIHByb2dyYW0sIGdsLlZBTElEQVRFX1NUQVRVUyApLCAnZ2wuZ2V0UHJvZ3JhbUluZm9Mb2cnLCBwcm9ncmFtTG9nLCB2ZXJ0ZXhMb2csIGZyYWdtZW50TG9nICk7XG5cbiAgICBcdH0gZWxzZSBpZiAoIHByb2dyYW1Mb2cgIT09ICcnICkge1xuXG4gICAgXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUHJvZ3JhbTogZ2wuZ2V0UHJvZ3JhbUluZm9Mb2coKScsIHByb2dyYW1Mb2cgKTtcblxuICAgIFx0fSBlbHNlIGlmICggdmVydGV4TG9nID09PSAnJyB8fCBmcmFnbWVudExvZyA9PT0gJycgKSB7XG5cbiAgICBcdFx0aGF2ZURpYWdub3N0aWNzID0gZmFsc2U7XG5cbiAgICBcdH1cblxuICAgIFx0aWYgKCBoYXZlRGlhZ25vc3RpY3MgKSB7XG5cbiAgICBcdFx0dGhpcy5kaWFnbm9zdGljcyA9IHtcblxuICAgIFx0XHRcdHJ1bm5hYmxlOiBydW5uYWJsZSxcbiAgICBcdFx0XHRtYXRlcmlhbDogbWF0ZXJpYWwsXG5cbiAgICBcdFx0XHRwcm9ncmFtTG9nOiBwcm9ncmFtTG9nLFxuXG4gICAgXHRcdFx0dmVydGV4U2hhZGVyOiB7XG5cbiAgICBcdFx0XHRcdGxvZzogdmVydGV4TG9nLFxuICAgIFx0XHRcdFx0cHJlZml4OiBwcmVmaXhWZXJ0ZXhcblxuICAgIFx0XHRcdH0sXG5cbiAgICBcdFx0XHRmcmFnbWVudFNoYWRlcjoge1xuXG4gICAgXHRcdFx0XHRsb2c6IGZyYWdtZW50TG9nLFxuICAgIFx0XHRcdFx0cHJlZml4OiBwcmVmaXhGcmFnbWVudFxuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH07XG5cbiAgICBcdH1cblxuICAgIFx0Ly8gY2xlYW4gdXBcblxuICAgIFx0Z2wuZGVsZXRlU2hhZGVyKCBnbFZlcnRleFNoYWRlciApO1xuICAgIFx0Z2wuZGVsZXRlU2hhZGVyKCBnbEZyYWdtZW50U2hhZGVyICk7XG5cbiAgICBcdC8vIHNldCB1cCBjYWNoaW5nIGZvciB1bmlmb3JtIGxvY2F0aW9uc1xuXG4gICAgXHR2YXIgY2FjaGVkVW5pZm9ybXM7XG5cbiAgICBcdHRoaXMuZ2V0VW5pZm9ybXMgPSBmdW5jdGlvbigpIHtcblxuICAgIFx0XHRpZiAoIGNhY2hlZFVuaWZvcm1zID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRjYWNoZWRVbmlmb3JtcyA9XG4gICAgXHRcdFx0XHRcdG5ldyBXZWJHTFVuaWZvcm1zKCBnbCwgcHJvZ3JhbSwgcmVuZGVyZXIgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIGNhY2hlZFVuaWZvcm1zO1xuXG4gICAgXHR9O1xuXG4gICAgXHQvLyBzZXQgdXAgY2FjaGluZyBmb3IgYXR0cmlidXRlIGxvY2F0aW9uc1xuXG4gICAgXHR2YXIgY2FjaGVkQXR0cmlidXRlcztcblxuICAgIFx0dGhpcy5nZXRBdHRyaWJ1dGVzID0gZnVuY3Rpb24oKSB7XG5cbiAgICBcdFx0aWYgKCBjYWNoZWRBdHRyaWJ1dGVzID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRjYWNoZWRBdHRyaWJ1dGVzID0gZmV0Y2hBdHRyaWJ1dGVMb2NhdGlvbnMoIGdsLCBwcm9ncmFtICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiBjYWNoZWRBdHRyaWJ1dGVzO1xuXG4gICAgXHR9O1xuXG4gICAgXHQvLyBmcmVlIHJlc291cmNlXG5cbiAgICBcdHRoaXMuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgXHRcdGdsLmRlbGV0ZVByb2dyYW0oIHByb2dyYW0gKTtcbiAgICBcdFx0dGhpcy5wcm9ncmFtID0gdW5kZWZpbmVkO1xuXG4gICAgXHR9O1xuXG4gICAgXHQvLyBERVBSRUNBVEVEXG5cbiAgICBcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCB0aGlzLCB7XG5cbiAgICBcdFx0dW5pZm9ybXM6IHtcbiAgICBcdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFByb2dyYW06IC51bmlmb3JtcyBpcyBub3cgLmdldFVuaWZvcm1zKCkuJyApO1xuICAgIFx0XHRcdFx0cmV0dXJuIHRoaXMuZ2V0VW5pZm9ybXMoKTtcblxuICAgIFx0XHRcdH1cbiAgICBcdFx0fSxcblxuICAgIFx0XHRhdHRyaWJ1dGVzOiB7XG4gICAgXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblxuICAgIFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xQcm9ncmFtOiAuYXR0cmlidXRlcyBpcyBub3cgLmdldEF0dHJpYnV0ZXMoKS4nICk7XG4gICAgXHRcdFx0XHRyZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGVzKCk7XG5cbiAgICBcdFx0XHR9XG4gICAgXHRcdH1cblxuICAgIFx0fSApO1xuXG5cbiAgICBcdC8vXG5cbiAgICBcdHRoaXMuaWQgPSBwcm9ncmFtSWRDb3VudCArKztcbiAgICBcdHRoaXMuY29kZSA9IGNvZGU7XG4gICAgXHR0aGlzLnVzZWRUaW1lcyA9IDE7XG4gICAgXHR0aGlzLnByb2dyYW0gPSBwcm9ncmFtO1xuICAgIFx0dGhpcy52ZXJ0ZXhTaGFkZXIgPSBnbFZlcnRleFNoYWRlcjtcbiAgICBcdHRoaXMuZnJhZ21lbnRTaGFkZXIgPSBnbEZyYWdtZW50U2hhZGVyO1xuXG4gICAgXHRyZXR1cm4gdGhpcztcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIFdlYkdMUHJvZ3JhbXMoIHJlbmRlcmVyLCBjYXBhYmlsaXRpZXMgKSB7XG5cbiAgICBcdHZhciBwcm9ncmFtcyA9IFtdO1xuXG4gICAgXHR2YXIgc2hhZGVySURzID0ge1xuICAgIFx0XHRNZXNoRGVwdGhNYXRlcmlhbDogJ2RlcHRoJyxcbiAgICBcdFx0TWVzaE5vcm1hbE1hdGVyaWFsOiAnbm9ybWFsJyxcbiAgICBcdFx0TWVzaEJhc2ljTWF0ZXJpYWw6ICdiYXNpYycsXG4gICAgXHRcdE1lc2hMYW1iZXJ0TWF0ZXJpYWw6ICdsYW1iZXJ0JyxcbiAgICBcdFx0TWVzaFBob25nTWF0ZXJpYWw6ICdwaG9uZycsXG4gICAgXHRcdE1lc2hTdGFuZGFyZE1hdGVyaWFsOiAncGh5c2ljYWwnLFxuICAgIFx0XHRNZXNoUGh5c2ljYWxNYXRlcmlhbDogJ3BoeXNpY2FsJyxcbiAgICBcdFx0TGluZUJhc2ljTWF0ZXJpYWw6ICdiYXNpYycsXG4gICAgXHRcdExpbmVEYXNoZWRNYXRlcmlhbDogJ2Rhc2hlZCcsXG4gICAgXHRcdFBvaW50c01hdGVyaWFsOiAncG9pbnRzJ1xuICAgIFx0fTtcblxuICAgIFx0dmFyIHBhcmFtZXRlck5hbWVzID0gW1xuICAgIFx0XHRcInByZWNpc2lvblwiLCBcInN1cHBvcnRzVmVydGV4VGV4dHVyZXNcIiwgXCJtYXBcIiwgXCJtYXBFbmNvZGluZ1wiLCBcImVudk1hcFwiLCBcImVudk1hcE1vZGVcIiwgXCJlbnZNYXBFbmNvZGluZ1wiLFxuICAgIFx0XHRcImxpZ2h0TWFwXCIsIFwiYW9NYXBcIiwgXCJlbWlzc2l2ZU1hcFwiLCBcImVtaXNzaXZlTWFwRW5jb2RpbmdcIiwgXCJidW1wTWFwXCIsIFwibm9ybWFsTWFwXCIsIFwiZGlzcGxhY2VtZW50TWFwXCIsIFwic3BlY3VsYXJNYXBcIixcbiAgICBcdFx0XCJyb3VnaG5lc3NNYXBcIiwgXCJtZXRhbG5lc3NNYXBcIixcbiAgICBcdFx0XCJhbHBoYU1hcFwiLCBcImNvbWJpbmVcIiwgXCJ2ZXJ0ZXhDb2xvcnNcIiwgXCJmb2dcIiwgXCJ1c2VGb2dcIiwgXCJmb2dFeHBcIixcbiAgICBcdFx0XCJmbGF0U2hhZGluZ1wiLCBcInNpemVBdHRlbnVhdGlvblwiLCBcImxvZ2FyaXRobWljRGVwdGhCdWZmZXJcIiwgXCJza2lubmluZ1wiLFxuICAgIFx0XHRcIm1heEJvbmVzXCIsIFwidXNlVmVydGV4VGV4dHVyZVwiLCBcIm1vcnBoVGFyZ2V0c1wiLCBcIm1vcnBoTm9ybWFsc1wiLFxuICAgIFx0XHRcIm1heE1vcnBoVGFyZ2V0c1wiLCBcIm1heE1vcnBoTm9ybWFsc1wiLCBcInByZW11bHRpcGxpZWRBbHBoYVwiLFxuICAgIFx0XHRcIm51bURpckxpZ2h0c1wiLCBcIm51bVBvaW50TGlnaHRzXCIsIFwibnVtU3BvdExpZ2h0c1wiLCBcIm51bUhlbWlMaWdodHNcIixcbiAgICBcdFx0XCJzaGFkb3dNYXBFbmFibGVkXCIsIFwic2hhZG93TWFwVHlwZVwiLCBcInRvbmVNYXBwaW5nXCIsICdwaHlzaWNhbGx5Q29ycmVjdExpZ2h0cycsXG4gICAgXHRcdFwiYWxwaGFUZXN0XCIsIFwiZG91YmxlU2lkZWRcIiwgXCJmbGlwU2lkZWRcIiwgXCJudW1DbGlwcGluZ1BsYW5lc1wiLCBcImRlcHRoUGFja2luZ1wiXG4gICAgXHRdO1xuXG5cbiAgICBcdGZ1bmN0aW9uIGFsbG9jYXRlQm9uZXMoIG9iamVjdCApIHtcblxuICAgIFx0XHRpZiAoIGNhcGFiaWxpdGllcy5mbG9hdFZlcnRleFRleHR1cmVzICYmIG9iamVjdCAmJiBvYmplY3Quc2tlbGV0b24gJiYgb2JqZWN0LnNrZWxldG9uLnVzZVZlcnRleFRleHR1cmUgKSB7XG5cbiAgICBcdFx0XHRyZXR1cm4gMTAyNDtcblxuICAgIFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0Ly8gZGVmYXVsdCBmb3Igd2hlbiBvYmplY3QgaXMgbm90IHNwZWNpZmllZFxuICAgIFx0XHRcdC8vICggZm9yIGV4YW1wbGUgd2hlbiBwcmVidWlsZGluZyBzaGFkZXIgdG8gYmUgdXNlZCB3aXRoIG11bHRpcGxlIG9iamVjdHMgKVxuICAgIFx0XHRcdC8vXG4gICAgXHRcdFx0Ly8gIC0gbGVhdmUgc29tZSBleHRyYSBzcGFjZSBmb3Igb3RoZXIgdW5pZm9ybXNcbiAgICBcdFx0XHQvLyAgLSBsaW1pdCBoZXJlIGlzIEFOR0xFJ3MgMjU0IG1heCB1bmlmb3JtIHZlY3RvcnNcbiAgICBcdFx0XHQvLyAgICAodXAgdG8gNTQgc2hvdWxkIGJlIHNhZmUpXG5cbiAgICBcdFx0XHR2YXIgblZlcnRleFVuaWZvcm1zID0gY2FwYWJpbGl0aWVzLm1heFZlcnRleFVuaWZvcm1zO1xuICAgIFx0XHRcdHZhciBuVmVydGV4TWF0cmljZXMgPSBNYXRoLmZsb29yKCAoIG5WZXJ0ZXhVbmlmb3JtcyAtIDIwICkgLyA0ICk7XG5cbiAgICBcdFx0XHR2YXIgbWF4Qm9uZXMgPSBuVmVydGV4TWF0cmljZXM7XG5cbiAgICBcdFx0XHRpZiAoIG9iamVjdCAhPT0gdW5kZWZpbmVkICYmIChvYmplY3QgJiYgb2JqZWN0LmlzU2tpbm5lZE1lc2gpICkge1xuXG4gICAgXHRcdFx0XHRtYXhCb25lcyA9IE1hdGgubWluKCBvYmplY3Quc2tlbGV0b24uYm9uZXMubGVuZ3RoLCBtYXhCb25lcyApO1xuXG4gICAgXHRcdFx0XHRpZiAoIG1heEJvbmVzIDwgb2JqZWN0LnNrZWxldG9uLmJvbmVzLmxlbmd0aCApIHtcblxuICAgIFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdXZWJHTFJlbmRlcmVyOiB0b28gbWFueSBib25lcyAtICcgKyBvYmplY3Quc2tlbGV0b24uYm9uZXMubGVuZ3RoICsgJywgdGhpcyBHUFUgc3VwcG9ydHMganVzdCAnICsgbWF4Qm9uZXMgKyAnICh0cnkgT3BlbkdMIGluc3RlYWQgb2YgQU5HTEUpJyApO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRyZXR1cm4gbWF4Qm9uZXM7XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9XG5cbiAgICBcdGZ1bmN0aW9uIGdldFRleHR1cmVFbmNvZGluZ0Zyb21NYXAoIG1hcCwgZ2FtbWFPdmVycmlkZUxpbmVhciApIHtcblxuICAgIFx0XHR2YXIgZW5jb2Rpbmc7XG5cbiAgICBcdFx0aWYgKCAhIG1hcCApIHtcblxuICAgIFx0XHRcdGVuY29kaW5nID0gTGluZWFyRW5jb2Rpbmc7XG5cbiAgICBcdFx0fSBlbHNlIGlmICggKG1hcCAmJiBtYXAuaXNUZXh0dXJlKSApIHtcblxuICAgIFx0XHRcdGVuY29kaW5nID0gbWFwLmVuY29kaW5nO1xuXG4gICAgXHRcdH0gZWxzZSBpZiAoIChtYXAgJiYgbWFwLmlzV2ViR0xSZW5kZXJUYXJnZXQpICkge1xuXG4gICAgXHRcdFx0Y29uc29sZS53YXJuKCBcIlRIUkVFLldlYkdMUHJvZ3JhbXMuZ2V0VGV4dHVyZUVuY29kaW5nRnJvbU1hcDogZG9uJ3QgdXNlIHJlbmRlciB0YXJnZXRzIGFzIHRleHR1cmVzLiBVc2UgdGhlaXIgLnRleHR1cmUgcHJvcGVydHkgaW5zdGVhZC5cIiApO1xuICAgIFx0XHRcdGVuY29kaW5nID0gbWFwLnRleHR1cmUuZW5jb2Rpbmc7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdC8vIGFkZCBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBmb3IgV2ViR0xSZW5kZXJlci5nYW1tYUlucHV0L2dhbW1hT3V0cHV0IHBhcmFtZXRlciwgc2hvdWxkIHByb2JhYmx5IGJlIHJlbW92ZWQgYXQgc29tZSBwb2ludC5cbiAgICBcdFx0aWYgKCBlbmNvZGluZyA9PT0gTGluZWFyRW5jb2RpbmcgJiYgZ2FtbWFPdmVycmlkZUxpbmVhciApIHtcblxuICAgIFx0XHRcdGVuY29kaW5nID0gR2FtbWFFbmNvZGluZztcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIGVuY29kaW5nO1xuXG4gICAgXHR9XG5cbiAgICBcdHRoaXMuZ2V0UGFyYW1ldGVycyA9IGZ1bmN0aW9uICggbWF0ZXJpYWwsIGxpZ2h0cywgZm9nLCBuQ2xpcFBsYW5lcywgb2JqZWN0ICkge1xuXG4gICAgXHRcdHZhciBzaGFkZXJJRCA9IHNoYWRlcklEc1sgbWF0ZXJpYWwudHlwZSBdO1xuXG4gICAgXHRcdC8vIGhldXJpc3RpY3MgdG8gY3JlYXRlIHNoYWRlciBwYXJhbWV0ZXJzIGFjY29yZGluZyB0byBsaWdodHMgaW4gdGhlIHNjZW5lXG4gICAgXHRcdC8vIChub3QgdG8gYmxvdyBvdmVyIG1heExpZ2h0cyBidWRnZXQpXG5cbiAgICBcdFx0dmFyIG1heEJvbmVzID0gYWxsb2NhdGVCb25lcyggb2JqZWN0ICk7XG4gICAgXHRcdHZhciBwcmVjaXNpb24gPSByZW5kZXJlci5nZXRQcmVjaXNpb24oKTtcblxuICAgIFx0XHRpZiAoIG1hdGVyaWFsLnByZWNpc2lvbiAhPT0gbnVsbCApIHtcblxuICAgIFx0XHRcdHByZWNpc2lvbiA9IGNhcGFiaWxpdGllcy5nZXRNYXhQcmVjaXNpb24oIG1hdGVyaWFsLnByZWNpc2lvbiApO1xuXG4gICAgXHRcdFx0aWYgKCBwcmVjaXNpb24gIT09IG1hdGVyaWFsLnByZWNpc2lvbiApIHtcblxuICAgIFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xQcm9ncmFtLmdldFBhcmFtZXRlcnM6JywgbWF0ZXJpYWwucHJlY2lzaW9uLCAnbm90IHN1cHBvcnRlZCwgdXNpbmcnLCBwcmVjaXNpb24sICdpbnN0ZWFkLicgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdFx0dmFyIGN1cnJlbnRSZW5kZXJUYXJnZXQgPSByZW5kZXJlci5nZXRDdXJyZW50UmVuZGVyVGFyZ2V0KCk7XG5cbiAgICBcdFx0dmFyIHBhcmFtZXRlcnMgPSB7XG5cbiAgICBcdFx0XHRzaGFkZXJJRDogc2hhZGVySUQsXG5cbiAgICBcdFx0XHRwcmVjaXNpb246IHByZWNpc2lvbixcbiAgICBcdFx0XHRzdXBwb3J0c1ZlcnRleFRleHR1cmVzOiBjYXBhYmlsaXRpZXMudmVydGV4VGV4dHVyZXMsXG4gICAgXHRcdFx0b3V0cHV0RW5jb2Rpbmc6IGdldFRleHR1cmVFbmNvZGluZ0Zyb21NYXAoICggISBjdXJyZW50UmVuZGVyVGFyZ2V0ICkgPyBudWxsIDogY3VycmVudFJlbmRlclRhcmdldC50ZXh0dXJlLCByZW5kZXJlci5nYW1tYU91dHB1dCApLFxuICAgIFx0XHRcdG1hcDogISEgbWF0ZXJpYWwubWFwLFxuICAgIFx0XHRcdG1hcEVuY29kaW5nOiBnZXRUZXh0dXJlRW5jb2RpbmdGcm9tTWFwKCBtYXRlcmlhbC5tYXAsIHJlbmRlcmVyLmdhbW1hSW5wdXQgKSxcbiAgICBcdFx0XHRlbnZNYXA6ICEhIG1hdGVyaWFsLmVudk1hcCxcbiAgICBcdFx0XHRlbnZNYXBNb2RlOiBtYXRlcmlhbC5lbnZNYXAgJiYgbWF0ZXJpYWwuZW52TWFwLm1hcHBpbmcsXG4gICAgXHRcdFx0ZW52TWFwRW5jb2Rpbmc6IGdldFRleHR1cmVFbmNvZGluZ0Zyb21NYXAoIG1hdGVyaWFsLmVudk1hcCwgcmVuZGVyZXIuZ2FtbWFJbnB1dCApLFxuICAgIFx0XHRcdGVudk1hcEN1YmVVVjogKCAhISBtYXRlcmlhbC5lbnZNYXAgKSAmJiAoICggbWF0ZXJpYWwuZW52TWFwLm1hcHBpbmcgPT09IEN1YmVVVlJlZmxlY3Rpb25NYXBwaW5nICkgfHwgKCBtYXRlcmlhbC5lbnZNYXAubWFwcGluZyA9PT0gQ3ViZVVWUmVmcmFjdGlvbk1hcHBpbmcgKSApLFxuICAgIFx0XHRcdGxpZ2h0TWFwOiAhISBtYXRlcmlhbC5saWdodE1hcCxcbiAgICBcdFx0XHRhb01hcDogISEgbWF0ZXJpYWwuYW9NYXAsXG4gICAgXHRcdFx0ZW1pc3NpdmVNYXA6ICEhIG1hdGVyaWFsLmVtaXNzaXZlTWFwLFxuICAgIFx0XHRcdGVtaXNzaXZlTWFwRW5jb2Rpbmc6IGdldFRleHR1cmVFbmNvZGluZ0Zyb21NYXAoIG1hdGVyaWFsLmVtaXNzaXZlTWFwLCByZW5kZXJlci5nYW1tYUlucHV0ICksXG4gICAgXHRcdFx0YnVtcE1hcDogISEgbWF0ZXJpYWwuYnVtcE1hcCxcbiAgICBcdFx0XHRub3JtYWxNYXA6ICEhIG1hdGVyaWFsLm5vcm1hbE1hcCxcbiAgICBcdFx0XHRkaXNwbGFjZW1lbnRNYXA6ICEhIG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcCxcbiAgICBcdFx0XHRyb3VnaG5lc3NNYXA6ICEhIG1hdGVyaWFsLnJvdWdobmVzc01hcCxcbiAgICBcdFx0XHRtZXRhbG5lc3NNYXA6ICEhIG1hdGVyaWFsLm1ldGFsbmVzc01hcCxcbiAgICBcdFx0XHRzcGVjdWxhck1hcDogISEgbWF0ZXJpYWwuc3BlY3VsYXJNYXAsXG4gICAgXHRcdFx0YWxwaGFNYXA6ICEhIG1hdGVyaWFsLmFscGhhTWFwLFxuXG4gICAgXHRcdFx0Y29tYmluZTogbWF0ZXJpYWwuY29tYmluZSxcblxuICAgIFx0XHRcdHZlcnRleENvbG9yczogbWF0ZXJpYWwudmVydGV4Q29sb3JzLFxuXG4gICAgXHRcdFx0Zm9nOiAhISBmb2csXG4gICAgXHRcdFx0dXNlRm9nOiBtYXRlcmlhbC5mb2csXG4gICAgXHRcdFx0Zm9nRXhwOiAoZm9nICYmIGZvZy5pc0ZvZ0V4cDIpLFxuXG4gICAgXHRcdFx0ZmxhdFNoYWRpbmc6IG1hdGVyaWFsLnNoYWRpbmcgPT09IEZsYXRTaGFkaW5nLFxuXG4gICAgXHRcdFx0c2l6ZUF0dGVudWF0aW9uOiBtYXRlcmlhbC5zaXplQXR0ZW51YXRpb24sXG4gICAgXHRcdFx0bG9nYXJpdGhtaWNEZXB0aEJ1ZmZlcjogY2FwYWJpbGl0aWVzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIsXG5cbiAgICBcdFx0XHRza2lubmluZzogbWF0ZXJpYWwuc2tpbm5pbmcsXG4gICAgXHRcdFx0bWF4Qm9uZXM6IG1heEJvbmVzLFxuICAgIFx0XHRcdHVzZVZlcnRleFRleHR1cmU6IGNhcGFiaWxpdGllcy5mbG9hdFZlcnRleFRleHR1cmVzICYmIG9iamVjdCAmJiBvYmplY3Quc2tlbGV0b24gJiYgb2JqZWN0LnNrZWxldG9uLnVzZVZlcnRleFRleHR1cmUsXG5cbiAgICBcdFx0XHRtb3JwaFRhcmdldHM6IG1hdGVyaWFsLm1vcnBoVGFyZ2V0cyxcbiAgICBcdFx0XHRtb3JwaE5vcm1hbHM6IG1hdGVyaWFsLm1vcnBoTm9ybWFscyxcbiAgICBcdFx0XHRtYXhNb3JwaFRhcmdldHM6IHJlbmRlcmVyLm1heE1vcnBoVGFyZ2V0cyxcbiAgICBcdFx0XHRtYXhNb3JwaE5vcm1hbHM6IHJlbmRlcmVyLm1heE1vcnBoTm9ybWFscyxcblxuICAgIFx0XHRcdG51bURpckxpZ2h0czogbGlnaHRzLmRpcmVjdGlvbmFsLmxlbmd0aCxcbiAgICBcdFx0XHRudW1Qb2ludExpZ2h0czogbGlnaHRzLnBvaW50Lmxlbmd0aCxcbiAgICBcdFx0XHRudW1TcG90TGlnaHRzOiBsaWdodHMuc3BvdC5sZW5ndGgsXG4gICAgXHRcdFx0bnVtSGVtaUxpZ2h0czogbGlnaHRzLmhlbWkubGVuZ3RoLFxuXG4gICAgXHRcdFx0bnVtQ2xpcHBpbmdQbGFuZXM6IG5DbGlwUGxhbmVzLFxuXG4gICAgXHRcdFx0c2hhZG93TWFwRW5hYmxlZDogcmVuZGVyZXIuc2hhZG93TWFwLmVuYWJsZWQgJiYgb2JqZWN0LnJlY2VpdmVTaGFkb3cgJiYgbGlnaHRzLnNoYWRvd3MubGVuZ3RoID4gMCxcbiAgICBcdFx0XHRzaGFkb3dNYXBUeXBlOiByZW5kZXJlci5zaGFkb3dNYXAudHlwZSxcblxuICAgIFx0XHRcdHRvbmVNYXBwaW5nOiByZW5kZXJlci50b25lTWFwcGluZyxcbiAgICBcdFx0XHRwaHlzaWNhbGx5Q29ycmVjdExpZ2h0czogcmVuZGVyZXIucGh5c2ljYWxseUNvcnJlY3RMaWdodHMsXG5cbiAgICBcdFx0XHRwcmVtdWx0aXBsaWVkQWxwaGE6IG1hdGVyaWFsLnByZW11bHRpcGxpZWRBbHBoYSxcblxuICAgIFx0XHRcdGFscGhhVGVzdDogbWF0ZXJpYWwuYWxwaGFUZXN0LFxuICAgIFx0XHRcdGRvdWJsZVNpZGVkOiBtYXRlcmlhbC5zaWRlID09PSBEb3VibGVTaWRlLFxuICAgIFx0XHRcdGZsaXBTaWRlZDogbWF0ZXJpYWwuc2lkZSA9PT0gQmFja1NpZGUsXG5cbiAgICBcdFx0XHRkZXB0aFBhY2tpbmc6ICggbWF0ZXJpYWwuZGVwdGhQYWNraW5nICE9PSB1bmRlZmluZWQgKSA/IG1hdGVyaWFsLmRlcHRoUGFja2luZyA6IGZhbHNlXG5cbiAgICBcdFx0fTtcblxuICAgIFx0XHRyZXR1cm4gcGFyYW1ldGVycztcblxuICAgIFx0fTtcblxuICAgIFx0dGhpcy5nZXRQcm9ncmFtQ29kZSA9IGZ1bmN0aW9uICggbWF0ZXJpYWwsIHBhcmFtZXRlcnMgKSB7XG5cbiAgICBcdFx0dmFyIGFycmF5ID0gW107XG5cbiAgICBcdFx0aWYgKCBwYXJhbWV0ZXJzLnNoYWRlcklEICkge1xuXG4gICAgXHRcdFx0YXJyYXkucHVzaCggcGFyYW1ldGVycy5zaGFkZXJJRCApO1xuXG4gICAgXHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRhcnJheS5wdXNoKCBtYXRlcmlhbC5mcmFnbWVudFNoYWRlciApO1xuICAgIFx0XHRcdGFycmF5LnB1c2goIG1hdGVyaWFsLnZlcnRleFNoYWRlciApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRpZiAoIG1hdGVyaWFsLmRlZmluZXMgIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdGZvciAoIHZhciBuYW1lIGluIG1hdGVyaWFsLmRlZmluZXMgKSB7XG5cbiAgICBcdFx0XHRcdGFycmF5LnB1c2goIG5hbWUgKTtcbiAgICBcdFx0XHRcdGFycmF5LnB1c2goIG1hdGVyaWFsLmRlZmluZXNbIG5hbWUgXSApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBwYXJhbWV0ZXJOYW1lcy5sZW5ndGg7IGkgKysgKSB7XG5cbiAgICBcdFx0XHRhcnJheS5wdXNoKCBwYXJhbWV0ZXJzWyBwYXJhbWV0ZXJOYW1lc1sgaSBdIF0gKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIGFycmF5LmpvaW4oKTtcblxuICAgIFx0fTtcblxuICAgIFx0dGhpcy5hY3F1aXJlUHJvZ3JhbSA9IGZ1bmN0aW9uICggbWF0ZXJpYWwsIHBhcmFtZXRlcnMsIGNvZGUgKSB7XG5cbiAgICBcdFx0dmFyIHByb2dyYW07XG5cbiAgICBcdFx0Ly8gQ2hlY2sgaWYgY29kZSBoYXMgYmVlbiBhbHJlYWR5IGNvbXBpbGVkXG4gICAgXHRcdGZvciAoIHZhciBwID0gMCwgcGwgPSBwcm9ncmFtcy5sZW5ndGg7IHAgPCBwbDsgcCArKyApIHtcblxuICAgIFx0XHRcdHZhciBwcm9ncmFtSW5mbyA9IHByb2dyYW1zWyBwIF07XG5cbiAgICBcdFx0XHRpZiAoIHByb2dyYW1JbmZvLmNvZGUgPT09IGNvZGUgKSB7XG5cbiAgICBcdFx0XHRcdHByb2dyYW0gPSBwcm9ncmFtSW5mbztcbiAgICBcdFx0XHRcdCsrIHByb2dyYW0udXNlZFRpbWVzO1xuXG4gICAgXHRcdFx0XHRicmVhaztcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdFx0aWYgKCBwcm9ncmFtID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRwcm9ncmFtID0gbmV3IFdlYkdMUHJvZ3JhbSggcmVuZGVyZXIsIGNvZGUsIG1hdGVyaWFsLCBwYXJhbWV0ZXJzICk7XG4gICAgXHRcdFx0cHJvZ3JhbXMucHVzaCggcHJvZ3JhbSApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gcHJvZ3JhbTtcblxuICAgIFx0fTtcblxuICAgIFx0dGhpcy5yZWxlYXNlUHJvZ3JhbSA9IGZ1bmN0aW9uKCBwcm9ncmFtICkge1xuXG4gICAgXHRcdGlmICggLS0gcHJvZ3JhbS51c2VkVGltZXMgPT09IDAgKSB7XG5cbiAgICBcdFx0XHQvLyBSZW1vdmUgZnJvbSB1bm9yZGVyZWQgc2V0XG4gICAgXHRcdFx0dmFyIGkgPSBwcm9ncmFtcy5pbmRleE9mKCBwcm9ncmFtICk7XG4gICAgXHRcdFx0cHJvZ3JhbXNbIGkgXSA9IHByb2dyYW1zWyBwcm9ncmFtcy5sZW5ndGggLSAxIF07XG4gICAgXHRcdFx0cHJvZ3JhbXMucG9wKCk7XG5cbiAgICBcdFx0XHQvLyBGcmVlIFdlYkdMIHJlc291cmNlc1xuICAgIFx0XHRcdHByb2dyYW0uZGVzdHJveSgpO1xuXG4gICAgXHRcdH1cblxuICAgIFx0fTtcblxuICAgIFx0Ly8gRXhwb3NlZCBmb3IgcmVzb3VyY2UgbW9uaXRvcmluZyAmIGVycm9yIGZlZWRiYWNrIHZpYSByZW5kZXJlci5pbmZvOlxuICAgIFx0dGhpcy5wcm9ncmFtcyA9IHByb2dyYW1zO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gV2ViR0xHZW9tZXRyaWVzKCBnbCwgcHJvcGVydGllcywgaW5mbyApIHtcblxuICAgIFx0dmFyIGdlb21ldHJpZXMgPSB7fTtcblxuICAgIFx0ZnVuY3Rpb24gb25HZW9tZXRyeURpc3Bvc2UoIGV2ZW50ICkge1xuXG4gICAgXHRcdHZhciBnZW9tZXRyeSA9IGV2ZW50LnRhcmdldDtcbiAgICBcdFx0dmFyIGJ1ZmZlcmdlb21ldHJ5ID0gZ2VvbWV0cmllc1sgZ2VvbWV0cnkuaWQgXTtcblxuICAgIFx0XHRpZiAoIGJ1ZmZlcmdlb21ldHJ5LmluZGV4ICE9PSBudWxsICkge1xuXG4gICAgXHRcdFx0ZGVsZXRlQXR0cmlidXRlKCBidWZmZXJnZW9tZXRyeS5pbmRleCApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRkZWxldGVBdHRyaWJ1dGVzKCBidWZmZXJnZW9tZXRyeS5hdHRyaWJ1dGVzICk7XG5cbiAgICBcdFx0Z2VvbWV0cnkucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvbkdlb21ldHJ5RGlzcG9zZSApO1xuXG4gICAgXHRcdGRlbGV0ZSBnZW9tZXRyaWVzWyBnZW9tZXRyeS5pZCBdO1xuXG4gICAgXHRcdC8vIFRPRE9cblxuICAgIFx0XHR2YXIgcHJvcGVydHkgPSBwcm9wZXJ0aWVzLmdldCggZ2VvbWV0cnkgKTtcblxuICAgIFx0XHRpZiAoIHByb3BlcnR5LndpcmVmcmFtZSApIHtcblxuICAgIFx0XHRcdGRlbGV0ZUF0dHJpYnV0ZSggcHJvcGVydHkud2lyZWZyYW1lICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHByb3BlcnRpZXMuZGVsZXRlKCBnZW9tZXRyeSApO1xuXG4gICAgXHRcdHZhciBidWZmZXJwcm9wZXJ0eSA9IHByb3BlcnRpZXMuZ2V0KCBidWZmZXJnZW9tZXRyeSApO1xuXG4gICAgXHRcdGlmICggYnVmZmVycHJvcGVydHkud2lyZWZyYW1lICkge1xuXG4gICAgXHRcdFx0ZGVsZXRlQXR0cmlidXRlKCBidWZmZXJwcm9wZXJ0eS53aXJlZnJhbWUgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cHJvcGVydGllcy5kZWxldGUoIGJ1ZmZlcmdlb21ldHJ5ICk7XG5cbiAgICBcdFx0Ly9cblxuICAgIFx0XHRpbmZvLm1lbW9yeS5nZW9tZXRyaWVzIC0tO1xuXG4gICAgXHR9XG5cbiAgICBcdGZ1bmN0aW9uIGdldEF0dHJpYnV0ZUJ1ZmZlciggYXR0cmlidXRlICkge1xuXG4gICAgXHRcdGlmICggYXR0cmlidXRlLmlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgKSB7XG5cbiAgICBcdFx0XHRyZXR1cm4gcHJvcGVydGllcy5nZXQoIGF0dHJpYnV0ZS5kYXRhICkuX193ZWJnbEJ1ZmZlcjtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIHByb3BlcnRpZXMuZ2V0KCBhdHRyaWJ1dGUgKS5fX3dlYmdsQnVmZmVyO1xuXG4gICAgXHR9XG5cbiAgICBcdGZ1bmN0aW9uIGRlbGV0ZUF0dHJpYnV0ZSggYXR0cmlidXRlICkge1xuXG4gICAgXHRcdHZhciBidWZmZXIgPSBnZXRBdHRyaWJ1dGVCdWZmZXIoIGF0dHJpYnV0ZSApO1xuXG4gICAgXHRcdGlmICggYnVmZmVyICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRnbC5kZWxldGVCdWZmZXIoIGJ1ZmZlciApO1xuICAgIFx0XHRcdHJlbW92ZUF0dHJpYnV0ZUJ1ZmZlciggYXR0cmlidXRlICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9XG5cbiAgICBcdGZ1bmN0aW9uIGRlbGV0ZUF0dHJpYnV0ZXMoIGF0dHJpYnV0ZXMgKSB7XG5cbiAgICBcdFx0Zm9yICggdmFyIG5hbWUgaW4gYXR0cmlidXRlcyApIHtcblxuICAgIFx0XHRcdGRlbGV0ZUF0dHJpYnV0ZSggYXR0cmlidXRlc1sgbmFtZSBdICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9XG5cbiAgICBcdGZ1bmN0aW9uIHJlbW92ZUF0dHJpYnV0ZUJ1ZmZlciggYXR0cmlidXRlICkge1xuXG4gICAgXHRcdGlmICggYXR0cmlidXRlLmlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgKSB7XG5cbiAgICBcdFx0XHRwcm9wZXJ0aWVzLmRlbGV0ZSggYXR0cmlidXRlLmRhdGEgKTtcblxuICAgIFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0cHJvcGVydGllcy5kZWxldGUoIGF0dHJpYnV0ZSApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0fVxuXG4gICAgXHRyZXR1cm4ge1xuXG4gICAgXHRcdGdldDogZnVuY3Rpb24gKCBvYmplY3QgKSB7XG5cbiAgICBcdFx0XHR2YXIgZ2VvbWV0cnkgPSBvYmplY3QuZ2VvbWV0cnk7XG5cbiAgICBcdFx0XHRpZiAoIGdlb21ldHJpZXNbIGdlb21ldHJ5LmlkIF0gIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0cmV0dXJuIGdlb21ldHJpZXNbIGdlb21ldHJ5LmlkIF07XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRnZW9tZXRyeS5hZGRFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uR2VvbWV0cnlEaXNwb3NlICk7XG5cbiAgICBcdFx0XHR2YXIgYnVmZmVyZ2VvbWV0cnk7XG5cbiAgICBcdFx0XHRpZiAoIGdlb21ldHJ5LmlzQnVmZmVyR2VvbWV0cnkgKSB7XG5cbiAgICBcdFx0XHRcdGJ1ZmZlcmdlb21ldHJ5ID0gZ2VvbWV0cnk7XG5cbiAgICBcdFx0XHR9IGVsc2UgaWYgKCBnZW9tZXRyeS5pc0dlb21ldHJ5ICkge1xuXG4gICAgXHRcdFx0XHRpZiAoIGdlb21ldHJ5Ll9idWZmZXJHZW9tZXRyeSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0XHRcdGdlb21ldHJ5Ll9idWZmZXJHZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpLnNldEZyb21PYmplY3QoIG9iamVjdCApO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdGJ1ZmZlcmdlb21ldHJ5ID0gZ2VvbWV0cnkuX2J1ZmZlckdlb21ldHJ5O1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0Z2VvbWV0cmllc1sgZ2VvbWV0cnkuaWQgXSA9IGJ1ZmZlcmdlb21ldHJ5O1xuXG4gICAgXHRcdFx0aW5mby5tZW1vcnkuZ2VvbWV0cmllcyArKztcblxuICAgIFx0XHRcdHJldHVybiBidWZmZXJnZW9tZXRyeTtcblxuICAgIFx0XHR9XG5cbiAgICBcdH07XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBXZWJHTE9iamVjdHMoIGdsLCBwcm9wZXJ0aWVzLCBpbmZvICkge1xuXG4gICAgXHR2YXIgZ2VvbWV0cmllcyA9IG5ldyBXZWJHTEdlb21ldHJpZXMoIGdsLCBwcm9wZXJ0aWVzLCBpbmZvICk7XG5cbiAgICBcdC8vXG5cbiAgICBcdGZ1bmN0aW9uIHVwZGF0ZSggb2JqZWN0ICkge1xuXG4gICAgXHRcdC8vIFRPRE86IEF2b2lkIHVwZGF0aW5nIHR3aWNlICh3aGVuIHVzaW5nIHNoYWRvd01hcCkuIE1heWJlIGFkZCBmcmFtZSBjb3VudGVyLlxuXG4gICAgXHRcdHZhciBnZW9tZXRyeSA9IGdlb21ldHJpZXMuZ2V0KCBvYmplY3QgKTtcblxuICAgIFx0XHRpZiAoIG9iamVjdC5nZW9tZXRyeS5pc0dlb21ldHJ5ICkge1xuXG4gICAgXHRcdFx0Z2VvbWV0cnkudXBkYXRlRnJvbU9iamVjdCggb2JqZWN0ICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHZhciBpbmRleCA9IGdlb21ldHJ5LmluZGV4O1xuICAgIFx0XHR2YXIgYXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XG5cbiAgICBcdFx0aWYgKCBpbmRleCAhPT0gbnVsbCApIHtcblxuICAgIFx0XHRcdHVwZGF0ZUF0dHJpYnV0ZSggaW5kZXgsIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGZvciAoIHZhciBuYW1lIGluIGF0dHJpYnV0ZXMgKSB7XG5cbiAgICBcdFx0XHR1cGRhdGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXNbIG5hbWUgXSwgZ2wuQVJSQVlfQlVGRkVSICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdC8vIG1vcnBoIHRhcmdldHNcblxuICAgIFx0XHR2YXIgbW9ycGhBdHRyaWJ1dGVzID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzO1xuXG4gICAgXHRcdGZvciAoIHZhciBuYW1lIGluIG1vcnBoQXR0cmlidXRlcyApIHtcblxuICAgIFx0XHRcdHZhciBhcnJheSA9IG1vcnBoQXR0cmlidXRlc1sgbmFtZSBdO1xuXG4gICAgXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gYXJyYXkubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgIFx0XHRcdFx0dXBkYXRlQXR0cmlidXRlKCBhcnJheVsgaSBdLCBnbC5BUlJBWV9CVUZGRVIgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIGdlb21ldHJ5O1xuXG4gICAgXHR9XG5cbiAgICBcdGZ1bmN0aW9uIHVwZGF0ZUF0dHJpYnV0ZSggYXR0cmlidXRlLCBidWZmZXJUeXBlICkge1xuXG4gICAgXHRcdHZhciBkYXRhID0gKCBhdHRyaWJ1dGUuaXNJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSApID8gYXR0cmlidXRlLmRhdGEgOiBhdHRyaWJ1dGU7XG5cbiAgICBcdFx0dmFyIGF0dHJpYnV0ZVByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggZGF0YSApO1xuXG4gICAgXHRcdGlmICggYXR0cmlidXRlUHJvcGVydGllcy5fX3dlYmdsQnVmZmVyID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRjcmVhdGVCdWZmZXIoIGF0dHJpYnV0ZVByb3BlcnRpZXMsIGRhdGEsIGJ1ZmZlclR5cGUgKTtcblxuICAgIFx0XHR9IGVsc2UgaWYgKCBhdHRyaWJ1dGVQcm9wZXJ0aWVzLnZlcnNpb24gIT09IGRhdGEudmVyc2lvbiApIHtcblxuICAgIFx0XHRcdHVwZGF0ZUJ1ZmZlciggYXR0cmlidXRlUHJvcGVydGllcywgZGF0YSwgYnVmZmVyVHlwZSApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0fVxuXG4gICAgXHRmdW5jdGlvbiBjcmVhdGVCdWZmZXIoIGF0dHJpYnV0ZVByb3BlcnRpZXMsIGRhdGEsIGJ1ZmZlclR5cGUgKSB7XG5cbiAgICBcdFx0YXR0cmlidXRlUHJvcGVydGllcy5fX3dlYmdsQnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgXHRcdGdsLmJpbmRCdWZmZXIoIGJ1ZmZlclR5cGUsIGF0dHJpYnV0ZVByb3BlcnRpZXMuX193ZWJnbEJ1ZmZlciApO1xuXG4gICAgXHRcdHZhciB1c2FnZSA9IGRhdGEuZHluYW1pYyA/IGdsLkRZTkFNSUNfRFJBVyA6IGdsLlNUQVRJQ19EUkFXO1xuXG4gICAgXHRcdGdsLmJ1ZmZlckRhdGEoIGJ1ZmZlclR5cGUsIGRhdGEuYXJyYXksIHVzYWdlICk7XG5cbiAgICBcdFx0YXR0cmlidXRlUHJvcGVydGllcy52ZXJzaW9uID0gZGF0YS52ZXJzaW9uO1xuXG4gICAgXHR9XG5cbiAgICBcdGZ1bmN0aW9uIHVwZGF0ZUJ1ZmZlciggYXR0cmlidXRlUHJvcGVydGllcywgZGF0YSwgYnVmZmVyVHlwZSApIHtcblxuICAgIFx0XHRnbC5iaW5kQnVmZmVyKCBidWZmZXJUeXBlLCBhdHRyaWJ1dGVQcm9wZXJ0aWVzLl9fd2ViZ2xCdWZmZXIgKTtcblxuICAgIFx0XHRpZiAoIGRhdGEuZHluYW1pYyA9PT0gZmFsc2UgfHwgZGF0YS51cGRhdGVSYW5nZS5jb3VudCA9PT0gLSAxICkge1xuXG4gICAgXHRcdFx0Ly8gTm90IHVzaW5nIHVwZGF0ZSByYW5nZXNcblxuICAgIFx0XHRcdGdsLmJ1ZmZlclN1YkRhdGEoIGJ1ZmZlclR5cGUsIDAsIGRhdGEuYXJyYXkgKTtcblxuICAgIFx0XHR9IGVsc2UgaWYgKCBkYXRhLnVwZGF0ZVJhbmdlLmNvdW50ID09PSAwICkge1xuXG4gICAgXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMT2JqZWN0cy51cGRhdGVCdWZmZXI6IGR5bmFtaWMgVEhSRUUuQnVmZmVyQXR0cmlidXRlIG1hcmtlZCBhcyBuZWVkc1VwZGF0ZSBidXQgdXBkYXRlUmFuZ2UuY291bnQgaXMgMCwgZW5zdXJlIHlvdSBhcmUgdXNpbmcgc2V0IG1ldGhvZHMgb3IgdXBkYXRpbmcgbWFudWFsbHkuJyApO1xuXG4gICAgXHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRnbC5idWZmZXJTdWJEYXRhKCBidWZmZXJUeXBlLCBkYXRhLnVwZGF0ZVJhbmdlLm9mZnNldCAqIGRhdGEuYXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXG4gICAgXHRcdFx0XHRcdFx0XHQgIGRhdGEuYXJyYXkuc3ViYXJyYXkoIGRhdGEudXBkYXRlUmFuZ2Uub2Zmc2V0LCBkYXRhLnVwZGF0ZVJhbmdlLm9mZnNldCArIGRhdGEudXBkYXRlUmFuZ2UuY291bnQgKSApO1xuXG4gICAgXHRcdFx0ZGF0YS51cGRhdGVSYW5nZS5jb3VudCA9IDA7IC8vIHJlc2V0IHJhbmdlXG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGF0dHJpYnV0ZVByb3BlcnRpZXMudmVyc2lvbiA9IGRhdGEudmVyc2lvbjtcblxuICAgIFx0fVxuXG4gICAgXHRmdW5jdGlvbiBnZXRBdHRyaWJ1dGVCdWZmZXIoIGF0dHJpYnV0ZSApIHtcblxuICAgIFx0XHRpZiAoIGF0dHJpYnV0ZS5pc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlICkge1xuXG4gICAgXHRcdFx0cmV0dXJuIHByb3BlcnRpZXMuZ2V0KCBhdHRyaWJ1dGUuZGF0YSApLl9fd2ViZ2xCdWZmZXI7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiBwcm9wZXJ0aWVzLmdldCggYXR0cmlidXRlICkuX193ZWJnbEJ1ZmZlcjtcblxuICAgIFx0fVxuXG4gICAgXHRmdW5jdGlvbiBnZXRXaXJlZnJhbWVBdHRyaWJ1dGUoIGdlb21ldHJ5ICkge1xuXG4gICAgXHRcdHZhciBwcm9wZXJ0eSA9IHByb3BlcnRpZXMuZ2V0KCBnZW9tZXRyeSApO1xuXG4gICAgXHRcdGlmICggcHJvcGVydHkud2lyZWZyYW1lICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRyZXR1cm4gcHJvcGVydHkud2lyZWZyYW1lO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHR2YXIgaW5kaWNlcyA9IFtdO1xuXG4gICAgXHRcdHZhciBpbmRleCA9IGdlb21ldHJ5LmluZGV4O1xuICAgIFx0XHR2YXIgYXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XG4gICAgXHRcdHZhciBwb3NpdGlvbiA9IGF0dHJpYnV0ZXMucG9zaXRpb247XG5cbiAgICBcdFx0Ly8gY29uc29sZS50aW1lKCAnd2lyZWZyYW1lJyApO1xuXG4gICAgXHRcdGlmICggaW5kZXggIT09IG51bGwgKSB7XG5cbiAgICBcdFx0XHR2YXIgZWRnZXMgPSB7fTtcbiAgICBcdFx0XHR2YXIgYXJyYXkgPSBpbmRleC5hcnJheTtcblxuICAgIFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGw7IGkgKz0gMyApIHtcblxuICAgIFx0XHRcdFx0dmFyIGEgPSBhcnJheVsgaSArIDAgXTtcbiAgICBcdFx0XHRcdHZhciBiID0gYXJyYXlbIGkgKyAxIF07XG4gICAgXHRcdFx0XHR2YXIgYyA9IGFycmF5WyBpICsgMiBdO1xuXG4gICAgXHRcdFx0XHRpbmRpY2VzLnB1c2goIGEsIGIsIGIsIGMsIGMsIGEgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0dmFyIGFycmF5ID0gYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcblxuICAgIFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9ICggYXJyYXkubGVuZ3RoIC8gMyApIC0gMTsgaSA8IGw7IGkgKz0gMyApIHtcblxuICAgIFx0XHRcdFx0dmFyIGEgPSBpICsgMDtcbiAgICBcdFx0XHRcdHZhciBiID0gaSArIDE7XG4gICAgXHRcdFx0XHR2YXIgYyA9IGkgKyAyO1xuXG4gICAgXHRcdFx0XHRpbmRpY2VzLnB1c2goIGEsIGIsIGIsIGMsIGMsIGEgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdFx0Ly8gY29uc29sZS50aW1lRW5kKCAnd2lyZWZyYW1lJyApO1xuXG4gICAgXHRcdHZhciBUeXBlQXJyYXkgPSBwb3NpdGlvbi5jb3VudCA+IDY1NTM1ID8gVWludDMyQXJyYXkgOiBVaW50MTZBcnJheTtcbiAgICBcdFx0dmFyIGF0dHJpYnV0ZSA9IG5ldyBCdWZmZXJBdHRyaWJ1dGUoIG5ldyBUeXBlQXJyYXkoIGluZGljZXMgKSwgMSApO1xuXG4gICAgXHRcdHVwZGF0ZUF0dHJpYnV0ZSggYXR0cmlidXRlLCBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiApO1xuXG4gICAgXHRcdHByb3BlcnR5LndpcmVmcmFtZSA9IGF0dHJpYnV0ZTtcblxuICAgIFx0XHRyZXR1cm4gYXR0cmlidXRlO1xuXG4gICAgXHR9XG5cbiAgICBcdHJldHVybiB7XG5cbiAgICBcdFx0Z2V0QXR0cmlidXRlQnVmZmVyOiBnZXRBdHRyaWJ1dGVCdWZmZXIsXG4gICAgXHRcdGdldFdpcmVmcmFtZUF0dHJpYnV0ZTogZ2V0V2lyZWZyYW1lQXR0cmlidXRlLFxuXG4gICAgXHRcdHVwZGF0ZTogdXBkYXRlXG5cbiAgICBcdH07XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBXZWJHTFRleHR1cmVzKCBfZ2wsIGV4dGVuc2lvbnMsIHN0YXRlLCBwcm9wZXJ0aWVzLCBjYXBhYmlsaXRpZXMsIHBhcmFtVGhyZWVUb0dMLCBpbmZvICkge1xuXG4gICAgXHR2YXIgX2luZm9NZW1vcnkgPSBpbmZvLm1lbW9yeTtcbiAgICBcdHZhciBfaXNXZWJHTDIgPSAoIHR5cGVvZiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0ICE9PSAndW5kZWZpbmVkJyAmJiBfZ2wgaW5zdGFuY2VvZiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0ICk7XG5cbiAgICBcdC8vXG5cbiAgICBcdGZ1bmN0aW9uIGNsYW1wVG9NYXhTaXplKCBpbWFnZSwgbWF4U2l6ZSApIHtcblxuICAgIFx0XHRpZiAoIGltYWdlLndpZHRoID4gbWF4U2l6ZSB8fCBpbWFnZS5oZWlnaHQgPiBtYXhTaXplICkge1xuXG4gICAgXHRcdFx0Ly8gV2FybmluZzogU2NhbGluZyB0aHJvdWdoIHRoZSBjYW52YXMgd2lsbCBvbmx5IHdvcmsgd2l0aCBpbWFnZXMgdGhhdCB1c2VcbiAgICBcdFx0XHQvLyBwcmVtdWx0aXBsaWVkIGFscGhhLlxuXG4gICAgXHRcdFx0dmFyIHNjYWxlID0gbWF4U2l6ZSAvIE1hdGgubWF4KCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0ICk7XG5cbiAgICBcdFx0XHR2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCcsICdjYW52YXMnICk7XG4gICAgXHRcdFx0Y2FudmFzLndpZHRoID0gTWF0aC5mbG9vciggaW1hZ2Uud2lkdGggKiBzY2FsZSApO1xuICAgIFx0XHRcdGNhbnZhcy5oZWlnaHQgPSBNYXRoLmZsb29yKCBpbWFnZS5oZWlnaHQgKiBzY2FsZSApO1xuXG4gICAgXHRcdFx0dmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCggJzJkJyApO1xuICAgIFx0XHRcdGNvbnRleHQuZHJhd0ltYWdlKCBpbWFnZSwgMCwgMCwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCwgMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0ICk7XG5cbiAgICBcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBpbWFnZSBpcyB0b28gYmlnICgnICsgaW1hZ2Uud2lkdGggKyAneCcgKyBpbWFnZS5oZWlnaHQgKyAnKS4gUmVzaXplZCB0byAnICsgY2FudmFzLndpZHRoICsgJ3gnICsgY2FudmFzLmhlaWdodCwgaW1hZ2UgKTtcblxuICAgIFx0XHRcdHJldHVybiBjYW52YXM7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiBpbWFnZTtcblxuICAgIFx0fVxuXG4gICAgXHRmdW5jdGlvbiBpc1Bvd2VyT2ZUd28oIGltYWdlICkge1xuXG4gICAgXHRcdHJldHVybiBleHBvcnRzLk1hdGguaXNQb3dlck9mVHdvKCBpbWFnZS53aWR0aCApICYmIGV4cG9ydHMuTWF0aC5pc1Bvd2VyT2ZUd28oIGltYWdlLmhlaWdodCApO1xuXG4gICAgXHR9XG5cbiAgICBcdGZ1bmN0aW9uIG1ha2VQb3dlck9mVHdvKCBpbWFnZSApIHtcblxuICAgIFx0XHRpZiAoIGltYWdlIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCB8fCBpbWFnZSBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50ICkge1xuXG4gICAgXHRcdFx0dmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyggJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnLCAnY2FudmFzJyApO1xuICAgIFx0XHRcdGNhbnZhcy53aWR0aCA9IGV4cG9ydHMuTWF0aC5uZWFyZXN0UG93ZXJPZlR3byggaW1hZ2Uud2lkdGggKTtcbiAgICBcdFx0XHRjYW52YXMuaGVpZ2h0ID0gZXhwb3J0cy5NYXRoLm5lYXJlc3RQb3dlck9mVHdvKCBpbWFnZS5oZWlnaHQgKTtcblxuICAgIFx0XHRcdHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoICcyZCcgKTtcbiAgICBcdFx0XHRjb250ZXh0LmRyYXdJbWFnZSggaW1hZ2UsIDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCApO1xuXG4gICAgXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogaW1hZ2UgaXMgbm90IHBvd2VyIG9mIHR3byAoJyArIGltYWdlLndpZHRoICsgJ3gnICsgaW1hZ2UuaGVpZ2h0ICsgJykuIFJlc2l6ZWQgdG8gJyArIGNhbnZhcy53aWR0aCArICd4JyArIGNhbnZhcy5oZWlnaHQsIGltYWdlICk7XG5cbiAgICBcdFx0XHRyZXR1cm4gY2FudmFzO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gaW1hZ2U7XG5cbiAgICBcdH1cblxuICAgIFx0ZnVuY3Rpb24gdGV4dHVyZU5lZWRzUG93ZXJPZlR3byggdGV4dHVyZSApIHtcblxuICAgIFx0XHRpZiAoIHRleHR1cmUud3JhcFMgIT09IENsYW1wVG9FZGdlV3JhcHBpbmcgfHwgdGV4dHVyZS53cmFwVCAhPT0gQ2xhbXBUb0VkZ2VXcmFwcGluZyApIHJldHVybiB0cnVlO1xuICAgIFx0XHRpZiAoIHRleHR1cmUubWluRmlsdGVyICE9PSBOZWFyZXN0RmlsdGVyICYmIHRleHR1cmUubWluRmlsdGVyICE9PSBMaW5lYXJGaWx0ZXIgKSByZXR1cm4gdHJ1ZTtcblxuICAgIFx0XHRyZXR1cm4gZmFsc2U7XG5cbiAgICBcdH1cblxuICAgIFx0Ly8gRmFsbGJhY2sgZmlsdGVycyBmb3Igbm9uLXBvd2VyLW9mLTIgdGV4dHVyZXNcblxuICAgIFx0ZnVuY3Rpb24gZmlsdGVyRmFsbGJhY2soIGYgKSB7XG5cbiAgICBcdFx0aWYgKCBmID09PSBOZWFyZXN0RmlsdGVyIHx8IGYgPT09IE5lYXJlc3RNaXBNYXBOZWFyZXN0RmlsdGVyIHx8IGYgPT09IE5lYXJlc3RNaXBNYXBMaW5lYXJGaWx0ZXIgKSB7XG5cbiAgICBcdFx0XHRyZXR1cm4gX2dsLk5FQVJFU1Q7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiBfZ2wuTElORUFSO1xuXG4gICAgXHR9XG5cbiAgICBcdC8vXG5cbiAgICBcdGZ1bmN0aW9uIG9uVGV4dHVyZURpc3Bvc2UoIGV2ZW50ICkge1xuXG4gICAgXHRcdHZhciB0ZXh0dXJlID0gZXZlbnQudGFyZ2V0O1xuXG4gICAgXHRcdHRleHR1cmUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvblRleHR1cmVEaXNwb3NlICk7XG5cbiAgICBcdFx0ZGVhbGxvY2F0ZVRleHR1cmUoIHRleHR1cmUgKTtcblxuICAgIFx0XHRfaW5mb01lbW9yeS50ZXh0dXJlcyAtLTtcblxuXG4gICAgXHR9XG5cbiAgICBcdGZ1bmN0aW9uIG9uUmVuZGVyVGFyZ2V0RGlzcG9zZSggZXZlbnQgKSB7XG5cbiAgICBcdFx0dmFyIHJlbmRlclRhcmdldCA9IGV2ZW50LnRhcmdldDtcblxuICAgIFx0XHRyZW5kZXJUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvblJlbmRlclRhcmdldERpc3Bvc2UgKTtcblxuICAgIFx0XHRkZWFsbG9jYXRlUmVuZGVyVGFyZ2V0KCByZW5kZXJUYXJnZXQgKTtcblxuICAgIFx0XHRfaW5mb01lbW9yeS50ZXh0dXJlcyAtLTtcblxuICAgIFx0fVxuXG4gICAgXHQvL1xuXG4gICAgXHRmdW5jdGlvbiBkZWFsbG9jYXRlVGV4dHVyZSggdGV4dHVyZSApIHtcblxuICAgIFx0XHR2YXIgdGV4dHVyZVByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggdGV4dHVyZSApO1xuXG4gICAgXHRcdGlmICggdGV4dHVyZS5pbWFnZSAmJiB0ZXh0dXJlUHJvcGVydGllcy5fX2ltYWdlX193ZWJnbFRleHR1cmVDdWJlICkge1xuXG4gICAgXHRcdFx0Ly8gY3ViZSB0ZXh0dXJlXG5cbiAgICBcdFx0XHRfZ2wuZGVsZXRlVGV4dHVyZSggdGV4dHVyZVByb3BlcnRpZXMuX19pbWFnZV9fd2ViZ2xUZXh0dXJlQ3ViZSApO1xuXG4gICAgXHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHQvLyAyRCB0ZXh0dXJlXG5cbiAgICBcdFx0XHRpZiAoIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xJbml0ID09PSB1bmRlZmluZWQgKSByZXR1cm47XG5cbiAgICBcdFx0XHRfZ2wuZGVsZXRlVGV4dHVyZSggdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0Ly8gcmVtb3ZlIGFsbCB3ZWJnbCBwcm9wZXJ0aWVzXG4gICAgXHRcdHByb3BlcnRpZXMuZGVsZXRlKCB0ZXh0dXJlICk7XG5cbiAgICBcdH1cblxuICAgIFx0ZnVuY3Rpb24gZGVhbGxvY2F0ZVJlbmRlclRhcmdldCggcmVuZGVyVGFyZ2V0ICkge1xuXG4gICAgXHRcdHZhciByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIHJlbmRlclRhcmdldCApO1xuICAgIFx0XHR2YXIgdGV4dHVyZVByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0LnRleHR1cmUgKTtcblxuICAgIFx0XHRpZiAoICEgcmVuZGVyVGFyZ2V0ICkgcmV0dXJuO1xuXG4gICAgXHRcdGlmICggdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUgIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdF9nbC5kZWxldGVUZXh0dXJlKCB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRpZiAoIHJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUgKSB7XG5cbiAgICBcdFx0XHRyZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlLmRpc3Bvc2UoKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0aWYgKCAocmVuZGVyVGFyZ2V0ICYmIHJlbmRlclRhcmdldC5pc1dlYkdMUmVuZGVyVGFyZ2V0Q3ViZSkgKSB7XG5cbiAgICBcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCA2OyBpICsrICkge1xuXG4gICAgXHRcdFx0XHRfZ2wuZGVsZXRlRnJhbWVidWZmZXIoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyWyBpIF0gKTtcbiAgICBcdFx0XHRcdGlmICggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRGVwdGhidWZmZXIgKSBfZ2wuZGVsZXRlUmVuZGVyYnVmZmVyKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xEZXB0aGJ1ZmZlclsgaSBdICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdF9nbC5kZWxldGVGcmFtZWJ1ZmZlciggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXIgKTtcbiAgICBcdFx0XHRpZiAoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbERlcHRoYnVmZmVyICkgX2dsLmRlbGV0ZVJlbmRlcmJ1ZmZlciggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRGVwdGhidWZmZXIgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cHJvcGVydGllcy5kZWxldGUoIHJlbmRlclRhcmdldC50ZXh0dXJlICk7XG4gICAgXHRcdHByb3BlcnRpZXMuZGVsZXRlKCByZW5kZXJUYXJnZXQgKTtcblxuICAgIFx0fVxuXG4gICAgXHQvL1xuXG5cblxuICAgIFx0ZnVuY3Rpb24gc2V0VGV4dHVyZTJEKCB0ZXh0dXJlLCBzbG90ICkge1xuXG4gICAgXHRcdHZhciB0ZXh0dXJlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCB0ZXh0dXJlICk7XG5cbiAgICBcdFx0aWYgKCB0ZXh0dXJlLnZlcnNpb24gPiAwICYmIHRleHR1cmVQcm9wZXJ0aWVzLl9fdmVyc2lvbiAhPT0gdGV4dHVyZS52ZXJzaW9uICkge1xuXG4gICAgXHRcdFx0dmFyIGltYWdlID0gdGV4dHVyZS5pbWFnZTtcblxuICAgIFx0XHRcdGlmICggaW1hZ2UgPT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogVGV4dHVyZSBtYXJrZWQgZm9yIHVwZGF0ZSBidXQgaW1hZ2UgaXMgdW5kZWZpbmVkJywgdGV4dHVyZSApO1xuXG4gICAgXHRcdFx0fSBlbHNlIGlmICggaW1hZ2UuY29tcGxldGUgPT09IGZhbHNlICkge1xuXG4gICAgXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBUZXh0dXJlIG1hcmtlZCBmb3IgdXBkYXRlIGJ1dCBpbWFnZSBpcyBpbmNvbXBsZXRlJywgdGV4dHVyZSApO1xuXG4gICAgXHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0dXBsb2FkVGV4dHVyZSggdGV4dHVyZVByb3BlcnRpZXMsIHRleHR1cmUsIHNsb3QgKTtcbiAgICBcdFx0XHRcdHJldHVybjtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdFx0c3RhdGUuYWN0aXZlVGV4dHVyZSggX2dsLlRFWFRVUkUwICsgc2xvdCApO1xuICAgIFx0XHRzdGF0ZS5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfMkQsIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlICk7XG5cbiAgICBcdH1cblxuICAgIFx0ZnVuY3Rpb24gc2V0VGV4dHVyZUN1YmUoIHRleHR1cmUsIHNsb3QgKSB7XG5cbiAgICBcdFx0dmFyIHRleHR1cmVQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIHRleHR1cmUgKTtcblxuICAgIFx0XHRpZiAoIHRleHR1cmUuaW1hZ2UubGVuZ3RoID09PSA2ICkge1xuXG4gICAgXHRcdFx0aWYgKCB0ZXh0dXJlLnZlcnNpb24gPiAwICYmIHRleHR1cmVQcm9wZXJ0aWVzLl9fdmVyc2lvbiAhPT0gdGV4dHVyZS52ZXJzaW9uICkge1xuXG4gICAgXHRcdFx0XHRpZiAoICEgdGV4dHVyZVByb3BlcnRpZXMuX19pbWFnZV9fd2ViZ2xUZXh0dXJlQ3ViZSApIHtcblxuICAgIFx0XHRcdFx0XHR0ZXh0dXJlLmFkZEV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25UZXh0dXJlRGlzcG9zZSApO1xuXG4gICAgXHRcdFx0XHRcdHRleHR1cmVQcm9wZXJ0aWVzLl9faW1hZ2VfX3dlYmdsVGV4dHVyZUN1YmUgPSBfZ2wuY3JlYXRlVGV4dHVyZSgpO1xuXG4gICAgXHRcdFx0XHRcdF9pbmZvTWVtb3J5LnRleHR1cmVzICsrO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdHN0YXRlLmFjdGl2ZVRleHR1cmUoIF9nbC5URVhUVVJFMCArIHNsb3QgKTtcbiAgICBcdFx0XHRcdHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCwgdGV4dHVyZVByb3BlcnRpZXMuX19pbWFnZV9fd2ViZ2xUZXh0dXJlQ3ViZSApO1xuXG4gICAgXHRcdFx0XHRfZ2wucGl4ZWxTdG9yZWkoIF9nbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCB0ZXh0dXJlLmZsaXBZICk7XG5cbiAgICBcdFx0XHRcdHZhciBpc0NvbXByZXNzZWQgPSAodGV4dHVyZSAmJiB0ZXh0dXJlLmlzQ29tcHJlc3NlZFRleHR1cmUpO1xuICAgIFx0XHRcdFx0dmFyIGlzRGF0YVRleHR1cmUgPSAodGV4dHVyZS5pbWFnZVsgMCBdICYmIHRleHR1cmUuaW1hZ2VbIDAgXS5pc0RhdGFUZXh0dXJlKTtcblxuICAgIFx0XHRcdFx0dmFyIGN1YmVJbWFnZSA9IFtdO1xuXG4gICAgXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCA2OyBpICsrICkge1xuXG4gICAgXHRcdFx0XHRcdGlmICggISBpc0NvbXByZXNzZWQgJiYgISBpc0RhdGFUZXh0dXJlICkge1xuXG4gICAgXHRcdFx0XHRcdFx0Y3ViZUltYWdlWyBpIF0gPSBjbGFtcFRvTWF4U2l6ZSggdGV4dHVyZS5pbWFnZVsgaSBdLCBjYXBhYmlsaXRpZXMubWF4Q3ViZW1hcFNpemUgKTtcblxuICAgIFx0XHRcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHRcdFx0Y3ViZUltYWdlWyBpIF0gPSBpc0RhdGFUZXh0dXJlID8gdGV4dHVyZS5pbWFnZVsgaSBdLmltYWdlIDogdGV4dHVyZS5pbWFnZVsgaSBdO1xuXG4gICAgXHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHR2YXIgaW1hZ2UgPSBjdWJlSW1hZ2VbIDAgXSxcbiAgICBcdFx0XHRcdGlzUG93ZXJPZlR3b0ltYWdlID0gaXNQb3dlck9mVHdvKCBpbWFnZSApLFxuICAgIFx0XHRcdFx0Z2xGb3JtYXQgPSBwYXJhbVRocmVlVG9HTCggdGV4dHVyZS5mb3JtYXQgKSxcbiAgICBcdFx0XHRcdGdsVHlwZSA9IHBhcmFtVGhyZWVUb0dMKCB0ZXh0dXJlLnR5cGUgKTtcblxuICAgIFx0XHRcdFx0c2V0VGV4dHVyZVBhcmFtZXRlcnMoIF9nbC5URVhUVVJFX0NVQkVfTUFQLCB0ZXh0dXJlLCBpc1Bvd2VyT2ZUd29JbWFnZSApO1xuXG4gICAgXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCA2OyBpICsrICkge1xuXG4gICAgXHRcdFx0XHRcdGlmICggISBpc0NvbXByZXNzZWQgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHRpZiAoIGlzRGF0YVRleHR1cmUgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHRcdHN0YXRlLnRleEltYWdlMkQoIF9nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpLCAwLCBnbEZvcm1hdCwgY3ViZUltYWdlWyBpIF0ud2lkdGgsIGN1YmVJbWFnZVsgaSBdLmhlaWdodCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgY3ViZUltYWdlWyBpIF0uZGF0YSApO1xuXG4gICAgXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0XHRcdFx0c3RhdGUudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGksIDAsIGdsRm9ybWF0LCBnbEZvcm1hdCwgZ2xUeXBlLCBjdWJlSW1hZ2VbIGkgXSApO1xuXG4gICAgXHRcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdFx0XHR2YXIgbWlwbWFwLCBtaXBtYXBzID0gY3ViZUltYWdlWyBpIF0ubWlwbWFwcztcblxuICAgIFx0XHRcdFx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSBtaXBtYXBzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG4gICAgXHRcdFx0XHRcdFx0XHRtaXBtYXAgPSBtaXBtYXBzWyBqIF07XG5cbiAgICBcdFx0XHRcdFx0XHRcdGlmICggdGV4dHVyZS5mb3JtYXQgIT09IFJHQkFGb3JtYXQgJiYgdGV4dHVyZS5mb3JtYXQgIT09IFJHQkZvcm1hdCApIHtcblxuICAgIFx0XHRcdFx0XHRcdFx0XHRpZiAoIHN0YXRlLmdldENvbXByZXNzZWRUZXh0dXJlRm9ybWF0cygpLmluZGV4T2YoIGdsRm9ybWF0ICkgPiAtIDEgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHRcdFx0XHRzdGF0ZS5jb21wcmVzc2VkVGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGksIGosIGdsRm9ybWF0LCBtaXBtYXAud2lkdGgsIG1pcG1hcC5oZWlnaHQsIDAsIG1pcG1hcC5kYXRhICk7XG5cbiAgICBcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggXCJUSFJFRS5XZWJHTFJlbmRlcmVyOiBBdHRlbXB0IHRvIGxvYWQgdW5zdXBwb3J0ZWQgY29tcHJlc3NlZCB0ZXh0dXJlIGZvcm1hdCBpbiAuc2V0VGV4dHVyZUN1YmUoKVwiICk7XG5cbiAgICBcdFx0XHRcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHRcdFx0XHRcdHN0YXRlLnRleEltYWdlMkQoIF9nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpLCBqLCBnbEZvcm1hdCwgbWlwbWFwLndpZHRoLCBtaXBtYXAuaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBtaXBtYXAuZGF0YSApO1xuXG4gICAgXHRcdFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdGlmICggdGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgJiYgaXNQb3dlck9mVHdvSW1hZ2UgKSB7XG5cbiAgICBcdFx0XHRcdFx0X2dsLmdlbmVyYXRlTWlwbWFwKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCApO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdHRleHR1cmVQcm9wZXJ0aWVzLl9fdmVyc2lvbiA9IHRleHR1cmUudmVyc2lvbjtcblxuICAgIFx0XHRcdFx0aWYgKCB0ZXh0dXJlLm9uVXBkYXRlICkgdGV4dHVyZS5vblVwZGF0ZSggdGV4dHVyZSApO1xuXG4gICAgXHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0c3RhdGUuYWN0aXZlVGV4dHVyZSggX2dsLlRFWFRVUkUwICsgc2xvdCApO1xuICAgIFx0XHRcdFx0c3RhdGUuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFX0NVQkVfTUFQLCB0ZXh0dXJlUHJvcGVydGllcy5fX2ltYWdlX193ZWJnbFRleHR1cmVDdWJlICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9XG5cbiAgICBcdGZ1bmN0aW9uIHNldFRleHR1cmVDdWJlRHluYW1pYyggdGV4dHVyZSwgc2xvdCApIHtcblxuICAgIFx0XHRzdGF0ZS5hY3RpdmVUZXh0dXJlKCBfZ2wuVEVYVFVSRTAgKyBzbG90ICk7XG4gICAgXHRcdHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCwgcHJvcGVydGllcy5nZXQoIHRleHR1cmUgKS5fX3dlYmdsVGV4dHVyZSApO1xuXG4gICAgXHR9XG5cbiAgICBcdGZ1bmN0aW9uIHNldFRleHR1cmVQYXJhbWV0ZXJzKCB0ZXh0dXJlVHlwZSwgdGV4dHVyZSwgaXNQb3dlck9mVHdvSW1hZ2UgKSB7XG5cbiAgICBcdFx0dmFyIGV4dGVuc2lvbjtcblxuICAgIFx0XHRpZiAoIGlzUG93ZXJPZlR3b0ltYWdlICkge1xuXG4gICAgXHRcdFx0X2dsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9XUkFQX1MsIHBhcmFtVGhyZWVUb0dMKCB0ZXh0dXJlLndyYXBTICkgKTtcbiAgICBcdFx0XHRfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX1dSQVBfVCwgcGFyYW1UaHJlZVRvR0woIHRleHR1cmUud3JhcFQgKSApO1xuXG4gICAgXHRcdFx0X2dsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBwYXJhbVRocmVlVG9HTCggdGV4dHVyZS5tYWdGaWx0ZXIgKSApO1xuICAgIFx0XHRcdF9nbC50ZXhQYXJhbWV0ZXJpKCB0ZXh0dXJlVHlwZSwgX2dsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgcGFyYW1UaHJlZVRvR0woIHRleHR1cmUubWluRmlsdGVyICkgKTtcblxuICAgIFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0X2dsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9XUkFQX1MsIF9nbC5DTEFNUF9UT19FREdFICk7XG4gICAgXHRcdFx0X2dsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9XUkFQX1QsIF9nbC5DTEFNUF9UT19FREdFICk7XG5cbiAgICBcdFx0XHRpZiAoIHRleHR1cmUud3JhcFMgIT09IENsYW1wVG9FZGdlV3JhcHBpbmcgfHwgdGV4dHVyZS53cmFwVCAhPT0gQ2xhbXBUb0VkZ2VXcmFwcGluZyApIHtcblxuICAgIFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogVGV4dHVyZSBpcyBub3QgcG93ZXIgb2YgdHdvLiBUZXh0dXJlLndyYXBTIGFuZCBUZXh0dXJlLndyYXBUIHNob3VsZCBiZSBzZXQgdG8gVEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZy4nLCB0ZXh0dXJlICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX01BR19GSUxURVIsIGZpbHRlckZhbGxiYWNrKCB0ZXh0dXJlLm1hZ0ZpbHRlciApICk7XG4gICAgXHRcdFx0X2dsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBmaWx0ZXJGYWxsYmFjayggdGV4dHVyZS5taW5GaWx0ZXIgKSApO1xuXG4gICAgXHRcdFx0aWYgKCB0ZXh0dXJlLm1pbkZpbHRlciAhPT0gTmVhcmVzdEZpbHRlciAmJiB0ZXh0dXJlLm1pbkZpbHRlciAhPT0gTGluZWFyRmlsdGVyICkge1xuXG4gICAgXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBUZXh0dXJlIGlzIG5vdCBwb3dlciBvZiB0d28uIFRleHR1cmUubWluRmlsdGVyIHNob3VsZCBiZSBzZXQgdG8gVEhSRUUuTmVhcmVzdEZpbHRlciBvciBUSFJFRS5MaW5lYXJGaWx0ZXIuJywgdGV4dHVyZSApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHRleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYycgKTtcblxuICAgIFx0XHRpZiAoIGV4dGVuc2lvbiApIHtcblxuICAgIFx0XHRcdGlmICggdGV4dHVyZS50eXBlID09PSBGbG9hdFR5cGUgJiYgZXh0ZW5zaW9ucy5nZXQoICdPRVNfdGV4dHVyZV9mbG9hdF9saW5lYXInICkgPT09IG51bGwgKSByZXR1cm47XG4gICAgXHRcdFx0aWYgKCB0ZXh0dXJlLnR5cGUgPT09IEhhbGZGbG9hdFR5cGUgJiYgZXh0ZW5zaW9ucy5nZXQoICdPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0X2xpbmVhcicgKSA9PT0gbnVsbCApIHJldHVybjtcblxuICAgIFx0XHRcdGlmICggdGV4dHVyZS5hbmlzb3Ryb3B5ID4gMSB8fCBwcm9wZXJ0aWVzLmdldCggdGV4dHVyZSApLl9fY3VycmVudEFuaXNvdHJvcHkgKSB7XG5cbiAgICBcdFx0XHRcdF9nbC50ZXhQYXJhbWV0ZXJmKCB0ZXh0dXJlVHlwZSwgZXh0ZW5zaW9uLlRFWFRVUkVfTUFYX0FOSVNPVFJPUFlfRVhULCBNYXRoLm1pbiggdGV4dHVyZS5hbmlzb3Ryb3B5LCBjYXBhYmlsaXRpZXMuZ2V0TWF4QW5pc290cm9weSgpICkgKTtcbiAgICBcdFx0XHRcdHByb3BlcnRpZXMuZ2V0KCB0ZXh0dXJlICkuX19jdXJyZW50QW5pc290cm9weSA9IHRleHR1cmUuYW5pc290cm9weTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdH1cblxuICAgIFx0ZnVuY3Rpb24gdXBsb2FkVGV4dHVyZSggdGV4dHVyZVByb3BlcnRpZXMsIHRleHR1cmUsIHNsb3QgKSB7XG5cbiAgICBcdFx0aWYgKCB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsSW5pdCA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0dGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbEluaXQgPSB0cnVlO1xuXG4gICAgXHRcdFx0dGV4dHVyZS5hZGRFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uVGV4dHVyZURpc3Bvc2UgKTtcblxuICAgIFx0XHRcdHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlID0gX2dsLmNyZWF0ZVRleHR1cmUoKTtcblxuICAgIFx0XHRcdF9pbmZvTWVtb3J5LnRleHR1cmVzICsrO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRzdGF0ZS5hY3RpdmVUZXh0dXJlKCBfZ2wuVEVYVFVSRTAgKyBzbG90ICk7XG4gICAgXHRcdHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUgKTtcblxuICAgIFx0XHRfZ2wucGl4ZWxTdG9yZWkoIF9nbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCB0ZXh0dXJlLmZsaXBZICk7XG4gICAgXHRcdF9nbC5waXhlbFN0b3JlaSggX2dsLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCwgdGV4dHVyZS5wcmVtdWx0aXBseUFscGhhICk7XG4gICAgXHRcdF9nbC5waXhlbFN0b3JlaSggX2dsLlVOUEFDS19BTElHTk1FTlQsIHRleHR1cmUudW5wYWNrQWxpZ25tZW50ICk7XG5cbiAgICBcdFx0dmFyIGltYWdlID0gY2xhbXBUb01heFNpemUoIHRleHR1cmUuaW1hZ2UsIGNhcGFiaWxpdGllcy5tYXhUZXh0dXJlU2l6ZSApO1xuXG4gICAgXHRcdGlmICggdGV4dHVyZU5lZWRzUG93ZXJPZlR3byggdGV4dHVyZSApICYmIGlzUG93ZXJPZlR3byggaW1hZ2UgKSA9PT0gZmFsc2UgKSB7XG5cbiAgICBcdFx0XHRpbWFnZSA9IG1ha2VQb3dlck9mVHdvKCBpbWFnZSApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHR2YXIgaXNQb3dlck9mVHdvSW1hZ2UgPSBpc1Bvd2VyT2ZUd28oIGltYWdlICksXG4gICAgXHRcdGdsRm9ybWF0ID0gcGFyYW1UaHJlZVRvR0woIHRleHR1cmUuZm9ybWF0ICksXG4gICAgXHRcdGdsVHlwZSA9IHBhcmFtVGhyZWVUb0dMKCB0ZXh0dXJlLnR5cGUgKTtcblxuICAgIFx0XHRzZXRUZXh0dXJlUGFyYW1ldGVycyggX2dsLlRFWFRVUkVfMkQsIHRleHR1cmUsIGlzUG93ZXJPZlR3b0ltYWdlICk7XG5cbiAgICBcdFx0dmFyIG1pcG1hcCwgbWlwbWFwcyA9IHRleHR1cmUubWlwbWFwcztcblxuICAgIFx0XHRpZiAoICh0ZXh0dXJlICYmIHRleHR1cmUuaXNEZXB0aFRleHR1cmUpICkge1xuXG4gICAgXHRcdFx0Ly8gcG9wdWxhdGUgZGVwdGggdGV4dHVyZSB3aXRoIGR1bW15IGRhdGFcblxuICAgIFx0XHRcdHZhciBpbnRlcm5hbEZvcm1hdCA9IF9nbC5ERVBUSF9DT01QT05FTlQ7XG5cbiAgICBcdFx0XHRpZiAoIHRleHR1cmUudHlwZSA9PT0gRmxvYXRUeXBlICkge1xuXG4gICAgXHRcdFx0XHRpZiAoICFfaXNXZWJHTDIgKSB0aHJvdyBuZXcgRXJyb3IoJ0Zsb2F0IERlcHRoIFRleHR1cmUgb25seSBzdXBwb3J0ZWQgaW4gV2ViR0wyLjAnKTtcbiAgICBcdFx0XHRcdGludGVybmFsRm9ybWF0ID0gX2dsLkRFUFRIX0NPTVBPTkVOVDMyRjtcblxuICAgIFx0XHRcdH0gZWxzZSBpZiAoIF9pc1dlYkdMMiApIHtcblxuICAgIFx0XHRcdFx0Ly8gV2ViR0wgMi4wIHJlcXVpcmVzIHNpZ25lZCBpbnRlcm5hbGZvcm1hdCBmb3IgZ2xUZXhJbWFnZTJEXG4gICAgXHRcdFx0XHRpbnRlcm5hbEZvcm1hdCA9IF9nbC5ERVBUSF9DT01QT05FTlQxNjtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdC8vIERlcHRoIHN0ZW5jaWwgdGV4dHVyZXMgbmVlZCB0aGUgREVQVEhfU1RFTkNJTCBpbnRlcm5hbCBmb3JtYXRcbiAgICBcdFx0XHQvLyAoaHR0cHM6Ly93d3cua2hyb25vcy5vcmcvcmVnaXN0cnkvd2ViZ2wvZXh0ZW5zaW9ucy9XRUJHTF9kZXB0aF90ZXh0dXJlLylcbiAgICBcdFx0XHRpZiAoIHRleHR1cmUuZm9ybWF0ID09PSBEZXB0aFN0ZW5jaWxGb3JtYXQgKSB7XG5cbiAgICBcdFx0XHRcdGludGVybmFsRm9ybWF0ID0gX2dsLkRFUFRIX1NURU5DSUw7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRzdGF0ZS50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgMCwgaW50ZXJuYWxGb3JtYXQsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIG51bGwgKTtcblxuICAgIFx0XHR9IGVsc2UgaWYgKCAodGV4dHVyZSAmJiB0ZXh0dXJlLmlzRGF0YVRleHR1cmUpICkge1xuXG4gICAgXHRcdFx0Ly8gdXNlIG1hbnVhbGx5IGNyZWF0ZWQgbWlwbWFwcyBpZiBhdmFpbGFibGVcbiAgICBcdFx0XHQvLyBpZiB0aGVyZSBhcmUgbm8gbWFudWFsIG1pcG1hcHNcbiAgICBcdFx0XHQvLyBzZXQgMCBsZXZlbCBtaXBtYXAgYW5kIHRoZW4gdXNlIEdMIHRvIGdlbmVyYXRlIG90aGVyIG1pcG1hcCBsZXZlbHNcblxuICAgIFx0XHRcdGlmICggbWlwbWFwcy5sZW5ndGggPiAwICYmIGlzUG93ZXJPZlR3b0ltYWdlICkge1xuXG4gICAgXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gbWlwbWFwcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuICAgIFx0XHRcdFx0XHRtaXBtYXAgPSBtaXBtYXBzWyBpIF07XG4gICAgXHRcdFx0XHRcdHN0YXRlLnRleEltYWdlMkQoIF9nbC5URVhUVVJFXzJELCBpLCBnbEZvcm1hdCwgbWlwbWFwLndpZHRoLCBtaXBtYXAuaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBtaXBtYXAuZGF0YSApO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdHRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XG5cbiAgICBcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHRzdGF0ZS50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgMCwgZ2xGb3JtYXQsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIGltYWdlLmRhdGEgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9IGVsc2UgaWYgKCAodGV4dHVyZSAmJiB0ZXh0dXJlLmlzQ29tcHJlc3NlZFRleHR1cmUpICkge1xuXG4gICAgXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IG1pcG1hcHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICBcdFx0XHRcdG1pcG1hcCA9IG1pcG1hcHNbIGkgXTtcblxuICAgIFx0XHRcdFx0aWYgKCB0ZXh0dXJlLmZvcm1hdCAhPT0gUkdCQUZvcm1hdCAmJiB0ZXh0dXJlLmZvcm1hdCAhPT0gUkdCRm9ybWF0ICkge1xuXG4gICAgXHRcdFx0XHRcdGlmICggc3RhdGUuZ2V0Q29tcHJlc3NlZFRleHR1cmVGb3JtYXRzKCkuaW5kZXhPZiggZ2xGb3JtYXQgKSA+IC0gMSApIHtcblxuICAgIFx0XHRcdFx0XHRcdHN0YXRlLmNvbXByZXNzZWRUZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgaSwgZ2xGb3JtYXQsIG1pcG1hcC53aWR0aCwgbWlwbWFwLmhlaWdodCwgMCwgbWlwbWFwLmRhdGEgKTtcblxuICAgIFx0XHRcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCBcIlRIUkVFLldlYkdMUmVuZGVyZXI6IEF0dGVtcHQgdG8gbG9hZCB1bnN1cHBvcnRlZCBjb21wcmVzc2VkIHRleHR1cmUgZm9ybWF0IGluIC51cGxvYWRUZXh0dXJlKClcIiApO1xuXG4gICAgXHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0XHRzdGF0ZS50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgaSwgZ2xGb3JtYXQsIG1pcG1hcC53aWR0aCwgbWlwbWFwLmhlaWdodCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgbWlwbWFwLmRhdGEgKTtcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHQvLyByZWd1bGFyIFRleHR1cmUgKGltYWdlLCB2aWRlbywgY2FudmFzKVxuXG4gICAgXHRcdFx0Ly8gdXNlIG1hbnVhbGx5IGNyZWF0ZWQgbWlwbWFwcyBpZiBhdmFpbGFibGVcbiAgICBcdFx0XHQvLyBpZiB0aGVyZSBhcmUgbm8gbWFudWFsIG1pcG1hcHNcbiAgICBcdFx0XHQvLyBzZXQgMCBsZXZlbCBtaXBtYXAgYW5kIHRoZW4gdXNlIEdMIHRvIGdlbmVyYXRlIG90aGVyIG1pcG1hcCBsZXZlbHNcblxuICAgIFx0XHRcdGlmICggbWlwbWFwcy5sZW5ndGggPiAwICYmIGlzUG93ZXJPZlR3b0ltYWdlICkge1xuXG4gICAgXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gbWlwbWFwcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuICAgIFx0XHRcdFx0XHRtaXBtYXAgPSBtaXBtYXBzWyBpIF07XG4gICAgXHRcdFx0XHRcdHN0YXRlLnRleEltYWdlMkQoIF9nbC5URVhUVVJFXzJELCBpLCBnbEZvcm1hdCwgZ2xGb3JtYXQsIGdsVHlwZSwgbWlwbWFwICk7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0dGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcblxuICAgIFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdHN0YXRlLnRleEltYWdlMkQoIF9nbC5URVhUVVJFXzJELCAwLCBnbEZvcm1hdCwgZ2xGb3JtYXQsIGdsVHlwZSwgaW1hZ2UgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdFx0aWYgKCB0ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyAmJiBpc1Bvd2VyT2ZUd29JbWFnZSApIF9nbC5nZW5lcmF0ZU1pcG1hcCggX2dsLlRFWFRVUkVfMkQgKTtcblxuICAgIFx0XHR0ZXh0dXJlUHJvcGVydGllcy5fX3ZlcnNpb24gPSB0ZXh0dXJlLnZlcnNpb247XG5cbiAgICBcdFx0aWYgKCB0ZXh0dXJlLm9uVXBkYXRlICkgdGV4dHVyZS5vblVwZGF0ZSggdGV4dHVyZSApO1xuXG4gICAgXHR9XG5cbiAgICBcdC8vIFJlbmRlciB0YXJnZXRzXG5cbiAgICBcdC8vIFNldHVwIHN0b3JhZ2UgZm9yIHRhcmdldCB0ZXh0dXJlIGFuZCBiaW5kIGl0IHRvIGNvcnJlY3QgZnJhbWVidWZmZXJcbiAgICBcdGZ1bmN0aW9uIHNldHVwRnJhbWVCdWZmZXJUZXh0dXJlKCBmcmFtZWJ1ZmZlciwgcmVuZGVyVGFyZ2V0LCBhdHRhY2htZW50LCB0ZXh0dXJlVGFyZ2V0ICkge1xuXG4gICAgXHRcdHZhciBnbEZvcm1hdCA9IHBhcmFtVGhyZWVUb0dMKCByZW5kZXJUYXJnZXQudGV4dHVyZS5mb3JtYXQgKTtcbiAgICBcdFx0dmFyIGdsVHlwZSA9IHBhcmFtVGhyZWVUb0dMKCByZW5kZXJUYXJnZXQudGV4dHVyZS50eXBlICk7XG4gICAgXHRcdHN0YXRlLnRleEltYWdlMkQoIHRleHR1cmVUYXJnZXQsIDAsIGdsRm9ybWF0LCByZW5kZXJUYXJnZXQud2lkdGgsIHJlbmRlclRhcmdldC5oZWlnaHQsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIG51bGwgKTtcbiAgICBcdFx0X2dsLmJpbmRGcmFtZWJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBmcmFtZWJ1ZmZlciApO1xuICAgIFx0XHRfZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoIF9nbC5GUkFNRUJVRkZFUiwgYXR0YWNobWVudCwgdGV4dHVyZVRhcmdldCwgcHJvcGVydGllcy5nZXQoIHJlbmRlclRhcmdldC50ZXh0dXJlICkuX193ZWJnbFRleHR1cmUsIDAgKTtcbiAgICBcdFx0X2dsLmJpbmRGcmFtZWJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBudWxsICk7XG5cbiAgICBcdH1cblxuICAgIFx0Ly8gU2V0dXAgc3RvcmFnZSBmb3IgaW50ZXJuYWwgZGVwdGgvc3RlbmNpbCBidWZmZXJzIGFuZCBiaW5kIHRvIGNvcnJlY3QgZnJhbWVidWZmZXJcbiAgICBcdGZ1bmN0aW9uIHNldHVwUmVuZGVyQnVmZmVyU3RvcmFnZSggcmVuZGVyYnVmZmVyLCByZW5kZXJUYXJnZXQgKSB7XG5cbiAgICBcdFx0X2dsLmJpbmRSZW5kZXJidWZmZXIoIF9nbC5SRU5ERVJCVUZGRVIsIHJlbmRlcmJ1ZmZlciApO1xuXG4gICAgXHRcdGlmICggcmVuZGVyVGFyZ2V0LmRlcHRoQnVmZmVyICYmICEgcmVuZGVyVGFyZ2V0LnN0ZW5jaWxCdWZmZXIgKSB7XG5cbiAgICBcdFx0XHRfZ2wucmVuZGVyYnVmZmVyU3RvcmFnZSggX2dsLlJFTkRFUkJVRkZFUiwgX2dsLkRFUFRIX0NPTVBPTkVOVDE2LCByZW5kZXJUYXJnZXQud2lkdGgsIHJlbmRlclRhcmdldC5oZWlnaHQgKTtcbiAgICBcdFx0XHRfZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgX2dsLkRFUFRIX0FUVEFDSE1FTlQsIF9nbC5SRU5ERVJCVUZGRVIsIHJlbmRlcmJ1ZmZlciApO1xuXG4gICAgXHRcdH0gZWxzZSBpZiAoIHJlbmRlclRhcmdldC5kZXB0aEJ1ZmZlciAmJiByZW5kZXJUYXJnZXQuc3RlbmNpbEJ1ZmZlciApIHtcblxuICAgIFx0XHRcdF9nbC5yZW5kZXJidWZmZXJTdG9yYWdlKCBfZ2wuUkVOREVSQlVGRkVSLCBfZ2wuREVQVEhfU1RFTkNJTCwgcmVuZGVyVGFyZ2V0LndpZHRoLCByZW5kZXJUYXJnZXQuaGVpZ2h0ICk7XG4gICAgXHRcdFx0X2dsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIF9nbC5ERVBUSF9TVEVOQ0lMX0FUVEFDSE1FTlQsIF9nbC5SRU5ERVJCVUZGRVIsIHJlbmRlcmJ1ZmZlciApO1xuXG4gICAgXHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHQvLyBGSVhNRTogV2UgZG9uJ3Qgc3VwcG9ydCAhZGVwdGggIXN0ZW5jaWxcbiAgICBcdFx0XHRfZ2wucmVuZGVyYnVmZmVyU3RvcmFnZSggX2dsLlJFTkRFUkJVRkZFUiwgX2dsLlJHQkE0LCByZW5kZXJUYXJnZXQud2lkdGgsIHJlbmRlclRhcmdldC5oZWlnaHQgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0X2dsLmJpbmRSZW5kZXJidWZmZXIoIF9nbC5SRU5ERVJCVUZGRVIsIG51bGwgKTtcblxuICAgIFx0fVxuXG4gICAgXHQvLyBTZXR1cCByZXNvdXJjZXMgZm9yIGEgRGVwdGggVGV4dHVyZSBmb3IgYSBGQk8gKG5lZWRzIGFuIGV4dGVuc2lvbilcbiAgICBcdGZ1bmN0aW9uIHNldHVwRGVwdGhUZXh0dXJlKCBmcmFtZWJ1ZmZlciwgcmVuZGVyVGFyZ2V0ICkge1xuXG4gICAgXHRcdHZhciBpc0N1YmUgPSAoIChyZW5kZXJUYXJnZXQgJiYgcmVuZGVyVGFyZ2V0LmlzV2ViR0xSZW5kZXJUYXJnZXRDdWJlKSApO1xuICAgIFx0XHRpZiAoIGlzQ3ViZSApIHRocm93IG5ldyBFcnJvcignRGVwdGggVGV4dHVyZSB3aXRoIGN1YmUgcmVuZGVyIHRhcmdldHMgaXMgbm90IHN1cHBvcnRlZCEnKTtcblxuICAgIFx0XHRfZ2wuYmluZEZyYW1lYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIGZyYW1lYnVmZmVyICk7XG5cbiAgICBcdFx0aWYgKCAhKCAocmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZSAmJiByZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlLmlzRGVwdGhUZXh0dXJlKSApICkge1xuXG4gICAgXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdyZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgVEhSRUUuRGVwdGhUZXh0dXJlJyk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdC8vIHVwbG9hZCBhbiBlbXB0eSBkZXB0aCB0ZXh0dXJlIHdpdGggZnJhbWVidWZmZXIgc2l6ZVxuICAgIFx0XHRpZiAoICFwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZSApLl9fd2ViZ2xUZXh0dXJlIHx8XG4gICAgXHRcdFx0XHRyZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlLmltYWdlLndpZHRoICE9PSByZW5kZXJUYXJnZXQud2lkdGggfHxcbiAgICBcdFx0XHRcdHJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUuaW1hZ2UuaGVpZ2h0ICE9PSByZW5kZXJUYXJnZXQuaGVpZ2h0ICkge1xuICAgIFx0XHRcdHJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUuaW1hZ2Uud2lkdGggPSByZW5kZXJUYXJnZXQud2lkdGg7XG4gICAgXHRcdFx0cmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZS5pbWFnZS5oZWlnaHQgPSByZW5kZXJUYXJnZXQuaGVpZ2h0O1xuICAgIFx0XHRcdHJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIFx0XHR9XG5cbiAgICBcdFx0c2V0VGV4dHVyZTJEKCByZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlLCAwICk7XG5cbiAgICBcdFx0dmFyIHdlYmdsRGVwdGhUZXh0dXJlID0gcHJvcGVydGllcy5nZXQoIHJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUgKS5fX3dlYmdsVGV4dHVyZTtcblxuICAgIFx0XHRpZiAoIHJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUuZm9ybWF0ID09PSBEZXB0aEZvcm1hdCApIHtcblxuICAgIFx0XHRcdF9nbC5mcmFtZWJ1ZmZlclRleHR1cmUyRCggX2dsLkZSQU1FQlVGRkVSLCBfZ2wuREVQVEhfQVRUQUNITUVOVCwgX2dsLlRFWFRVUkVfMkQsIHdlYmdsRGVwdGhUZXh0dXJlLCAwICk7XG5cbiAgICBcdFx0fSBlbHNlIGlmICggcmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZS5mb3JtYXQgPT09IERlcHRoU3RlbmNpbEZvcm1hdCApIHtcblxuICAgIFx0XHRcdF9nbC5mcmFtZWJ1ZmZlclRleHR1cmUyRCggX2dsLkZSQU1FQlVGRkVSLCBfZ2wuREVQVEhfU1RFTkNJTF9BVFRBQ0hNRU5ULCBfZ2wuVEVYVFVSRV8yRCwgd2ViZ2xEZXB0aFRleHR1cmUsIDAgKTtcblxuICAgIFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGRlcHRoVGV4dHVyZSBmb3JtYXQnKVxuXG4gICAgXHRcdH1cblxuICAgIFx0fVxuXG4gICAgXHQvLyBTZXR1cCBHTCByZXNvdXJjZXMgZm9yIGEgbm9uLXRleHR1cmUgZGVwdGggYnVmZmVyXG4gICAgXHRmdW5jdGlvbiBzZXR1cERlcHRoUmVuZGVyYnVmZmVyKCByZW5kZXJUYXJnZXQgKSB7XG5cbiAgICBcdFx0dmFyIHJlbmRlclRhcmdldFByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0ICk7XG5cbiAgICBcdFx0dmFyIGlzQ3ViZSA9ICggKHJlbmRlclRhcmdldCAmJiByZW5kZXJUYXJnZXQuaXNXZWJHTFJlbmRlclRhcmdldEN1YmUpICk7XG5cbiAgICBcdFx0aWYgKCByZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlICkge1xuXG4gICAgXHRcdFx0aWYgKCBpc0N1YmUgKSB0aHJvdyBuZXcgRXJyb3IoJ3RhcmdldC5kZXB0aFRleHR1cmUgbm90IHN1cHBvcnRlZCBpbiBDdWJlIHJlbmRlciB0YXJnZXRzJyk7XG5cbiAgICBcdFx0XHRzZXR1cERlcHRoVGV4dHVyZSggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXIsIHJlbmRlclRhcmdldCApO1xuXG4gICAgXHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRpZiAoIGlzQ3ViZSApIHtcblxuICAgIFx0XHRcdFx0cmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRGVwdGhidWZmZXIgPSBbXTtcblxuICAgIFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgNjsgaSArKyApIHtcblxuICAgIFx0XHRcdFx0XHRfZ2wuYmluZEZyYW1lYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyWyBpIF0gKTtcbiAgICBcdFx0XHRcdFx0cmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRGVwdGhidWZmZXJbIGkgXSA9IF9nbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcbiAgICBcdFx0XHRcdFx0c2V0dXBSZW5kZXJCdWZmZXJTdG9yYWdlKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xEZXB0aGJ1ZmZlclsgaSBdLCByZW5kZXJUYXJnZXQgKTtcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0X2dsLmJpbmRGcmFtZWJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlciApO1xuICAgIFx0XHRcdFx0cmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRGVwdGhidWZmZXIgPSBfZ2wuY3JlYXRlUmVuZGVyYnVmZmVyKCk7XG4gICAgXHRcdFx0XHRzZXR1cFJlbmRlckJ1ZmZlclN0b3JhZ2UoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbERlcHRoYnVmZmVyLCByZW5kZXJUYXJnZXQgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdFx0X2dsLmJpbmRGcmFtZWJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBudWxsICk7XG5cbiAgICBcdH1cblxuICAgIFx0Ly8gU2V0IHVwIEdMIHJlc291cmNlcyBmb3IgdGhlIHJlbmRlciB0YXJnZXRcbiAgICBcdGZ1bmN0aW9uIHNldHVwUmVuZGVyVGFyZ2V0KCByZW5kZXJUYXJnZXQgKSB7XG5cbiAgICBcdFx0dmFyIHJlbmRlclRhcmdldFByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0ICk7XG4gICAgXHRcdHZhciB0ZXh0dXJlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQudGV4dHVyZSApO1xuXG4gICAgXHRcdHJlbmRlclRhcmdldC5hZGRFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uUmVuZGVyVGFyZ2V0RGlzcG9zZSApO1xuXG4gICAgXHRcdHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlID0gX2dsLmNyZWF0ZVRleHR1cmUoKTtcblxuICAgIFx0XHRfaW5mb01lbW9yeS50ZXh0dXJlcyArKztcblxuICAgIFx0XHR2YXIgaXNDdWJlID0gKCAocmVuZGVyVGFyZ2V0ICYmIHJlbmRlclRhcmdldC5pc1dlYkdMUmVuZGVyVGFyZ2V0Q3ViZSkgKTtcbiAgICBcdFx0dmFyIGlzVGFyZ2V0UG93ZXJPZlR3byA9IGlzUG93ZXJPZlR3byggcmVuZGVyVGFyZ2V0ICk7XG5cbiAgICBcdFx0Ly8gU2V0dXAgZnJhbWVidWZmZXJcblxuICAgIFx0XHRpZiAoIGlzQ3ViZSApIHtcblxuICAgIFx0XHRcdHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyID0gW107XG5cbiAgICBcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCA2OyBpICsrICkge1xuXG4gICAgXHRcdFx0XHRyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlclsgaSBdID0gX2dsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyID0gX2dsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdC8vIFNldHVwIGNvbG9yIGJ1ZmZlclxuXG4gICAgXHRcdGlmICggaXNDdWJlICkge1xuXG4gICAgXHRcdFx0c3RhdGUuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFX0NVQkVfTUFQLCB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSApO1xuICAgIFx0XHRcdHNldFRleHR1cmVQYXJhbWV0ZXJzKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCwgcmVuZGVyVGFyZ2V0LnRleHR1cmUsIGlzVGFyZ2V0UG93ZXJPZlR3byApO1xuXG4gICAgXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgNjsgaSArKyApIHtcblxuICAgIFx0XHRcdFx0c2V0dXBGcmFtZUJ1ZmZlclRleHR1cmUoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyWyBpIF0sIHJlbmRlclRhcmdldCwgX2dsLkNPTE9SX0FUVEFDSE1FTlQwLCBfZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaSApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0aWYgKCByZW5kZXJUYXJnZXQudGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgJiYgaXNUYXJnZXRQb3dlck9mVHdvICkgX2dsLmdlbmVyYXRlTWlwbWFwKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCApO1xuICAgIFx0XHRcdHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCwgbnVsbCApO1xuXG4gICAgXHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRzdGF0ZS5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfMkQsIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlICk7XG4gICAgXHRcdFx0c2V0VGV4dHVyZVBhcmFtZXRlcnMoIF9nbC5URVhUVVJFXzJELCByZW5kZXJUYXJnZXQudGV4dHVyZSwgaXNUYXJnZXRQb3dlck9mVHdvICk7XG4gICAgXHRcdFx0c2V0dXBGcmFtZUJ1ZmZlclRleHR1cmUoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyLCByZW5kZXJUYXJnZXQsIF9nbC5DT0xPUl9BVFRBQ0hNRU5UMCwgX2dsLlRFWFRVUkVfMkQgKTtcblxuICAgIFx0XHRcdGlmICggcmVuZGVyVGFyZ2V0LnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzICYmIGlzVGFyZ2V0UG93ZXJPZlR3byApIF9nbC5nZW5lcmF0ZU1pcG1hcCggX2dsLlRFWFRVUkVfMkQgKTtcbiAgICBcdFx0XHRzdGF0ZS5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfMkQsIG51bGwgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0Ly8gU2V0dXAgZGVwdGggYW5kIHN0ZW5jaWwgYnVmZmVyc1xuXG4gICAgXHRcdGlmICggcmVuZGVyVGFyZ2V0LmRlcHRoQnVmZmVyICkge1xuXG4gICAgXHRcdFx0c2V0dXBEZXB0aFJlbmRlcmJ1ZmZlciggcmVuZGVyVGFyZ2V0ICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9XG5cbiAgICBcdGZ1bmN0aW9uIHVwZGF0ZVJlbmRlclRhcmdldE1pcG1hcCggcmVuZGVyVGFyZ2V0ICkge1xuXG4gICAgXHRcdHZhciB0ZXh0dXJlID0gcmVuZGVyVGFyZ2V0LnRleHR1cmU7XG5cbiAgICBcdFx0aWYgKCB0ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyAmJiBpc1Bvd2VyT2ZUd28oIHJlbmRlclRhcmdldCApICYmXG4gICAgXHRcdFx0XHR0ZXh0dXJlLm1pbkZpbHRlciAhPT0gTmVhcmVzdEZpbHRlciAmJlxuICAgIFx0XHRcdFx0dGV4dHVyZS5taW5GaWx0ZXIgIT09IExpbmVhckZpbHRlciApIHtcblxuICAgIFx0XHRcdHZhciB0YXJnZXQgPSAocmVuZGVyVGFyZ2V0ICYmIHJlbmRlclRhcmdldC5pc1dlYkdMUmVuZGVyVGFyZ2V0Q3ViZSkgPyBfZ2wuVEVYVFVSRV9DVUJFX01BUCA6IF9nbC5URVhUVVJFXzJEO1xuICAgIFx0XHRcdHZhciB3ZWJnbFRleHR1cmUgPSBwcm9wZXJ0aWVzLmdldCggdGV4dHVyZSApLl9fd2ViZ2xUZXh0dXJlO1xuXG4gICAgXHRcdFx0c3RhdGUuYmluZFRleHR1cmUoIHRhcmdldCwgd2ViZ2xUZXh0dXJlICk7XG4gICAgXHRcdFx0X2dsLmdlbmVyYXRlTWlwbWFwKCB0YXJnZXQgKTtcbiAgICBcdFx0XHRzdGF0ZS5iaW5kVGV4dHVyZSggdGFyZ2V0LCBudWxsICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9XG5cbiAgICBcdHRoaXMuc2V0VGV4dHVyZTJEID0gc2V0VGV4dHVyZTJEO1xuICAgIFx0dGhpcy5zZXRUZXh0dXJlQ3ViZSA9IHNldFRleHR1cmVDdWJlO1xuICAgIFx0dGhpcy5zZXRUZXh0dXJlQ3ViZUR5bmFtaWMgPSBzZXRUZXh0dXJlQ3ViZUR5bmFtaWM7XG4gICAgXHR0aGlzLnNldHVwUmVuZGVyVGFyZ2V0ID0gc2V0dXBSZW5kZXJUYXJnZXQ7XG4gICAgXHR0aGlzLnVwZGF0ZVJlbmRlclRhcmdldE1pcG1hcCA9IHVwZGF0ZVJlbmRlclRhcmdldE1pcG1hcDtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgZm9yZGFjaW91cyAvIGZvcmRhY2lvdXMuZ2l0aHViLmlvXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBXZWJHTFByb3BlcnRpZXMoKSB7XG5cbiAgICBcdHZhciBwcm9wZXJ0aWVzID0ge307XG5cbiAgICBcdHJldHVybiB7XG5cbiAgICBcdFx0Z2V0OiBmdW5jdGlvbiAoIG9iamVjdCApIHtcblxuICAgIFx0XHRcdHZhciB1dWlkID0gb2JqZWN0LnV1aWQ7XG4gICAgXHRcdFx0dmFyIG1hcCA9IHByb3BlcnRpZXNbIHV1aWQgXTtcblxuICAgIFx0XHRcdGlmICggbWFwID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRcdG1hcCA9IHt9O1xuICAgIFx0XHRcdFx0cHJvcGVydGllc1sgdXVpZCBdID0gbWFwO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0cmV0dXJuIG1hcDtcblxuICAgIFx0XHR9LFxuXG4gICAgXHRcdGRlbGV0ZTogZnVuY3Rpb24gKCBvYmplY3QgKSB7XG5cbiAgICBcdFx0XHRkZWxldGUgcHJvcGVydGllc1sgb2JqZWN0LnV1aWQgXTtcblxuICAgIFx0XHR9LFxuXG4gICAgXHRcdGNsZWFyOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0XHRwcm9wZXJ0aWVzID0ge307XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9O1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gV2ViR0xTdGF0ZSggZ2wsIGV4dGVuc2lvbnMsIHBhcmFtVGhyZWVUb0dMICkge1xuXG4gICAgXHRmdW5jdGlvbiBDb2xvckJ1ZmZlcigpIHtcblxuICAgIFx0XHR2YXIgbG9ja2VkID0gZmFsc2U7XG5cbiAgICBcdFx0dmFyIGNvbG9yID0gbmV3IFZlY3RvcjQoKTtcbiAgICBcdFx0dmFyIGN1cnJlbnRDb2xvck1hc2sgPSBudWxsO1xuICAgIFx0XHR2YXIgY3VycmVudENvbG9yQ2xlYXIgPSBuZXcgVmVjdG9yNCgpO1xuXG4gICAgXHRcdHJldHVybiB7XG5cbiAgICBcdFx0XHRzZXRNYXNrOiBmdW5jdGlvbiAoIGNvbG9yTWFzayApIHtcblxuICAgIFx0XHRcdFx0aWYgKCBjdXJyZW50Q29sb3JNYXNrICE9PSBjb2xvck1hc2sgJiYgISBsb2NrZWQgKSB7XG5cbiAgICBcdFx0XHRcdFx0Z2wuY29sb3JNYXNrKCBjb2xvck1hc2ssIGNvbG9yTWFzaywgY29sb3JNYXNrLCBjb2xvck1hc2sgKTtcbiAgICBcdFx0XHRcdFx0Y3VycmVudENvbG9yTWFzayA9IGNvbG9yTWFzaztcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0fSxcblxuICAgIFx0XHRcdHNldExvY2tlZDogZnVuY3Rpb24gKCBsb2NrICkge1xuXG4gICAgXHRcdFx0XHRsb2NrZWQgPSBsb2NrO1xuXG4gICAgXHRcdFx0fSxcblxuICAgIFx0XHRcdHNldENsZWFyOiBmdW5jdGlvbiAoIHIsIGcsIGIsIGEgKSB7XG5cbiAgICBcdFx0XHRcdGNvbG9yLnNldCggciwgZywgYiwgYSApO1xuXG4gICAgXHRcdFx0XHRpZiAoIGN1cnJlbnRDb2xvckNsZWFyLmVxdWFscyggY29sb3IgKSA9PT0gZmFsc2UgKSB7XG5cbiAgICBcdFx0XHRcdFx0Z2wuY2xlYXJDb2xvciggciwgZywgYiwgYSApO1xuICAgIFx0XHRcdFx0XHRjdXJyZW50Q29sb3JDbGVhci5jb3B5KCBjb2xvciApO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHR9LFxuXG4gICAgXHRcdFx0cmVzZXQ6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHRcdFx0bG9ja2VkID0gZmFsc2U7XG5cbiAgICBcdFx0XHRcdGN1cnJlbnRDb2xvck1hc2sgPSBudWxsO1xuICAgIFx0XHRcdFx0Y3VycmVudENvbG9yQ2xlYXIuc2V0KCAwLCAwLCAwLCAxICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fTtcblxuICAgIFx0fVxuXG4gICAgXHRmdW5jdGlvbiBEZXB0aEJ1ZmZlcigpIHtcblxuICAgIFx0XHR2YXIgbG9ja2VkID0gZmFsc2U7XG5cbiAgICBcdFx0dmFyIGN1cnJlbnREZXB0aE1hc2sgPSBudWxsO1xuICAgIFx0XHR2YXIgY3VycmVudERlcHRoRnVuYyA9IG51bGw7XG4gICAgXHRcdHZhciBjdXJyZW50RGVwdGhDbGVhciA9IG51bGw7XG5cbiAgICBcdFx0cmV0dXJuIHtcblxuICAgIFx0XHRcdHNldFRlc3Q6IGZ1bmN0aW9uICggZGVwdGhUZXN0ICkge1xuXG4gICAgXHRcdFx0XHRpZiAoIGRlcHRoVGVzdCApIHtcblxuICAgIFx0XHRcdFx0XHRlbmFibGUoIGdsLkRFUFRIX1RFU1QgKTtcblxuICAgIFx0XHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0XHRkaXNhYmxlKCBnbC5ERVBUSF9URVNUICk7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdH0sXG5cbiAgICBcdFx0XHRzZXRNYXNrOiBmdW5jdGlvbiAoIGRlcHRoTWFzayApIHtcblxuICAgIFx0XHRcdFx0aWYgKCBjdXJyZW50RGVwdGhNYXNrICE9PSBkZXB0aE1hc2sgJiYgISBsb2NrZWQgKSB7XG5cbiAgICBcdFx0XHRcdFx0Z2wuZGVwdGhNYXNrKCBkZXB0aE1hc2sgKTtcbiAgICBcdFx0XHRcdFx0Y3VycmVudERlcHRoTWFzayA9IGRlcHRoTWFzaztcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0fSxcblxuICAgIFx0XHRcdHNldEZ1bmM6IGZ1bmN0aW9uICggZGVwdGhGdW5jICkge1xuXG4gICAgXHRcdFx0XHRpZiAoIGN1cnJlbnREZXB0aEZ1bmMgIT09IGRlcHRoRnVuYyApIHtcblxuICAgIFx0XHRcdFx0XHRpZiAoIGRlcHRoRnVuYyApIHtcblxuICAgIFx0XHRcdFx0XHRcdHN3aXRjaCAoIGRlcHRoRnVuYyApIHtcblxuICAgIFx0XHRcdFx0XHRcdFx0Y2FzZSBOZXZlckRlcHRoOlxuXG4gICAgXHRcdFx0XHRcdFx0XHRcdGdsLmRlcHRoRnVuYyggZ2wuTkVWRVIgKTtcbiAgICBcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cbiAgICBcdFx0XHRcdFx0XHRcdGNhc2UgQWx3YXlzRGVwdGg6XG5cbiAgICBcdFx0XHRcdFx0XHRcdFx0Z2wuZGVwdGhGdW5jKCBnbC5BTFdBWVMgKTtcbiAgICBcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cbiAgICBcdFx0XHRcdFx0XHRcdGNhc2UgTGVzc0RlcHRoOlxuXG4gICAgXHRcdFx0XHRcdFx0XHRcdGdsLmRlcHRoRnVuYyggZ2wuTEVTUyApO1xuICAgIFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuICAgIFx0XHRcdFx0XHRcdFx0Y2FzZSBMZXNzRXF1YWxEZXB0aDpcblxuICAgIFx0XHRcdFx0XHRcdFx0XHRnbC5kZXB0aEZ1bmMoIGdsLkxFUVVBTCApO1xuICAgIFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuICAgIFx0XHRcdFx0XHRcdFx0Y2FzZSBFcXVhbERlcHRoOlxuXG4gICAgXHRcdFx0XHRcdFx0XHRcdGdsLmRlcHRoRnVuYyggZ2wuRVFVQUwgKTtcbiAgICBcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cbiAgICBcdFx0XHRcdFx0XHRcdGNhc2UgR3JlYXRlckVxdWFsRGVwdGg6XG5cbiAgICBcdFx0XHRcdFx0XHRcdFx0Z2wuZGVwdGhGdW5jKCBnbC5HRVFVQUwgKTtcbiAgICBcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cbiAgICBcdFx0XHRcdFx0XHRcdGNhc2UgR3JlYXRlckRlcHRoOlxuXG4gICAgXHRcdFx0XHRcdFx0XHRcdGdsLmRlcHRoRnVuYyggZ2wuR1JFQVRFUiApO1xuICAgIFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblxuICAgIFx0XHRcdFx0XHRcdFx0Y2FzZSBOb3RFcXVhbERlcHRoOlxuXG4gICAgXHRcdFx0XHRcdFx0XHRcdGdsLmRlcHRoRnVuYyggZ2wuTk9URVFVQUwgKTtcbiAgICBcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cbiAgICBcdFx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cbiAgICBcdFx0XHRcdFx0XHRcdFx0Z2wuZGVwdGhGdW5jKCBnbC5MRVFVQUwgKTtcblxuICAgIFx0XHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHRcdFx0Z2wuZGVwdGhGdW5jKCBnbC5MRVFVQUwgKTtcblxuICAgIFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdFx0Y3VycmVudERlcHRoRnVuYyA9IGRlcHRoRnVuYztcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0fSxcblxuICAgIFx0XHRcdHNldExvY2tlZDogZnVuY3Rpb24gKCBsb2NrICkge1xuXG4gICAgXHRcdFx0XHRsb2NrZWQgPSBsb2NrO1xuXG4gICAgXHRcdFx0fSxcblxuICAgIFx0XHRcdHNldENsZWFyOiBmdW5jdGlvbiAoIGRlcHRoICkge1xuXG4gICAgXHRcdFx0XHRpZiAoIGN1cnJlbnREZXB0aENsZWFyICE9PSBkZXB0aCApIHtcblxuICAgIFx0XHRcdFx0XHRnbC5jbGVhckRlcHRoKCBkZXB0aCApO1xuICAgIFx0XHRcdFx0XHRjdXJyZW50RGVwdGhDbGVhciA9IGRlcHRoO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHR9LFxuXG4gICAgXHRcdFx0cmVzZXQ6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHRcdFx0bG9ja2VkID0gZmFsc2U7XG5cbiAgICBcdFx0XHRcdGN1cnJlbnREZXB0aE1hc2sgPSBudWxsO1xuICAgIFx0XHRcdFx0Y3VycmVudERlcHRoRnVuYyA9IG51bGw7XG4gICAgXHRcdFx0XHRjdXJyZW50RGVwdGhDbGVhciA9IG51bGw7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fTtcblxuICAgIFx0fVxuXG4gICAgXHRmdW5jdGlvbiBTdGVuY2lsQnVmZmVyKCkge1xuXG4gICAgXHRcdHZhciBsb2NrZWQgPSBmYWxzZTtcblxuICAgIFx0XHR2YXIgY3VycmVudFN0ZW5jaWxNYXNrID0gbnVsbDtcbiAgICBcdFx0dmFyIGN1cnJlbnRTdGVuY2lsRnVuYyA9IG51bGw7XG4gICAgXHRcdHZhciBjdXJyZW50U3RlbmNpbFJlZiA9IG51bGw7XG4gICAgXHRcdHZhciBjdXJyZW50U3RlbmNpbEZ1bmNNYXNrID0gbnVsbDtcbiAgICBcdFx0dmFyIGN1cnJlbnRTdGVuY2lsRmFpbCAgPSBudWxsO1xuICAgIFx0XHR2YXIgY3VycmVudFN0ZW5jaWxaRmFpbCA9IG51bGw7XG4gICAgXHRcdHZhciBjdXJyZW50U3RlbmNpbFpQYXNzID0gbnVsbDtcbiAgICBcdFx0dmFyIGN1cnJlbnRTdGVuY2lsQ2xlYXIgPSBudWxsO1xuXG4gICAgXHRcdHJldHVybiB7XG5cbiAgICBcdFx0XHRzZXRUZXN0OiBmdW5jdGlvbiAoIHN0ZW5jaWxUZXN0ICkge1xuXG4gICAgXHRcdFx0XHRpZiAoIHN0ZW5jaWxUZXN0ICkge1xuXG4gICAgXHRcdFx0XHRcdGVuYWJsZSggZ2wuU1RFTkNJTF9URVNUICk7XG5cbiAgICBcdFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdFx0ZGlzYWJsZSggZ2wuU1RFTkNJTF9URVNUICk7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdH0sXG5cbiAgICBcdFx0XHRzZXRNYXNrOiBmdW5jdGlvbiAoIHN0ZW5jaWxNYXNrICkge1xuXG4gICAgXHRcdFx0XHRpZiAoIGN1cnJlbnRTdGVuY2lsTWFzayAhPT0gc3RlbmNpbE1hc2sgJiYgISBsb2NrZWQgKSB7XG5cbiAgICBcdFx0XHRcdFx0Z2wuc3RlbmNpbE1hc2soIHN0ZW5jaWxNYXNrICk7XG4gICAgXHRcdFx0XHRcdGN1cnJlbnRTdGVuY2lsTWFzayA9IHN0ZW5jaWxNYXNrO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHR9LFxuXG4gICAgXHRcdFx0c2V0RnVuYzogZnVuY3Rpb24gKCBzdGVuY2lsRnVuYywgc3RlbmNpbFJlZiwgc3RlbmNpbE1hc2sgKSB7XG5cbiAgICBcdFx0XHRcdGlmICggY3VycmVudFN0ZW5jaWxGdW5jICE9PSBzdGVuY2lsRnVuYyB8fFxuICAgIFx0XHRcdFx0ICAgICBjdXJyZW50U3RlbmNpbFJlZiBcdCE9PSBzdGVuY2lsUmVmIFx0fHxcbiAgICBcdFx0XHRcdCAgICAgY3VycmVudFN0ZW5jaWxGdW5jTWFzayAhPT0gc3RlbmNpbE1hc2sgKSB7XG5cbiAgICBcdFx0XHRcdFx0Z2wuc3RlbmNpbEZ1bmMoIHN0ZW5jaWxGdW5jLCAgc3RlbmNpbFJlZiwgc3RlbmNpbE1hc2sgKTtcblxuICAgIFx0XHRcdFx0XHRjdXJyZW50U3RlbmNpbEZ1bmMgPSBzdGVuY2lsRnVuYztcbiAgICBcdFx0XHRcdFx0Y3VycmVudFN0ZW5jaWxSZWYgID0gc3RlbmNpbFJlZjtcbiAgICBcdFx0XHRcdFx0Y3VycmVudFN0ZW5jaWxGdW5jTWFzayA9IHN0ZW5jaWxNYXNrO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHR9LFxuXG4gICAgXHRcdFx0c2V0T3A6IGZ1bmN0aW9uICggc3RlbmNpbEZhaWwsIHN0ZW5jaWxaRmFpbCwgc3RlbmNpbFpQYXNzICkge1xuXG4gICAgXHRcdFx0XHRpZiAoIGN1cnJlbnRTdGVuY2lsRmFpbFx0ICE9PSBzdGVuY2lsRmFpbCBcdHx8XG4gICAgXHRcdFx0XHQgICAgIGN1cnJlbnRTdGVuY2lsWkZhaWwgIT09IHN0ZW5jaWxaRmFpbCB8fFxuICAgIFx0XHRcdFx0ICAgICBjdXJyZW50U3RlbmNpbFpQYXNzICE9PSBzdGVuY2lsWlBhc3MgKSB7XG5cbiAgICBcdFx0XHRcdFx0Z2wuc3RlbmNpbE9wKCBzdGVuY2lsRmFpbCwgIHN0ZW5jaWxaRmFpbCwgc3RlbmNpbFpQYXNzICk7XG5cbiAgICBcdFx0XHRcdFx0Y3VycmVudFN0ZW5jaWxGYWlsICA9IHN0ZW5jaWxGYWlsO1xuICAgIFx0XHRcdFx0XHRjdXJyZW50U3RlbmNpbFpGYWlsID0gc3RlbmNpbFpGYWlsO1xuICAgIFx0XHRcdFx0XHRjdXJyZW50U3RlbmNpbFpQYXNzID0gc3RlbmNpbFpQYXNzO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHR9LFxuXG4gICAgXHRcdFx0c2V0TG9ja2VkOiBmdW5jdGlvbiAoIGxvY2sgKSB7XG5cbiAgICBcdFx0XHRcdGxvY2tlZCA9IGxvY2s7XG5cbiAgICBcdFx0XHR9LFxuXG4gICAgXHRcdFx0c2V0Q2xlYXI6IGZ1bmN0aW9uICggc3RlbmNpbCApIHtcblxuICAgIFx0XHRcdFx0aWYgKCBjdXJyZW50U3RlbmNpbENsZWFyICE9PSBzdGVuY2lsICkge1xuXG4gICAgXHRcdFx0XHRcdGdsLmNsZWFyU3RlbmNpbCggc3RlbmNpbCApO1xuICAgIFx0XHRcdFx0XHRjdXJyZW50U3RlbmNpbENsZWFyID0gc3RlbmNpbDtcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0fSxcblxuICAgIFx0XHRcdHJlc2V0OiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0XHRcdGxvY2tlZCA9IGZhbHNlO1xuXG4gICAgXHRcdFx0XHRjdXJyZW50U3RlbmNpbE1hc2sgPSBudWxsO1xuICAgIFx0XHRcdFx0Y3VycmVudFN0ZW5jaWxGdW5jID0gbnVsbDtcbiAgICBcdFx0XHRcdGN1cnJlbnRTdGVuY2lsUmVmID0gbnVsbDtcbiAgICBcdFx0XHRcdGN1cnJlbnRTdGVuY2lsRnVuY01hc2sgPSBudWxsO1xuICAgIFx0XHRcdFx0Y3VycmVudFN0ZW5jaWxGYWlsID0gbnVsbDtcbiAgICBcdFx0XHRcdGN1cnJlbnRTdGVuY2lsWkZhaWwgPSBudWxsO1xuICAgIFx0XHRcdFx0Y3VycmVudFN0ZW5jaWxaUGFzcyA9IG51bGw7XG4gICAgXHRcdFx0XHRjdXJyZW50U3RlbmNpbENsZWFyID0gbnVsbDtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9O1xuXG4gICAgXHR9XG5cbiAgICBcdC8vXG5cbiAgICBcdHZhciBjb2xvckJ1ZmZlciA9IG5ldyBDb2xvckJ1ZmZlcigpO1xuICAgIFx0dmFyIGRlcHRoQnVmZmVyID0gbmV3IERlcHRoQnVmZmVyKCk7XG4gICAgXHR2YXIgc3RlbmNpbEJ1ZmZlciA9IG5ldyBTdGVuY2lsQnVmZmVyKCk7XG5cbiAgICBcdHZhciBtYXhWZXJ0ZXhBdHRyaWJ1dGVzID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5NQVhfVkVSVEVYX0FUVFJJQlMgKTtcbiAgICBcdHZhciBuZXdBdHRyaWJ1dGVzID0gbmV3IFVpbnQ4QXJyYXkoIG1heFZlcnRleEF0dHJpYnV0ZXMgKTtcbiAgICBcdHZhciBlbmFibGVkQXR0cmlidXRlcyA9IG5ldyBVaW50OEFycmF5KCBtYXhWZXJ0ZXhBdHRyaWJ1dGVzICk7XG4gICAgXHR2YXIgYXR0cmlidXRlRGl2aXNvcnMgPSBuZXcgVWludDhBcnJheSggbWF4VmVydGV4QXR0cmlidXRlcyApO1xuXG4gICAgXHR2YXIgY2FwYWJpbGl0aWVzID0ge307XG5cbiAgICBcdHZhciBjb21wcmVzc2VkVGV4dHVyZUZvcm1hdHMgPSBudWxsO1xuXG4gICAgXHR2YXIgY3VycmVudEJsZW5kaW5nID0gbnVsbDtcbiAgICBcdHZhciBjdXJyZW50QmxlbmRFcXVhdGlvbiA9IG51bGw7XG4gICAgXHR2YXIgY3VycmVudEJsZW5kU3JjID0gbnVsbDtcbiAgICBcdHZhciBjdXJyZW50QmxlbmREc3QgPSBudWxsO1xuICAgIFx0dmFyIGN1cnJlbnRCbGVuZEVxdWF0aW9uQWxwaGEgPSBudWxsO1xuICAgIFx0dmFyIGN1cnJlbnRCbGVuZFNyY0FscGhhID0gbnVsbDtcbiAgICBcdHZhciBjdXJyZW50QmxlbmREc3RBbHBoYSA9IG51bGw7XG4gICAgXHR2YXIgY3VycmVudFByZW11bHRpcGxlZEFscGhhID0gZmFsc2U7XG5cbiAgICBcdHZhciBjdXJyZW50RmxpcFNpZGVkID0gbnVsbDtcbiAgICBcdHZhciBjdXJyZW50Q3VsbEZhY2UgPSBudWxsO1xuXG4gICAgXHR2YXIgY3VycmVudExpbmVXaWR0aCA9IG51bGw7XG5cbiAgICBcdHZhciBjdXJyZW50UG9seWdvbk9mZnNldEZhY3RvciA9IG51bGw7XG4gICAgXHR2YXIgY3VycmVudFBvbHlnb25PZmZzZXRVbml0cyA9IG51bGw7XG5cbiAgICBcdHZhciBjdXJyZW50U2Npc3NvclRlc3QgPSBudWxsO1xuXG4gICAgXHR2YXIgbWF4VGV4dHVyZXMgPSBnbC5nZXRQYXJhbWV0ZXIoIGdsLk1BWF9URVhUVVJFX0lNQUdFX1VOSVRTICk7XG5cbiAgICBcdHZhciBjdXJyZW50VGV4dHVyZVNsb3QgPSBudWxsO1xuICAgIFx0dmFyIGN1cnJlbnRCb3VuZFRleHR1cmVzID0ge307XG5cbiAgICBcdHZhciBjdXJyZW50U2Npc3NvciA9IG5ldyBWZWN0b3I0KCk7XG4gICAgXHR2YXIgY3VycmVudFZpZXdwb3J0ID0gbmV3IFZlY3RvcjQoKTtcblxuICAgIFx0ZnVuY3Rpb24gY3JlYXRlVGV4dHVyZSggdHlwZSwgdGFyZ2V0LCBjb3VudCApIHtcblxuICAgIFx0XHR2YXIgZGF0YSA9IG5ldyBVaW50OEFycmF5KCA0ICk7IC8vIDQgaXMgcmVxdWlyZWQgdG8gbWF0Y2ggZGVmYXVsdCB1bnBhY2sgYWxpZ25tZW50IG9mIDQuXG4gICAgXHRcdHZhciB0ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuXG4gICAgXHRcdGdsLmJpbmRUZXh0dXJlKCB0eXBlLCB0ZXh0dXJlICk7XG4gICAgXHRcdGdsLnRleFBhcmFtZXRlcmkoIHR5cGUsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTkVBUkVTVCApO1xuICAgIFx0XHRnbC50ZXhQYXJhbWV0ZXJpKCB0eXBlLCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QgKTtcblxuICAgIFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSArKyApIHtcblxuICAgIFx0XHRcdGdsLnRleEltYWdlMkQoIHRhcmdldCArIGksIDAsIGdsLlJHQkEsIDEsIDEsIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIGRhdGEgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIHRleHR1cmU7XG5cbiAgICBcdH1cblxuICAgIFx0dmFyIGVtcHR5VGV4dHVyZXMgPSB7fTtcbiAgICBcdGVtcHR5VGV4dHVyZXNbIGdsLlRFWFRVUkVfMkQgXSA9IGNyZWF0ZVRleHR1cmUoIGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfMkQsIDEgKTtcbiAgICBcdGVtcHR5VGV4dHVyZXNbIGdsLlRFWFRVUkVfQ1VCRV9NQVAgXSA9IGNyZWF0ZVRleHR1cmUoIGdsLlRFWFRVUkVfQ1VCRV9NQVAsIGdsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCwgNiApO1xuXG4gICAgXHQvL1xuXG4gICAgXHRmdW5jdGlvbiBpbml0KCkge1xuXG4gICAgXHRcdGNsZWFyQ29sb3IoIDAsIDAsIDAsIDEgKTtcbiAgICBcdFx0Y2xlYXJEZXB0aCggMSApO1xuICAgIFx0XHRjbGVhclN0ZW5jaWwoIDAgKTtcblxuICAgIFx0XHRlbmFibGUoIGdsLkRFUFRIX1RFU1QgKTtcbiAgICBcdFx0c2V0RGVwdGhGdW5jKCBMZXNzRXF1YWxEZXB0aCApO1xuXG4gICAgXHRcdHNldEZsaXBTaWRlZCggZmFsc2UgKTtcbiAgICBcdFx0c2V0Q3VsbEZhY2UoIEN1bGxGYWNlQmFjayApO1xuICAgIFx0XHRlbmFibGUoIGdsLkNVTExfRkFDRSApO1xuXG4gICAgXHRcdGVuYWJsZSggZ2wuQkxFTkQgKTtcbiAgICBcdFx0c2V0QmxlbmRpbmcoIE5vcm1hbEJsZW5kaW5nICk7XG5cbiAgICBcdH1cblxuICAgIFx0ZnVuY3Rpb24gaW5pdEF0dHJpYnV0ZXMoKSB7XG5cbiAgICBcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gbmV3QXR0cmlidXRlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgXHRcdFx0bmV3QXR0cmlidXRlc1sgaSBdID0gMDtcblxuICAgIFx0XHR9XG5cbiAgICBcdH1cblxuICAgIFx0ZnVuY3Rpb24gZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGUgKSB7XG5cbiAgICBcdFx0bmV3QXR0cmlidXRlc1sgYXR0cmlidXRlIF0gPSAxO1xuXG4gICAgXHRcdGlmICggZW5hYmxlZEF0dHJpYnV0ZXNbIGF0dHJpYnV0ZSBdID09PSAwICkge1xuXG4gICAgXHRcdFx0Z2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoIGF0dHJpYnV0ZSApO1xuICAgIFx0XHRcdGVuYWJsZWRBdHRyaWJ1dGVzWyBhdHRyaWJ1dGUgXSA9IDE7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGlmICggYXR0cmlidXRlRGl2aXNvcnNbIGF0dHJpYnV0ZSBdICE9PSAwICkge1xuXG4gICAgXHRcdFx0dmFyIGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnQU5HTEVfaW5zdGFuY2VkX2FycmF5cycgKTtcblxuICAgIFx0XHRcdGV4dGVuc2lvbi52ZXJ0ZXhBdHRyaWJEaXZpc29yQU5HTEUoIGF0dHJpYnV0ZSwgMCApO1xuICAgIFx0XHRcdGF0dHJpYnV0ZURpdmlzb3JzWyBhdHRyaWJ1dGUgXSA9IDA7XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9XG5cbiAgICBcdGZ1bmN0aW9uIGVuYWJsZUF0dHJpYnV0ZUFuZERpdmlzb3IoIGF0dHJpYnV0ZSwgbWVzaFBlckF0dHJpYnV0ZSwgZXh0ZW5zaW9uICkge1xuXG4gICAgXHRcdG5ld0F0dHJpYnV0ZXNbIGF0dHJpYnV0ZSBdID0gMTtcblxuICAgIFx0XHRpZiAoIGVuYWJsZWRBdHRyaWJ1dGVzWyBhdHRyaWJ1dGUgXSA9PT0gMCApIHtcblxuICAgIFx0XHRcdGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KCBhdHRyaWJ1dGUgKTtcbiAgICBcdFx0XHRlbmFibGVkQXR0cmlidXRlc1sgYXR0cmlidXRlIF0gPSAxO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRpZiAoIGF0dHJpYnV0ZURpdmlzb3JzWyBhdHRyaWJ1dGUgXSAhPT0gbWVzaFBlckF0dHJpYnV0ZSApIHtcblxuICAgIFx0XHRcdGV4dGVuc2lvbi52ZXJ0ZXhBdHRyaWJEaXZpc29yQU5HTEUoIGF0dHJpYnV0ZSwgbWVzaFBlckF0dHJpYnV0ZSApO1xuICAgIFx0XHRcdGF0dHJpYnV0ZURpdmlzb3JzWyBhdHRyaWJ1dGUgXSA9IG1lc2hQZXJBdHRyaWJ1dGU7XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9XG5cbiAgICBcdGZ1bmN0aW9uIGRpc2FibGVVbnVzZWRBdHRyaWJ1dGVzKCkge1xuXG4gICAgXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGVuYWJsZWRBdHRyaWJ1dGVzLmxlbmd0aDsgaSAhPT0gbDsgKysgaSApIHtcblxuICAgIFx0XHRcdGlmICggZW5hYmxlZEF0dHJpYnV0ZXNbIGkgXSAhPT0gbmV3QXR0cmlidXRlc1sgaSBdICkge1xuXG4gICAgXHRcdFx0XHRnbC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkoIGkgKTtcbiAgICBcdFx0XHRcdGVuYWJsZWRBdHRyaWJ1dGVzWyBpIF0gPSAwO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0fVxuXG4gICAgXHRmdW5jdGlvbiBlbmFibGUoIGlkICkge1xuXG4gICAgXHRcdGlmICggY2FwYWJpbGl0aWVzWyBpZCBdICE9PSB0cnVlICkge1xuXG4gICAgXHRcdFx0Z2wuZW5hYmxlKCBpZCApO1xuICAgIFx0XHRcdGNhcGFiaWxpdGllc1sgaWQgXSA9IHRydWU7XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9XG5cbiAgICBcdGZ1bmN0aW9uIGRpc2FibGUoIGlkICkge1xuXG4gICAgXHRcdGlmICggY2FwYWJpbGl0aWVzWyBpZCBdICE9PSBmYWxzZSApIHtcblxuICAgIFx0XHRcdGdsLmRpc2FibGUoIGlkICk7XG4gICAgXHRcdFx0Y2FwYWJpbGl0aWVzWyBpZCBdID0gZmFsc2U7XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9XG5cbiAgICBcdGZ1bmN0aW9uIGdldENvbXByZXNzZWRUZXh0dXJlRm9ybWF0cygpIHtcblxuICAgIFx0XHRpZiAoIGNvbXByZXNzZWRUZXh0dXJlRm9ybWF0cyA9PT0gbnVsbCApIHtcblxuICAgIFx0XHRcdGNvbXByZXNzZWRUZXh0dXJlRm9ybWF0cyA9IFtdO1xuXG4gICAgXHRcdFx0aWYgKCBleHRlbnNpb25zLmdldCggJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0YycgKSB8fFxuICAgIFx0XHRcdCAgICAgZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0YycgKSB8fFxuICAgIFx0XHRcdCAgICAgZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfZXRjMScgKSApIHtcblxuICAgIFx0XHRcdFx0dmFyIGZvcm1hdHMgPSBnbC5nZXRQYXJhbWV0ZXIoIGdsLkNPTVBSRVNTRURfVEVYVFVSRV9GT1JNQVRTICk7XG5cbiAgICBcdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGZvcm1hdHMubGVuZ3RoOyBpICsrICkge1xuXG4gICAgXHRcdFx0XHRcdGNvbXByZXNzZWRUZXh0dXJlRm9ybWF0cy5wdXNoKCBmb3JtYXRzWyBpIF0gKTtcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gY29tcHJlc3NlZFRleHR1cmVGb3JtYXRzO1xuXG4gICAgXHR9XG5cbiAgICBcdGZ1bmN0aW9uIHNldEJsZW5kaW5nKCBibGVuZGluZywgYmxlbmRFcXVhdGlvbiwgYmxlbmRTcmMsIGJsZW5kRHN0LCBibGVuZEVxdWF0aW9uQWxwaGEsIGJsZW5kU3JjQWxwaGEsIGJsZW5kRHN0QWxwaGEsIHByZW11bHRpcGxpZWRBbHBoYSApIHtcblxuICAgIFx0XHRpZiAoIGJsZW5kaW5nICE9PSBOb0JsZW5kaW5nICkge1xuXG4gICAgXHRcdFx0ZW5hYmxlKCBnbC5CTEVORCApO1xuXG4gICAgXHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRkaXNhYmxlKCBnbC5CTEVORCApO1xuICAgIFx0XHRcdGN1cnJlbnRCbGVuZGluZyA9IGJsZW5kaW5nOyAvLyBubyBibGVuZGluZywgdGhhdCBpc1xuICAgIFx0XHRcdHJldHVybjtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0aWYgKCBibGVuZGluZyAhPT0gY3VycmVudEJsZW5kaW5nIHx8IHByZW11bHRpcGxpZWRBbHBoYSAhPT0gY3VycmVudFByZW11bHRpcGxlZEFscGhhICkge1xuXG4gICAgXHRcdFx0aWYgKCBibGVuZGluZyA9PT0gQWRkaXRpdmVCbGVuZGluZyApIHtcblxuICAgIFx0XHRcdFx0aWYgKCBwcmVtdWx0aXBsaWVkQWxwaGEgKSB7XG5cbiAgICBcdFx0XHRcdFx0Z2wuYmxlbmRFcXVhdGlvblNlcGFyYXRlKCBnbC5GVU5DX0FERCwgZ2wuRlVOQ19BREQgKTtcbiAgICBcdFx0XHRcdFx0Z2wuYmxlbmRGdW5jU2VwYXJhdGUoIGdsLk9ORSwgZ2wuT05FLCBnbC5PTkUsIGdsLk9ORSApO1xuXG4gICAgXHRcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHRcdGdsLmJsZW5kRXF1YXRpb24oIGdsLkZVTkNfQUREICk7XG4gICAgXHRcdFx0XHRcdGdsLmJsZW5kRnVuYyggZ2wuU1JDX0FMUEhBLCBnbC5PTkUgKTtcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0fSBlbHNlIGlmICggYmxlbmRpbmcgPT09IFN1YnRyYWN0aXZlQmxlbmRpbmcgKSB7XG5cbiAgICBcdFx0XHRcdGlmICggcHJlbXVsdGlwbGllZEFscGhhICkge1xuXG4gICAgXHRcdFx0XHRcdGdsLmJsZW5kRXF1YXRpb25TZXBhcmF0ZSggZ2wuRlVOQ19BREQsIGdsLkZVTkNfQUREICk7XG4gICAgXHRcdFx0XHRcdGdsLmJsZW5kRnVuY1NlcGFyYXRlKCBnbC5aRVJPLCBnbC5aRVJPLCBnbC5PTkVfTUlOVVNfU1JDX0NPTE9SLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBICk7XG5cbiAgICBcdFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdFx0Z2wuYmxlbmRFcXVhdGlvbiggZ2wuRlVOQ19BREQgKTtcbiAgICBcdFx0XHRcdFx0Z2wuYmxlbmRGdW5jKCBnbC5aRVJPLCBnbC5PTkVfTUlOVVNfU1JDX0NPTE9SICk7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdH0gZWxzZSBpZiAoIGJsZW5kaW5nID09PSBNdWx0aXBseUJsZW5kaW5nICkge1xuXG4gICAgXHRcdFx0XHRpZiAoIHByZW11bHRpcGxpZWRBbHBoYSApIHtcblxuICAgIFx0XHRcdFx0XHRnbC5ibGVuZEVxdWF0aW9uU2VwYXJhdGUoIGdsLkZVTkNfQURELCBnbC5GVU5DX0FERCApO1xuICAgIFx0XHRcdFx0XHRnbC5ibGVuZEZ1bmNTZXBhcmF0ZSggZ2wuWkVSTywgZ2wuU1JDX0NPTE9SLCBnbC5aRVJPLCBnbC5TUkNfQUxQSEEgKTtcblxuICAgIFx0XHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0XHRnbC5ibGVuZEVxdWF0aW9uKCBnbC5GVU5DX0FERCApO1xuICAgIFx0XHRcdFx0XHRnbC5ibGVuZEZ1bmMoIGdsLlpFUk8sIGdsLlNSQ19DT0xPUiApO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHRpZiAoIHByZW11bHRpcGxpZWRBbHBoYSApIHtcblxuICAgIFx0XHRcdFx0XHRnbC5ibGVuZEVxdWF0aW9uU2VwYXJhdGUoIGdsLkZVTkNfQURELCBnbC5GVU5DX0FERCApO1xuICAgIFx0XHRcdFx0XHRnbC5ibGVuZEZ1bmNTZXBhcmF0ZSggZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBLCBnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEgKTtcblxuICAgIFx0XHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0XHRnbC5ibGVuZEVxdWF0aW9uU2VwYXJhdGUoIGdsLkZVTkNfQURELCBnbC5GVU5DX0FERCApO1xuICAgIFx0XHRcdFx0XHRnbC5ibGVuZEZ1bmNTZXBhcmF0ZSggZ2wuU1JDX0FMUEhBLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBLCBnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEgKTtcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0Y3VycmVudEJsZW5kaW5nID0gYmxlbmRpbmc7XG4gICAgXHRcdFx0Y3VycmVudFByZW11bHRpcGxlZEFscGhhID0gcHJlbXVsdGlwbGllZEFscGhhO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRpZiAoIGJsZW5kaW5nID09PSBDdXN0b21CbGVuZGluZyApIHtcblxuICAgIFx0XHRcdGJsZW5kRXF1YXRpb25BbHBoYSA9IGJsZW5kRXF1YXRpb25BbHBoYSB8fCBibGVuZEVxdWF0aW9uO1xuICAgIFx0XHRcdGJsZW5kU3JjQWxwaGEgPSBibGVuZFNyY0FscGhhIHx8IGJsZW5kU3JjO1xuICAgIFx0XHRcdGJsZW5kRHN0QWxwaGEgPSBibGVuZERzdEFscGhhIHx8IGJsZW5kRHN0O1xuXG4gICAgXHRcdFx0aWYgKCBibGVuZEVxdWF0aW9uICE9PSBjdXJyZW50QmxlbmRFcXVhdGlvbiB8fCBibGVuZEVxdWF0aW9uQWxwaGEgIT09IGN1cnJlbnRCbGVuZEVxdWF0aW9uQWxwaGEgKSB7XG5cbiAgICBcdFx0XHRcdGdsLmJsZW5kRXF1YXRpb25TZXBhcmF0ZSggcGFyYW1UaHJlZVRvR0woIGJsZW5kRXF1YXRpb24gKSwgcGFyYW1UaHJlZVRvR0woIGJsZW5kRXF1YXRpb25BbHBoYSApICk7XG5cbiAgICBcdFx0XHRcdGN1cnJlbnRCbGVuZEVxdWF0aW9uID0gYmxlbmRFcXVhdGlvbjtcbiAgICBcdFx0XHRcdGN1cnJlbnRCbGVuZEVxdWF0aW9uQWxwaGEgPSBibGVuZEVxdWF0aW9uQWxwaGE7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRpZiAoIGJsZW5kU3JjICE9PSBjdXJyZW50QmxlbmRTcmMgfHwgYmxlbmREc3QgIT09IGN1cnJlbnRCbGVuZERzdCB8fCBibGVuZFNyY0FscGhhICE9PSBjdXJyZW50QmxlbmRTcmNBbHBoYSB8fCBibGVuZERzdEFscGhhICE9PSBjdXJyZW50QmxlbmREc3RBbHBoYSApIHtcblxuICAgIFx0XHRcdFx0Z2wuYmxlbmRGdW5jU2VwYXJhdGUoIHBhcmFtVGhyZWVUb0dMKCBibGVuZFNyYyApLCBwYXJhbVRocmVlVG9HTCggYmxlbmREc3QgKSwgcGFyYW1UaHJlZVRvR0woIGJsZW5kU3JjQWxwaGEgKSwgcGFyYW1UaHJlZVRvR0woIGJsZW5kRHN0QWxwaGEgKSApO1xuXG4gICAgXHRcdFx0XHRjdXJyZW50QmxlbmRTcmMgPSBibGVuZFNyYztcbiAgICBcdFx0XHRcdGN1cnJlbnRCbGVuZERzdCA9IGJsZW5kRHN0O1xuICAgIFx0XHRcdFx0Y3VycmVudEJsZW5kU3JjQWxwaGEgPSBibGVuZFNyY0FscGhhO1xuICAgIFx0XHRcdFx0Y3VycmVudEJsZW5kRHN0QWxwaGEgPSBibGVuZERzdEFscGhhO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRjdXJyZW50QmxlbmRFcXVhdGlvbiA9IG51bGw7XG4gICAgXHRcdFx0Y3VycmVudEJsZW5kU3JjID0gbnVsbDtcbiAgICBcdFx0XHRjdXJyZW50QmxlbmREc3QgPSBudWxsO1xuICAgIFx0XHRcdGN1cnJlbnRCbGVuZEVxdWF0aW9uQWxwaGEgPSBudWxsO1xuICAgIFx0XHRcdGN1cnJlbnRCbGVuZFNyY0FscGhhID0gbnVsbDtcbiAgICBcdFx0XHRjdXJyZW50QmxlbmREc3RBbHBoYSA9IG51bGw7XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9XG5cbiAgICBcdC8vIFRPRE8gRGVwcmVjYXRlXG5cbiAgICBcdGZ1bmN0aW9uIHNldENvbG9yV3JpdGUoIGNvbG9yV3JpdGUgKSB7XG5cbiAgICBcdFx0Y29sb3JCdWZmZXIuc2V0TWFzayggY29sb3JXcml0ZSApO1xuXG4gICAgXHR9XG5cbiAgICBcdGZ1bmN0aW9uIHNldERlcHRoVGVzdCggZGVwdGhUZXN0ICkge1xuXG4gICAgXHRcdGRlcHRoQnVmZmVyLnNldFRlc3QoIGRlcHRoVGVzdCApO1xuXG4gICAgXHR9XG5cbiAgICBcdGZ1bmN0aW9uIHNldERlcHRoV3JpdGUoIGRlcHRoV3JpdGUgKSB7XG5cbiAgICBcdFx0ZGVwdGhCdWZmZXIuc2V0TWFzayggZGVwdGhXcml0ZSApO1xuXG4gICAgXHR9XG5cbiAgICBcdGZ1bmN0aW9uIHNldERlcHRoRnVuYyggZGVwdGhGdW5jICkge1xuXG4gICAgXHRcdGRlcHRoQnVmZmVyLnNldEZ1bmMoIGRlcHRoRnVuYyApO1xuXG4gICAgXHR9XG5cbiAgICBcdGZ1bmN0aW9uIHNldFN0ZW5jaWxUZXN0KCBzdGVuY2lsVGVzdCApIHtcblxuICAgIFx0XHRzdGVuY2lsQnVmZmVyLnNldFRlc3QoIHN0ZW5jaWxUZXN0ICk7XG5cbiAgICBcdH1cblxuICAgIFx0ZnVuY3Rpb24gc2V0U3RlbmNpbFdyaXRlKCBzdGVuY2lsV3JpdGUgKSB7XG5cbiAgICBcdFx0c3RlbmNpbEJ1ZmZlci5zZXRNYXNrKCBzdGVuY2lsV3JpdGUgKTtcblxuICAgIFx0fVxuXG4gICAgXHRmdW5jdGlvbiBzZXRTdGVuY2lsRnVuYyggc3RlbmNpbEZ1bmMsIHN0ZW5jaWxSZWYsIHN0ZW5jaWxNYXNrICkge1xuXG4gICAgXHRcdHN0ZW5jaWxCdWZmZXIuc2V0RnVuYyggc3RlbmNpbEZ1bmMsIHN0ZW5jaWxSZWYsIHN0ZW5jaWxNYXNrICk7XG5cbiAgICBcdH1cblxuICAgIFx0ZnVuY3Rpb24gc2V0U3RlbmNpbE9wKCBzdGVuY2lsRmFpbCwgc3RlbmNpbFpGYWlsLCBzdGVuY2lsWlBhc3MgKSB7XG5cbiAgICBcdFx0c3RlbmNpbEJ1ZmZlci5zZXRPcCggc3RlbmNpbEZhaWwsIHN0ZW5jaWxaRmFpbCwgc3RlbmNpbFpQYXNzICk7XG5cbiAgICBcdH1cblxuICAgIFx0Ly9cblxuICAgIFx0ZnVuY3Rpb24gc2V0RmxpcFNpZGVkKCBmbGlwU2lkZWQgKSB7XG5cbiAgICBcdFx0aWYgKCBjdXJyZW50RmxpcFNpZGVkICE9PSBmbGlwU2lkZWQgKSB7XG5cbiAgICBcdFx0XHRpZiAoIGZsaXBTaWRlZCApIHtcblxuICAgIFx0XHRcdFx0Z2wuZnJvbnRGYWNlKCBnbC5DVyApO1xuXG4gICAgXHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0Z2wuZnJvbnRGYWNlKCBnbC5DQ1cgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdGN1cnJlbnRGbGlwU2lkZWQgPSBmbGlwU2lkZWQ7XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9XG5cbiAgICBcdGZ1bmN0aW9uIHNldEN1bGxGYWNlKCBjdWxsRmFjZSApIHtcblxuICAgIFx0XHRpZiAoIGN1bGxGYWNlICE9PSBDdWxsRmFjZU5vbmUgKSB7XG5cbiAgICBcdFx0XHRlbmFibGUoIGdsLkNVTExfRkFDRSApO1xuXG4gICAgXHRcdFx0aWYgKCBjdWxsRmFjZSAhPT0gY3VycmVudEN1bGxGYWNlICkge1xuXG4gICAgXHRcdFx0XHRpZiAoIGN1bGxGYWNlID09PSBDdWxsRmFjZUJhY2sgKSB7XG5cbiAgICBcdFx0XHRcdFx0Z2wuY3VsbEZhY2UoIGdsLkJBQ0sgKTtcblxuICAgIFx0XHRcdFx0fSBlbHNlIGlmICggY3VsbEZhY2UgPT09IEN1bGxGYWNlRnJvbnQgKSB7XG5cbiAgICBcdFx0XHRcdFx0Z2wuY3VsbEZhY2UoIGdsLkZST05UICk7XG5cbiAgICBcdFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdFx0Z2wuY3VsbEZhY2UoIGdsLkZST05UX0FORF9CQUNLICk7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0ZGlzYWJsZSggZ2wuQ1VMTF9GQUNFICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGN1cnJlbnRDdWxsRmFjZSA9IGN1bGxGYWNlO1xuXG4gICAgXHR9XG5cbiAgICBcdGZ1bmN0aW9uIHNldExpbmVXaWR0aCggd2lkdGggKSB7XG5cbiAgICBcdFx0aWYgKCB3aWR0aCAhPT0gY3VycmVudExpbmVXaWR0aCApIHtcblxuICAgIFx0XHRcdGdsLmxpbmVXaWR0aCggd2lkdGggKTtcblxuICAgIFx0XHRcdGN1cnJlbnRMaW5lV2lkdGggPSB3aWR0aDtcblxuICAgIFx0XHR9XG5cbiAgICBcdH1cblxuICAgIFx0ZnVuY3Rpb24gc2V0UG9seWdvbk9mZnNldCggcG9seWdvbk9mZnNldCwgZmFjdG9yLCB1bml0cyApIHtcblxuICAgIFx0XHRpZiAoIHBvbHlnb25PZmZzZXQgKSB7XG5cbiAgICBcdFx0XHRlbmFibGUoIGdsLlBPTFlHT05fT0ZGU0VUX0ZJTEwgKTtcblxuICAgIFx0XHRcdGlmICggY3VycmVudFBvbHlnb25PZmZzZXRGYWN0b3IgIT09IGZhY3RvciB8fCBjdXJyZW50UG9seWdvbk9mZnNldFVuaXRzICE9PSB1bml0cyApIHtcblxuICAgIFx0XHRcdFx0Z2wucG9seWdvbk9mZnNldCggZmFjdG9yLCB1bml0cyApO1xuXG4gICAgXHRcdFx0XHRjdXJyZW50UG9seWdvbk9mZnNldEZhY3RvciA9IGZhY3RvcjtcbiAgICBcdFx0XHRcdGN1cnJlbnRQb2x5Z29uT2Zmc2V0VW5pdHMgPSB1bml0cztcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0ZGlzYWJsZSggZ2wuUE9MWUdPTl9PRkZTRVRfRklMTCApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0fVxuXG4gICAgXHRmdW5jdGlvbiBnZXRTY2lzc29yVGVzdCgpIHtcblxuICAgIFx0XHRyZXR1cm4gY3VycmVudFNjaXNzb3JUZXN0O1xuXG4gICAgXHR9XG5cbiAgICBcdGZ1bmN0aW9uIHNldFNjaXNzb3JUZXN0KCBzY2lzc29yVGVzdCApIHtcblxuICAgIFx0XHRjdXJyZW50U2Npc3NvclRlc3QgPSBzY2lzc29yVGVzdDtcblxuICAgIFx0XHRpZiAoIHNjaXNzb3JUZXN0ICkge1xuXG4gICAgXHRcdFx0ZW5hYmxlKCBnbC5TQ0lTU09SX1RFU1QgKTtcblxuICAgIFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0ZGlzYWJsZSggZ2wuU0NJU1NPUl9URVNUICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9XG5cbiAgICBcdC8vIHRleHR1cmVcblxuICAgIFx0ZnVuY3Rpb24gYWN0aXZlVGV4dHVyZSggd2ViZ2xTbG90ICkge1xuXG4gICAgXHRcdGlmICggd2ViZ2xTbG90ID09PSB1bmRlZmluZWQgKSB3ZWJnbFNsb3QgPSBnbC5URVhUVVJFMCArIG1heFRleHR1cmVzIC0gMTtcblxuICAgIFx0XHRpZiAoIGN1cnJlbnRUZXh0dXJlU2xvdCAhPT0gd2ViZ2xTbG90ICkge1xuXG4gICAgXHRcdFx0Z2wuYWN0aXZlVGV4dHVyZSggd2ViZ2xTbG90ICk7XG4gICAgXHRcdFx0Y3VycmVudFRleHR1cmVTbG90ID0gd2ViZ2xTbG90O1xuXG4gICAgXHRcdH1cblxuICAgIFx0fVxuXG4gICAgXHRmdW5jdGlvbiBiaW5kVGV4dHVyZSggd2ViZ2xUeXBlLCB3ZWJnbFRleHR1cmUgKSB7XG5cbiAgICBcdFx0aWYgKCBjdXJyZW50VGV4dHVyZVNsb3QgPT09IG51bGwgKSB7XG5cbiAgICBcdFx0XHRhY3RpdmVUZXh0dXJlKCk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHZhciBib3VuZFRleHR1cmUgPSBjdXJyZW50Qm91bmRUZXh0dXJlc1sgY3VycmVudFRleHR1cmVTbG90IF07XG5cbiAgICBcdFx0aWYgKCBib3VuZFRleHR1cmUgPT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdGJvdW5kVGV4dHVyZSA9IHsgdHlwZTogdW5kZWZpbmVkLCB0ZXh0dXJlOiB1bmRlZmluZWQgfTtcbiAgICBcdFx0XHRjdXJyZW50Qm91bmRUZXh0dXJlc1sgY3VycmVudFRleHR1cmVTbG90IF0gPSBib3VuZFRleHR1cmU7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGlmICggYm91bmRUZXh0dXJlLnR5cGUgIT09IHdlYmdsVHlwZSB8fCBib3VuZFRleHR1cmUudGV4dHVyZSAhPT0gd2ViZ2xUZXh0dXJlICkge1xuXG4gICAgXHRcdFx0Z2wuYmluZFRleHR1cmUoIHdlYmdsVHlwZSwgd2ViZ2xUZXh0dXJlIHx8IGVtcHR5VGV4dHVyZXNbIHdlYmdsVHlwZSBdICk7XG5cbiAgICBcdFx0XHRib3VuZFRleHR1cmUudHlwZSA9IHdlYmdsVHlwZTtcbiAgICBcdFx0XHRib3VuZFRleHR1cmUudGV4dHVyZSA9IHdlYmdsVGV4dHVyZTtcblxuICAgIFx0XHR9XG5cbiAgICBcdH1cblxuICAgIFx0ZnVuY3Rpb24gY29tcHJlc3NlZFRleEltYWdlMkQoKSB7XG5cbiAgICBcdFx0dHJ5IHtcblxuICAgIFx0XHRcdGdsLmNvbXByZXNzZWRUZXhJbWFnZTJELmFwcGx5KCBnbCwgYXJndW1lbnRzICk7XG5cbiAgICBcdFx0fSBjYXRjaCAoIGVycm9yICkge1xuXG4gICAgXHRcdFx0Y29uc29sZS5lcnJvciggZXJyb3IgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdH1cblxuICAgIFx0ZnVuY3Rpb24gdGV4SW1hZ2UyRCgpIHtcblxuICAgIFx0XHR0cnkge1xuXG4gICAgXHRcdFx0Z2wudGV4SW1hZ2UyRC5hcHBseSggZ2wsIGFyZ3VtZW50cyApO1xuXG4gICAgXHRcdH0gY2F0Y2ggKCBlcnJvciApIHtcblxuICAgIFx0XHRcdGNvbnNvbGUuZXJyb3IoIGVycm9yICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9XG5cbiAgICBcdC8vIFRPRE8gRGVwcmVjYXRlXG5cbiAgICBcdGZ1bmN0aW9uIGNsZWFyQ29sb3IoIHIsIGcsIGIsIGEgKSB7XG5cbiAgICBcdFx0Y29sb3JCdWZmZXIuc2V0Q2xlYXIoIHIsIGcsIGIsIGEgKTtcblxuICAgIFx0fVxuXG4gICAgXHRmdW5jdGlvbiBjbGVhckRlcHRoKCBkZXB0aCApIHtcblxuICAgIFx0XHRkZXB0aEJ1ZmZlci5zZXRDbGVhciggZGVwdGggKTtcblxuICAgIFx0fVxuXG4gICAgXHRmdW5jdGlvbiBjbGVhclN0ZW5jaWwoIHN0ZW5jaWwgKSB7XG5cbiAgICBcdFx0c3RlbmNpbEJ1ZmZlci5zZXRDbGVhciggc3RlbmNpbCApO1xuXG4gICAgXHR9XG5cbiAgICBcdC8vXG5cbiAgICBcdGZ1bmN0aW9uIHNjaXNzb3IoIHNjaXNzb3IgKSB7XG5cbiAgICBcdFx0aWYgKCBjdXJyZW50U2Npc3Nvci5lcXVhbHMoIHNjaXNzb3IgKSA9PT0gZmFsc2UgKSB7XG5cbiAgICBcdFx0XHRnbC5zY2lzc29yKCBzY2lzc29yLngsIHNjaXNzb3IueSwgc2Npc3Nvci56LCBzY2lzc29yLncgKTtcbiAgICBcdFx0XHRjdXJyZW50U2Npc3Nvci5jb3B5KCBzY2lzc29yICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9XG5cbiAgICBcdGZ1bmN0aW9uIHZpZXdwb3J0KCB2aWV3cG9ydCApIHtcblxuICAgIFx0XHRpZiAoIGN1cnJlbnRWaWV3cG9ydC5lcXVhbHMoIHZpZXdwb3J0ICkgPT09IGZhbHNlICkge1xuXG4gICAgXHRcdFx0Z2wudmlld3BvcnQoIHZpZXdwb3J0LngsIHZpZXdwb3J0LnksIHZpZXdwb3J0LnosIHZpZXdwb3J0LncgKTtcbiAgICBcdFx0XHRjdXJyZW50Vmlld3BvcnQuY29weSggdmlld3BvcnQgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdH1cblxuICAgIFx0Ly9cblxuICAgIFx0ZnVuY3Rpb24gcmVzZXQoKSB7XG5cbiAgICBcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZW5hYmxlZEF0dHJpYnV0ZXMubGVuZ3RoOyBpICsrICkge1xuXG4gICAgXHRcdFx0aWYgKCBlbmFibGVkQXR0cmlidXRlc1sgaSBdID09PSAxICkge1xuXG4gICAgXHRcdFx0XHRnbC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkoIGkgKTtcbiAgICBcdFx0XHRcdGVuYWJsZWRBdHRyaWJ1dGVzWyBpIF0gPSAwO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHRjYXBhYmlsaXRpZXMgPSB7fTtcblxuICAgIFx0XHRjb21wcmVzc2VkVGV4dHVyZUZvcm1hdHMgPSBudWxsO1xuXG4gICAgXHRcdGN1cnJlbnRUZXh0dXJlU2xvdCA9IG51bGw7XG4gICAgXHRcdGN1cnJlbnRCb3VuZFRleHR1cmVzID0ge307XG5cbiAgICBcdFx0Y3VycmVudEJsZW5kaW5nID0gbnVsbDtcblxuICAgIFx0XHRjdXJyZW50RmxpcFNpZGVkID0gbnVsbDtcbiAgICBcdFx0Y3VycmVudEN1bGxGYWNlID0gbnVsbDtcblxuICAgIFx0XHRjb2xvckJ1ZmZlci5yZXNldCgpO1xuICAgIFx0XHRkZXB0aEJ1ZmZlci5yZXNldCgpO1xuICAgIFx0XHRzdGVuY2lsQnVmZmVyLnJlc2V0KCk7XG5cbiAgICBcdH1cblxuICAgIFx0cmV0dXJuIHtcblxuICAgIFx0XHRidWZmZXJzOiB7XG4gICAgXHRcdFx0Y29sb3I6IGNvbG9yQnVmZmVyLFxuICAgIFx0XHRcdGRlcHRoOiBkZXB0aEJ1ZmZlcixcbiAgICBcdFx0XHRzdGVuY2lsOiBzdGVuY2lsQnVmZmVyXG4gICAgXHRcdH0sXG5cbiAgICBcdFx0aW5pdDogaW5pdCxcbiAgICBcdFx0aW5pdEF0dHJpYnV0ZXM6IGluaXRBdHRyaWJ1dGVzLFxuICAgIFx0XHRlbmFibGVBdHRyaWJ1dGU6IGVuYWJsZUF0dHJpYnV0ZSxcbiAgICBcdFx0ZW5hYmxlQXR0cmlidXRlQW5kRGl2aXNvcjogZW5hYmxlQXR0cmlidXRlQW5kRGl2aXNvcixcbiAgICBcdFx0ZGlzYWJsZVVudXNlZEF0dHJpYnV0ZXM6IGRpc2FibGVVbnVzZWRBdHRyaWJ1dGVzLFxuICAgIFx0XHRlbmFibGU6IGVuYWJsZSxcbiAgICBcdFx0ZGlzYWJsZTogZGlzYWJsZSxcbiAgICBcdFx0Z2V0Q29tcHJlc3NlZFRleHR1cmVGb3JtYXRzOiBnZXRDb21wcmVzc2VkVGV4dHVyZUZvcm1hdHMsXG5cbiAgICBcdFx0c2V0QmxlbmRpbmc6IHNldEJsZW5kaW5nLFxuXG4gICAgXHRcdHNldENvbG9yV3JpdGU6IHNldENvbG9yV3JpdGUsXG4gICAgXHRcdHNldERlcHRoVGVzdDogc2V0RGVwdGhUZXN0LFxuICAgIFx0XHRzZXREZXB0aFdyaXRlOiBzZXREZXB0aFdyaXRlLFxuICAgIFx0XHRzZXREZXB0aEZ1bmM6IHNldERlcHRoRnVuYyxcbiAgICBcdFx0c2V0U3RlbmNpbFRlc3Q6IHNldFN0ZW5jaWxUZXN0LFxuICAgIFx0XHRzZXRTdGVuY2lsV3JpdGU6IHNldFN0ZW5jaWxXcml0ZSxcbiAgICBcdFx0c2V0U3RlbmNpbEZ1bmM6IHNldFN0ZW5jaWxGdW5jLFxuICAgIFx0XHRzZXRTdGVuY2lsT3A6IHNldFN0ZW5jaWxPcCxcblxuICAgIFx0XHRzZXRGbGlwU2lkZWQ6IHNldEZsaXBTaWRlZCxcbiAgICBcdFx0c2V0Q3VsbEZhY2U6IHNldEN1bGxGYWNlLFxuXG4gICAgXHRcdHNldExpbmVXaWR0aDogc2V0TGluZVdpZHRoLFxuICAgIFx0XHRzZXRQb2x5Z29uT2Zmc2V0OiBzZXRQb2x5Z29uT2Zmc2V0LFxuXG4gICAgXHRcdGdldFNjaXNzb3JUZXN0OiBnZXRTY2lzc29yVGVzdCxcbiAgICBcdFx0c2V0U2Npc3NvclRlc3Q6IHNldFNjaXNzb3JUZXN0LFxuXG4gICAgXHRcdGFjdGl2ZVRleHR1cmU6IGFjdGl2ZVRleHR1cmUsXG4gICAgXHRcdGJpbmRUZXh0dXJlOiBiaW5kVGV4dHVyZSxcbiAgICBcdFx0Y29tcHJlc3NlZFRleEltYWdlMkQ6IGNvbXByZXNzZWRUZXhJbWFnZTJELFxuICAgIFx0XHR0ZXhJbWFnZTJEOiB0ZXhJbWFnZTJELFxuXG4gICAgXHRcdGNsZWFyQ29sb3I6IGNsZWFyQ29sb3IsXG4gICAgXHRcdGNsZWFyRGVwdGg6IGNsZWFyRGVwdGgsXG4gICAgXHRcdGNsZWFyU3RlbmNpbDogY2xlYXJTdGVuY2lsLFxuXG4gICAgXHRcdHNjaXNzb3I6IHNjaXNzb3IsXG4gICAgXHRcdHZpZXdwb3J0OiB2aWV3cG9ydCxcblxuICAgIFx0XHRyZXNldDogcmVzZXRcblxuICAgIFx0fTtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBXZWJHTENhcGFiaWxpdGllcyggZ2wsIGV4dGVuc2lvbnMsIHBhcmFtZXRlcnMgKSB7XG5cbiAgICBcdHZhciBtYXhBbmlzb3Ryb3B5O1xuXG4gICAgXHRmdW5jdGlvbiBnZXRNYXhBbmlzb3Ryb3B5KCkge1xuXG4gICAgXHRcdGlmICggbWF4QW5pc290cm9weSAhPT0gdW5kZWZpbmVkICkgcmV0dXJuIG1heEFuaXNvdHJvcHk7XG5cbiAgICBcdFx0dmFyIGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJyApO1xuXG4gICAgXHRcdGlmICggZXh0ZW5zaW9uICE9PSBudWxsICkge1xuXG4gICAgXHRcdFx0bWF4QW5pc290cm9weSA9IGdsLmdldFBhcmFtZXRlciggZXh0ZW5zaW9uLk1BWF9URVhUVVJFX01BWF9BTklTT1RST1BZX0VYVCApO1xuXG4gICAgXHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRtYXhBbmlzb3Ryb3B5ID0gMDtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIG1heEFuaXNvdHJvcHk7XG5cbiAgICBcdH1cblxuICAgIFx0ZnVuY3Rpb24gZ2V0TWF4UHJlY2lzaW9uKCBwcmVjaXNpb24gKSB7XG5cbiAgICBcdFx0aWYgKCBwcmVjaXNpb24gPT09ICdoaWdocCcgKSB7XG5cbiAgICBcdFx0XHRpZiAoIGdsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdCggZ2wuVkVSVEVYX1NIQURFUiwgZ2wuSElHSF9GTE9BVCApLnByZWNpc2lvbiA+IDAgJiZcbiAgICBcdFx0XHQgICAgIGdsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdCggZ2wuRlJBR01FTlRfU0hBREVSLCBnbC5ISUdIX0ZMT0FUICkucHJlY2lzaW9uID4gMCApIHtcblxuICAgIFx0XHRcdFx0cmV0dXJuICdoaWdocCc7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRwcmVjaXNpb24gPSAnbWVkaXVtcCc7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGlmICggcHJlY2lzaW9uID09PSAnbWVkaXVtcCcgKSB7XG5cbiAgICBcdFx0XHRpZiAoIGdsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdCggZ2wuVkVSVEVYX1NIQURFUiwgZ2wuTUVESVVNX0ZMT0FUICkucHJlY2lzaW9uID4gMCAmJlxuICAgIFx0XHRcdCAgICAgZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KCBnbC5GUkFHTUVOVF9TSEFERVIsIGdsLk1FRElVTV9GTE9BVCApLnByZWNpc2lvbiA+IDAgKSB7XG5cbiAgICBcdFx0XHRcdHJldHVybiAnbWVkaXVtcCc7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiAnbG93cCc7XG5cbiAgICBcdH1cblxuICAgIFx0dmFyIHByZWNpc2lvbiA9IHBhcmFtZXRlcnMucHJlY2lzaW9uICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLnByZWNpc2lvbiA6ICdoaWdocCc7XG4gICAgXHR2YXIgbWF4UHJlY2lzaW9uID0gZ2V0TWF4UHJlY2lzaW9uKCBwcmVjaXNpb24gKTtcblxuICAgIFx0aWYgKCBtYXhQcmVjaXNpb24gIT09IHByZWNpc2lvbiApIHtcblxuICAgIFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOicsIHByZWNpc2lvbiwgJ25vdCBzdXBwb3J0ZWQsIHVzaW5nJywgbWF4UHJlY2lzaW9uLCAnaW5zdGVhZC4nICk7XG4gICAgXHRcdHByZWNpc2lvbiA9IG1heFByZWNpc2lvbjtcblxuICAgIFx0fVxuXG4gICAgXHR2YXIgbG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciA9IHBhcmFtZXRlcnMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciA9PT0gdHJ1ZSAmJiAhISBleHRlbnNpb25zLmdldCggJ0VYVF9mcmFnX2RlcHRoJyApO1xuXG4gICAgXHR2YXIgbWF4VGV4dHVyZXMgPSBnbC5nZXRQYXJhbWV0ZXIoIGdsLk1BWF9URVhUVVJFX0lNQUdFX1VOSVRTICk7XG4gICAgXHR2YXIgbWF4VmVydGV4VGV4dHVyZXMgPSBnbC5nZXRQYXJhbWV0ZXIoIGdsLk1BWF9WRVJURVhfVEVYVFVSRV9JTUFHRV9VTklUUyApO1xuICAgIFx0dmFyIG1heFRleHR1cmVTaXplID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5NQVhfVEVYVFVSRV9TSVpFICk7XG4gICAgXHR2YXIgbWF4Q3ViZW1hcFNpemUgPSBnbC5nZXRQYXJhbWV0ZXIoIGdsLk1BWF9DVUJFX01BUF9URVhUVVJFX1NJWkUgKTtcblxuICAgIFx0dmFyIG1heEF0dHJpYnV0ZXMgPSBnbC5nZXRQYXJhbWV0ZXIoIGdsLk1BWF9WRVJURVhfQVRUUklCUyApO1xuICAgIFx0dmFyIG1heFZlcnRleFVuaWZvcm1zID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5NQVhfVkVSVEVYX1VOSUZPUk1fVkVDVE9SUyApO1xuICAgIFx0dmFyIG1heFZhcnlpbmdzID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5NQVhfVkFSWUlOR19WRUNUT1JTICk7XG4gICAgXHR2YXIgbWF4RnJhZ21lbnRVbmlmb3JtcyA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX0ZSQUdNRU5UX1VOSUZPUk1fVkVDVE9SUyApO1xuXG4gICAgXHR2YXIgdmVydGV4VGV4dHVyZXMgPSBtYXhWZXJ0ZXhUZXh0dXJlcyA+IDA7XG4gICAgXHR2YXIgZmxvYXRGcmFnbWVudFRleHR1cmVzID0gISEgZXh0ZW5zaW9ucy5nZXQoICdPRVNfdGV4dHVyZV9mbG9hdCcgKTtcbiAgICBcdHZhciBmbG9hdFZlcnRleFRleHR1cmVzID0gdmVydGV4VGV4dHVyZXMgJiYgZmxvYXRGcmFnbWVudFRleHR1cmVzO1xuXG4gICAgXHRyZXR1cm4ge1xuXG4gICAgXHRcdGdldE1heEFuaXNvdHJvcHk6IGdldE1heEFuaXNvdHJvcHksXG4gICAgXHRcdGdldE1heFByZWNpc2lvbjogZ2V0TWF4UHJlY2lzaW9uLFxuXG4gICAgXHRcdHByZWNpc2lvbjogcHJlY2lzaW9uLFxuICAgIFx0XHRsb2dhcml0aG1pY0RlcHRoQnVmZmVyOiBsb2dhcml0aG1pY0RlcHRoQnVmZmVyLFxuXG4gICAgXHRcdG1heFRleHR1cmVzOiBtYXhUZXh0dXJlcyxcbiAgICBcdFx0bWF4VmVydGV4VGV4dHVyZXM6IG1heFZlcnRleFRleHR1cmVzLFxuICAgIFx0XHRtYXhUZXh0dXJlU2l6ZTogbWF4VGV4dHVyZVNpemUsXG4gICAgXHRcdG1heEN1YmVtYXBTaXplOiBtYXhDdWJlbWFwU2l6ZSxcblxuICAgIFx0XHRtYXhBdHRyaWJ1dGVzOiBtYXhBdHRyaWJ1dGVzLFxuICAgIFx0XHRtYXhWZXJ0ZXhVbmlmb3JtczogbWF4VmVydGV4VW5pZm9ybXMsXG4gICAgXHRcdG1heFZhcnlpbmdzOiBtYXhWYXJ5aW5ncyxcbiAgICBcdFx0bWF4RnJhZ21lbnRVbmlmb3JtczogbWF4RnJhZ21lbnRVbmlmb3JtcyxcblxuICAgIFx0XHR2ZXJ0ZXhUZXh0dXJlczogdmVydGV4VGV4dHVyZXMsXG4gICAgXHRcdGZsb2F0RnJhZ21lbnRUZXh0dXJlczogZmxvYXRGcmFnbWVudFRleHR1cmVzLFxuICAgIFx0XHRmbG9hdFZlcnRleFRleHR1cmVzOiBmbG9hdFZlcnRleFRleHR1cmVzXG5cbiAgICBcdH07XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gV2ViR0xFeHRlbnNpb25zKCBnbCApIHtcblxuICAgIFx0dmFyIGV4dGVuc2lvbnMgPSB7fTtcblxuICAgIFx0cmV0dXJuIHtcblxuICAgIFx0XHRnZXQ6IGZ1bmN0aW9uICggbmFtZSApIHtcblxuICAgIFx0XHRcdGlmICggZXh0ZW5zaW9uc1sgbmFtZSBdICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRcdHJldHVybiBleHRlbnNpb25zWyBuYW1lIF07XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHR2YXIgZXh0ZW5zaW9uO1xuXG4gICAgXHRcdFx0c3dpdGNoICggbmFtZSApIHtcblxuICAgIFx0XHRcdFx0Y2FzZSAnV0VCR0xfZGVwdGhfdGV4dHVyZSc6XG4gICAgXHRcdFx0XHRcdGV4dGVuc2lvbiA9IGdsLmdldEV4dGVuc2lvbiggJ1dFQkdMX2RlcHRoX3RleHR1cmUnICkgfHwgZ2wuZ2V0RXh0ZW5zaW9uKCAnTU9aX1dFQkdMX2RlcHRoX3RleHR1cmUnICkgfHwgZ2wuZ2V0RXh0ZW5zaW9uKCAnV0VCS0lUX1dFQkdMX2RlcHRoX3RleHR1cmUnICk7XG4gICAgXHRcdFx0XHRcdGJyZWFrO1xuXG4gICAgXHRcdFx0XHRjYXNlICdFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnOlxuICAgIFx0XHRcdFx0XHRleHRlbnNpb24gPSBnbC5nZXRFeHRlbnNpb24oICdFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnICkgfHwgZ2wuZ2V0RXh0ZW5zaW9uKCAnTU9aX0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYycgKSB8fCBnbC5nZXRFeHRlbnNpb24oICdXRUJLSVRfRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJyApO1xuICAgIFx0XHRcdFx0XHRicmVhaztcblxuICAgIFx0XHRcdFx0Y2FzZSAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGMnOlxuICAgIFx0XHRcdFx0XHRleHRlbnNpb24gPSBnbC5nZXRFeHRlbnNpb24oICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0YycgKSB8fCBnbC5nZXRFeHRlbnNpb24oICdNT1pfV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGMnICkgfHwgZ2wuZ2V0RXh0ZW5zaW9uKCAnV0VCS0lUX1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjJyApO1xuICAgIFx0XHRcdFx0XHRicmVhaztcblxuICAgIFx0XHRcdFx0Y2FzZSAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjJzpcbiAgICBcdFx0XHRcdFx0ZXh0ZW5zaW9uID0gZ2wuZ2V0RXh0ZW5zaW9uKCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjJyApIHx8IGdsLmdldEV4dGVuc2lvbiggJ1dFQktJVF9XRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGMnICk7XG4gICAgXHRcdFx0XHRcdGJyZWFrO1xuXG4gICAgXHRcdFx0XHRjYXNlICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfZXRjMSc6XG4gICAgXHRcdFx0XHRcdGV4dGVuc2lvbiA9IGdsLmdldEV4dGVuc2lvbiggJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9ldGMxJyApO1xuICAgIFx0XHRcdFx0XHRicmVhaztcblxuICAgIFx0XHRcdFx0ZGVmYXVsdDpcbiAgICBcdFx0XHRcdFx0ZXh0ZW5zaW9uID0gZ2wuZ2V0RXh0ZW5zaW9uKCBuYW1lICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRpZiAoIGV4dGVuc2lvbiA9PT0gbnVsbCApIHtcblxuICAgIFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogJyArIG5hbWUgKyAnIGV4dGVuc2lvbiBub3Qgc3VwcG9ydGVkLicgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdGV4dGVuc2lvbnNbIG5hbWUgXSA9IGV4dGVuc2lvbjtcblxuICAgIFx0XHRcdHJldHVybiBleHRlbnNpb247XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9O1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gV2ViR0xDbGlwcGluZygpIHtcblxuICAgIFx0dmFyIHNjb3BlID0gdGhpcyxcblxuICAgIFx0XHRnbG9iYWxTdGF0ZSA9IG51bGwsXG4gICAgXHRcdG51bUdsb2JhbFBsYW5lcyA9IDAsXG4gICAgXHRcdGxvY2FsQ2xpcHBpbmdFbmFibGVkID0gZmFsc2UsXG4gICAgXHRcdHJlbmRlcmluZ1NoYWRvd3MgPSBmYWxzZSxcblxuICAgIFx0XHRwbGFuZSA9IG5ldyBQbGFuZSgpLFxuICAgIFx0XHR2aWV3Tm9ybWFsTWF0cml4ID0gbmV3IE1hdHJpeDMoKSxcblxuICAgIFx0XHR1bmlmb3JtID0geyB2YWx1ZTogbnVsbCwgbmVlZHNVcGRhdGU6IGZhbHNlIH07XG5cbiAgICBcdHRoaXMudW5pZm9ybSA9IHVuaWZvcm07XG4gICAgXHR0aGlzLm51bVBsYW5lcyA9IDA7XG5cbiAgICBcdHRoaXMuaW5pdCA9IGZ1bmN0aW9uKCBwbGFuZXMsIGVuYWJsZUxvY2FsQ2xpcHBpbmcsIGNhbWVyYSApIHtcblxuICAgIFx0XHR2YXIgZW5hYmxlZCA9XG4gICAgXHRcdFx0cGxhbmVzLmxlbmd0aCAhPT0gMCB8fFxuICAgIFx0XHRcdGVuYWJsZUxvY2FsQ2xpcHBpbmcgfHxcbiAgICBcdFx0XHQvLyBlbmFibGUgc3RhdGUgb2YgcHJldmlvdXMgZnJhbWUgLSB0aGUgY2xpcHBpbmcgY29kZSBoYXMgdG9cbiAgICBcdFx0XHQvLyBydW4gYW5vdGhlciBmcmFtZSBpbiBvcmRlciB0byByZXNldCB0aGUgc3RhdGU6XG4gICAgXHRcdFx0bnVtR2xvYmFsUGxhbmVzICE9PSAwIHx8XG4gICAgXHRcdFx0bG9jYWxDbGlwcGluZ0VuYWJsZWQ7XG5cbiAgICBcdFx0bG9jYWxDbGlwcGluZ0VuYWJsZWQgPSBlbmFibGVMb2NhbENsaXBwaW5nO1xuXG4gICAgXHRcdGdsb2JhbFN0YXRlID0gcHJvamVjdFBsYW5lcyggcGxhbmVzLCBjYW1lcmEsIDAgKTtcbiAgICBcdFx0bnVtR2xvYmFsUGxhbmVzID0gcGxhbmVzLmxlbmd0aDtcblxuICAgIFx0XHRyZXR1cm4gZW5hYmxlZDtcblxuICAgIFx0fTtcblxuICAgIFx0dGhpcy5iZWdpblNoYWRvd3MgPSBmdW5jdGlvbigpIHtcblxuICAgIFx0XHRyZW5kZXJpbmdTaGFkb3dzID0gdHJ1ZTtcbiAgICBcdFx0cHJvamVjdFBsYW5lcyggbnVsbCApO1xuXG4gICAgXHR9O1xuXG4gICAgXHR0aGlzLmVuZFNoYWRvd3MgPSBmdW5jdGlvbigpIHtcblxuICAgIFx0XHRyZW5kZXJpbmdTaGFkb3dzID0gZmFsc2U7XG4gICAgXHRcdHJlc2V0R2xvYmFsU3RhdGUoKTtcblxuICAgIFx0fTtcblxuICAgIFx0dGhpcy5zZXRTdGF0ZSA9IGZ1bmN0aW9uKCBwbGFuZXMsIGNsaXBTaGFkb3dzLCBjYW1lcmEsIGNhY2hlLCBmcm9tQ2FjaGUgKSB7XG5cbiAgICBcdFx0aWYgKCAhIGxvY2FsQ2xpcHBpbmdFbmFibGVkIHx8XG4gICAgXHRcdFx0XHRwbGFuZXMgPT09IG51bGwgfHwgcGxhbmVzLmxlbmd0aCA9PT0gMCB8fFxuICAgIFx0XHRcdFx0cmVuZGVyaW5nU2hhZG93cyAmJiAhIGNsaXBTaGFkb3dzICkge1xuICAgIFx0XHRcdC8vIHRoZXJlJ3Mgbm8gbG9jYWwgY2xpcHBpbmdcblxuICAgIFx0XHRcdGlmICggcmVuZGVyaW5nU2hhZG93cyApIHtcbiAgICBcdFx0XHRcdC8vIHRoZXJlJ3Mgbm8gZ2xvYmFsIGNsaXBwaW5nXG5cbiAgICBcdFx0XHRcdHByb2plY3RQbGFuZXMoIG51bGwgKTtcblxuICAgIFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdHJlc2V0R2xvYmFsU3RhdGUoKTtcbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdHZhciBuR2xvYmFsID0gcmVuZGVyaW5nU2hhZG93cyA/IDAgOiBudW1HbG9iYWxQbGFuZXMsXG4gICAgXHRcdFx0XHRsR2xvYmFsID0gbkdsb2JhbCAqIDQsXG5cbiAgICBcdFx0XHRcdGRzdEFycmF5ID0gY2FjaGUuY2xpcHBpbmdTdGF0ZSB8fCBudWxsO1xuXG4gICAgXHRcdFx0dW5pZm9ybS52YWx1ZSA9IGRzdEFycmF5OyAvLyBlbnN1cmUgdW5pcXVlIHN0YXRlXG5cbiAgICBcdFx0XHRkc3RBcnJheSA9IHByb2plY3RQbGFuZXMoIHBsYW5lcywgY2FtZXJhLCBsR2xvYmFsLCBmcm9tQ2FjaGUgKTtcblxuICAgIFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSAhPT0gbEdsb2JhbDsgKysgaSApIHtcblxuICAgIFx0XHRcdFx0ZHN0QXJyYXlbIGkgXSA9IGdsb2JhbFN0YXRlWyBpIF07XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRjYWNoZS5jbGlwcGluZ1N0YXRlID0gZHN0QXJyYXk7XG4gICAgXHRcdFx0dGhpcy5udW1QbGFuZXMgKz0gbkdsb2JhbDtcblxuICAgIFx0XHR9XG5cblxuICAgIFx0fTtcblxuICAgIFx0ZnVuY3Rpb24gcmVzZXRHbG9iYWxTdGF0ZSgpIHtcblxuICAgIFx0XHRpZiAoIHVuaWZvcm0udmFsdWUgIT09IGdsb2JhbFN0YXRlICkge1xuXG4gICAgXHRcdFx0dW5pZm9ybS52YWx1ZSA9IGdsb2JhbFN0YXRlO1xuICAgIFx0XHRcdHVuaWZvcm0ubmVlZHNVcGRhdGUgPSBudW1HbG9iYWxQbGFuZXMgPiAwO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRzY29wZS5udW1QbGFuZXMgPSBudW1HbG9iYWxQbGFuZXM7XG5cbiAgICBcdH1cblxuICAgIFx0ZnVuY3Rpb24gcHJvamVjdFBsYW5lcyggcGxhbmVzLCBjYW1lcmEsIGRzdE9mZnNldCwgc2tpcFRyYW5zZm9ybSApIHtcblxuICAgIFx0XHR2YXIgblBsYW5lcyA9IHBsYW5lcyAhPT0gbnVsbCA/IHBsYW5lcy5sZW5ndGggOiAwLFxuICAgIFx0XHRcdGRzdEFycmF5ID0gbnVsbDtcblxuICAgIFx0XHRpZiAoIG5QbGFuZXMgIT09IDAgKSB7XG5cbiAgICBcdFx0XHRkc3RBcnJheSA9IHVuaWZvcm0udmFsdWU7XG5cbiAgICBcdFx0XHRpZiAoIHNraXBUcmFuc2Zvcm0gIT09IHRydWUgfHwgZHN0QXJyYXkgPT09IG51bGwgKSB7XG5cbiAgICBcdFx0XHRcdHZhciBmbGF0U2l6ZSA9IGRzdE9mZnNldCArIG5QbGFuZXMgKiA0LFxuICAgIFx0XHRcdFx0XHR2aWV3TWF0cml4ID0gY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZTtcblxuICAgIFx0XHRcdFx0dmlld05vcm1hbE1hdHJpeC5nZXROb3JtYWxNYXRyaXgoIHZpZXdNYXRyaXggKTtcblxuICAgIFx0XHRcdFx0aWYgKCBkc3RBcnJheSA9PT0gbnVsbCB8fCBkc3RBcnJheS5sZW5ndGggPCBmbGF0U2l6ZSApIHtcblxuICAgIFx0XHRcdFx0XHRkc3RBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIGZsYXRTaXplICk7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpNCA9IGRzdE9mZnNldDtcbiAgICBcdFx0XHRcdFx0XHRcdFx0XHRpICE9PSBuUGxhbmVzOyArKyBpLCBpNCArPSA0ICkge1xuXG4gICAgXHRcdFx0XHRcdHBsYW5lLmNvcHkoIHBsYW5lc1sgaSBdICkuXG4gICAgXHRcdFx0XHRcdFx0XHRhcHBseU1hdHJpeDQoIHZpZXdNYXRyaXgsIHZpZXdOb3JtYWxNYXRyaXggKTtcblxuICAgIFx0XHRcdFx0XHRwbGFuZS5ub3JtYWwudG9BcnJheSggZHN0QXJyYXksIGk0ICk7XG4gICAgXHRcdFx0XHRcdGRzdEFycmF5WyBpNCArIDMgXSA9IHBsYW5lLmNvbnN0YW50O1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHR1bmlmb3JtLnZhbHVlID0gZHN0QXJyYXk7XG4gICAgXHRcdFx0dW5pZm9ybS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHNjb3BlLm51bVBsYW5lcyA9IG5QbGFuZXM7XG4gICAgXHRcdHJldHVybiBkc3RBcnJheTtcblxuICAgIFx0fVxuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBzdXBlcmVnZ2JlcnQgLyBodHRwOi8vd3d3LnBhdWxicnVudC5jby51ay9cbiAgICAgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICAgICAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gICAgICogQGF1dGhvciBzemltZWsgLyBodHRwczovL2dpdGh1Yi5jb20vc3ppbWVrL1xuICAgICAqIEBhdXRob3IgdHNjaHdcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIFdlYkdMUmVuZGVyZXIoIHBhcmFtZXRlcnMgKSB7XG5cbiAgICBcdGNvbnNvbGUubG9nKCAnVEhSRUUuV2ViR0xSZW5kZXJlcicsIFJFVklTSU9OICk7XG5cbiAgICBcdHBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzIHx8IHt9O1xuXG4gICAgXHR2YXIgX2NhbnZhcyA9IHBhcmFtZXRlcnMuY2FudmFzICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmNhbnZhcyA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyggJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnLCAnY2FudmFzJyApLFxuICAgIFx0X2NvbnRleHQgPSBwYXJhbWV0ZXJzLmNvbnRleHQgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuY29udGV4dCA6IG51bGwsXG5cbiAgICBcdF9hbHBoYSA9IHBhcmFtZXRlcnMuYWxwaGEgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuYWxwaGEgOiBmYWxzZSxcbiAgICBcdF9kZXB0aCA9IHBhcmFtZXRlcnMuZGVwdGggIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuZGVwdGggOiB0cnVlLFxuICAgIFx0X3N0ZW5jaWwgPSBwYXJhbWV0ZXJzLnN0ZW5jaWwgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuc3RlbmNpbCA6IHRydWUsXG4gICAgXHRfYW50aWFsaWFzID0gcGFyYW1ldGVycy5hbnRpYWxpYXMgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuYW50aWFsaWFzIDogZmFsc2UsXG4gICAgXHRfcHJlbXVsdGlwbGllZEFscGhhID0gcGFyYW1ldGVycy5wcmVtdWx0aXBsaWVkQWxwaGEgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMucHJlbXVsdGlwbGllZEFscGhhIDogdHJ1ZSxcbiAgICBcdF9wcmVzZXJ2ZURyYXdpbmdCdWZmZXIgPSBwYXJhbWV0ZXJzLnByZXNlcnZlRHJhd2luZ0J1ZmZlciAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5wcmVzZXJ2ZURyYXdpbmdCdWZmZXIgOiBmYWxzZTtcblxuICAgIFx0dmFyIGxpZ2h0cyA9IFtdO1xuXG4gICAgXHR2YXIgb3BhcXVlT2JqZWN0cyA9IFtdO1xuICAgIFx0dmFyIG9wYXF1ZU9iamVjdHNMYXN0SW5kZXggPSAtIDE7XG4gICAgXHR2YXIgdHJhbnNwYXJlbnRPYmplY3RzID0gW107XG4gICAgXHR2YXIgdHJhbnNwYXJlbnRPYmplY3RzTGFzdEluZGV4ID0gLSAxO1xuXG4gICAgXHR2YXIgbW9ycGhJbmZsdWVuY2VzID0gbmV3IEZsb2F0MzJBcnJheSggOCApO1xuXG4gICAgXHR2YXIgc3ByaXRlcyA9IFtdO1xuICAgIFx0dmFyIGxlbnNGbGFyZXMgPSBbXTtcblxuICAgIFx0Ly8gcHVibGljIHByb3BlcnRpZXNcblxuICAgIFx0dGhpcy5kb21FbGVtZW50ID0gX2NhbnZhcztcbiAgICBcdHRoaXMuY29udGV4dCA9IG51bGw7XG5cbiAgICBcdC8vIGNsZWFyaW5nXG5cbiAgICBcdHRoaXMuYXV0b0NsZWFyID0gdHJ1ZTtcbiAgICBcdHRoaXMuYXV0b0NsZWFyQ29sb3IgPSB0cnVlO1xuICAgIFx0dGhpcy5hdXRvQ2xlYXJEZXB0aCA9IHRydWU7XG4gICAgXHR0aGlzLmF1dG9DbGVhclN0ZW5jaWwgPSB0cnVlO1xuXG4gICAgXHQvLyBzY2VuZSBncmFwaFxuXG4gICAgXHR0aGlzLnNvcnRPYmplY3RzID0gdHJ1ZTtcblxuICAgIFx0Ly8gdXNlci1kZWZpbmVkIGNsaXBwaW5nXG5cbiAgICBcdHRoaXMuY2xpcHBpbmdQbGFuZXMgPSBbXTtcbiAgICBcdHRoaXMubG9jYWxDbGlwcGluZ0VuYWJsZWQgPSBmYWxzZTtcblxuICAgIFx0Ly8gcGh5c2ljYWxseSBiYXNlZCBzaGFkaW5nXG5cbiAgICBcdHRoaXMuZ2FtbWFGYWN0b3IgPSAyLjA7XHQvLyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICBcdHRoaXMuZ2FtbWFJbnB1dCA9IGZhbHNlO1xuICAgIFx0dGhpcy5nYW1tYU91dHB1dCA9IGZhbHNlO1xuXG4gICAgXHQvLyBwaHlzaWNhbCBsaWdodHNcblxuICAgIFx0dGhpcy5waHlzaWNhbGx5Q29ycmVjdExpZ2h0cyA9IGZhbHNlO1xuXG4gICAgXHQvLyB0b25lIG1hcHBpbmdcblxuICAgIFx0dGhpcy50b25lTWFwcGluZyA9IExpbmVhclRvbmVNYXBwaW5nO1xuICAgIFx0dGhpcy50b25lTWFwcGluZ0V4cG9zdXJlID0gMS4wO1xuICAgIFx0dGhpcy50b25lTWFwcGluZ1doaXRlUG9pbnQgPSAxLjA7XG5cbiAgICBcdC8vIG1vcnBoc1xuXG4gICAgXHR0aGlzLm1heE1vcnBoVGFyZ2V0cyA9IDg7XG4gICAgXHR0aGlzLm1heE1vcnBoTm9ybWFscyA9IDQ7XG5cbiAgICBcdC8vIGludGVybmFsIHByb3BlcnRpZXNcblxuICAgIFx0dmFyIF90aGlzID0gdGhpcyxcblxuICAgIFx0Ly8gaW50ZXJuYWwgc3RhdGUgY2FjaGVcblxuICAgIFx0X2N1cnJlbnRQcm9ncmFtID0gbnVsbCxcbiAgICBcdF9jdXJyZW50UmVuZGVyVGFyZ2V0ID0gbnVsbCxcbiAgICBcdF9jdXJyZW50RnJhbWVidWZmZXIgPSBudWxsLFxuICAgIFx0X2N1cnJlbnRNYXRlcmlhbElkID0gLSAxLFxuICAgIFx0X2N1cnJlbnRHZW9tZXRyeVByb2dyYW0gPSAnJyxcbiAgICBcdF9jdXJyZW50Q2FtZXJhID0gbnVsbCxcblxuICAgIFx0X2N1cnJlbnRTY2lzc29yID0gbmV3IFZlY3RvcjQoKSxcbiAgICBcdF9jdXJyZW50U2Npc3NvclRlc3QgPSBudWxsLFxuXG4gICAgXHRfY3VycmVudFZpZXdwb3J0ID0gbmV3IFZlY3RvcjQoKSxcblxuICAgIFx0Ly9cblxuICAgIFx0X3VzZWRUZXh0dXJlVW5pdHMgPSAwLFxuXG4gICAgXHQvL1xuXG4gICAgXHRfY2xlYXJDb2xvciA9IG5ldyBDb2xvciggMHgwMDAwMDAgKSxcbiAgICBcdF9jbGVhckFscGhhID0gMCxcblxuICAgIFx0X3dpZHRoID0gX2NhbnZhcy53aWR0aCxcbiAgICBcdF9oZWlnaHQgPSBfY2FudmFzLmhlaWdodCxcblxuICAgIFx0X3BpeGVsUmF0aW8gPSAxLFxuXG4gICAgXHRfc2Npc3NvciA9IG5ldyBWZWN0b3I0KCAwLCAwLCBfd2lkdGgsIF9oZWlnaHQgKSxcbiAgICBcdF9zY2lzc29yVGVzdCA9IGZhbHNlLFxuXG4gICAgXHRfdmlld3BvcnQgPSBuZXcgVmVjdG9yNCggMCwgMCwgX3dpZHRoLCBfaGVpZ2h0ICksXG5cbiAgICBcdC8vIGZydXN0dW1cblxuICAgIFx0X2ZydXN0dW0gPSBuZXcgRnJ1c3R1bSgpLFxuXG4gICAgXHQvLyBjbGlwcGluZ1xuXG4gICAgXHRfY2xpcHBpbmcgPSBuZXcgV2ViR0xDbGlwcGluZygpLFxuICAgIFx0X2NsaXBwaW5nRW5hYmxlZCA9IGZhbHNlLFxuICAgIFx0X2xvY2FsQ2xpcHBpbmdFbmFibGVkID0gZmFsc2UsXG5cbiAgICBcdF9zcGhlcmUgPSBuZXcgU3BoZXJlKCksXG5cbiAgICBcdC8vIGNhbWVyYSBtYXRyaWNlcyBjYWNoZVxuXG4gICAgXHRfcHJvalNjcmVlbk1hdHJpeCA9IG5ldyBNYXRyaXg0KCksXG5cbiAgICBcdF92ZWN0b3IzID0gbmV3IFZlY3RvcjMoKSxcblxuICAgIFx0Ly8gbGlnaHQgYXJyYXlzIGNhY2hlXG5cbiAgICBcdF9saWdodHMgPSB7XG5cbiAgICBcdFx0aGFzaDogJycsXG5cbiAgICBcdFx0YW1iaWVudDogWyAwLCAwLCAwIF0sXG4gICAgXHRcdGRpcmVjdGlvbmFsOiBbXSxcbiAgICBcdFx0ZGlyZWN0aW9uYWxTaGFkb3dNYXA6IFtdLFxuICAgIFx0XHRkaXJlY3Rpb25hbFNoYWRvd01hdHJpeDogW10sXG4gICAgXHRcdHNwb3Q6IFtdLFxuICAgIFx0XHRzcG90U2hhZG93TWFwOiBbXSxcbiAgICBcdFx0c3BvdFNoYWRvd01hdHJpeDogW10sXG4gICAgXHRcdHBvaW50OiBbXSxcbiAgICBcdFx0cG9pbnRTaGFkb3dNYXA6IFtdLFxuICAgIFx0XHRwb2ludFNoYWRvd01hdHJpeDogW10sXG4gICAgXHRcdGhlbWk6IFtdLFxuXG4gICAgXHRcdHNoYWRvd3M6IFtdXG5cbiAgICBcdH0sXG5cbiAgICBcdC8vIGluZm9cblxuICAgIFx0X2luZm9SZW5kZXIgPSB7XG5cbiAgICBcdFx0Y2FsbHM6IDAsXG4gICAgXHRcdHZlcnRpY2VzOiAwLFxuICAgIFx0XHRmYWNlczogMCxcbiAgICBcdFx0cG9pbnRzOiAwXG5cbiAgICBcdH07XG5cbiAgICBcdHRoaXMuaW5mbyA9IHtcblxuICAgIFx0XHRyZW5kZXI6IF9pbmZvUmVuZGVyLFxuICAgIFx0XHRtZW1vcnk6IHtcblxuICAgIFx0XHRcdGdlb21ldHJpZXM6IDAsXG4gICAgXHRcdFx0dGV4dHVyZXM6IDBcblxuICAgIFx0XHR9LFxuICAgIFx0XHRwcm9ncmFtczogbnVsbFxuXG4gICAgXHR9O1xuXG5cbiAgICBcdC8vIGluaXRpYWxpemVcblxuICAgIFx0dmFyIF9nbDtcblxuICAgIFx0dHJ5IHtcblxuICAgIFx0XHR2YXIgYXR0cmlidXRlcyA9IHtcbiAgICBcdFx0XHRhbHBoYTogX2FscGhhLFxuICAgIFx0XHRcdGRlcHRoOiBfZGVwdGgsXG4gICAgXHRcdFx0c3RlbmNpbDogX3N0ZW5jaWwsXG4gICAgXHRcdFx0YW50aWFsaWFzOiBfYW50aWFsaWFzLFxuICAgIFx0XHRcdHByZW11bHRpcGxpZWRBbHBoYTogX3ByZW11bHRpcGxpZWRBbHBoYSxcbiAgICBcdFx0XHRwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IF9wcmVzZXJ2ZURyYXdpbmdCdWZmZXJcbiAgICBcdFx0fTtcblxuICAgIFx0XHRfZ2wgPSBfY29udGV4dCB8fCBfY2FudmFzLmdldENvbnRleHQoICd3ZWJnbCcsIGF0dHJpYnV0ZXMgKSB8fCBfY2FudmFzLmdldENvbnRleHQoICdleHBlcmltZW50YWwtd2ViZ2wnLCBhdHRyaWJ1dGVzICk7XG5cbiAgICBcdFx0aWYgKCBfZ2wgPT09IG51bGwgKSB7XG5cbiAgICBcdFx0XHRpZiAoIF9jYW52YXMuZ2V0Q29udGV4dCggJ3dlYmdsJyApICE9PSBudWxsICkge1xuXG4gICAgXHRcdFx0XHR0aHJvdyAnRXJyb3IgY3JlYXRpbmcgV2ViR0wgY29udGV4dCB3aXRoIHlvdXIgc2VsZWN0ZWQgYXR0cmlidXRlcy4nO1xuXG4gICAgXHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0dGhyb3cgJ0Vycm9yIGNyZWF0aW5nIFdlYkdMIGNvbnRleHQuJztcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdFx0Ly8gU29tZSBleHBlcmltZW50YWwtd2ViZ2wgaW1wbGVtZW50YXRpb25zIGRvIG5vdCBoYXZlIGdldFNoYWRlclByZWNpc2lvbkZvcm1hdFxuXG4gICAgXHRcdGlmICggX2dsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdCA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0X2dsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdCA9IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHRcdFx0cmV0dXJuIHsgJ3JhbmdlTWluJzogMSwgJ3JhbmdlTWF4JzogMSwgJ3ByZWNpc2lvbic6IDEgfTtcblxuICAgIFx0XHRcdH07XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdF9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lciggJ3dlYmdsY29udGV4dGxvc3QnLCBvbkNvbnRleHRMb3N0LCBmYWxzZSApO1xuXG4gICAgXHR9IGNhdGNoICggZXJyb3IgKSB7XG5cbiAgICBcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMUmVuZGVyZXI6ICcgKyBlcnJvciApO1xuXG4gICAgXHR9XG5cbiAgICBcdHZhciBleHRlbnNpb25zID0gbmV3IFdlYkdMRXh0ZW5zaW9ucyggX2dsICk7XG5cbiAgICBcdGV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfZGVwdGhfdGV4dHVyZScgKTtcbiAgICBcdGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3RleHR1cmVfZmxvYXQnICk7XG4gICAgXHRleHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2Zsb2F0X2xpbmVhcicgKTtcbiAgICBcdGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3RleHR1cmVfaGFsZl9mbG9hdCcgKTtcbiAgICBcdGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3RleHR1cmVfaGFsZl9mbG9hdF9saW5lYXInICk7XG4gICAgXHRleHRlbnNpb25zLmdldCggJ09FU19zdGFuZGFyZF9kZXJpdmF0aXZlcycgKTtcbiAgICBcdGV4dGVuc2lvbnMuZ2V0KCAnQU5HTEVfaW5zdGFuY2VkX2FycmF5cycgKTtcblxuICAgIFx0aWYgKCBleHRlbnNpb25zLmdldCggJ09FU19lbGVtZW50X2luZGV4X3VpbnQnICkgKSB7XG5cbiAgICBcdFx0QnVmZmVyR2VvbWV0cnkuTWF4SW5kZXggPSA0Mjk0OTY3Mjk2O1xuXG4gICAgXHR9XG5cbiAgICBcdHZhciBjYXBhYmlsaXRpZXMgPSBuZXcgV2ViR0xDYXBhYmlsaXRpZXMoIF9nbCwgZXh0ZW5zaW9ucywgcGFyYW1ldGVycyApO1xuXG4gICAgXHR2YXIgc3RhdGUgPSBuZXcgV2ViR0xTdGF0ZSggX2dsLCBleHRlbnNpb25zLCBwYXJhbVRocmVlVG9HTCApO1xuICAgIFx0dmFyIHByb3BlcnRpZXMgPSBuZXcgV2ViR0xQcm9wZXJ0aWVzKCk7XG4gICAgXHR2YXIgdGV4dHVyZXMgPSBuZXcgV2ViR0xUZXh0dXJlcyggX2dsLCBleHRlbnNpb25zLCBzdGF0ZSwgcHJvcGVydGllcywgY2FwYWJpbGl0aWVzLCBwYXJhbVRocmVlVG9HTCwgdGhpcy5pbmZvICk7XG4gICAgXHR2YXIgb2JqZWN0cyA9IG5ldyBXZWJHTE9iamVjdHMoIF9nbCwgcHJvcGVydGllcywgdGhpcy5pbmZvICk7XG4gICAgXHR2YXIgcHJvZ3JhbUNhY2hlID0gbmV3IFdlYkdMUHJvZ3JhbXMoIHRoaXMsIGNhcGFiaWxpdGllcyApO1xuICAgIFx0dmFyIGxpZ2h0Q2FjaGUgPSBuZXcgV2ViR0xMaWdodHMoKTtcblxuICAgIFx0dGhpcy5pbmZvLnByb2dyYW1zID0gcHJvZ3JhbUNhY2hlLnByb2dyYW1zO1xuXG4gICAgXHR2YXIgYnVmZmVyUmVuZGVyZXIgPSBuZXcgV2ViR0xCdWZmZXJSZW5kZXJlciggX2dsLCBleHRlbnNpb25zLCBfaW5mb1JlbmRlciApO1xuICAgIFx0dmFyIGluZGV4ZWRCdWZmZXJSZW5kZXJlciA9IG5ldyBXZWJHTEluZGV4ZWRCdWZmZXJSZW5kZXJlciggX2dsLCBleHRlbnNpb25zLCBfaW5mb1JlbmRlciApO1xuXG4gICAgXHQvL1xuXG4gICAgXHR2YXIgYmFja2dyb3VuZENhbWVyYSA9IG5ldyBPcnRob2dyYXBoaWNDYW1lcmEoIC0gMSwgMSwgMSwgLSAxLCAwLCAxICk7XG4gICAgXHR2YXIgYmFja2dyb3VuZENhbWVyYTIgPSBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoKTtcbiAgICBcdHZhciBiYWNrZ3JvdW5kUGxhbmVNZXNoID0gbmV3IE1lc2goXG4gICAgXHRcdG5ldyBQbGFuZUJ1ZmZlckdlb21ldHJ5KCAyLCAyICksXG4gICAgXHRcdG5ldyBNZXNoQmFzaWNNYXRlcmlhbCggeyBkZXB0aFRlc3Q6IGZhbHNlLCBkZXB0aFdyaXRlOiBmYWxzZSwgZm9nOiBmYWxzZSB9IClcbiAgICBcdCk7XG4gICAgXHR2YXIgYmFja2dyb3VuZEJveFNoYWRlciA9IFNoYWRlckxpYlsgJ2N1YmUnIF07XG4gICAgXHR2YXIgYmFja2dyb3VuZEJveE1lc2ggPSBuZXcgTWVzaChcbiAgICBcdFx0bmV3IEJveEJ1ZmZlckdlb21ldHJ5KCA1LCA1LCA1ICksXG4gICAgXHRcdG5ldyBTaGFkZXJNYXRlcmlhbCgge1xuICAgIFx0XHRcdHVuaWZvcm1zOiBiYWNrZ3JvdW5kQm94U2hhZGVyLnVuaWZvcm1zLFxuICAgIFx0XHRcdHZlcnRleFNoYWRlcjogYmFja2dyb3VuZEJveFNoYWRlci52ZXJ0ZXhTaGFkZXIsXG4gICAgXHRcdFx0ZnJhZ21lbnRTaGFkZXI6IGJhY2tncm91bmRCb3hTaGFkZXIuZnJhZ21lbnRTaGFkZXIsXG4gICAgXHRcdFx0c2lkZTogQmFja1NpZGUsXG4gICAgXHRcdFx0ZGVwdGhUZXN0OiBmYWxzZSxcbiAgICBcdFx0XHRkZXB0aFdyaXRlOiBmYWxzZSxcbiAgICBcdFx0XHRmb2c6IGZhbHNlXG4gICAgXHRcdH0gKVxuICAgIFx0KTtcblxuICAgIFx0Ly9cblxuICAgIFx0ZnVuY3Rpb24gZ2V0VGFyZ2V0UGl4ZWxSYXRpbygpIHtcblxuICAgIFx0XHRyZXR1cm4gX2N1cnJlbnRSZW5kZXJUYXJnZXQgPT09IG51bGwgPyBfcGl4ZWxSYXRpbyA6IDE7XG5cbiAgICBcdH1cblxuICAgIFx0ZnVuY3Rpb24gZ2xDbGVhckNvbG9yKCByLCBnLCBiLCBhICkge1xuXG4gICAgXHRcdGlmICggX3ByZW11bHRpcGxpZWRBbHBoYSA9PT0gdHJ1ZSApIHtcblxuICAgIFx0XHRcdHIgKj0gYTsgZyAqPSBhOyBiICo9IGE7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHN0YXRlLmNsZWFyQ29sb3IoIHIsIGcsIGIsIGEgKTtcblxuICAgIFx0fVxuXG4gICAgXHRmdW5jdGlvbiBzZXREZWZhdWx0R0xTdGF0ZSgpIHtcblxuICAgIFx0XHRzdGF0ZS5pbml0KCk7XG5cbiAgICBcdFx0c3RhdGUuc2Npc3NvciggX2N1cnJlbnRTY2lzc29yLmNvcHkoIF9zY2lzc29yICkubXVsdGlwbHlTY2FsYXIoIF9waXhlbFJhdGlvICkgKTtcbiAgICBcdFx0c3RhdGUudmlld3BvcnQoIF9jdXJyZW50Vmlld3BvcnQuY29weSggX3ZpZXdwb3J0ICkubXVsdGlwbHlTY2FsYXIoIF9waXhlbFJhdGlvICkgKTtcblxuICAgIFx0XHRnbENsZWFyQ29sb3IoIF9jbGVhckNvbG9yLnIsIF9jbGVhckNvbG9yLmcsIF9jbGVhckNvbG9yLmIsIF9jbGVhckFscGhhICk7XG5cbiAgICBcdH1cblxuICAgIFx0ZnVuY3Rpb24gcmVzZXRHTFN0YXRlKCkge1xuXG4gICAgXHRcdF9jdXJyZW50UHJvZ3JhbSA9IG51bGw7XG4gICAgXHRcdF9jdXJyZW50Q2FtZXJhID0gbnVsbDtcblxuICAgIFx0XHRfY3VycmVudEdlb21ldHJ5UHJvZ3JhbSA9ICcnO1xuICAgIFx0XHRfY3VycmVudE1hdGVyaWFsSWQgPSAtIDE7XG5cbiAgICBcdFx0c3RhdGUucmVzZXQoKTtcblxuICAgIFx0fVxuXG4gICAgXHRzZXREZWZhdWx0R0xTdGF0ZSgpO1xuXG4gICAgXHR0aGlzLmNvbnRleHQgPSBfZ2w7XG4gICAgXHR0aGlzLmNhcGFiaWxpdGllcyA9IGNhcGFiaWxpdGllcztcbiAgICBcdHRoaXMuZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnM7XG4gICAgXHR0aGlzLnByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzO1xuICAgIFx0dGhpcy5zdGF0ZSA9IHN0YXRlO1xuXG4gICAgXHQvLyBzaGFkb3cgbWFwXG5cbiAgICBcdHZhciBzaGFkb3dNYXAgPSBuZXcgV2ViR0xTaGFkb3dNYXAoIHRoaXMsIF9saWdodHMsIG9iamVjdHMsIGNhcGFiaWxpdGllcyApO1xuXG4gICAgXHR0aGlzLnNoYWRvd01hcCA9IHNoYWRvd01hcDtcblxuXG4gICAgXHQvLyBQbHVnaW5zXG5cbiAgICBcdHZhciBzcHJpdGVQbHVnaW4gPSBuZXcgU3ByaXRlUGx1Z2luKCB0aGlzLCBzcHJpdGVzICk7XG4gICAgXHR2YXIgbGVuc0ZsYXJlUGx1Z2luID0gbmV3IExlbnNGbGFyZVBsdWdpbiggdGhpcywgbGVuc0ZsYXJlcyApO1xuXG4gICAgXHQvLyBBUElcblxuICAgIFx0dGhpcy5nZXRDb250ZXh0ID0gZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHJldHVybiBfZ2w7XG5cbiAgICBcdH07XG5cbiAgICBcdHRoaXMuZ2V0Q29udGV4dEF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0cmV0dXJuIF9nbC5nZXRDb250ZXh0QXR0cmlidXRlcygpO1xuXG4gICAgXHR9O1xuXG4gICAgXHR0aGlzLmZvcmNlQ29udGV4dExvc3MgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0ZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9sb3NlX2NvbnRleHQnICkubG9zZUNvbnRleHQoKTtcblxuICAgIFx0fTtcblxuICAgIFx0dGhpcy5nZXRNYXhBbmlzb3Ryb3B5ID0gZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHJldHVybiBjYXBhYmlsaXRpZXMuZ2V0TWF4QW5pc290cm9weSgpO1xuXG4gICAgXHR9O1xuXG4gICAgXHR0aGlzLmdldFByZWNpc2lvbiA9IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHRyZXR1cm4gY2FwYWJpbGl0aWVzLnByZWNpc2lvbjtcblxuICAgIFx0fTtcblxuICAgIFx0dGhpcy5nZXRQaXhlbFJhdGlvID0gZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHJldHVybiBfcGl4ZWxSYXRpbztcblxuICAgIFx0fTtcblxuICAgIFx0dGhpcy5zZXRQaXhlbFJhdGlvID0gZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuICAgIFx0XHRpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgKSByZXR1cm47XG5cbiAgICBcdFx0X3BpeGVsUmF0aW8gPSB2YWx1ZTtcblxuICAgIFx0XHR0aGlzLnNldFNpemUoIF92aWV3cG9ydC56LCBfdmlld3BvcnQudywgZmFsc2UgKTtcblxuICAgIFx0fTtcblxuICAgIFx0dGhpcy5nZXRTaXplID0gZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHJldHVybiB7XG4gICAgXHRcdFx0d2lkdGg6IF93aWR0aCxcbiAgICBcdFx0XHRoZWlnaHQ6IF9oZWlnaHRcbiAgICBcdFx0fTtcblxuICAgIFx0fTtcblxuICAgIFx0dGhpcy5zZXRTaXplID0gZnVuY3Rpb24gKCB3aWR0aCwgaGVpZ2h0LCB1cGRhdGVTdHlsZSApIHtcblxuICAgIFx0XHRfd2lkdGggPSB3aWR0aDtcbiAgICBcdFx0X2hlaWdodCA9IGhlaWdodDtcblxuICAgIFx0XHRfY2FudmFzLndpZHRoID0gd2lkdGggKiBfcGl4ZWxSYXRpbztcbiAgICBcdFx0X2NhbnZhcy5oZWlnaHQgPSBoZWlnaHQgKiBfcGl4ZWxSYXRpbztcblxuICAgIFx0XHRpZiAoIHVwZGF0ZVN0eWxlICE9PSBmYWxzZSApIHtcblxuICAgIFx0XHRcdF9jYW52YXMuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gICAgXHRcdFx0X2NhbnZhcy5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHR0aGlzLnNldFZpZXdwb3J0KCAwLCAwLCB3aWR0aCwgaGVpZ2h0ICk7XG5cbiAgICBcdH07XG5cbiAgICBcdHRoaXMuc2V0Vmlld3BvcnQgPSBmdW5jdGlvbiAoIHgsIHksIHdpZHRoLCBoZWlnaHQgKSB7XG5cbiAgICBcdFx0c3RhdGUudmlld3BvcnQoIF92aWV3cG9ydC5zZXQoIHgsIHksIHdpZHRoLCBoZWlnaHQgKSApO1xuXG4gICAgXHR9O1xuXG4gICAgXHR0aGlzLnNldFNjaXNzb3IgPSBmdW5jdGlvbiAoIHgsIHksIHdpZHRoLCBoZWlnaHQgKSB7XG5cbiAgICBcdFx0c3RhdGUuc2Npc3NvciggX3NjaXNzb3Iuc2V0KCB4LCB5LCB3aWR0aCwgaGVpZ2h0ICkgKTtcblxuICAgIFx0fTtcblxuICAgIFx0dGhpcy5zZXRTY2lzc29yVGVzdCA9IGZ1bmN0aW9uICggYm9vbGVhbiApIHtcblxuICAgIFx0XHRzdGF0ZS5zZXRTY2lzc29yVGVzdCggX3NjaXNzb3JUZXN0ID0gYm9vbGVhbiApO1xuXG4gICAgXHR9O1xuXG4gICAgXHQvLyBDbGVhcmluZ1xuXG4gICAgXHR0aGlzLmdldENsZWFyQ29sb3IgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0cmV0dXJuIF9jbGVhckNvbG9yO1xuXG4gICAgXHR9O1xuXG4gICAgXHR0aGlzLnNldENsZWFyQ29sb3IgPSBmdW5jdGlvbiAoIGNvbG9yLCBhbHBoYSApIHtcblxuICAgIFx0XHRfY2xlYXJDb2xvci5zZXQoIGNvbG9yICk7XG5cbiAgICBcdFx0X2NsZWFyQWxwaGEgPSBhbHBoYSAhPT0gdW5kZWZpbmVkID8gYWxwaGEgOiAxO1xuXG4gICAgXHRcdGdsQ2xlYXJDb2xvciggX2NsZWFyQ29sb3IuciwgX2NsZWFyQ29sb3IuZywgX2NsZWFyQ29sb3IuYiwgX2NsZWFyQWxwaGEgKTtcblxuICAgIFx0fTtcblxuICAgIFx0dGhpcy5nZXRDbGVhckFscGhhID0gZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHJldHVybiBfY2xlYXJBbHBoYTtcblxuICAgIFx0fTtcblxuICAgIFx0dGhpcy5zZXRDbGVhckFscGhhID0gZnVuY3Rpb24gKCBhbHBoYSApIHtcblxuICAgIFx0XHRfY2xlYXJBbHBoYSA9IGFscGhhO1xuXG4gICAgXHRcdGdsQ2xlYXJDb2xvciggX2NsZWFyQ29sb3IuciwgX2NsZWFyQ29sb3IuZywgX2NsZWFyQ29sb3IuYiwgX2NsZWFyQWxwaGEgKTtcblxuICAgIFx0fTtcblxuICAgIFx0dGhpcy5jbGVhciA9IGZ1bmN0aW9uICggY29sb3IsIGRlcHRoLCBzdGVuY2lsICkge1xuXG4gICAgXHRcdHZhciBiaXRzID0gMDtcblxuICAgIFx0XHRpZiAoIGNvbG9yID09PSB1bmRlZmluZWQgfHwgY29sb3IgKSBiaXRzIHw9IF9nbC5DT0xPUl9CVUZGRVJfQklUO1xuICAgIFx0XHRpZiAoIGRlcHRoID09PSB1bmRlZmluZWQgfHwgZGVwdGggKSBiaXRzIHw9IF9nbC5ERVBUSF9CVUZGRVJfQklUO1xuICAgIFx0XHRpZiAoIHN0ZW5jaWwgPT09IHVuZGVmaW5lZCB8fCBzdGVuY2lsICkgYml0cyB8PSBfZ2wuU1RFTkNJTF9CVUZGRVJfQklUO1xuXG4gICAgXHRcdF9nbC5jbGVhciggYml0cyApO1xuXG4gICAgXHR9O1xuXG4gICAgXHR0aGlzLmNsZWFyQ29sb3IgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dGhpcy5jbGVhciggdHJ1ZSwgZmFsc2UsIGZhbHNlICk7XG5cbiAgICBcdH07XG5cbiAgICBcdHRoaXMuY2xlYXJEZXB0aCA9IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR0aGlzLmNsZWFyKCBmYWxzZSwgdHJ1ZSwgZmFsc2UgKTtcblxuICAgIFx0fTtcblxuICAgIFx0dGhpcy5jbGVhclN0ZW5jaWwgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dGhpcy5jbGVhciggZmFsc2UsIGZhbHNlLCB0cnVlICk7XG5cbiAgICBcdH07XG5cbiAgICBcdHRoaXMuY2xlYXJUYXJnZXQgPSBmdW5jdGlvbiAoIHJlbmRlclRhcmdldCwgY29sb3IsIGRlcHRoLCBzdGVuY2lsICkge1xuXG4gICAgXHRcdHRoaXMuc2V0UmVuZGVyVGFyZ2V0KCByZW5kZXJUYXJnZXQgKTtcbiAgICBcdFx0dGhpcy5jbGVhciggY29sb3IsIGRlcHRoLCBzdGVuY2lsICk7XG5cbiAgICBcdH07XG5cbiAgICBcdC8vIFJlc2V0XG5cbiAgICBcdHRoaXMucmVzZXRHTFN0YXRlID0gcmVzZXRHTFN0YXRlO1xuXG4gICAgXHR0aGlzLmRpc3Bvc2UgPSBmdW5jdGlvbigpIHtcblxuICAgIFx0XHR0cmFuc3BhcmVudE9iamVjdHMgPSBbXTtcbiAgICBcdFx0dHJhbnNwYXJlbnRPYmplY3RzTGFzdEluZGV4ID0gLTE7XG4gICAgXHRcdG9wYXF1ZU9iamVjdHMgPSBbXTtcbiAgICBcdFx0b3BhcXVlT2JqZWN0c0xhc3RJbmRleCA9IC0xO1xuXG4gICAgXHRcdF9jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ3dlYmdsY29udGV4dGxvc3QnLCBvbkNvbnRleHRMb3N0LCBmYWxzZSApO1xuXG4gICAgXHR9O1xuXG4gICAgXHQvLyBFdmVudHNcblxuICAgIFx0ZnVuY3Rpb24gb25Db250ZXh0TG9zdCggZXZlbnQgKSB7XG5cbiAgICBcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgIFx0XHRyZXNldEdMU3RhdGUoKTtcbiAgICBcdFx0c2V0RGVmYXVsdEdMU3RhdGUoKTtcblxuICAgIFx0XHRwcm9wZXJ0aWVzLmNsZWFyKCk7XG5cbiAgICBcdH1cblxuICAgIFx0ZnVuY3Rpb24gb25NYXRlcmlhbERpc3Bvc2UoIGV2ZW50ICkge1xuXG4gICAgXHRcdHZhciBtYXRlcmlhbCA9IGV2ZW50LnRhcmdldDtcblxuICAgIFx0XHRtYXRlcmlhbC5yZW1vdmVFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uTWF0ZXJpYWxEaXNwb3NlICk7XG5cbiAgICBcdFx0ZGVhbGxvY2F0ZU1hdGVyaWFsKCBtYXRlcmlhbCApO1xuXG4gICAgXHR9XG5cbiAgICBcdC8vIEJ1ZmZlciBkZWFsbG9jYXRpb25cblxuICAgIFx0ZnVuY3Rpb24gZGVhbGxvY2F0ZU1hdGVyaWFsKCBtYXRlcmlhbCApIHtcblxuICAgIFx0XHRyZWxlYXNlTWF0ZXJpYWxQcm9ncmFtUmVmZXJlbmNlKCBtYXRlcmlhbCApO1xuXG4gICAgXHRcdHByb3BlcnRpZXMuZGVsZXRlKCBtYXRlcmlhbCApO1xuXG4gICAgXHR9XG5cblxuICAgIFx0ZnVuY3Rpb24gcmVsZWFzZU1hdGVyaWFsUHJvZ3JhbVJlZmVyZW5jZSggbWF0ZXJpYWwgKSB7XG5cbiAgICBcdFx0dmFyIHByb2dyYW1JbmZvID0gcHJvcGVydGllcy5nZXQoIG1hdGVyaWFsICkucHJvZ3JhbTtcblxuICAgIFx0XHRtYXRlcmlhbC5wcm9ncmFtID0gdW5kZWZpbmVkO1xuXG4gICAgXHRcdGlmICggcHJvZ3JhbUluZm8gIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdHByb2dyYW1DYWNoZS5yZWxlYXNlUHJvZ3JhbSggcHJvZ3JhbUluZm8gKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdH1cblxuICAgIFx0Ly8gQnVmZmVyIHJlbmRlcmluZ1xuXG4gICAgXHR0aGlzLnJlbmRlckJ1ZmZlckltbWVkaWF0ZSA9IGZ1bmN0aW9uICggb2JqZWN0LCBwcm9ncmFtLCBtYXRlcmlhbCApIHtcblxuICAgIFx0XHRzdGF0ZS5pbml0QXR0cmlidXRlcygpO1xuXG4gICAgXHRcdHZhciBidWZmZXJzID0gcHJvcGVydGllcy5nZXQoIG9iamVjdCApO1xuXG4gICAgXHRcdGlmICggb2JqZWN0Lmhhc1Bvc2l0aW9ucyAmJiAhIGJ1ZmZlcnMucG9zaXRpb24gKSBidWZmZXJzLnBvc2l0aW9uID0gX2dsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIFx0XHRpZiAoIG9iamVjdC5oYXNOb3JtYWxzICYmICEgYnVmZmVycy5ub3JtYWwgKSBidWZmZXJzLm5vcm1hbCA9IF9nbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBcdFx0aWYgKCBvYmplY3QuaGFzVXZzICYmICEgYnVmZmVycy51diApIGJ1ZmZlcnMudXYgPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgXHRcdGlmICggb2JqZWN0Lmhhc0NvbG9ycyAmJiAhIGJ1ZmZlcnMuY29sb3IgKSBidWZmZXJzLmNvbG9yID0gX2dsLmNyZWF0ZUJ1ZmZlcigpO1xuXG4gICAgXHRcdHZhciBhdHRyaWJ1dGVzID0gcHJvZ3JhbS5nZXRBdHRyaWJ1dGVzKCk7XG5cbiAgICBcdFx0aWYgKCBvYmplY3QuaGFzUG9zaXRpb25zICkge1xuXG4gICAgXHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcnMucG9zaXRpb24gKTtcbiAgICBcdFx0XHRfZ2wuYnVmZmVyRGF0YSggX2dsLkFSUkFZX0JVRkZFUiwgb2JqZWN0LnBvc2l0aW9uQXJyYXksIF9nbC5EWU5BTUlDX0RSQVcgKTtcblxuICAgIFx0XHRcdHN0YXRlLmVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlcy5wb3NpdGlvbiApO1xuICAgIFx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLnBvc2l0aW9uLCAzLCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCAwICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGlmICggb2JqZWN0Lmhhc05vcm1hbHMgKSB7XG5cbiAgICBcdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgYnVmZmVycy5ub3JtYWwgKTtcblxuICAgIFx0XHRcdGlmICggISBtYXRlcmlhbC5pc01lc2hQaG9uZ01hdGVyaWFsICYmXG4gICAgXHRcdFx0ICAgICAhIG1hdGVyaWFsLmlzTWVzaFN0YW5kYXJkTWF0ZXJpYWwgJiZcbiAgICBcdFx0XHQgICAgICAgbWF0ZXJpYWwuc2hhZGluZyA9PT0gRmxhdFNoYWRpbmcgKSB7XG5cbiAgICBcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IG9iamVjdC5jb3VudCAqIDM7IGkgPCBsOyBpICs9IDkgKSB7XG5cbiAgICBcdFx0XHRcdFx0dmFyIGFycmF5ID0gb2JqZWN0Lm5vcm1hbEFycmF5O1xuXG4gICAgXHRcdFx0XHRcdHZhciBueCA9ICggYXJyYXlbIGkgKyAwIF0gKyBhcnJheVsgaSArIDMgXSArIGFycmF5WyBpICsgNiBdICkgLyAzO1xuICAgIFx0XHRcdFx0XHR2YXIgbnkgPSAoIGFycmF5WyBpICsgMSBdICsgYXJyYXlbIGkgKyA0IF0gKyBhcnJheVsgaSArIDcgXSApIC8gMztcbiAgICBcdFx0XHRcdFx0dmFyIG56ID0gKCBhcnJheVsgaSArIDIgXSArIGFycmF5WyBpICsgNSBdICsgYXJyYXlbIGkgKyA4IF0gKSAvIDM7XG5cbiAgICBcdFx0XHRcdFx0YXJyYXlbIGkgKyAwIF0gPSBueDtcbiAgICBcdFx0XHRcdFx0YXJyYXlbIGkgKyAxIF0gPSBueTtcbiAgICBcdFx0XHRcdFx0YXJyYXlbIGkgKyAyIF0gPSBuejtcblxuICAgIFx0XHRcdFx0XHRhcnJheVsgaSArIDMgXSA9IG54O1xuICAgIFx0XHRcdFx0XHRhcnJheVsgaSArIDQgXSA9IG55O1xuICAgIFx0XHRcdFx0XHRhcnJheVsgaSArIDUgXSA9IG56O1xuXG4gICAgXHRcdFx0XHRcdGFycmF5WyBpICsgNiBdID0gbng7XG4gICAgXHRcdFx0XHRcdGFycmF5WyBpICsgNyBdID0gbnk7XG4gICAgXHRcdFx0XHRcdGFycmF5WyBpICsgOCBdID0gbno7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCBvYmplY3Qubm9ybWFsQXJyYXksIF9nbC5EWU5BTUlDX0RSQVcgKTtcblxuICAgIFx0XHRcdHN0YXRlLmVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlcy5ub3JtYWwgKTtcblxuICAgIFx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLm5vcm1hbCwgMywgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRpZiAoIG9iamVjdC5oYXNVdnMgJiYgbWF0ZXJpYWwubWFwICkge1xuXG4gICAgXHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcnMudXYgKTtcbiAgICBcdFx0XHRfZ2wuYnVmZmVyRGF0YSggX2dsLkFSUkFZX0JVRkZFUiwgb2JqZWN0LnV2QXJyYXksIF9nbC5EWU5BTUlDX0RSQVcgKTtcblxuICAgIFx0XHRcdHN0YXRlLmVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlcy51diApO1xuXG4gICAgXHRcdFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMudXYsIDIsIF9nbC5GTE9BVCwgZmFsc2UsIDAsIDAgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0aWYgKCBvYmplY3QuaGFzQ29sb3JzICYmIG1hdGVyaWFsLnZlcnRleENvbG9ycyAhPT0gTm9Db2xvcnMgKSB7XG5cbiAgICBcdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgYnVmZmVycy5jb2xvciApO1xuICAgIFx0XHRcdF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCBvYmplY3QuY29sb3JBcnJheSwgX2dsLkRZTkFNSUNfRFJBVyApO1xuXG4gICAgXHRcdFx0c3RhdGUuZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzLmNvbG9yICk7XG5cbiAgICBcdFx0XHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy5jb2xvciwgMywgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRzdGF0ZS5kaXNhYmxlVW51c2VkQXR0cmlidXRlcygpO1xuXG4gICAgXHRcdF9nbC5kcmF3QXJyYXlzKCBfZ2wuVFJJQU5HTEVTLCAwLCBvYmplY3QuY291bnQgKTtcblxuICAgIFx0XHRvYmplY3QuY291bnQgPSAwO1xuXG4gICAgXHR9O1xuXG4gICAgXHR0aGlzLnJlbmRlckJ1ZmZlckRpcmVjdCA9IGZ1bmN0aW9uICggY2FtZXJhLCBmb2csIGdlb21ldHJ5LCBtYXRlcmlhbCwgb2JqZWN0LCBncm91cCApIHtcblxuICAgIFx0XHRzZXRNYXRlcmlhbCggbWF0ZXJpYWwgKTtcblxuICAgIFx0XHR2YXIgcHJvZ3JhbSA9IHNldFByb2dyYW0oIGNhbWVyYSwgZm9nLCBtYXRlcmlhbCwgb2JqZWN0ICk7XG5cbiAgICBcdFx0dmFyIHVwZGF0ZUJ1ZmZlcnMgPSBmYWxzZTtcbiAgICBcdFx0dmFyIGdlb21ldHJ5UHJvZ3JhbSA9IGdlb21ldHJ5LmlkICsgJ18nICsgcHJvZ3JhbS5pZCArICdfJyArIG1hdGVyaWFsLndpcmVmcmFtZTtcblxuICAgIFx0XHRpZiAoIGdlb21ldHJ5UHJvZ3JhbSAhPT0gX2N1cnJlbnRHZW9tZXRyeVByb2dyYW0gKSB7XG5cbiAgICBcdFx0XHRfY3VycmVudEdlb21ldHJ5UHJvZ3JhbSA9IGdlb21ldHJ5UHJvZ3JhbTtcbiAgICBcdFx0XHR1cGRhdGVCdWZmZXJzID0gdHJ1ZTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0Ly8gbW9ycGggdGFyZ2V0c1xuXG4gICAgXHRcdHZhciBtb3JwaFRhcmdldEluZmx1ZW5jZXMgPSBvYmplY3QubW9ycGhUYXJnZXRJbmZsdWVuY2VzO1xuXG4gICAgXHRcdGlmICggbW9ycGhUYXJnZXRJbmZsdWVuY2VzICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHR2YXIgYWN0aXZlSW5mbHVlbmNlcyA9IFtdO1xuXG4gICAgXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gbW9ycGhUYXJnZXRJbmZsdWVuY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICBcdFx0XHRcdHZhciBpbmZsdWVuY2UgPSBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIGkgXTtcbiAgICBcdFx0XHRcdGFjdGl2ZUluZmx1ZW5jZXMucHVzaCggWyBpbmZsdWVuY2UsIGkgXSApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0YWN0aXZlSW5mbHVlbmNlcy5zb3J0KCBhYnNOdW1lcmljYWxTb3J0ICk7XG5cbiAgICBcdFx0XHRpZiAoIGFjdGl2ZUluZmx1ZW5jZXMubGVuZ3RoID4gOCApIHtcblxuICAgIFx0XHRcdFx0YWN0aXZlSW5mbHVlbmNlcy5sZW5ndGggPSA4O1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0dmFyIG1vcnBoQXR0cmlidXRlcyA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcztcblxuICAgIFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGFjdGl2ZUluZmx1ZW5jZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgIFx0XHRcdFx0dmFyIGluZmx1ZW5jZSA9IGFjdGl2ZUluZmx1ZW5jZXNbIGkgXTtcbiAgICBcdFx0XHRcdG1vcnBoSW5mbHVlbmNlc1sgaSBdID0gaW5mbHVlbmNlWyAwIF07XG5cbiAgICBcdFx0XHRcdGlmICggaW5mbHVlbmNlWyAwIF0gIT09IDAgKSB7XG5cbiAgICBcdFx0XHRcdFx0dmFyIGluZGV4ID0gaW5mbHVlbmNlWyAxIF07XG5cbiAgICBcdFx0XHRcdFx0aWYgKCBtYXRlcmlhbC5tb3JwaFRhcmdldHMgPT09IHRydWUgJiYgbW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uICkgZ2VvbWV0cnkuYWRkQXR0cmlidXRlKCAnbW9ycGhUYXJnZXQnICsgaSwgbW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uWyBpbmRleCBdICk7XG4gICAgXHRcdFx0XHRcdGlmICggbWF0ZXJpYWwubW9ycGhOb3JtYWxzID09PSB0cnVlICYmIG1vcnBoQXR0cmlidXRlcy5ub3JtYWwgKSBnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdtb3JwaE5vcm1hbCcgKyBpLCBtb3JwaEF0dHJpYnV0ZXMubm9ybWFsWyBpbmRleCBdICk7XG5cbiAgICBcdFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdFx0aWYgKCBtYXRlcmlhbC5tb3JwaFRhcmdldHMgPT09IHRydWUgKSBnZW9tZXRyeS5yZW1vdmVBdHRyaWJ1dGUoICdtb3JwaFRhcmdldCcgKyBpICk7XG4gICAgXHRcdFx0XHRcdGlmICggbWF0ZXJpYWwubW9ycGhOb3JtYWxzID09PSB0cnVlICkgZ2VvbWV0cnkucmVtb3ZlQXR0cmlidXRlKCAnbW9ycGhOb3JtYWwnICsgaSApO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRmb3IgKCB2YXIgaSA9IGFjdGl2ZUluZmx1ZW5jZXMubGVuZ3RoLCBpbCA9IG1vcnBoSW5mbHVlbmNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuICAgIFx0XHRcdFx0bW9ycGhJbmZsdWVuY2VzWyBpIF0gPSAwLjA7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRwcm9ncmFtLmdldFVuaWZvcm1zKCkuc2V0VmFsdWUoXG4gICAgXHRcdFx0XHRcdF9nbCwgJ21vcnBoVGFyZ2V0SW5mbHVlbmNlcycsIG1vcnBoSW5mbHVlbmNlcyApO1xuXG4gICAgXHRcdFx0dXBkYXRlQnVmZmVycyA9IHRydWU7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdC8vXG5cbiAgICBcdFx0dmFyIGluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XG4gICAgXHRcdHZhciBwb3NpdGlvbiA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG4gICAgXHRcdHZhciByYW5nZUZhY3RvciA9IDE7XG5cbiAgICBcdFx0aWYgKCBtYXRlcmlhbC53aXJlZnJhbWUgPT09IHRydWUgKSB7XG5cbiAgICBcdFx0XHRpbmRleCA9IG9iamVjdHMuZ2V0V2lyZWZyYW1lQXR0cmlidXRlKCBnZW9tZXRyeSApO1xuICAgIFx0XHRcdHJhbmdlRmFjdG9yID0gMjtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0dmFyIHJlbmRlcmVyO1xuXG4gICAgXHRcdGlmICggaW5kZXggIT09IG51bGwgKSB7XG5cbiAgICBcdFx0XHRyZW5kZXJlciA9IGluZGV4ZWRCdWZmZXJSZW5kZXJlcjtcbiAgICBcdFx0XHRyZW5kZXJlci5zZXRJbmRleCggaW5kZXggKTtcblxuICAgIFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0cmVuZGVyZXIgPSBidWZmZXJSZW5kZXJlcjtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0aWYgKCB1cGRhdGVCdWZmZXJzICkge1xuXG4gICAgXHRcdFx0c2V0dXBWZXJ0ZXhBdHRyaWJ1dGVzKCBtYXRlcmlhbCwgcHJvZ3JhbSwgZ2VvbWV0cnkgKTtcblxuICAgIFx0XHRcdGlmICggaW5kZXggIT09IG51bGwgKSB7XG5cbiAgICBcdFx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIG9iamVjdHMuZ2V0QXR0cmlidXRlQnVmZmVyKCBpbmRleCApICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdC8vXG5cbiAgICBcdFx0dmFyIGRhdGFDb3VudCA9IDA7XG5cbiAgICBcdFx0aWYgKCBpbmRleCAhPT0gbnVsbCApIHtcblxuICAgIFx0XHRcdGRhdGFDb3VudCA9IGluZGV4LmNvdW50O1xuXG4gICAgXHRcdH0gZWxzZSBpZiAoIHBvc2l0aW9uICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRkYXRhQ291bnQgPSBwb3NpdGlvbi5jb3VudDtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0dmFyIHJhbmdlU3RhcnQgPSBnZW9tZXRyeS5kcmF3UmFuZ2Uuc3RhcnQgKiByYW5nZUZhY3RvcjtcbiAgICBcdFx0dmFyIHJhbmdlQ291bnQgPSBnZW9tZXRyeS5kcmF3UmFuZ2UuY291bnQgKiByYW5nZUZhY3RvcjtcblxuICAgIFx0XHR2YXIgZ3JvdXBTdGFydCA9IGdyb3VwICE9PSBudWxsID8gZ3JvdXAuc3RhcnQgKiByYW5nZUZhY3RvciA6IDA7XG4gICAgXHRcdHZhciBncm91cENvdW50ID0gZ3JvdXAgIT09IG51bGwgPyBncm91cC5jb3VudCAqIHJhbmdlRmFjdG9yIDogSW5maW5pdHk7XG5cbiAgICBcdFx0dmFyIGRyYXdTdGFydCA9IE1hdGgubWF4KCByYW5nZVN0YXJ0LCBncm91cFN0YXJ0ICk7XG4gICAgXHRcdHZhciBkcmF3RW5kID0gTWF0aC5taW4oIGRhdGFDb3VudCwgcmFuZ2VTdGFydCArIHJhbmdlQ291bnQsIGdyb3VwU3RhcnQgKyBncm91cENvdW50ICkgLSAxO1xuXG4gICAgXHRcdHZhciBkcmF3Q291bnQgPSBNYXRoLm1heCggMCwgZHJhd0VuZCAtIGRyYXdTdGFydCArIDEgKTtcblxuICAgIFx0XHRpZiAoIGRyYXdDb3VudCA9PT0gMCApIHJldHVybjtcblxuICAgIFx0XHQvL1xuXG4gICAgXHRcdGlmICggb2JqZWN0LmlzTWVzaCApIHtcblxuICAgIFx0XHRcdGlmICggbWF0ZXJpYWwud2lyZWZyYW1lID09PSB0cnVlICkge1xuXG4gICAgXHRcdFx0XHRzdGF0ZS5zZXRMaW5lV2lkdGgoIG1hdGVyaWFsLndpcmVmcmFtZUxpbmV3aWR0aCAqIGdldFRhcmdldFBpeGVsUmF0aW8oKSApO1xuICAgIFx0XHRcdFx0cmVuZGVyZXIuc2V0TW9kZSggX2dsLkxJTkVTICk7XG5cbiAgICBcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHRzd2l0Y2ggKCBvYmplY3QuZHJhd01vZGUgKSB7XG5cbiAgICBcdFx0XHRcdFx0Y2FzZSBUcmlhbmdsZXNEcmF3TW9kZTpcbiAgICBcdFx0XHRcdFx0XHRyZW5kZXJlci5zZXRNb2RlKCBfZ2wuVFJJQU5HTEVTICk7XG4gICAgXHRcdFx0XHRcdFx0YnJlYWs7XG5cbiAgICBcdFx0XHRcdFx0Y2FzZSBUcmlhbmdsZVN0cmlwRHJhd01vZGU6XG4gICAgXHRcdFx0XHRcdFx0cmVuZGVyZXIuc2V0TW9kZSggX2dsLlRSSUFOR0xFX1NUUklQICk7XG4gICAgXHRcdFx0XHRcdFx0YnJlYWs7XG5cbiAgICBcdFx0XHRcdFx0Y2FzZSBUcmlhbmdsZUZhbkRyYXdNb2RlOlxuICAgIFx0XHRcdFx0XHRcdHJlbmRlcmVyLnNldE1vZGUoIF9nbC5UUklBTkdMRV9GQU4gKTtcbiAgICBcdFx0XHRcdFx0XHRicmVhaztcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0fVxuXG5cbiAgICBcdFx0fSBlbHNlIGlmICggb2JqZWN0LmlzTGluZSApIHtcblxuICAgIFx0XHRcdHZhciBsaW5lV2lkdGggPSBtYXRlcmlhbC5saW5ld2lkdGg7XG5cbiAgICBcdFx0XHRpZiAoIGxpbmVXaWR0aCA9PT0gdW5kZWZpbmVkICkgbGluZVdpZHRoID0gMTsgLy8gTm90IHVzaW5nIExpbmUqTWF0ZXJpYWxcblxuICAgIFx0XHRcdHN0YXRlLnNldExpbmVXaWR0aCggbGluZVdpZHRoICogZ2V0VGFyZ2V0UGl4ZWxSYXRpbygpICk7XG5cbiAgICBcdFx0XHRpZiAoIG9iamVjdC5pc0xpbmVTZWdtZW50cyApIHtcblxuICAgIFx0XHRcdFx0cmVuZGVyZXIuc2V0TW9kZSggX2dsLkxJTkVTICk7XG5cbiAgICBcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHRyZW5kZXJlci5zZXRNb2RlKCBfZ2wuTElORV9TVFJJUCApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH0gZWxzZSBpZiAoIG9iamVjdC5pc1BvaW50cyApIHtcblxuICAgIFx0XHRcdHJlbmRlcmVyLnNldE1vZGUoIF9nbC5QT0lOVFMgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0aWYgKCBnZW9tZXRyeSAmJiBnZW9tZXRyeS5pc0luc3RhbmNlZEJ1ZmZlckdlb21ldHJ5ICkge1xuXG4gICAgXHRcdFx0aWYgKCBnZW9tZXRyeS5tYXhJbnN0YW5jZWRDb3VudCA+IDAgKSB7XG5cbiAgICBcdFx0XHRcdHJlbmRlcmVyLnJlbmRlckluc3RhbmNlcyggZ2VvbWV0cnksIGRyYXdTdGFydCwgZHJhd0NvdW50ICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdHJlbmRlcmVyLnJlbmRlciggZHJhd1N0YXJ0LCBkcmF3Q291bnQgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdH07XG5cbiAgICBcdGZ1bmN0aW9uIHNldHVwVmVydGV4QXR0cmlidXRlcyggbWF0ZXJpYWwsIHByb2dyYW0sIGdlb21ldHJ5LCBzdGFydEluZGV4ICkge1xuXG4gICAgXHRcdHZhciBleHRlbnNpb247XG5cbiAgICBcdFx0aWYgKCBnZW9tZXRyeSAmJiBnZW9tZXRyeS5pc0luc3RhbmNlZEJ1ZmZlckdlb21ldHJ5ICkge1xuXG4gICAgXHRcdFx0ZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJyApO1xuXG4gICAgXHRcdFx0aWYgKCBleHRlbnNpb24gPT09IG51bGwgKSB7XG5cbiAgICBcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFJlbmRlcmVyLnNldHVwVmVydGV4QXR0cmlidXRlczogdXNpbmcgVEhSRUUuSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkgYnV0IGhhcmR3YXJlIGRvZXMgbm90IHN1cHBvcnQgZXh0ZW5zaW9uIEFOR0xFX2luc3RhbmNlZF9hcnJheXMuJyApO1xuICAgIFx0XHRcdFx0cmV0dXJuO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHRpZiAoIHN0YXJ0SW5kZXggPT09IHVuZGVmaW5lZCApIHN0YXJ0SW5kZXggPSAwO1xuXG4gICAgXHRcdHN0YXRlLmluaXRBdHRyaWJ1dGVzKCk7XG5cbiAgICBcdFx0dmFyIGdlb21ldHJ5QXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XG5cbiAgICBcdFx0dmFyIHByb2dyYW1BdHRyaWJ1dGVzID0gcHJvZ3JhbS5nZXRBdHRyaWJ1dGVzKCk7XG5cbiAgICBcdFx0dmFyIG1hdGVyaWFsRGVmYXVsdEF0dHJpYnV0ZVZhbHVlcyA9IG1hdGVyaWFsLmRlZmF1bHRBdHRyaWJ1dGVWYWx1ZXM7XG5cbiAgICBcdFx0Zm9yICggdmFyIG5hbWUgaW4gcHJvZ3JhbUF0dHJpYnV0ZXMgKSB7XG5cbiAgICBcdFx0XHR2YXIgcHJvZ3JhbUF0dHJpYnV0ZSA9IHByb2dyYW1BdHRyaWJ1dGVzWyBuYW1lIF07XG5cbiAgICBcdFx0XHRpZiAoIHByb2dyYW1BdHRyaWJ1dGUgPj0gMCApIHtcblxuICAgIFx0XHRcdFx0dmFyIGdlb21ldHJ5QXR0cmlidXRlID0gZ2VvbWV0cnlBdHRyaWJ1dGVzWyBuYW1lIF07XG5cbiAgICBcdFx0XHRcdGlmICggZ2VvbWV0cnlBdHRyaWJ1dGUgIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0XHR2YXIgdHlwZSA9IF9nbC5GTE9BVDtcbiAgICBcdFx0XHRcdFx0dmFyIGFycmF5ID0gZ2VvbWV0cnlBdHRyaWJ1dGUuYXJyYXk7XG4gICAgXHRcdFx0XHRcdHZhciBub3JtYWxpemVkID0gZ2VvbWV0cnlBdHRyaWJ1dGUubm9ybWFsaXplZDtcblxuICAgIFx0XHRcdFx0XHRpZiAoIGFycmF5IGluc3RhbmNlb2YgRmxvYXQzMkFycmF5ICkge1xuXG4gICAgXHRcdFx0XHRcdFx0dHlwZSA9IF9nbC5GTE9BVDtcblxuICAgIFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBhcnJheSBpbnN0YW5jZW9mIEZsb2F0NjRBcnJheSApIHtcblxuICAgIFx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggXCJVbnN1cHBvcnRlZCBkYXRhIGJ1ZmZlciBmb3JtYXQ6IEZsb2F0NjRBcnJheVwiICk7XG5cbiAgICBcdFx0XHRcdFx0fSBlbHNlIGlmICggYXJyYXkgaW5zdGFuY2VvZiBVaW50MTZBcnJheSApIHtcblxuICAgIFx0XHRcdFx0XHRcdHR5cGUgPSBfZ2wuVU5TSUdORURfU0hPUlQ7XG5cbiAgICBcdFx0XHRcdFx0fSBlbHNlIGlmICggYXJyYXkgaW5zdGFuY2VvZiBJbnQxNkFycmF5ICkge1xuXG4gICAgXHRcdFx0XHRcdFx0dHlwZSA9IF9nbC5TSE9SVDtcblxuICAgIFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBhcnJheSBpbnN0YW5jZW9mIFVpbnQzMkFycmF5ICkge1xuXG4gICAgXHRcdFx0XHRcdFx0dHlwZSA9IF9nbC5VTlNJR05FRF9JTlQ7XG5cbiAgICBcdFx0XHRcdFx0fSBlbHNlIGlmICggYXJyYXkgaW5zdGFuY2VvZiBJbnQzMkFycmF5ICkge1xuXG4gICAgXHRcdFx0XHRcdFx0dHlwZSA9IF9nbC5JTlQ7XG5cbiAgICBcdFx0XHRcdFx0fSBlbHNlIGlmICggYXJyYXkgaW5zdGFuY2VvZiBJbnQ4QXJyYXkgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHR0eXBlID0gX2dsLkJZVEU7XG5cbiAgICBcdFx0XHRcdFx0fSBlbHNlIGlmICggYXJyYXkgaW5zdGFuY2VvZiBVaW50OEFycmF5ICkge1xuXG4gICAgXHRcdFx0XHRcdFx0dHlwZSA9IF9nbC5VTlNJR05FRF9CWVRFO1xuXG4gICAgXHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0XHR2YXIgc2l6ZSA9IGdlb21ldHJ5QXR0cmlidXRlLml0ZW1TaXplO1xuICAgIFx0XHRcdFx0XHR2YXIgYnVmZmVyID0gb2JqZWN0cy5nZXRBdHRyaWJ1dGVCdWZmZXIoIGdlb21ldHJ5QXR0cmlidXRlICk7XG5cbiAgICBcdFx0XHRcdFx0aWYgKCBnZW9tZXRyeUF0dHJpYnV0ZSAmJiBnZW9tZXRyeUF0dHJpYnV0ZS5pc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlICkge1xuXG4gICAgXHRcdFx0XHRcdFx0dmFyIGRhdGEgPSBnZW9tZXRyeUF0dHJpYnV0ZS5kYXRhO1xuICAgIFx0XHRcdFx0XHRcdHZhciBzdHJpZGUgPSBkYXRhLnN0cmlkZTtcbiAgICBcdFx0XHRcdFx0XHR2YXIgb2Zmc2V0ID0gZ2VvbWV0cnlBdHRyaWJ1dGUub2Zmc2V0O1xuXG4gICAgXHRcdFx0XHRcdFx0aWYgKCBkYXRhICYmIGRhdGEuaXNJbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlciApIHtcblxuICAgIFx0XHRcdFx0XHRcdFx0c3RhdGUuZW5hYmxlQXR0cmlidXRlQW5kRGl2aXNvciggcHJvZ3JhbUF0dHJpYnV0ZSwgZGF0YS5tZXNoUGVyQXR0cmlidXRlLCBleHRlbnNpb24gKTtcblxuICAgIFx0XHRcdFx0XHRcdFx0aWYgKCBnZW9tZXRyeS5tYXhJbnN0YW5jZWRDb3VudCA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0XHRcdFx0XHRcdGdlb21ldHJ5Lm1heEluc3RhbmNlZENvdW50ID0gZGF0YS5tZXNoUGVyQXR0cmlidXRlICogZGF0YS5jb3VudDtcblxuICAgIFx0XHRcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0XHRcdFx0c3RhdGUuZW5hYmxlQXR0cmlidXRlKCBwcm9ncmFtQXR0cmlidXRlICk7XG5cbiAgICBcdFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgYnVmZmVyICk7XG4gICAgXHRcdFx0XHRcdFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIHByb2dyYW1BdHRyaWJ1dGUsIHNpemUsIHR5cGUsIG5vcm1hbGl6ZWQsIHN0cmlkZSAqIGRhdGEuYXJyYXkuQllURVNfUEVSX0VMRU1FTlQsICggc3RhcnRJbmRleCAqIHN0cmlkZSArIG9mZnNldCApICogZGF0YS5hcnJheS5CWVRFU19QRVJfRUxFTUVOVCApO1xuXG4gICAgXHRcdFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdFx0XHRpZiAoIGdlb21ldHJ5QXR0cmlidXRlICYmIGdlb21ldHJ5QXR0cmlidXRlLmlzSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlICkge1xuXG4gICAgXHRcdFx0XHRcdFx0XHRzdGF0ZS5lbmFibGVBdHRyaWJ1dGVBbmREaXZpc29yKCBwcm9ncmFtQXR0cmlidXRlLCBnZW9tZXRyeUF0dHJpYnV0ZS5tZXNoUGVyQXR0cmlidXRlLCBleHRlbnNpb24gKTtcblxuICAgIFx0XHRcdFx0XHRcdFx0aWYgKCBnZW9tZXRyeS5tYXhJbnN0YW5jZWRDb3VudCA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0XHRcdFx0XHRcdGdlb21ldHJ5Lm1heEluc3RhbmNlZENvdW50ID0gZ2VvbWV0cnlBdHRyaWJ1dGUubWVzaFBlckF0dHJpYnV0ZSAqIGdlb21ldHJ5QXR0cmlidXRlLmNvdW50O1xuXG4gICAgXHRcdFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHRcdFx0XHRzdGF0ZS5lbmFibGVBdHRyaWJ1dGUoIHByb2dyYW1BdHRyaWJ1dGUgKTtcblxuICAgIFx0XHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIgKTtcbiAgICBcdFx0XHRcdFx0XHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggcHJvZ3JhbUF0dHJpYnV0ZSwgc2l6ZSwgdHlwZSwgbm9ybWFsaXplZCwgMCwgc3RhcnRJbmRleCAqIHNpemUgKiBnZW9tZXRyeUF0dHJpYnV0ZS5hcnJheS5CWVRFU19QRVJfRUxFTUVOVCApO1xuXG4gICAgXHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWxEZWZhdWx0QXR0cmlidXRlVmFsdWVzICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRcdFx0dmFyIHZhbHVlID0gbWF0ZXJpYWxEZWZhdWx0QXR0cmlidXRlVmFsdWVzWyBuYW1lIF07XG5cbiAgICBcdFx0XHRcdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0XHRcdFx0c3dpdGNoICggdmFsdWUubGVuZ3RoICkge1xuXG4gICAgXHRcdFx0XHRcdFx0XHRjYXNlIDI6XG4gICAgXHRcdFx0XHRcdFx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWIyZnYoIHByb2dyYW1BdHRyaWJ1dGUsIHZhbHVlICk7XG4gICAgXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG4gICAgXHRcdFx0XHRcdFx0XHRjYXNlIDM6XG4gICAgXHRcdFx0XHRcdFx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWIzZnYoIHByb2dyYW1BdHRyaWJ1dGUsIHZhbHVlICk7XG4gICAgXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG4gICAgXHRcdFx0XHRcdFx0XHRjYXNlIDQ6XG4gICAgXHRcdFx0XHRcdFx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWI0ZnYoIHByb2dyYW1BdHRyaWJ1dGUsIHZhbHVlICk7XG4gICAgXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG4gICAgXHRcdFx0XHRcdFx0XHRkZWZhdWx0OlxuICAgIFx0XHRcdFx0XHRcdFx0XHRfZ2wudmVydGV4QXR0cmliMWZ2KCBwcm9ncmFtQXR0cmlidXRlLCB2YWx1ZSApO1xuXG4gICAgXHRcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHRzdGF0ZS5kaXNhYmxlVW51c2VkQXR0cmlidXRlcygpO1xuXG4gICAgXHR9XG5cbiAgICBcdC8vIFNvcnRpbmdcblxuICAgIFx0ZnVuY3Rpb24gYWJzTnVtZXJpY2FsU29ydCggYSwgYiApIHtcblxuICAgIFx0XHRyZXR1cm4gTWF0aC5hYnMoIGJbIDAgXSApIC0gTWF0aC5hYnMoIGFbIDAgXSApO1xuXG4gICAgXHR9XG5cbiAgICBcdGZ1bmN0aW9uIHBhaW50ZXJTb3J0U3RhYmxlKCBhLCBiICkge1xuXG4gICAgXHRcdGlmICggYS5vYmplY3QucmVuZGVyT3JkZXIgIT09IGIub2JqZWN0LnJlbmRlck9yZGVyICkge1xuXG4gICAgXHRcdFx0cmV0dXJuIGEub2JqZWN0LnJlbmRlck9yZGVyIC0gYi5vYmplY3QucmVuZGVyT3JkZXI7XG5cbiAgICBcdFx0fSBlbHNlIGlmICggYS5tYXRlcmlhbC5wcm9ncmFtICYmIGIubWF0ZXJpYWwucHJvZ3JhbSAmJiBhLm1hdGVyaWFsLnByb2dyYW0gIT09IGIubWF0ZXJpYWwucHJvZ3JhbSApIHtcblxuICAgIFx0XHRcdHJldHVybiBhLm1hdGVyaWFsLnByb2dyYW0uaWQgLSBiLm1hdGVyaWFsLnByb2dyYW0uaWQ7XG5cbiAgICBcdFx0fSBlbHNlIGlmICggYS5tYXRlcmlhbC5pZCAhPT0gYi5tYXRlcmlhbC5pZCApIHtcblxuICAgIFx0XHRcdHJldHVybiBhLm1hdGVyaWFsLmlkIC0gYi5tYXRlcmlhbC5pZDtcblxuICAgIFx0XHR9IGVsc2UgaWYgKCBhLnogIT09IGIueiApIHtcblxuICAgIFx0XHRcdHJldHVybiBhLnogLSBiLno7XG5cbiAgICBcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdHJldHVybiBhLmlkIC0gYi5pZDtcblxuICAgIFx0XHR9XG5cbiAgICBcdH1cblxuICAgIFx0ZnVuY3Rpb24gcmV2ZXJzZVBhaW50ZXJTb3J0U3RhYmxlKCBhLCBiICkge1xuXG4gICAgXHRcdGlmICggYS5vYmplY3QucmVuZGVyT3JkZXIgIT09IGIub2JqZWN0LnJlbmRlck9yZGVyICkge1xuXG4gICAgXHRcdFx0cmV0dXJuIGEub2JqZWN0LnJlbmRlck9yZGVyIC0gYi5vYmplY3QucmVuZGVyT3JkZXI7XG5cbiAgICBcdFx0fSBpZiAoIGEueiAhPT0gYi56ICkge1xuXG4gICAgXHRcdFx0cmV0dXJuIGIueiAtIGEuejtcblxuICAgIFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0cmV0dXJuIGEuaWQgLSBiLmlkO1xuXG4gICAgXHRcdH1cblxuICAgIFx0fVxuXG4gICAgXHQvLyBSZW5kZXJpbmdcblxuICAgIFx0dGhpcy5yZW5kZXIgPSBmdW5jdGlvbiAoIHNjZW5lLCBjYW1lcmEsIHJlbmRlclRhcmdldCwgZm9yY2VDbGVhciApIHtcblxuICAgIFx0XHRpZiAoIGNhbWVyYSAhPT0gdW5kZWZpbmVkICYmIGNhbWVyYS5pc0NhbWVyYSAhPT0gdHJ1ZSApIHtcblxuICAgIFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFJlbmRlcmVyLnJlbmRlcjogY2FtZXJhIGlzIG5vdCBhbiBpbnN0YW5jZSBvZiBUSFJFRS5DYW1lcmEuJyApO1xuICAgIFx0XHRcdHJldHVybjtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0dmFyIGZvZyA9IHNjZW5lLmZvZztcblxuICAgIFx0XHQvLyByZXNldCBjYWNoaW5nIGZvciB0aGlzIGZyYW1lXG5cbiAgICBcdFx0X2N1cnJlbnRHZW9tZXRyeVByb2dyYW0gPSAnJztcbiAgICBcdFx0X2N1cnJlbnRNYXRlcmlhbElkID0gLSAxO1xuICAgIFx0XHRfY3VycmVudENhbWVyYSA9IG51bGw7XG5cbiAgICBcdFx0Ly8gdXBkYXRlIHNjZW5lIGdyYXBoXG5cbiAgICBcdFx0aWYgKCBzY2VuZS5hdXRvVXBkYXRlID09PSB0cnVlICkgc2NlbmUudXBkYXRlTWF0cml4V29ybGQoKTtcblxuICAgIFx0XHQvLyB1cGRhdGUgY2FtZXJhIG1hdHJpY2VzIGFuZCBmcnVzdHVtXG5cbiAgICBcdFx0aWYgKCBjYW1lcmEucGFyZW50ID09PSBudWxsICkgY2FtZXJhLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG5cbiAgICBcdFx0Y2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZS5nZXRJbnZlcnNlKCBjYW1lcmEubWF0cml4V29ybGQgKTtcblxuICAgIFx0XHRfcHJvalNjcmVlbk1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBjYW1lcmEucHJvamVjdGlvbk1hdHJpeCwgY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSApO1xuICAgIFx0XHRfZnJ1c3R1bS5zZXRGcm9tTWF0cml4KCBfcHJvalNjcmVlbk1hdHJpeCApO1xuXG4gICAgXHRcdGxpZ2h0cy5sZW5ndGggPSAwO1xuXG4gICAgXHRcdG9wYXF1ZU9iamVjdHNMYXN0SW5kZXggPSAtIDE7XG4gICAgXHRcdHRyYW5zcGFyZW50T2JqZWN0c0xhc3RJbmRleCA9IC0gMTtcblxuICAgIFx0XHRzcHJpdGVzLmxlbmd0aCA9IDA7XG4gICAgXHRcdGxlbnNGbGFyZXMubGVuZ3RoID0gMDtcblxuICAgIFx0XHRfbG9jYWxDbGlwcGluZ0VuYWJsZWQgPSB0aGlzLmxvY2FsQ2xpcHBpbmdFbmFibGVkO1xuICAgIFx0XHRfY2xpcHBpbmdFbmFibGVkID0gX2NsaXBwaW5nLmluaXQoIHRoaXMuY2xpcHBpbmdQbGFuZXMsIF9sb2NhbENsaXBwaW5nRW5hYmxlZCwgY2FtZXJhICk7XG5cbiAgICBcdFx0cHJvamVjdE9iamVjdCggc2NlbmUsIGNhbWVyYSApO1xuXG4gICAgXHRcdG9wYXF1ZU9iamVjdHMubGVuZ3RoID0gb3BhcXVlT2JqZWN0c0xhc3RJbmRleCArIDE7XG4gICAgXHRcdHRyYW5zcGFyZW50T2JqZWN0cy5sZW5ndGggPSB0cmFuc3BhcmVudE9iamVjdHNMYXN0SW5kZXggKyAxO1xuXG4gICAgXHRcdGlmICggX3RoaXMuc29ydE9iamVjdHMgPT09IHRydWUgKSB7XG5cbiAgICBcdFx0XHRvcGFxdWVPYmplY3RzLnNvcnQoIHBhaW50ZXJTb3J0U3RhYmxlICk7XG4gICAgXHRcdFx0dHJhbnNwYXJlbnRPYmplY3RzLnNvcnQoIHJldmVyc2VQYWludGVyU29ydFN0YWJsZSApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHQvL1xuXG4gICAgXHRcdGlmICggX2NsaXBwaW5nRW5hYmxlZCApIF9jbGlwcGluZy5iZWdpblNoYWRvd3MoKTtcblxuICAgIFx0XHRzZXR1cFNoYWRvd3MoIGxpZ2h0cyApO1xuXG4gICAgXHRcdHNoYWRvd01hcC5yZW5kZXIoIHNjZW5lLCBjYW1lcmEgKTtcblxuICAgIFx0XHRzZXR1cExpZ2h0cyggbGlnaHRzLCBjYW1lcmEgKTtcblxuICAgIFx0XHRpZiAoIF9jbGlwcGluZ0VuYWJsZWQgKSBfY2xpcHBpbmcuZW5kU2hhZG93cygpO1xuXG4gICAgXHRcdC8vXG5cbiAgICBcdFx0X2luZm9SZW5kZXIuY2FsbHMgPSAwO1xuICAgIFx0XHRfaW5mb1JlbmRlci52ZXJ0aWNlcyA9IDA7XG4gICAgXHRcdF9pbmZvUmVuZGVyLmZhY2VzID0gMDtcbiAgICBcdFx0X2luZm9SZW5kZXIucG9pbnRzID0gMDtcblxuICAgIFx0XHRpZiAoIHJlbmRlclRhcmdldCA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0cmVuZGVyVGFyZ2V0ID0gbnVsbDtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0dGhpcy5zZXRSZW5kZXJUYXJnZXQoIHJlbmRlclRhcmdldCApO1xuXG4gICAgXHRcdC8vXG5cbiAgICBcdFx0dmFyIGJhY2tncm91bmQgPSBzY2VuZS5iYWNrZ3JvdW5kO1xuXG4gICAgXHRcdGlmICggYmFja2dyb3VuZCA9PT0gbnVsbCApIHtcblxuICAgIFx0XHRcdGdsQ2xlYXJDb2xvciggX2NsZWFyQ29sb3IuciwgX2NsZWFyQ29sb3IuZywgX2NsZWFyQ29sb3IuYiwgX2NsZWFyQWxwaGEgKTtcblxuICAgIFx0XHR9IGVsc2UgaWYgKCBiYWNrZ3JvdW5kICYmIGJhY2tncm91bmQuaXNDb2xvciApIHtcblxuICAgIFx0XHRcdGdsQ2xlYXJDb2xvciggYmFja2dyb3VuZC5yLCBiYWNrZ3JvdW5kLmcsIGJhY2tncm91bmQuYiwgMSApO1xuICAgIFx0XHRcdGZvcmNlQ2xlYXIgPSB0cnVlO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRpZiAoIHRoaXMuYXV0b0NsZWFyIHx8IGZvcmNlQ2xlYXIgKSB7XG5cbiAgICBcdFx0XHR0aGlzLmNsZWFyKCB0aGlzLmF1dG9DbGVhckNvbG9yLCB0aGlzLmF1dG9DbGVhckRlcHRoLCB0aGlzLmF1dG9DbGVhclN0ZW5jaWwgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0aWYgKCBiYWNrZ3JvdW5kICYmIGJhY2tncm91bmQuaXNDdWJlVGV4dHVyZSApIHtcblxuICAgIFx0XHRcdGJhY2tncm91bmRDYW1lcmEyLnByb2plY3Rpb25NYXRyaXguY29weSggY2FtZXJhLnByb2plY3Rpb25NYXRyaXggKTtcblxuICAgIFx0XHRcdGJhY2tncm91bmRDYW1lcmEyLm1hdHJpeFdvcmxkLmV4dHJhY3RSb3RhdGlvbiggY2FtZXJhLm1hdHJpeFdvcmxkICk7XG4gICAgXHRcdFx0YmFja2dyb3VuZENhbWVyYTIubWF0cml4V29ybGRJbnZlcnNlLmdldEludmVyc2UoIGJhY2tncm91bmRDYW1lcmEyLm1hdHJpeFdvcmxkICk7XG5cbiAgICBcdFx0XHRiYWNrZ3JvdW5kQm94TWVzaC5tYXRlcmlhbC51bmlmb3Jtc1sgXCJ0Q3ViZVwiIF0udmFsdWUgPSBiYWNrZ3JvdW5kO1xuICAgIFx0XHRcdGJhY2tncm91bmRCb3hNZXNoLm1vZGVsVmlld01hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBiYWNrZ3JvdW5kQ2FtZXJhMi5tYXRyaXhXb3JsZEludmVyc2UsIGJhY2tncm91bmRCb3hNZXNoLm1hdHJpeFdvcmxkICk7XG5cbiAgICBcdFx0XHRvYmplY3RzLnVwZGF0ZSggYmFja2dyb3VuZEJveE1lc2ggKTtcblxuICAgIFx0XHRcdF90aGlzLnJlbmRlckJ1ZmZlckRpcmVjdCggYmFja2dyb3VuZENhbWVyYTIsIG51bGwsIGJhY2tncm91bmRCb3hNZXNoLmdlb21ldHJ5LCBiYWNrZ3JvdW5kQm94TWVzaC5tYXRlcmlhbCwgYmFja2dyb3VuZEJveE1lc2gsIG51bGwgKTtcblxuICAgIFx0XHR9IGVsc2UgaWYgKCBiYWNrZ3JvdW5kICYmIGJhY2tncm91bmQuaXNUZXh0dXJlICkge1xuXG4gICAgXHRcdFx0YmFja2dyb3VuZFBsYW5lTWVzaC5tYXRlcmlhbC5tYXAgPSBiYWNrZ3JvdW5kO1xuXG4gICAgXHRcdFx0b2JqZWN0cy51cGRhdGUoIGJhY2tncm91bmRQbGFuZU1lc2ggKTtcblxuICAgIFx0XHRcdF90aGlzLnJlbmRlckJ1ZmZlckRpcmVjdCggYmFja2dyb3VuZENhbWVyYSwgbnVsbCwgYmFja2dyb3VuZFBsYW5lTWVzaC5nZW9tZXRyeSwgYmFja2dyb3VuZFBsYW5lTWVzaC5tYXRlcmlhbCwgYmFja2dyb3VuZFBsYW5lTWVzaCwgbnVsbCApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHQvL1xuXG4gICAgXHRcdGlmICggc2NlbmUub3ZlcnJpZGVNYXRlcmlhbCApIHtcblxuICAgIFx0XHRcdHZhciBvdmVycmlkZU1hdGVyaWFsID0gc2NlbmUub3ZlcnJpZGVNYXRlcmlhbDtcblxuICAgIFx0XHRcdHJlbmRlck9iamVjdHMoIG9wYXF1ZU9iamVjdHMsIGNhbWVyYSwgZm9nLCBvdmVycmlkZU1hdGVyaWFsICk7XG4gICAgXHRcdFx0cmVuZGVyT2JqZWN0cyggdHJhbnNwYXJlbnRPYmplY3RzLCBjYW1lcmEsIGZvZywgb3ZlcnJpZGVNYXRlcmlhbCApO1xuXG4gICAgXHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHQvLyBvcGFxdWUgcGFzcyAoZnJvbnQtdG8tYmFjayBvcmRlcilcblxuICAgIFx0XHRcdHN0YXRlLnNldEJsZW5kaW5nKCBOb0JsZW5kaW5nICk7XG4gICAgXHRcdFx0cmVuZGVyT2JqZWN0cyggb3BhcXVlT2JqZWN0cywgY2FtZXJhLCBmb2cgKTtcblxuICAgIFx0XHRcdC8vIHRyYW5zcGFyZW50IHBhc3MgKGJhY2stdG8tZnJvbnQgb3JkZXIpXG5cbiAgICBcdFx0XHRyZW5kZXJPYmplY3RzKCB0cmFuc3BhcmVudE9iamVjdHMsIGNhbWVyYSwgZm9nICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdC8vIGN1c3RvbSByZW5kZXIgcGx1Z2lucyAocG9zdCBwYXNzKVxuXG4gICAgXHRcdHNwcml0ZVBsdWdpbi5yZW5kZXIoIHNjZW5lLCBjYW1lcmEgKTtcbiAgICBcdFx0bGVuc0ZsYXJlUGx1Z2luLnJlbmRlciggc2NlbmUsIGNhbWVyYSwgX2N1cnJlbnRWaWV3cG9ydCApO1xuXG4gICAgXHRcdC8vIEdlbmVyYXRlIG1pcG1hcCBpZiB3ZSdyZSB1c2luZyBhbnkga2luZCBvZiBtaXBtYXAgZmlsdGVyaW5nXG5cbiAgICBcdFx0aWYgKCByZW5kZXJUYXJnZXQgKSB7XG5cbiAgICBcdFx0XHR0ZXh0dXJlcy51cGRhdGVSZW5kZXJUYXJnZXRNaXBtYXAoIHJlbmRlclRhcmdldCApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHQvLyBFbnN1cmUgZGVwdGggYnVmZmVyIHdyaXRpbmcgaXMgZW5hYmxlZCBzbyBpdCBjYW4gYmUgY2xlYXJlZCBvbiBuZXh0IHJlbmRlclxuXG4gICAgXHRcdHN0YXRlLnNldERlcHRoVGVzdCggdHJ1ZSApO1xuICAgIFx0XHRzdGF0ZS5zZXREZXB0aFdyaXRlKCB0cnVlICk7XG4gICAgXHRcdHN0YXRlLnNldENvbG9yV3JpdGUoIHRydWUgKTtcblxuICAgIFx0XHQvLyBfZ2wuZmluaXNoKCk7XG5cbiAgICBcdH07XG5cbiAgICBcdGZ1bmN0aW9uIHB1c2hSZW5kZXJJdGVtKCBvYmplY3QsIGdlb21ldHJ5LCBtYXRlcmlhbCwgeiwgZ3JvdXAgKSB7XG5cbiAgICBcdFx0dmFyIGFycmF5LCBpbmRleDtcblxuICAgIFx0XHQvLyBhbGxvY2F0ZSB0aGUgbmV4dCBwb3NpdGlvbiBpbiB0aGUgYXBwcm9wcmlhdGUgYXJyYXlcblxuICAgIFx0XHRpZiAoIG1hdGVyaWFsLnRyYW5zcGFyZW50ICkge1xuXG4gICAgXHRcdFx0YXJyYXkgPSB0cmFuc3BhcmVudE9iamVjdHM7XG4gICAgXHRcdFx0aW5kZXggPSArKyB0cmFuc3BhcmVudE9iamVjdHNMYXN0SW5kZXg7XG5cbiAgICBcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdGFycmF5ID0gb3BhcXVlT2JqZWN0cztcbiAgICBcdFx0XHRpbmRleCA9ICsrIG9wYXF1ZU9iamVjdHNMYXN0SW5kZXg7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdC8vIHJlY3ljbGUgZXhpc3RpbmcgcmVuZGVyIGl0ZW0gb3IgZ3JvdyB0aGUgYXJyYXlcblxuICAgIFx0XHR2YXIgcmVuZGVySXRlbSA9IGFycmF5WyBpbmRleCBdO1xuXG4gICAgXHRcdGlmICggcmVuZGVySXRlbSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0cmVuZGVySXRlbS5pZCA9IG9iamVjdC5pZDtcbiAgICBcdFx0XHRyZW5kZXJJdGVtLm9iamVjdCA9IG9iamVjdDtcbiAgICBcdFx0XHRyZW5kZXJJdGVtLmdlb21ldHJ5ID0gZ2VvbWV0cnk7XG4gICAgXHRcdFx0cmVuZGVySXRlbS5tYXRlcmlhbCA9IG1hdGVyaWFsO1xuICAgIFx0XHRcdHJlbmRlckl0ZW0ueiA9IF92ZWN0b3IzLno7XG4gICAgXHRcdFx0cmVuZGVySXRlbS5ncm91cCA9IGdyb3VwO1xuXG4gICAgXHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRyZW5kZXJJdGVtID0ge1xuICAgIFx0XHRcdFx0aWQ6IG9iamVjdC5pZCxcbiAgICBcdFx0XHRcdG9iamVjdDogb2JqZWN0LFxuICAgIFx0XHRcdFx0Z2VvbWV0cnk6IGdlb21ldHJ5LFxuICAgIFx0XHRcdFx0bWF0ZXJpYWw6IG1hdGVyaWFsLFxuICAgIFx0XHRcdFx0ejogX3ZlY3RvcjMueixcbiAgICBcdFx0XHRcdGdyb3VwOiBncm91cFxuICAgIFx0XHRcdH07XG5cbiAgICBcdFx0XHQvLyBhc3NlcnQoIGluZGV4ID09PSBhcnJheS5sZW5ndGggKTtcbiAgICBcdFx0XHRhcnJheS5wdXNoKCByZW5kZXJJdGVtICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9XG5cbiAgICBcdC8vIFRPRE8gRHVwbGljYXRlZCBjb2RlIChGcnVzdHVtKVxuXG4gICAgXHRmdW5jdGlvbiBpc09iamVjdFZpZXdhYmxlKCBvYmplY3QgKSB7XG5cbiAgICBcdFx0dmFyIGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5O1xuXG4gICAgXHRcdGlmICggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgPT09IG51bGwgKVxuICAgIFx0XHRcdGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xuXG4gICAgXHRcdF9zcGhlcmUuY29weSggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgKS5cbiAgICBcdFx0XHRhcHBseU1hdHJpeDQoIG9iamVjdC5tYXRyaXhXb3JsZCApO1xuXG4gICAgXHRcdHJldHVybiBpc1NwaGVyZVZpZXdhYmxlKCBfc3BoZXJlICk7XG5cbiAgICBcdH1cblxuICAgIFx0ZnVuY3Rpb24gaXNTcHJpdGVWaWV3YWJsZSggc3ByaXRlICkge1xuXG4gICAgXHRcdF9zcGhlcmUuY2VudGVyLnNldCggMCwgMCwgMCApO1xuICAgIFx0XHRfc3BoZXJlLnJhZGl1cyA9IDAuNzA3MTA2NzgxMTg2NTQ3NjtcbiAgICBcdFx0X3NwaGVyZS5hcHBseU1hdHJpeDQoIHNwcml0ZS5tYXRyaXhXb3JsZCApO1xuXG4gICAgXHRcdHJldHVybiBpc1NwaGVyZVZpZXdhYmxlKCBfc3BoZXJlICk7XG5cbiAgICBcdH1cblxuICAgIFx0ZnVuY3Rpb24gaXNTcGhlcmVWaWV3YWJsZSggc3BoZXJlICkge1xuXG4gICAgXHRcdGlmICggISBfZnJ1c3R1bS5pbnRlcnNlY3RzU3BoZXJlKCBzcGhlcmUgKSApIHJldHVybiBmYWxzZTtcblxuICAgIFx0XHR2YXIgbnVtUGxhbmVzID0gX2NsaXBwaW5nLm51bVBsYW5lcztcblxuICAgIFx0XHRpZiAoIG51bVBsYW5lcyA9PT0gMCApIHJldHVybiB0cnVlO1xuXG4gICAgXHRcdHZhciBwbGFuZXMgPSBfdGhpcy5jbGlwcGluZ1BsYW5lcyxcblxuICAgIFx0XHRcdGNlbnRlciA9IHNwaGVyZS5jZW50ZXIsXG4gICAgXHRcdFx0bmVnUmFkID0gLSBzcGhlcmUucmFkaXVzLFxuICAgIFx0XHRcdGkgPSAwO1xuXG4gICAgXHRcdGRvIHtcblxuICAgIFx0XHRcdC8vIG91dCB3aGVuIGRlZXBlciB0aGFuIHJhZGl1cyBpbiB0aGUgbmVnYXRpdmUgaGFsZnNwYWNlXG4gICAgXHRcdFx0aWYgKCBwbGFuZXNbIGkgXS5kaXN0YW5jZVRvUG9pbnQoIGNlbnRlciApIDwgbmVnUmFkICkgcmV0dXJuIGZhbHNlO1xuXG4gICAgXHRcdH0gd2hpbGUgKCArKyBpICE9PSBudW1QbGFuZXMgKTtcblxuICAgIFx0XHRyZXR1cm4gdHJ1ZTtcblxuICAgIFx0fVxuXG4gICAgXHRmdW5jdGlvbiBwcm9qZWN0T2JqZWN0KCBvYmplY3QsIGNhbWVyYSApIHtcblxuICAgIFx0XHRpZiAoIG9iamVjdC52aXNpYmxlID09PSBmYWxzZSApIHJldHVybjtcblxuICAgIFx0XHR2YXIgdmlzaWJsZSA9ICggb2JqZWN0LmxheWVycy5tYXNrICYgY2FtZXJhLmxheWVycy5tYXNrICkgIT09IDA7XG5cbiAgICBcdFx0aWYgKCB2aXNpYmxlICkge1xuXG4gICAgXHRcdFx0aWYgKCBvYmplY3QuaXNMaWdodCApIHtcblxuICAgIFx0XHRcdFx0bGlnaHRzLnB1c2goIG9iamVjdCApO1xuXG4gICAgXHRcdFx0fSBlbHNlIGlmICggb2JqZWN0LmlzU3ByaXRlICkge1xuXG4gICAgXHRcdFx0XHRpZiAoIG9iamVjdC5mcnVzdHVtQ3VsbGVkID09PSBmYWxzZSB8fCBpc1Nwcml0ZVZpZXdhYmxlKCBvYmplY3QgKSA9PT0gdHJ1ZSApIHtcblxuICAgIFx0XHRcdFx0XHRzcHJpdGVzLnB1c2goIG9iamVjdCApO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHR9IGVsc2UgaWYgKCBvYmplY3QuaXNMZW5zRmxhcmUgKSB7XG5cbiAgICBcdFx0XHRcdGxlbnNGbGFyZXMucHVzaCggb2JqZWN0ICk7XG5cbiAgICBcdFx0XHR9IGVsc2UgaWYgKCBvYmplY3QuaXNJbW1lZGlhdGVSZW5kZXJPYmplY3QgKSB7XG5cbiAgICBcdFx0XHRcdGlmICggX3RoaXMuc29ydE9iamVjdHMgPT09IHRydWUgKSB7XG5cbiAgICBcdFx0XHRcdFx0X3ZlY3RvcjMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBvYmplY3QubWF0cml4V29ybGQgKTtcbiAgICBcdFx0XHRcdFx0X3ZlY3RvcjMuYXBwbHlQcm9qZWN0aW9uKCBfcHJvalNjcmVlbk1hdHJpeCApO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdHB1c2hSZW5kZXJJdGVtKCBvYmplY3QsIG51bGwsIG9iamVjdC5tYXRlcmlhbCwgX3ZlY3RvcjMueiwgbnVsbCApO1xuXG4gICAgXHRcdFx0fSBlbHNlIGlmICggb2JqZWN0LmlzTWVzaCB8fCBvYmplY3QuaXNMaW5lIHx8IG9iamVjdC5pc1BvaW50cyApIHtcblxuICAgIFx0XHRcdFx0aWYgKCBvYmplY3QuaXNTa2lubmVkTWVzaCApIHtcblxuICAgIFx0XHRcdFx0XHRvYmplY3Quc2tlbGV0b24udXBkYXRlKCk7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0aWYgKCBvYmplY3QuZnJ1c3R1bUN1bGxlZCA9PT0gZmFsc2UgfHwgaXNPYmplY3RWaWV3YWJsZSggb2JqZWN0ICkgPT09IHRydWUgKSB7XG5cbiAgICBcdFx0XHRcdFx0dmFyIG1hdGVyaWFsID0gb2JqZWN0Lm1hdGVyaWFsO1xuXG4gICAgXHRcdFx0XHRcdGlmICggbWF0ZXJpYWwudmlzaWJsZSA9PT0gdHJ1ZSApIHtcblxuICAgIFx0XHRcdFx0XHRcdGlmICggX3RoaXMuc29ydE9iamVjdHMgPT09IHRydWUgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHRcdF92ZWN0b3IzLnNldEZyb21NYXRyaXhQb3NpdGlvbiggb2JqZWN0Lm1hdHJpeFdvcmxkICk7XG4gICAgXHRcdFx0XHRcdFx0XHRfdmVjdG9yMy5hcHBseVByb2plY3Rpb24oIF9wcm9qU2NyZWVuTWF0cml4ICk7XG5cbiAgICBcdFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdFx0XHR2YXIgZ2VvbWV0cnkgPSBvYmplY3RzLnVwZGF0ZSggb2JqZWN0ICk7XG5cbiAgICBcdFx0XHRcdFx0XHRpZiAoIG1hdGVyaWFsLmlzTXVsdGlNYXRlcmlhbCApIHtcblxuICAgIFx0XHRcdFx0XHRcdFx0dmFyIGdyb3VwcyA9IGdlb21ldHJ5Lmdyb3VwcztcbiAgICBcdFx0XHRcdFx0XHRcdHZhciBtYXRlcmlhbHMgPSBtYXRlcmlhbC5tYXRlcmlhbHM7XG5cbiAgICBcdFx0XHRcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGdyb3Vwcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgXHRcdFx0XHRcdFx0XHRcdHZhciBncm91cCA9IGdyb3Vwc1sgaSBdO1xuICAgIFx0XHRcdFx0XHRcdFx0XHR2YXIgZ3JvdXBNYXRlcmlhbCA9IG1hdGVyaWFsc1sgZ3JvdXAubWF0ZXJpYWxJbmRleCBdO1xuXG4gICAgXHRcdFx0XHRcdFx0XHRcdGlmICggZ3JvdXBNYXRlcmlhbC52aXNpYmxlID09PSB0cnVlICkge1xuXG4gICAgXHRcdFx0XHRcdFx0XHRcdFx0cHVzaFJlbmRlckl0ZW0oIG9iamVjdCwgZ2VvbWV0cnksIGdyb3VwTWF0ZXJpYWwsIF92ZWN0b3IzLnosIGdyb3VwICk7XG5cbiAgICBcdFx0XHRcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHRcdFx0XHRwdXNoUmVuZGVySXRlbSggb2JqZWN0LCBnZW9tZXRyeSwgbWF0ZXJpYWwsIF92ZWN0b3IzLnosIG51bGwgKTtcblxuICAgIFx0XHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdFx0dmFyIGNoaWxkcmVuID0gb2JqZWN0LmNoaWxkcmVuO1xuXG4gICAgXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICBcdFx0XHRwcm9qZWN0T2JqZWN0KCBjaGlsZHJlblsgaSBdLCBjYW1lcmEgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdH1cblxuICAgIFx0ZnVuY3Rpb24gcmVuZGVyT2JqZWN0cyggcmVuZGVyTGlzdCwgY2FtZXJhLCBmb2csIG92ZXJyaWRlTWF0ZXJpYWwgKSB7XG5cbiAgICBcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gcmVuZGVyTGlzdC5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgXHRcdFx0dmFyIHJlbmRlckl0ZW0gPSByZW5kZXJMaXN0WyBpIF07XG5cbiAgICBcdFx0XHR2YXIgb2JqZWN0ID0gcmVuZGVySXRlbS5vYmplY3Q7XG4gICAgXHRcdFx0dmFyIGdlb21ldHJ5ID0gcmVuZGVySXRlbS5nZW9tZXRyeTtcbiAgICBcdFx0XHR2YXIgbWF0ZXJpYWwgPSBvdmVycmlkZU1hdGVyaWFsID09PSB1bmRlZmluZWQgPyByZW5kZXJJdGVtLm1hdGVyaWFsIDogb3ZlcnJpZGVNYXRlcmlhbDtcbiAgICBcdFx0XHR2YXIgZ3JvdXAgPSByZW5kZXJJdGVtLmdyb3VwO1xuXG4gICAgXHRcdFx0b2JqZWN0Lm1vZGVsVmlld01hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLCBvYmplY3QubWF0cml4V29ybGQgKTtcbiAgICBcdFx0XHRvYmplY3Qubm9ybWFsTWF0cml4LmdldE5vcm1hbE1hdHJpeCggb2JqZWN0Lm1vZGVsVmlld01hdHJpeCApO1xuXG4gICAgXHRcdFx0aWYgKCBvYmplY3QuaXNJbW1lZGlhdGVSZW5kZXJPYmplY3QgKSB7XG5cbiAgICBcdFx0XHRcdHNldE1hdGVyaWFsKCBtYXRlcmlhbCApO1xuXG4gICAgXHRcdFx0XHR2YXIgcHJvZ3JhbSA9IHNldFByb2dyYW0oIGNhbWVyYSwgZm9nLCBtYXRlcmlhbCwgb2JqZWN0ICk7XG5cbiAgICBcdFx0XHRcdF9jdXJyZW50R2VvbWV0cnlQcm9ncmFtID0gJyc7XG5cbiAgICBcdFx0XHRcdG9iamVjdC5yZW5kZXIoIGZ1bmN0aW9uICggb2JqZWN0ICkge1xuXG4gICAgXHRcdFx0XHRcdF90aGlzLnJlbmRlckJ1ZmZlckltbWVkaWF0ZSggb2JqZWN0LCBwcm9ncmFtLCBtYXRlcmlhbCApO1xuXG4gICAgXHRcdFx0XHR9ICk7XG5cbiAgICBcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHRpZiAoIG9iamVjdC5vbkJlZm9yZVJlbmRlciAhPT0gbnVsbCApIG9iamVjdC5vbkJlZm9yZVJlbmRlcigpO1xuXG4gICAgXHRcdFx0XHRfdGhpcy5yZW5kZXJCdWZmZXJEaXJlY3QoIGNhbWVyYSwgZm9nLCBnZW9tZXRyeSwgbWF0ZXJpYWwsIG9iamVjdCwgZ3JvdXAgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdH1cblxuICAgIFx0ZnVuY3Rpb24gaW5pdE1hdGVyaWFsKCBtYXRlcmlhbCwgZm9nLCBvYmplY3QgKSB7XG5cbiAgICBcdFx0dmFyIG1hdGVyaWFsUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCBtYXRlcmlhbCApO1xuXG4gICAgXHRcdHZhciBwYXJhbWV0ZXJzID0gcHJvZ3JhbUNhY2hlLmdldFBhcmFtZXRlcnMoXG4gICAgXHRcdFx0XHRtYXRlcmlhbCwgX2xpZ2h0cywgZm9nLCBfY2xpcHBpbmcubnVtUGxhbmVzLCBvYmplY3QgKTtcblxuICAgIFx0XHR2YXIgY29kZSA9IHByb2dyYW1DYWNoZS5nZXRQcm9ncmFtQ29kZSggbWF0ZXJpYWwsIHBhcmFtZXRlcnMgKTtcblxuICAgIFx0XHR2YXIgcHJvZ3JhbSA9IG1hdGVyaWFsUHJvcGVydGllcy5wcm9ncmFtO1xuICAgIFx0XHR2YXIgcHJvZ3JhbUNoYW5nZSA9IHRydWU7XG5cbiAgICBcdFx0aWYgKCBwcm9ncmFtID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHQvLyBuZXcgbWF0ZXJpYWxcbiAgICBcdFx0XHRtYXRlcmlhbC5hZGRFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uTWF0ZXJpYWxEaXNwb3NlICk7XG5cbiAgICBcdFx0fSBlbHNlIGlmICggcHJvZ3JhbS5jb2RlICE9PSBjb2RlICkge1xuXG4gICAgXHRcdFx0Ly8gY2hhbmdlZCBnbHNsIG9yIHBhcmFtZXRlcnNcbiAgICBcdFx0XHRyZWxlYXNlTWF0ZXJpYWxQcm9ncmFtUmVmZXJlbmNlKCBtYXRlcmlhbCApO1xuXG4gICAgXHRcdH0gZWxzZSBpZiAoIHBhcmFtZXRlcnMuc2hhZGVySUQgIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdC8vIHNhbWUgZ2xzbCBhbmQgdW5pZm9ybSBsaXN0XG4gICAgXHRcdFx0cmV0dXJuO1xuXG4gICAgXHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHQvLyBvbmx5IHJlYnVpbGQgdW5pZm9ybSBsaXN0XG4gICAgXHRcdFx0cHJvZ3JhbUNoYW5nZSA9IGZhbHNlO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRpZiAoIHByb2dyYW1DaGFuZ2UgKSB7XG5cbiAgICBcdFx0XHRpZiAoIHBhcmFtZXRlcnMuc2hhZGVySUQgKSB7XG5cbiAgICBcdFx0XHRcdHZhciBzaGFkZXIgPSBTaGFkZXJMaWJbIHBhcmFtZXRlcnMuc2hhZGVySUQgXTtcblxuICAgIFx0XHRcdFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLl9fd2ViZ2xTaGFkZXIgPSB7XG4gICAgXHRcdFx0XHRcdG5hbWU6IG1hdGVyaWFsLnR5cGUsXG4gICAgXHRcdFx0XHRcdHVuaWZvcm1zOiBleHBvcnRzLlVuaWZvcm1zVXRpbHMuY2xvbmUoIHNoYWRlci51bmlmb3JtcyApLFxuICAgIFx0XHRcdFx0XHR2ZXJ0ZXhTaGFkZXI6IHNoYWRlci52ZXJ0ZXhTaGFkZXIsXG4gICAgXHRcdFx0XHRcdGZyYWdtZW50U2hhZGVyOiBzaGFkZXIuZnJhZ21lbnRTaGFkZXJcbiAgICBcdFx0XHRcdH07XG5cbiAgICBcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHRtYXRlcmlhbFByb3BlcnRpZXMuX193ZWJnbFNoYWRlciA9IHtcbiAgICBcdFx0XHRcdFx0bmFtZTogbWF0ZXJpYWwudHlwZSxcbiAgICBcdFx0XHRcdFx0dW5pZm9ybXM6IG1hdGVyaWFsLnVuaWZvcm1zLFxuICAgIFx0XHRcdFx0XHR2ZXJ0ZXhTaGFkZXI6IG1hdGVyaWFsLnZlcnRleFNoYWRlcixcbiAgICBcdFx0XHRcdFx0ZnJhZ21lbnRTaGFkZXI6IG1hdGVyaWFsLmZyYWdtZW50U2hhZGVyXG4gICAgXHRcdFx0XHR9O1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0bWF0ZXJpYWwuX193ZWJnbFNoYWRlciA9IG1hdGVyaWFsUHJvcGVydGllcy5fX3dlYmdsU2hhZGVyO1xuXG4gICAgXHRcdFx0cHJvZ3JhbSA9IHByb2dyYW1DYWNoZS5hY3F1aXJlUHJvZ3JhbSggbWF0ZXJpYWwsIHBhcmFtZXRlcnMsIGNvZGUgKTtcblxuICAgIFx0XHRcdG1hdGVyaWFsUHJvcGVydGllcy5wcm9ncmFtID0gcHJvZ3JhbTtcbiAgICBcdFx0XHRtYXRlcmlhbC5wcm9ncmFtID0gcHJvZ3JhbTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0dmFyIGF0dHJpYnV0ZXMgPSBwcm9ncmFtLmdldEF0dHJpYnV0ZXMoKTtcblxuICAgIFx0XHRpZiAoIG1hdGVyaWFsLm1vcnBoVGFyZ2V0cyApIHtcblxuICAgIFx0XHRcdG1hdGVyaWFsLm51bVN1cHBvcnRlZE1vcnBoVGFyZ2V0cyA9IDA7XG5cbiAgICBcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBfdGhpcy5tYXhNb3JwaFRhcmdldHM7IGkgKysgKSB7XG5cbiAgICBcdFx0XHRcdGlmICggYXR0cmlidXRlc1sgJ21vcnBoVGFyZ2V0JyArIGkgXSA+PSAwICkge1xuXG4gICAgXHRcdFx0XHRcdG1hdGVyaWFsLm51bVN1cHBvcnRlZE1vcnBoVGFyZ2V0cyArKztcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHRpZiAoIG1hdGVyaWFsLm1vcnBoTm9ybWFscyApIHtcblxuICAgIFx0XHRcdG1hdGVyaWFsLm51bVN1cHBvcnRlZE1vcnBoTm9ybWFscyA9IDA7XG5cbiAgICBcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBfdGhpcy5tYXhNb3JwaE5vcm1hbHM7IGkgKysgKSB7XG5cbiAgICBcdFx0XHRcdGlmICggYXR0cmlidXRlc1sgJ21vcnBoTm9ybWFsJyArIGkgXSA+PSAwICkge1xuXG4gICAgXHRcdFx0XHRcdG1hdGVyaWFsLm51bVN1cHBvcnRlZE1vcnBoTm9ybWFscyArKztcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHR2YXIgdW5pZm9ybXMgPSBtYXRlcmlhbFByb3BlcnRpZXMuX193ZWJnbFNoYWRlci51bmlmb3JtcztcblxuICAgIFx0XHRpZiAoICEgbWF0ZXJpYWwuaXNTaGFkZXJNYXRlcmlhbCAmJlxuICAgIFx0XHQgICAgICEgbWF0ZXJpYWwuaXNSYXdTaGFkZXJNYXRlcmlhbCB8fFxuICAgIFx0XHQgICAgICAgbWF0ZXJpYWwuY2xpcHBpbmcgPT09IHRydWUgKSB7XG5cbiAgICBcdFx0XHRtYXRlcmlhbFByb3BlcnRpZXMubnVtQ2xpcHBpbmdQbGFuZXMgPSBfY2xpcHBpbmcubnVtUGxhbmVzO1xuICAgIFx0XHRcdHVuaWZvcm1zLmNsaXBwaW5nUGxhbmVzID0gX2NsaXBwaW5nLnVuaWZvcm07XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdG1hdGVyaWFsUHJvcGVydGllcy5mb2cgPSBmb2c7XG5cbiAgICBcdFx0Ly8gc3RvcmUgdGhlIGxpZ2h0IHNldHVwIGl0IHdhcyBjcmVhdGVkIGZvclxuXG4gICAgXHRcdG1hdGVyaWFsUHJvcGVydGllcy5saWdodHNIYXNoID0gX2xpZ2h0cy5oYXNoO1xuXG4gICAgXHRcdGlmICggbWF0ZXJpYWwubGlnaHRzICkge1xuXG4gICAgXHRcdFx0Ly8gd2lyZSB1cCB0aGUgbWF0ZXJpYWwgdG8gdGhpcyByZW5kZXJlcidzIGxpZ2h0aW5nIHN0YXRlXG5cbiAgICBcdFx0XHR1bmlmb3Jtcy5hbWJpZW50TGlnaHRDb2xvci52YWx1ZSA9IF9saWdodHMuYW1iaWVudDtcbiAgICBcdFx0XHR1bmlmb3Jtcy5kaXJlY3Rpb25hbExpZ2h0cy52YWx1ZSA9IF9saWdodHMuZGlyZWN0aW9uYWw7XG4gICAgXHRcdFx0dW5pZm9ybXMuc3BvdExpZ2h0cy52YWx1ZSA9IF9saWdodHMuc3BvdDtcbiAgICBcdFx0XHR1bmlmb3Jtcy5wb2ludExpZ2h0cy52YWx1ZSA9IF9saWdodHMucG9pbnQ7XG4gICAgXHRcdFx0dW5pZm9ybXMuaGVtaXNwaGVyZUxpZ2h0cy52YWx1ZSA9IF9saWdodHMuaGVtaTtcblxuICAgIFx0XHRcdHVuaWZvcm1zLmRpcmVjdGlvbmFsU2hhZG93TWFwLnZhbHVlID0gX2xpZ2h0cy5kaXJlY3Rpb25hbFNoYWRvd01hcDtcbiAgICBcdFx0XHR1bmlmb3Jtcy5kaXJlY3Rpb25hbFNoYWRvd01hdHJpeC52YWx1ZSA9IF9saWdodHMuZGlyZWN0aW9uYWxTaGFkb3dNYXRyaXg7XG4gICAgXHRcdFx0dW5pZm9ybXMuc3BvdFNoYWRvd01hcC52YWx1ZSA9IF9saWdodHMuc3BvdFNoYWRvd01hcDtcbiAgICBcdFx0XHR1bmlmb3Jtcy5zcG90U2hhZG93TWF0cml4LnZhbHVlID0gX2xpZ2h0cy5zcG90U2hhZG93TWF0cml4O1xuICAgIFx0XHRcdHVuaWZvcm1zLnBvaW50U2hhZG93TWFwLnZhbHVlID0gX2xpZ2h0cy5wb2ludFNoYWRvd01hcDtcbiAgICBcdFx0XHR1bmlmb3Jtcy5wb2ludFNoYWRvd01hdHJpeC52YWx1ZSA9IF9saWdodHMucG9pbnRTaGFkb3dNYXRyaXg7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHZhciBwcm9nVW5pZm9ybXMgPSBtYXRlcmlhbFByb3BlcnRpZXMucHJvZ3JhbS5nZXRVbmlmb3JtcygpLFxuICAgIFx0XHRcdHVuaWZvcm1zTGlzdCA9XG4gICAgXHRcdFx0XHRcdFdlYkdMVW5pZm9ybXMuc2VxV2l0aFZhbHVlKCBwcm9nVW5pZm9ybXMuc2VxLCB1bmlmb3JtcyApO1xuXG4gICAgXHRcdG1hdGVyaWFsUHJvcGVydGllcy51bmlmb3Jtc0xpc3QgPSB1bmlmb3Jtc0xpc3Q7XG4gICAgXHRcdG1hdGVyaWFsUHJvcGVydGllcy5keW5hbWljVW5pZm9ybXMgPVxuICAgIFx0XHRcdFx0V2ViR0xVbmlmb3Jtcy5zcGxpdER5bmFtaWMoIHVuaWZvcm1zTGlzdCwgdW5pZm9ybXMgKTtcblxuICAgIFx0fVxuXG4gICAgXHRmdW5jdGlvbiBzZXRNYXRlcmlhbCggbWF0ZXJpYWwgKSB7XG5cbiAgICBcdFx0bWF0ZXJpYWwuc2lkZSA9PT0gRG91YmxlU2lkZVxuICAgIFx0XHRcdD8gc3RhdGUuZGlzYWJsZSggX2dsLkNVTExfRkFDRSApXG4gICAgXHRcdFx0OiBzdGF0ZS5lbmFibGUoIF9nbC5DVUxMX0ZBQ0UgKTtcblxuICAgIFx0XHRzdGF0ZS5zZXRGbGlwU2lkZWQoIG1hdGVyaWFsLnNpZGUgPT09IEJhY2tTaWRlICk7XG5cbiAgICBcdFx0bWF0ZXJpYWwudHJhbnNwYXJlbnQgPT09IHRydWVcbiAgICBcdFx0XHQ/IHN0YXRlLnNldEJsZW5kaW5nKCBtYXRlcmlhbC5ibGVuZGluZywgbWF0ZXJpYWwuYmxlbmRFcXVhdGlvbiwgbWF0ZXJpYWwuYmxlbmRTcmMsIG1hdGVyaWFsLmJsZW5kRHN0LCBtYXRlcmlhbC5ibGVuZEVxdWF0aW9uQWxwaGEsIG1hdGVyaWFsLmJsZW5kU3JjQWxwaGEsIG1hdGVyaWFsLmJsZW5kRHN0QWxwaGEsIG1hdGVyaWFsLnByZW11bHRpcGxpZWRBbHBoYSApXG4gICAgXHRcdFx0OiBzdGF0ZS5zZXRCbGVuZGluZyggTm9CbGVuZGluZyApO1xuXG4gICAgXHRcdHN0YXRlLnNldERlcHRoRnVuYyggbWF0ZXJpYWwuZGVwdGhGdW5jICk7XG4gICAgXHRcdHN0YXRlLnNldERlcHRoVGVzdCggbWF0ZXJpYWwuZGVwdGhUZXN0ICk7XG4gICAgXHRcdHN0YXRlLnNldERlcHRoV3JpdGUoIG1hdGVyaWFsLmRlcHRoV3JpdGUgKTtcbiAgICBcdFx0c3RhdGUuc2V0Q29sb3JXcml0ZSggbWF0ZXJpYWwuY29sb3JXcml0ZSApO1xuICAgIFx0XHRzdGF0ZS5zZXRQb2x5Z29uT2Zmc2V0KCBtYXRlcmlhbC5wb2x5Z29uT2Zmc2V0LCBtYXRlcmlhbC5wb2x5Z29uT2Zmc2V0RmFjdG9yLCBtYXRlcmlhbC5wb2x5Z29uT2Zmc2V0VW5pdHMgKTtcblxuICAgIFx0fVxuXG4gICAgXHRmdW5jdGlvbiBzZXRQcm9ncmFtKCBjYW1lcmEsIGZvZywgbWF0ZXJpYWwsIG9iamVjdCApIHtcblxuICAgIFx0XHRfdXNlZFRleHR1cmVVbml0cyA9IDA7XG5cbiAgICBcdFx0dmFyIG1hdGVyaWFsUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCBtYXRlcmlhbCApO1xuXG4gICAgXHRcdGlmICggX2NsaXBwaW5nRW5hYmxlZCApIHtcblxuICAgIFx0XHRcdGlmICggX2xvY2FsQ2xpcHBpbmdFbmFibGVkIHx8IGNhbWVyYSAhPT0gX2N1cnJlbnRDYW1lcmEgKSB7XG5cbiAgICBcdFx0XHRcdHZhciB1c2VDYWNoZSA9XG4gICAgXHRcdFx0XHRcdFx0Y2FtZXJhID09PSBfY3VycmVudENhbWVyYSAmJlxuICAgIFx0XHRcdFx0XHRcdG1hdGVyaWFsLmlkID09PSBfY3VycmVudE1hdGVyaWFsSWQ7XG5cbiAgICBcdFx0XHRcdC8vIHdlIG1pZ2h0IHdhbnQgdG8gY2FsbCB0aGlzIGZ1bmN0aW9uIHdpdGggc29tZSBDbGlwcGluZ0dyb3VwXG4gICAgXHRcdFx0XHQvLyBvYmplY3QgaW5zdGVhZCBvZiB0aGUgbWF0ZXJpYWwsIG9uY2UgaXQgYmVjb21lcyBmZWFzaWJsZVxuICAgIFx0XHRcdFx0Ly8gKCM4NDY1LCAjODM3OSlcbiAgICBcdFx0XHRcdF9jbGlwcGluZy5zZXRTdGF0ZShcbiAgICBcdFx0XHRcdFx0XHRtYXRlcmlhbC5jbGlwcGluZ1BsYW5lcywgbWF0ZXJpYWwuY2xpcFNoYWRvd3MsXG4gICAgXHRcdFx0XHRcdFx0Y2FtZXJhLCBtYXRlcmlhbFByb3BlcnRpZXMsIHVzZUNhY2hlICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGlmICggbWF0ZXJpYWwubmVlZHNVcGRhdGUgPT09IGZhbHNlICkge1xuXG4gICAgXHRcdFx0aWYgKCBtYXRlcmlhbFByb3BlcnRpZXMucHJvZ3JhbSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0XHRtYXRlcmlhbC5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICBcdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5mb2cgJiYgbWF0ZXJpYWxQcm9wZXJ0aWVzLmZvZyAhPT0gZm9nICkge1xuXG4gICAgXHRcdFx0XHRtYXRlcmlhbC5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICBcdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5saWdodHMgJiYgbWF0ZXJpYWxQcm9wZXJ0aWVzLmxpZ2h0c0hhc2ggIT09IF9saWdodHMuaGFzaCApIHtcblxuICAgIFx0XHRcdFx0bWF0ZXJpYWwubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgXHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWxQcm9wZXJ0aWVzLm51bUNsaXBwaW5nUGxhbmVzICE9PSB1bmRlZmluZWQgJiZcbiAgICBcdFx0XHRcdG1hdGVyaWFsUHJvcGVydGllcy5udW1DbGlwcGluZ1BsYW5lcyAhPT0gX2NsaXBwaW5nLm51bVBsYW5lcyApIHtcblxuICAgIFx0XHRcdFx0bWF0ZXJpYWwubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHRpZiAoIG1hdGVyaWFsLm5lZWRzVXBkYXRlICkge1xuXG4gICAgXHRcdFx0aW5pdE1hdGVyaWFsKCBtYXRlcmlhbCwgZm9nLCBvYmplY3QgKTtcbiAgICBcdFx0XHRtYXRlcmlhbC5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHR2YXIgcmVmcmVzaFByb2dyYW0gPSBmYWxzZTtcbiAgICBcdFx0dmFyIHJlZnJlc2hNYXRlcmlhbCA9IGZhbHNlO1xuICAgIFx0XHR2YXIgcmVmcmVzaExpZ2h0cyA9IGZhbHNlO1xuXG4gICAgXHRcdHZhciBwcm9ncmFtID0gbWF0ZXJpYWxQcm9wZXJ0aWVzLnByb2dyYW0sXG4gICAgXHRcdFx0cF91bmlmb3JtcyA9IHByb2dyYW0uZ2V0VW5pZm9ybXMoKSxcbiAgICBcdFx0XHRtX3VuaWZvcm1zID0gbWF0ZXJpYWxQcm9wZXJ0aWVzLl9fd2ViZ2xTaGFkZXIudW5pZm9ybXM7XG5cbiAgICBcdFx0aWYgKCBwcm9ncmFtLmlkICE9PSBfY3VycmVudFByb2dyYW0gKSB7XG5cbiAgICBcdFx0XHRfZ2wudXNlUHJvZ3JhbSggcHJvZ3JhbS5wcm9ncmFtICk7XG4gICAgXHRcdFx0X2N1cnJlbnRQcm9ncmFtID0gcHJvZ3JhbS5pZDtcblxuICAgIFx0XHRcdHJlZnJlc2hQcm9ncmFtID0gdHJ1ZTtcbiAgICBcdFx0XHRyZWZyZXNoTWF0ZXJpYWwgPSB0cnVlO1xuICAgIFx0XHRcdHJlZnJlc2hMaWdodHMgPSB0cnVlO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRpZiAoIG1hdGVyaWFsLmlkICE9PSBfY3VycmVudE1hdGVyaWFsSWQgKSB7XG5cbiAgICBcdFx0XHRfY3VycmVudE1hdGVyaWFsSWQgPSBtYXRlcmlhbC5pZDtcblxuICAgIFx0XHRcdHJlZnJlc2hNYXRlcmlhbCA9IHRydWU7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGlmICggcmVmcmVzaFByb2dyYW0gfHwgY2FtZXJhICE9PSBfY3VycmVudENhbWVyYSApIHtcblxuICAgIFx0XHRcdHBfdW5pZm9ybXMuc2V0KCBfZ2wsIGNhbWVyYSwgJ3Byb2plY3Rpb25NYXRyaXgnICk7XG5cbiAgICBcdFx0XHRpZiAoIGNhcGFiaWxpdGllcy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyICkge1xuXG4gICAgXHRcdFx0XHRwX3VuaWZvcm1zLnNldFZhbHVlKCBfZ2wsICdsb2dEZXB0aEJ1ZkZDJyxcbiAgICBcdFx0XHRcdFx0XHQyLjAgLyAoIE1hdGgubG9nKCBjYW1lcmEuZmFyICsgMS4wICkgLyBNYXRoLkxOMiApICk7XG5cbiAgICBcdFx0XHR9XG5cblxuICAgIFx0XHRcdGlmICggY2FtZXJhICE9PSBfY3VycmVudENhbWVyYSApIHtcblxuICAgIFx0XHRcdFx0X2N1cnJlbnRDYW1lcmEgPSBjYW1lcmE7XG5cbiAgICBcdFx0XHRcdC8vIGxpZ2h0aW5nIHVuaWZvcm1zIGRlcGVuZCBvbiB0aGUgY2FtZXJhIHNvIGVuZm9yY2UgYW4gdXBkYXRlXG4gICAgXHRcdFx0XHQvLyBub3csIGluIGNhc2UgdGhpcyBtYXRlcmlhbCBzdXBwb3J0cyBsaWdodHMgLSBvciBsYXRlciwgd2hlblxuICAgIFx0XHRcdFx0Ly8gdGhlIG5leHQgbWF0ZXJpYWwgdGhhdCBkb2VzIGdldHMgYWN0aXZhdGVkOlxuXG4gICAgXHRcdFx0XHRyZWZyZXNoTWF0ZXJpYWwgPSB0cnVlO1x0XHQvLyBzZXQgdG8gdHJ1ZSBvbiBtYXRlcmlhbCBjaGFuZ2VcbiAgICBcdFx0XHRcdHJlZnJlc2hMaWdodHMgPSB0cnVlO1x0XHQvLyByZW1haW5zIHNldCB1bnRpbCB1cGRhdGUgZG9uZVxuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0Ly8gbG9hZCBtYXRlcmlhbCBzcGVjaWZpYyB1bmlmb3Jtc1xuICAgIFx0XHRcdC8vIChzaGFkZXIgbWF0ZXJpYWwgYWxzbyBnZXRzIHRoZW0gZm9yIHRoZSBzYWtlIG9mIGdlbmVyaWNpdHkpXG5cbiAgICBcdFx0XHRpZiAoIG1hdGVyaWFsLmlzU2hhZGVyTWF0ZXJpYWwgfHxcbiAgICBcdFx0XHQgICAgIG1hdGVyaWFsLmlzTWVzaFBob25nTWF0ZXJpYWwgfHxcbiAgICBcdFx0XHQgICAgIG1hdGVyaWFsLmlzTWVzaFN0YW5kYXJkTWF0ZXJpYWwgfHxcbiAgICBcdFx0XHQgICAgIG1hdGVyaWFsLmVudk1hcCApIHtcblxuICAgIFx0XHRcdFx0dmFyIHVDYW1Qb3MgPSBwX3VuaWZvcm1zLm1hcC5jYW1lcmFQb3NpdGlvbjtcblxuICAgIFx0XHRcdFx0aWYgKCB1Q2FtUG9zICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRcdFx0dUNhbVBvcy5zZXRWYWx1ZSggX2dsLFxuICAgIFx0XHRcdFx0XHRcdFx0X3ZlY3RvcjMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBjYW1lcmEubWF0cml4V29ybGQgKSApO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRpZiAoIG1hdGVyaWFsLmlzTWVzaFBob25nTWF0ZXJpYWwgfHxcbiAgICBcdFx0XHQgICAgIG1hdGVyaWFsLmlzTWVzaExhbWJlcnRNYXRlcmlhbCB8fFxuICAgIFx0XHRcdCAgICAgbWF0ZXJpYWwuaXNNZXNoQmFzaWNNYXRlcmlhbCB8fFxuICAgIFx0XHRcdCAgICAgbWF0ZXJpYWwuaXNNZXNoU3RhbmRhcmRNYXRlcmlhbCB8fFxuICAgIFx0XHRcdCAgICAgbWF0ZXJpYWwuaXNTaGFkZXJNYXRlcmlhbCB8fFxuICAgIFx0XHRcdCAgICAgbWF0ZXJpYWwuc2tpbm5pbmcgKSB7XG5cbiAgICBcdFx0XHRcdHBfdW5pZm9ybXMuc2V0VmFsdWUoIF9nbCwgJ3ZpZXdNYXRyaXgnLCBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRwX3VuaWZvcm1zLnNldCggX2dsLCBfdGhpcywgJ3RvbmVNYXBwaW5nRXhwb3N1cmUnICk7XG4gICAgXHRcdFx0cF91bmlmb3Jtcy5zZXQoIF9nbCwgX3RoaXMsICd0b25lTWFwcGluZ1doaXRlUG9pbnQnICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdC8vIHNraW5uaW5nIHVuaWZvcm1zIG11c3QgYmUgc2V0IGV2ZW4gaWYgbWF0ZXJpYWwgZGlkbid0IGNoYW5nZVxuICAgIFx0XHQvLyBhdXRvLXNldHRpbmcgb2YgdGV4dHVyZSB1bml0IGZvciBib25lIHRleHR1cmUgbXVzdCBnbyBiZWZvcmUgb3RoZXIgdGV4dHVyZXNcbiAgICBcdFx0Ly8gbm90IHN1cmUgd2h5LCBidXQgb3RoZXJ3aXNlIHdlaXJkIHRoaW5ncyBoYXBwZW5cblxuICAgIFx0XHRpZiAoIG1hdGVyaWFsLnNraW5uaW5nICkge1xuXG4gICAgXHRcdFx0cF91bmlmb3Jtcy5zZXRPcHRpb25hbCggX2dsLCBvYmplY3QsICdiaW5kTWF0cml4JyApO1xuICAgIFx0XHRcdHBfdW5pZm9ybXMuc2V0T3B0aW9uYWwoIF9nbCwgb2JqZWN0LCAnYmluZE1hdHJpeEludmVyc2UnICk7XG5cbiAgICBcdFx0XHR2YXIgc2tlbGV0b24gPSBvYmplY3Quc2tlbGV0b247XG5cbiAgICBcdFx0XHRpZiAoIHNrZWxldG9uICkge1xuXG4gICAgXHRcdFx0XHRpZiAoIGNhcGFiaWxpdGllcy5mbG9hdFZlcnRleFRleHR1cmVzICYmIHNrZWxldG9uLnVzZVZlcnRleFRleHR1cmUgKSB7XG5cbiAgICBcdFx0XHRcdFx0cF91bmlmb3Jtcy5zZXQoIF9nbCwgc2tlbGV0b24sICdib25lVGV4dHVyZScgKTtcbiAgICBcdFx0XHRcdFx0cF91bmlmb3Jtcy5zZXQoIF9nbCwgc2tlbGV0b24sICdib25lVGV4dHVyZVdpZHRoJyApO1xuICAgIFx0XHRcdFx0XHRwX3VuaWZvcm1zLnNldCggX2dsLCBza2VsZXRvbiwgJ2JvbmVUZXh0dXJlSGVpZ2h0JyApO1xuXG4gICAgXHRcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHRcdHBfdW5pZm9ybXMuc2V0T3B0aW9uYWwoIF9nbCwgc2tlbGV0b24sICdib25lTWF0cmljZXMnICk7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdFx0aWYgKCByZWZyZXNoTWF0ZXJpYWwgKSB7XG5cbiAgICBcdFx0XHRpZiAoIG1hdGVyaWFsLmxpZ2h0cyApIHtcblxuICAgIFx0XHRcdFx0Ly8gdGhlIGN1cnJlbnQgbWF0ZXJpYWwgcmVxdWlyZXMgbGlnaHRpbmcgaW5mb1xuXG4gICAgXHRcdFx0XHQvLyBub3RlOiBhbGwgbGlnaHRpbmcgdW5pZm9ybXMgYXJlIGFsd2F5cyBzZXQgY29ycmVjdGx5XG4gICAgXHRcdFx0XHQvLyB0aGV5IHNpbXBseSByZWZlcmVuY2UgdGhlIHJlbmRlcmVyJ3Mgc3RhdGUgZm9yIHRoZWlyXG4gICAgXHRcdFx0XHQvLyB2YWx1ZXNcbiAgICBcdFx0XHRcdC8vXG4gICAgXHRcdFx0XHQvLyB1c2UgdGhlIGN1cnJlbnQgbWF0ZXJpYWwncyAubmVlZHNVcGRhdGUgZmxhZ3MgdG8gc2V0XG4gICAgXHRcdFx0XHQvLyB0aGUgR0wgc3RhdGUgd2hlbiByZXF1aXJlZFxuXG4gICAgXHRcdFx0XHRtYXJrVW5pZm9ybXNMaWdodHNOZWVkc1VwZGF0ZSggbV91bmlmb3JtcywgcmVmcmVzaExpZ2h0cyApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0Ly8gcmVmcmVzaCB1bmlmb3JtcyBjb21tb24gdG8gc2V2ZXJhbCBtYXRlcmlhbHNcblxuICAgIFx0XHRcdGlmICggZm9nICYmIG1hdGVyaWFsLmZvZyApIHtcblxuICAgIFx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zRm9nKCBtX3VuaWZvcm1zLCBmb2cgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdGlmICggbWF0ZXJpYWwuaXNNZXNoQmFzaWNNYXRlcmlhbCB8fFxuICAgIFx0XHRcdCAgICAgbWF0ZXJpYWwuaXNNZXNoTGFtYmVydE1hdGVyaWFsIHx8XG4gICAgXHRcdFx0ICAgICBtYXRlcmlhbC5pc01lc2hQaG9uZ01hdGVyaWFsIHx8XG4gICAgXHRcdFx0ICAgICBtYXRlcmlhbC5pc01lc2hTdGFuZGFyZE1hdGVyaWFsIHx8XG4gICAgXHRcdFx0ICAgICBtYXRlcmlhbC5pc01lc2hEZXB0aE1hdGVyaWFsICkge1xuXG4gICAgXHRcdFx0XHRyZWZyZXNoVW5pZm9ybXNDb21tb24oIG1fdW5pZm9ybXMsIG1hdGVyaWFsICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHQvLyByZWZyZXNoIHNpbmdsZSBtYXRlcmlhbCBzcGVjaWZpYyB1bmlmb3Jtc1xuXG4gICAgXHRcdFx0aWYgKCBtYXRlcmlhbC5pc0xpbmVCYXNpY01hdGVyaWFsICkge1xuXG4gICAgXHRcdFx0XHRyZWZyZXNoVW5pZm9ybXNMaW5lKCBtX3VuaWZvcm1zLCBtYXRlcmlhbCApO1xuXG4gICAgXHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuaXNMaW5lRGFzaGVkTWF0ZXJpYWwgKSB7XG5cbiAgICBcdFx0XHRcdHJlZnJlc2hVbmlmb3Jtc0xpbmUoIG1fdW5pZm9ybXMsIG1hdGVyaWFsICk7XG4gICAgXHRcdFx0XHRyZWZyZXNoVW5pZm9ybXNEYXNoKCBtX3VuaWZvcm1zLCBtYXRlcmlhbCApO1xuXG4gICAgXHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuaXNQb2ludHNNYXRlcmlhbCApIHtcblxuICAgIFx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zUG9pbnRzKCBtX3VuaWZvcm1zLCBtYXRlcmlhbCApO1xuXG4gICAgXHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuaXNNZXNoTGFtYmVydE1hdGVyaWFsICkge1xuXG4gICAgXHRcdFx0XHRyZWZyZXNoVW5pZm9ybXNMYW1iZXJ0KCBtX3VuaWZvcm1zLCBtYXRlcmlhbCApO1xuXG4gICAgXHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuaXNNZXNoUGhvbmdNYXRlcmlhbCApIHtcblxuICAgIFx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zUGhvbmcoIG1fdW5pZm9ybXMsIG1hdGVyaWFsICk7XG5cbiAgICBcdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5pc01lc2hQaHlzaWNhbE1hdGVyaWFsICkge1xuXG4gICAgXHRcdFx0XHRyZWZyZXNoVW5pZm9ybXNQaHlzaWNhbCggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcblxuICAgIFx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLmlzTWVzaFN0YW5kYXJkTWF0ZXJpYWwgKSB7XG5cbiAgICBcdFx0XHRcdHJlZnJlc2hVbmlmb3Jtc1N0YW5kYXJkKCBtX3VuaWZvcm1zLCBtYXRlcmlhbCApO1xuXG4gICAgXHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuaXNNZXNoRGVwdGhNYXRlcmlhbCApIHtcblxuICAgIFx0XHRcdFx0aWYgKCBtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXAgKSB7XG5cbiAgICBcdFx0XHRcdFx0bV91bmlmb3Jtcy5kaXNwbGFjZW1lbnRNYXAudmFsdWUgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXA7XG4gICAgXHRcdFx0XHRcdG1fdW5pZm9ybXMuZGlzcGxhY2VtZW50U2NhbGUudmFsdWUgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRTY2FsZTtcbiAgICBcdFx0XHRcdFx0bV91bmlmb3Jtcy5kaXNwbGFjZW1lbnRCaWFzLnZhbHVlID0gbWF0ZXJpYWwuZGlzcGxhY2VtZW50QmlhcztcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuaXNNZXNoTm9ybWFsTWF0ZXJpYWwgKSB7XG5cbiAgICBcdFx0XHRcdG1fdW5pZm9ybXMub3BhY2l0eS52YWx1ZSA9IG1hdGVyaWFsLm9wYWNpdHk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRXZWJHTFVuaWZvcm1zLnVwbG9hZChcbiAgICBcdFx0XHRcdFx0X2dsLCBtYXRlcmlhbFByb3BlcnRpZXMudW5pZm9ybXNMaXN0LCBtX3VuaWZvcm1zLCBfdGhpcyApO1xuXG4gICAgXHRcdH1cblxuXG4gICAgXHRcdC8vIGNvbW1vbiBtYXRyaWNlc1xuXG4gICAgXHRcdHBfdW5pZm9ybXMuc2V0KCBfZ2wsIG9iamVjdCwgJ21vZGVsVmlld01hdHJpeCcgKTtcbiAgICBcdFx0cF91bmlmb3Jtcy5zZXQoIF9nbCwgb2JqZWN0LCAnbm9ybWFsTWF0cml4JyApO1xuICAgIFx0XHRwX3VuaWZvcm1zLnNldFZhbHVlKCBfZ2wsICdtb2RlbE1hdHJpeCcsIG9iamVjdC5tYXRyaXhXb3JsZCApO1xuXG5cbiAgICBcdFx0Ly8gZHluYW1pYyB1bmlmb3Jtc1xuXG4gICAgXHRcdHZhciBkeW5Vbmlmb3JtcyA9IG1hdGVyaWFsUHJvcGVydGllcy5keW5hbWljVW5pZm9ybXM7XG5cbiAgICBcdFx0aWYgKCBkeW5Vbmlmb3JtcyAhPT0gbnVsbCApIHtcblxuICAgIFx0XHRcdFdlYkdMVW5pZm9ybXMuZXZhbER5bmFtaWMoIGR5blVuaWZvcm1zLCBtX3VuaWZvcm1zLCBvYmplY3QsIG1hdGVyaWFsLCBjYW1lcmEgKTtcbiAgICBcdFx0XHRXZWJHTFVuaWZvcm1zLnVwbG9hZCggX2dsLCBkeW5Vbmlmb3JtcywgbV91bmlmb3JtcywgX3RoaXMgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIHByb2dyYW07XG5cbiAgICBcdH1cblxuICAgIFx0Ly8gVW5pZm9ybXMgKHJlZnJlc2ggdW5pZm9ybXMgb2JqZWN0cylcblxuICAgIFx0ZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zQ29tbW9uKCB1bmlmb3JtcywgbWF0ZXJpYWwgKSB7XG5cbiAgICBcdFx0dW5pZm9ybXMub3BhY2l0eS52YWx1ZSA9IG1hdGVyaWFsLm9wYWNpdHk7XG5cbiAgICBcdFx0dW5pZm9ybXMuZGlmZnVzZS52YWx1ZSA9IG1hdGVyaWFsLmNvbG9yO1xuXG4gICAgXHRcdGlmICggbWF0ZXJpYWwuZW1pc3NpdmUgKSB7XG5cbiAgICBcdFx0XHR1bmlmb3Jtcy5lbWlzc2l2ZS52YWx1ZS5jb3B5KCBtYXRlcmlhbC5lbWlzc2l2ZSApLm11bHRpcGx5U2NhbGFyKCBtYXRlcmlhbC5lbWlzc2l2ZUludGVuc2l0eSApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHR1bmlmb3Jtcy5tYXAudmFsdWUgPSBtYXRlcmlhbC5tYXA7XG4gICAgXHRcdHVuaWZvcm1zLnNwZWN1bGFyTWFwLnZhbHVlID0gbWF0ZXJpYWwuc3BlY3VsYXJNYXA7XG4gICAgXHRcdHVuaWZvcm1zLmFscGhhTWFwLnZhbHVlID0gbWF0ZXJpYWwuYWxwaGFNYXA7XG5cbiAgICBcdFx0aWYgKCBtYXRlcmlhbC5hb01hcCApIHtcblxuICAgIFx0XHRcdHVuaWZvcm1zLmFvTWFwLnZhbHVlID0gbWF0ZXJpYWwuYW9NYXA7XG4gICAgXHRcdFx0dW5pZm9ybXMuYW9NYXBJbnRlbnNpdHkudmFsdWUgPSBtYXRlcmlhbC5hb01hcEludGVuc2l0eTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0Ly8gdXYgcmVwZWF0IGFuZCBvZmZzZXQgc2V0dGluZyBwcmlvcml0aWVzXG4gICAgXHRcdC8vIDEuIGNvbG9yIG1hcFxuICAgIFx0XHQvLyAyLiBzcGVjdWxhciBtYXBcbiAgICBcdFx0Ly8gMy4gbm9ybWFsIG1hcFxuICAgIFx0XHQvLyA0LiBidW1wIG1hcFxuICAgIFx0XHQvLyA1LiBhbHBoYSBtYXBcbiAgICBcdFx0Ly8gNi4gZW1pc3NpdmUgbWFwXG5cbiAgICBcdFx0dmFyIHV2U2NhbGVNYXA7XG5cbiAgICBcdFx0aWYgKCBtYXRlcmlhbC5tYXAgKSB7XG5cbiAgICBcdFx0XHR1dlNjYWxlTWFwID0gbWF0ZXJpYWwubWFwO1xuXG4gICAgXHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLnNwZWN1bGFyTWFwICkge1xuXG4gICAgXHRcdFx0dXZTY2FsZU1hcCA9IG1hdGVyaWFsLnNwZWN1bGFyTWFwO1xuXG4gICAgXHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcCApIHtcblxuICAgIFx0XHRcdHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXA7XG5cbiAgICBcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwubm9ybWFsTWFwICkge1xuXG4gICAgXHRcdFx0dXZTY2FsZU1hcCA9IG1hdGVyaWFsLm5vcm1hbE1hcDtcblxuICAgIFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5idW1wTWFwICkge1xuXG4gICAgXHRcdFx0dXZTY2FsZU1hcCA9IG1hdGVyaWFsLmJ1bXBNYXA7XG5cbiAgICBcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwucm91Z2huZXNzTWFwICkge1xuXG4gICAgXHRcdFx0dXZTY2FsZU1hcCA9IG1hdGVyaWFsLnJvdWdobmVzc01hcDtcblxuICAgIFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5tZXRhbG5lc3NNYXAgKSB7XG5cbiAgICBcdFx0XHR1dlNjYWxlTWFwID0gbWF0ZXJpYWwubWV0YWxuZXNzTWFwO1xuXG4gICAgXHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLmFscGhhTWFwICkge1xuXG4gICAgXHRcdFx0dXZTY2FsZU1hcCA9IG1hdGVyaWFsLmFscGhhTWFwO1xuXG4gICAgXHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLmVtaXNzaXZlTWFwICkge1xuXG4gICAgXHRcdFx0dXZTY2FsZU1hcCA9IG1hdGVyaWFsLmVtaXNzaXZlTWFwO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRpZiAoIHV2U2NhbGVNYXAgIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgXHRcdFx0aWYgKCB1dlNjYWxlTWFwLmlzV2ViR0xSZW5kZXJUYXJnZXQgKSB7XG5cbiAgICBcdFx0XHRcdHV2U2NhbGVNYXAgPSB1dlNjYWxlTWFwLnRleHR1cmU7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHR2YXIgb2Zmc2V0ID0gdXZTY2FsZU1hcC5vZmZzZXQ7XG4gICAgXHRcdFx0dmFyIHJlcGVhdCA9IHV2U2NhbGVNYXAucmVwZWF0O1xuXG4gICAgXHRcdFx0dW5pZm9ybXMub2Zmc2V0UmVwZWF0LnZhbHVlLnNldCggb2Zmc2V0LngsIG9mZnNldC55LCByZXBlYXQueCwgcmVwZWF0LnkgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0dW5pZm9ybXMuZW52TWFwLnZhbHVlID0gbWF0ZXJpYWwuZW52TWFwO1xuXG4gICAgXHRcdC8vIGRvbid0IGZsaXAgQ3ViZVRleHR1cmUgZW52TWFwcywgZmxpcCBldmVyeXRoaW5nIGVsc2U6XG4gICAgXHRcdC8vICBXZWJHTFJlbmRlclRhcmdldEN1YmUgd2lsbCBiZSBmbGlwcGVkIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgIFx0XHQvLyAgV2ViR0xSZW5kZXJUYXJnZXRDdWJlLnRleHR1cmUgd2lsbCBiZSBmbGlwcGVkIGJlY2F1c2UgaXQncyBhIFRleHR1cmUgYW5kIE5PVCBhIEN1YmVUZXh0dXJlXG4gICAgXHRcdC8vIHRoaXMgY2hlY2sgbXVzdCBiZSBoYW5kbGVkIGRpZmZlcmVudGx5LCBvciByZW1vdmVkIGVudGlyZWx5LCBpZiBXZWJHTFJlbmRlclRhcmdldEN1YmUgdXNlcyBhIEN1YmVUZXh0dXJlIGluIHRoZSBmdXR1cmVcbiAgICBcdFx0dW5pZm9ybXMuZmxpcEVudk1hcC52YWx1ZSA9ICggISAoIG1hdGVyaWFsLmVudk1hcCAmJiBtYXRlcmlhbC5lbnZNYXAuaXNDdWJlVGV4dHVyZSApICkgPyAxIDogLSAxO1xuXG4gICAgXHRcdHVuaWZvcm1zLnJlZmxlY3Rpdml0eS52YWx1ZSA9IG1hdGVyaWFsLnJlZmxlY3Rpdml0eTtcbiAgICBcdFx0dW5pZm9ybXMucmVmcmFjdGlvblJhdGlvLnZhbHVlID0gbWF0ZXJpYWwucmVmcmFjdGlvblJhdGlvO1xuXG4gICAgXHR9XG5cbiAgICBcdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc0xpbmUoIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcblxuICAgIFx0XHR1bmlmb3Jtcy5kaWZmdXNlLnZhbHVlID0gbWF0ZXJpYWwuY29sb3I7XG4gICAgXHRcdHVuaWZvcm1zLm9wYWNpdHkudmFsdWUgPSBtYXRlcmlhbC5vcGFjaXR5O1xuXG4gICAgXHR9XG5cbiAgICBcdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc0Rhc2goIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcblxuICAgIFx0XHR1bmlmb3Jtcy5kYXNoU2l6ZS52YWx1ZSA9IG1hdGVyaWFsLmRhc2hTaXplO1xuICAgIFx0XHR1bmlmb3Jtcy50b3RhbFNpemUudmFsdWUgPSBtYXRlcmlhbC5kYXNoU2l6ZSArIG1hdGVyaWFsLmdhcFNpemU7XG4gICAgXHRcdHVuaWZvcm1zLnNjYWxlLnZhbHVlID0gbWF0ZXJpYWwuc2NhbGU7XG5cbiAgICBcdH1cblxuICAgIFx0ZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zUG9pbnRzKCB1bmlmb3JtcywgbWF0ZXJpYWwgKSB7XG5cbiAgICBcdFx0dW5pZm9ybXMuZGlmZnVzZS52YWx1ZSA9IG1hdGVyaWFsLmNvbG9yO1xuICAgIFx0XHR1bmlmb3Jtcy5vcGFjaXR5LnZhbHVlID0gbWF0ZXJpYWwub3BhY2l0eTtcbiAgICBcdFx0dW5pZm9ybXMuc2l6ZS52YWx1ZSA9IG1hdGVyaWFsLnNpemUgKiBfcGl4ZWxSYXRpbztcbiAgICBcdFx0dW5pZm9ybXMuc2NhbGUudmFsdWUgPSBfY2FudmFzLmNsaWVudEhlaWdodCAqIDAuNTtcblxuICAgIFx0XHR1bmlmb3Jtcy5tYXAudmFsdWUgPSBtYXRlcmlhbC5tYXA7XG5cbiAgICBcdFx0aWYgKCBtYXRlcmlhbC5tYXAgIT09IG51bGwgKSB7XG5cbiAgICBcdFx0XHR2YXIgb2Zmc2V0ID0gbWF0ZXJpYWwubWFwLm9mZnNldDtcbiAgICBcdFx0XHR2YXIgcmVwZWF0ID0gbWF0ZXJpYWwubWFwLnJlcGVhdDtcblxuICAgIFx0XHRcdHVuaWZvcm1zLm9mZnNldFJlcGVhdC52YWx1ZS5zZXQoIG9mZnNldC54LCBvZmZzZXQueSwgcmVwZWF0LngsIHJlcGVhdC55ICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9XG5cbiAgICBcdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc0ZvZyggdW5pZm9ybXMsIGZvZyApIHtcblxuICAgIFx0XHR1bmlmb3Jtcy5mb2dDb2xvci52YWx1ZSA9IGZvZy5jb2xvcjtcblxuICAgIFx0XHRpZiAoIGZvZy5pc0ZvZyApIHtcblxuICAgIFx0XHRcdHVuaWZvcm1zLmZvZ05lYXIudmFsdWUgPSBmb2cubmVhcjtcbiAgICBcdFx0XHR1bmlmb3Jtcy5mb2dGYXIudmFsdWUgPSBmb2cuZmFyO1xuXG4gICAgXHRcdH0gZWxzZSBpZiAoIGZvZy5pc0ZvZ0V4cDIgKSB7XG5cbiAgICBcdFx0XHR1bmlmb3Jtcy5mb2dEZW5zaXR5LnZhbHVlID0gZm9nLmRlbnNpdHk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9XG5cbiAgICBcdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc0xhbWJlcnQoIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcblxuICAgIFx0XHRpZiAoIG1hdGVyaWFsLmxpZ2h0TWFwICkge1xuXG4gICAgXHRcdFx0dW5pZm9ybXMubGlnaHRNYXAudmFsdWUgPSBtYXRlcmlhbC5saWdodE1hcDtcbiAgICBcdFx0XHR1bmlmb3Jtcy5saWdodE1hcEludGVuc2l0eS52YWx1ZSA9IG1hdGVyaWFsLmxpZ2h0TWFwSW50ZW5zaXR5O1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRpZiAoIG1hdGVyaWFsLmVtaXNzaXZlTWFwICkge1xuXG4gICAgXHRcdFx0dW5pZm9ybXMuZW1pc3NpdmVNYXAudmFsdWUgPSBtYXRlcmlhbC5lbWlzc2l2ZU1hcDtcblxuICAgIFx0XHR9XG5cbiAgICBcdH1cblxuICAgIFx0ZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zUGhvbmcoIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcblxuICAgIFx0XHR1bmlmb3Jtcy5zcGVjdWxhci52YWx1ZSA9IG1hdGVyaWFsLnNwZWN1bGFyO1xuICAgIFx0XHR1bmlmb3Jtcy5zaGluaW5lc3MudmFsdWUgPSBNYXRoLm1heCggbWF0ZXJpYWwuc2hpbmluZXNzLCAxZS00ICk7IC8vIHRvIHByZXZlbnQgcG93KCAwLjAsIDAuMCApXG5cbiAgICBcdFx0aWYgKCBtYXRlcmlhbC5saWdodE1hcCApIHtcblxuICAgIFx0XHRcdHVuaWZvcm1zLmxpZ2h0TWFwLnZhbHVlID0gbWF0ZXJpYWwubGlnaHRNYXA7XG4gICAgXHRcdFx0dW5pZm9ybXMubGlnaHRNYXBJbnRlbnNpdHkudmFsdWUgPSBtYXRlcmlhbC5saWdodE1hcEludGVuc2l0eTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0aWYgKCBtYXRlcmlhbC5lbWlzc2l2ZU1hcCApIHtcblxuICAgIFx0XHRcdHVuaWZvcm1zLmVtaXNzaXZlTWFwLnZhbHVlID0gbWF0ZXJpYWwuZW1pc3NpdmVNYXA7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGlmICggbWF0ZXJpYWwuYnVtcE1hcCApIHtcblxuICAgIFx0XHRcdHVuaWZvcm1zLmJ1bXBNYXAudmFsdWUgPSBtYXRlcmlhbC5idW1wTWFwO1xuICAgIFx0XHRcdHVuaWZvcm1zLmJ1bXBTY2FsZS52YWx1ZSA9IG1hdGVyaWFsLmJ1bXBTY2FsZTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0aWYgKCBtYXRlcmlhbC5ub3JtYWxNYXAgKSB7XG5cbiAgICBcdFx0XHR1bmlmb3Jtcy5ub3JtYWxNYXAudmFsdWUgPSBtYXRlcmlhbC5ub3JtYWxNYXA7XG4gICAgXHRcdFx0dW5pZm9ybXMubm9ybWFsU2NhbGUudmFsdWUuY29weSggbWF0ZXJpYWwubm9ybWFsU2NhbGUgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0aWYgKCBtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXAgKSB7XG5cbiAgICBcdFx0XHR1bmlmb3Jtcy5kaXNwbGFjZW1lbnRNYXAudmFsdWUgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXA7XG4gICAgXHRcdFx0dW5pZm9ybXMuZGlzcGxhY2VtZW50U2NhbGUudmFsdWUgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRTY2FsZTtcbiAgICBcdFx0XHR1bmlmb3Jtcy5kaXNwbGFjZW1lbnRCaWFzLnZhbHVlID0gbWF0ZXJpYWwuZGlzcGxhY2VtZW50QmlhcztcblxuICAgIFx0XHR9XG5cbiAgICBcdH1cblxuICAgIFx0ZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zU3RhbmRhcmQoIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcblxuICAgIFx0XHR1bmlmb3Jtcy5yb3VnaG5lc3MudmFsdWUgPSBtYXRlcmlhbC5yb3VnaG5lc3M7XG4gICAgXHRcdHVuaWZvcm1zLm1ldGFsbmVzcy52YWx1ZSA9IG1hdGVyaWFsLm1ldGFsbmVzcztcblxuICAgIFx0XHRpZiAoIG1hdGVyaWFsLnJvdWdobmVzc01hcCApIHtcblxuICAgIFx0XHRcdHVuaWZvcm1zLnJvdWdobmVzc01hcC52YWx1ZSA9IG1hdGVyaWFsLnJvdWdobmVzc01hcDtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0aWYgKCBtYXRlcmlhbC5tZXRhbG5lc3NNYXAgKSB7XG5cbiAgICBcdFx0XHR1bmlmb3Jtcy5tZXRhbG5lc3NNYXAudmFsdWUgPSBtYXRlcmlhbC5tZXRhbG5lc3NNYXA7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGlmICggbWF0ZXJpYWwubGlnaHRNYXAgKSB7XG5cbiAgICBcdFx0XHR1bmlmb3Jtcy5saWdodE1hcC52YWx1ZSA9IG1hdGVyaWFsLmxpZ2h0TWFwO1xuICAgIFx0XHRcdHVuaWZvcm1zLmxpZ2h0TWFwSW50ZW5zaXR5LnZhbHVlID0gbWF0ZXJpYWwubGlnaHRNYXBJbnRlbnNpdHk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGlmICggbWF0ZXJpYWwuZW1pc3NpdmVNYXAgKSB7XG5cbiAgICBcdFx0XHR1bmlmb3Jtcy5lbWlzc2l2ZU1hcC52YWx1ZSA9IG1hdGVyaWFsLmVtaXNzaXZlTWFwO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRpZiAoIG1hdGVyaWFsLmJ1bXBNYXAgKSB7XG5cbiAgICBcdFx0XHR1bmlmb3Jtcy5idW1wTWFwLnZhbHVlID0gbWF0ZXJpYWwuYnVtcE1hcDtcbiAgICBcdFx0XHR1bmlmb3Jtcy5idW1wU2NhbGUudmFsdWUgPSBtYXRlcmlhbC5idW1wU2NhbGU7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGlmICggbWF0ZXJpYWwubm9ybWFsTWFwICkge1xuXG4gICAgXHRcdFx0dW5pZm9ybXMubm9ybWFsTWFwLnZhbHVlID0gbWF0ZXJpYWwubm9ybWFsTWFwO1xuICAgIFx0XHRcdHVuaWZvcm1zLm5vcm1hbFNjYWxlLnZhbHVlLmNvcHkoIG1hdGVyaWFsLm5vcm1hbFNjYWxlICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGlmICggbWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwICkge1xuXG4gICAgXHRcdFx0dW5pZm9ybXMuZGlzcGxhY2VtZW50TWFwLnZhbHVlID0gbWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwO1xuICAgIFx0XHRcdHVuaWZvcm1zLmRpc3BsYWNlbWVudFNjYWxlLnZhbHVlID0gbWF0ZXJpYWwuZGlzcGxhY2VtZW50U2NhbGU7XG4gICAgXHRcdFx0dW5pZm9ybXMuZGlzcGxhY2VtZW50Qmlhcy52YWx1ZSA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudEJpYXM7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGlmICggbWF0ZXJpYWwuZW52TWFwICkge1xuXG4gICAgXHRcdFx0Ly91bmlmb3Jtcy5lbnZNYXAudmFsdWUgPSBtYXRlcmlhbC5lbnZNYXA7IC8vIHBhcnQgb2YgdW5pZm9ybXMgY29tbW9uXG4gICAgXHRcdFx0dW5pZm9ybXMuZW52TWFwSW50ZW5zaXR5LnZhbHVlID0gbWF0ZXJpYWwuZW52TWFwSW50ZW5zaXR5O1xuXG4gICAgXHRcdH1cblxuICAgIFx0fVxuXG4gICAgXHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNQaHlzaWNhbCggdW5pZm9ybXMsIG1hdGVyaWFsICkge1xuXG4gICAgXHRcdHVuaWZvcm1zLmNsZWFyQ29hdC52YWx1ZSA9IG1hdGVyaWFsLmNsZWFyQ29hdDtcbiAgICBcdFx0dW5pZm9ybXMuY2xlYXJDb2F0Um91Z2huZXNzLnZhbHVlID0gbWF0ZXJpYWwuY2xlYXJDb2F0Um91Z2huZXNzO1xuXG4gICAgXHRcdHJlZnJlc2hVbmlmb3Jtc1N0YW5kYXJkKCB1bmlmb3JtcywgbWF0ZXJpYWwgKTtcblxuICAgIFx0fVxuXG4gICAgXHQvLyBJZiB1bmlmb3JtcyBhcmUgbWFya2VkIGFzIGNsZWFuLCB0aGV5IGRvbid0IG5lZWQgdG8gYmUgbG9hZGVkIHRvIHRoZSBHUFUuXG5cbiAgICBcdGZ1bmN0aW9uIG1hcmtVbmlmb3Jtc0xpZ2h0c05lZWRzVXBkYXRlKCB1bmlmb3JtcywgdmFsdWUgKSB7XG5cbiAgICBcdFx0dW5pZm9ybXMuYW1iaWVudExpZ2h0Q29sb3IubmVlZHNVcGRhdGUgPSB2YWx1ZTtcblxuICAgIFx0XHR1bmlmb3Jtcy5kaXJlY3Rpb25hbExpZ2h0cy5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xuICAgIFx0XHR1bmlmb3Jtcy5wb2ludExpZ2h0cy5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xuICAgIFx0XHR1bmlmb3Jtcy5zcG90TGlnaHRzLm5lZWRzVXBkYXRlID0gdmFsdWU7XG4gICAgXHRcdHVuaWZvcm1zLmhlbWlzcGhlcmVMaWdodHMubmVlZHNVcGRhdGUgPSB2YWx1ZTtcblxuICAgIFx0fVxuXG4gICAgXHQvLyBMaWdodGluZ1xuXG4gICAgXHRmdW5jdGlvbiBzZXR1cFNoYWRvd3MoIGxpZ2h0cyApIHtcblxuICAgIFx0XHR2YXIgbGlnaHRTaGFkb3dzTGVuZ3RoID0gMDtcblxuICAgIFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBsaWdodHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgIFx0XHRcdHZhciBsaWdodCA9IGxpZ2h0c1sgaSBdO1xuXG4gICAgXHRcdFx0aWYgKCBsaWdodC5jYXN0U2hhZG93ICkge1xuXG4gICAgXHRcdFx0XHRfbGlnaHRzLnNoYWRvd3NbIGxpZ2h0U2hhZG93c0xlbmd0aCArKyBdID0gbGlnaHQ7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdF9saWdodHMuc2hhZG93cy5sZW5ndGggPSBsaWdodFNoYWRvd3NMZW5ndGg7XG5cbiAgICBcdH1cblxuICAgIFx0ZnVuY3Rpb24gc2V0dXBMaWdodHMoIGxpZ2h0cywgY2FtZXJhICkge1xuXG4gICAgXHRcdHZhciBsLCBsbCwgbGlnaHQsXG4gICAgXHRcdHIgPSAwLCBnID0gMCwgYiA9IDAsXG4gICAgXHRcdGNvbG9yLFxuICAgIFx0XHRpbnRlbnNpdHksXG4gICAgXHRcdGRpc3RhbmNlLFxuICAgIFx0XHRzaGFkb3dNYXAsXG5cbiAgICBcdFx0dmlld01hdHJpeCA9IGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UsXG5cbiAgICBcdFx0ZGlyZWN0aW9uYWxMZW5ndGggPSAwLFxuICAgIFx0XHRwb2ludExlbmd0aCA9IDAsXG4gICAgXHRcdHNwb3RMZW5ndGggPSAwLFxuICAgIFx0XHRoZW1pTGVuZ3RoID0gMDtcblxuICAgIFx0XHRmb3IgKCBsID0gMCwgbGwgPSBsaWdodHMubGVuZ3RoOyBsIDwgbGw7IGwgKysgKSB7XG5cbiAgICBcdFx0XHRsaWdodCA9IGxpZ2h0c1sgbCBdO1xuXG4gICAgXHRcdFx0Y29sb3IgPSBsaWdodC5jb2xvcjtcbiAgICBcdFx0XHRpbnRlbnNpdHkgPSBsaWdodC5pbnRlbnNpdHk7XG4gICAgXHRcdFx0ZGlzdGFuY2UgPSBsaWdodC5kaXN0YW5jZTtcblxuICAgIFx0XHRcdHNoYWRvd01hcCA9ICggbGlnaHQuc2hhZG93ICYmIGxpZ2h0LnNoYWRvdy5tYXAgKSA/IGxpZ2h0LnNoYWRvdy5tYXAudGV4dHVyZSA6IG51bGw7XG5cbiAgICBcdFx0XHRpZiAoIGxpZ2h0LmlzQW1iaWVudExpZ2h0ICkge1xuXG4gICAgXHRcdFx0XHRyICs9IGNvbG9yLnIgKiBpbnRlbnNpdHk7XG4gICAgXHRcdFx0XHRnICs9IGNvbG9yLmcgKiBpbnRlbnNpdHk7XG4gICAgXHRcdFx0XHRiICs9IGNvbG9yLmIgKiBpbnRlbnNpdHk7XG5cbiAgICBcdFx0XHR9IGVsc2UgaWYgKCBsaWdodC5pc0RpcmVjdGlvbmFsTGlnaHQgKSB7XG5cbiAgICBcdFx0XHRcdHZhciB1bmlmb3JtcyA9IGxpZ2h0Q2FjaGUuZ2V0KCBsaWdodCApO1xuXG4gICAgXHRcdFx0XHR1bmlmb3Jtcy5jb2xvci5jb3B5KCBsaWdodC5jb2xvciApLm11bHRpcGx5U2NhbGFyKCBsaWdodC5pbnRlbnNpdHkgKTtcbiAgICBcdFx0XHRcdHVuaWZvcm1zLmRpcmVjdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0Lm1hdHJpeFdvcmxkICk7XG4gICAgXHRcdFx0XHRfdmVjdG9yMy5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0LnRhcmdldC5tYXRyaXhXb3JsZCApO1xuICAgIFx0XHRcdFx0dW5pZm9ybXMuZGlyZWN0aW9uLnN1YiggX3ZlY3RvcjMgKTtcbiAgICBcdFx0XHRcdHVuaWZvcm1zLmRpcmVjdGlvbi50cmFuc2Zvcm1EaXJlY3Rpb24oIHZpZXdNYXRyaXggKTtcblxuICAgIFx0XHRcdFx0dW5pZm9ybXMuc2hhZG93ID0gbGlnaHQuY2FzdFNoYWRvdztcblxuICAgIFx0XHRcdFx0aWYgKCBsaWdodC5jYXN0U2hhZG93ICkge1xuXG4gICAgXHRcdFx0XHRcdHVuaWZvcm1zLnNoYWRvd0JpYXMgPSBsaWdodC5zaGFkb3cuYmlhcztcbiAgICBcdFx0XHRcdFx0dW5pZm9ybXMuc2hhZG93UmFkaXVzID0gbGlnaHQuc2hhZG93LnJhZGl1cztcbiAgICBcdFx0XHRcdFx0dW5pZm9ybXMuc2hhZG93TWFwU2l6ZSA9IGxpZ2h0LnNoYWRvdy5tYXBTaXplO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdF9saWdodHMuZGlyZWN0aW9uYWxTaGFkb3dNYXBbIGRpcmVjdGlvbmFsTGVuZ3RoIF0gPSBzaGFkb3dNYXA7XG4gICAgXHRcdFx0XHRfbGlnaHRzLmRpcmVjdGlvbmFsU2hhZG93TWF0cml4WyBkaXJlY3Rpb25hbExlbmd0aCBdID0gbGlnaHQuc2hhZG93Lm1hdHJpeDtcbiAgICBcdFx0XHRcdF9saWdodHMuZGlyZWN0aW9uYWxbIGRpcmVjdGlvbmFsTGVuZ3RoICsrIF0gPSB1bmlmb3JtcztcblxuICAgIFx0XHRcdH0gZWxzZSBpZiAoIGxpZ2h0LmlzU3BvdExpZ2h0ICkge1xuXG4gICAgXHRcdFx0XHR2YXIgdW5pZm9ybXMgPSBsaWdodENhY2hlLmdldCggbGlnaHQgKTtcblxuICAgIFx0XHRcdFx0dW5pZm9ybXMucG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC5tYXRyaXhXb3JsZCApO1xuICAgIFx0XHRcdFx0dW5pZm9ybXMucG9zaXRpb24uYXBwbHlNYXRyaXg0KCB2aWV3TWF0cml4ICk7XG5cbiAgICBcdFx0XHRcdHVuaWZvcm1zLmNvbG9yLmNvcHkoIGNvbG9yICkubXVsdGlwbHlTY2FsYXIoIGludGVuc2l0eSApO1xuICAgIFx0XHRcdFx0dW5pZm9ybXMuZGlzdGFuY2UgPSBkaXN0YW5jZTtcblxuICAgIFx0XHRcdFx0dW5pZm9ybXMuZGlyZWN0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQubWF0cml4V29ybGQgKTtcbiAgICBcdFx0XHRcdF92ZWN0b3IzLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQudGFyZ2V0Lm1hdHJpeFdvcmxkICk7XG4gICAgXHRcdFx0XHR1bmlmb3Jtcy5kaXJlY3Rpb24uc3ViKCBfdmVjdG9yMyApO1xuICAgIFx0XHRcdFx0dW5pZm9ybXMuZGlyZWN0aW9uLnRyYW5zZm9ybURpcmVjdGlvbiggdmlld01hdHJpeCApO1xuXG4gICAgXHRcdFx0XHR1bmlmb3Jtcy5jb25lQ29zID0gTWF0aC5jb3MoIGxpZ2h0LmFuZ2xlICk7XG4gICAgXHRcdFx0XHR1bmlmb3Jtcy5wZW51bWJyYUNvcyA9IE1hdGguY29zKCBsaWdodC5hbmdsZSAqICggMSAtIGxpZ2h0LnBlbnVtYnJhICkgKTtcbiAgICBcdFx0XHRcdHVuaWZvcm1zLmRlY2F5ID0gKCBsaWdodC5kaXN0YW5jZSA9PT0gMCApID8gMC4wIDogbGlnaHQuZGVjYXk7XG5cbiAgICBcdFx0XHRcdHVuaWZvcm1zLnNoYWRvdyA9IGxpZ2h0LmNhc3RTaGFkb3c7XG5cbiAgICBcdFx0XHRcdGlmICggbGlnaHQuY2FzdFNoYWRvdyApIHtcblxuICAgIFx0XHRcdFx0XHR1bmlmb3Jtcy5zaGFkb3dCaWFzID0gbGlnaHQuc2hhZG93LmJpYXM7XG4gICAgXHRcdFx0XHRcdHVuaWZvcm1zLnNoYWRvd1JhZGl1cyA9IGxpZ2h0LnNoYWRvdy5yYWRpdXM7XG4gICAgXHRcdFx0XHRcdHVuaWZvcm1zLnNoYWRvd01hcFNpemUgPSBsaWdodC5zaGFkb3cubWFwU2l6ZTtcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHRfbGlnaHRzLnNwb3RTaGFkb3dNYXBbIHNwb3RMZW5ndGggXSA9IHNoYWRvd01hcDtcbiAgICBcdFx0XHRcdF9saWdodHMuc3BvdFNoYWRvd01hdHJpeFsgc3BvdExlbmd0aCBdID0gbGlnaHQuc2hhZG93Lm1hdHJpeDtcbiAgICBcdFx0XHRcdF9saWdodHMuc3BvdFsgc3BvdExlbmd0aCArKyBdID0gdW5pZm9ybXM7XG5cbiAgICBcdFx0XHR9IGVsc2UgaWYgKCBsaWdodC5pc1BvaW50TGlnaHQgKSB7XG5cbiAgICBcdFx0XHRcdHZhciB1bmlmb3JtcyA9IGxpZ2h0Q2FjaGUuZ2V0KCBsaWdodCApO1xuXG4gICAgXHRcdFx0XHR1bmlmb3Jtcy5wb3NpdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0Lm1hdHJpeFdvcmxkICk7XG4gICAgXHRcdFx0XHR1bmlmb3Jtcy5wb3NpdGlvbi5hcHBseU1hdHJpeDQoIHZpZXdNYXRyaXggKTtcblxuICAgIFx0XHRcdFx0dW5pZm9ybXMuY29sb3IuY29weSggbGlnaHQuY29sb3IgKS5tdWx0aXBseVNjYWxhciggbGlnaHQuaW50ZW5zaXR5ICk7XG4gICAgXHRcdFx0XHR1bmlmb3Jtcy5kaXN0YW5jZSA9IGxpZ2h0LmRpc3RhbmNlO1xuICAgIFx0XHRcdFx0dW5pZm9ybXMuZGVjYXkgPSAoIGxpZ2h0LmRpc3RhbmNlID09PSAwICkgPyAwLjAgOiBsaWdodC5kZWNheTtcblxuICAgIFx0XHRcdFx0dW5pZm9ybXMuc2hhZG93ID0gbGlnaHQuY2FzdFNoYWRvdztcblxuICAgIFx0XHRcdFx0aWYgKCBsaWdodC5jYXN0U2hhZG93ICkge1xuXG4gICAgXHRcdFx0XHRcdHVuaWZvcm1zLnNoYWRvd0JpYXMgPSBsaWdodC5zaGFkb3cuYmlhcztcbiAgICBcdFx0XHRcdFx0dW5pZm9ybXMuc2hhZG93UmFkaXVzID0gbGlnaHQuc2hhZG93LnJhZGl1cztcbiAgICBcdFx0XHRcdFx0dW5pZm9ybXMuc2hhZG93TWFwU2l6ZSA9IGxpZ2h0LnNoYWRvdy5tYXBTaXplO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdF9saWdodHMucG9pbnRTaGFkb3dNYXBbIHBvaW50TGVuZ3RoIF0gPSBzaGFkb3dNYXA7XG5cbiAgICBcdFx0XHRcdGlmICggX2xpZ2h0cy5wb2ludFNoYWRvd01hdHJpeFsgcG9pbnRMZW5ndGggXSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0XHRcdF9saWdodHMucG9pbnRTaGFkb3dNYXRyaXhbIHBvaW50TGVuZ3RoIF0gPSBuZXcgTWF0cml4NCgpO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdC8vIGZvciBwb2ludCBsaWdodHMgd2Ugc2V0IHRoZSBzaGFkb3cgbWF0cml4IHRvIGJlIGEgdHJhbnNsYXRpb24tb25seSBtYXRyaXhcbiAgICBcdFx0XHRcdC8vIGVxdWFsIHRvIGludmVyc2Ugb2YgdGhlIGxpZ2h0J3MgcG9zaXRpb25cbiAgICBcdFx0XHRcdF92ZWN0b3IzLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQubWF0cml4V29ybGQgKS5uZWdhdGUoKTtcbiAgICBcdFx0XHRcdF9saWdodHMucG9pbnRTaGFkb3dNYXRyaXhbIHBvaW50TGVuZ3RoIF0uaWRlbnRpdHkoKS5zZXRQb3NpdGlvbiggX3ZlY3RvcjMgKTtcblxuICAgIFx0XHRcdFx0X2xpZ2h0cy5wb2ludFsgcG9pbnRMZW5ndGggKysgXSA9IHVuaWZvcm1zO1xuXG4gICAgXHRcdFx0fSBlbHNlIGlmICggbGlnaHQuaXNIZW1pc3BoZXJlTGlnaHQgKSB7XG5cbiAgICBcdFx0XHRcdHZhciB1bmlmb3JtcyA9IGxpZ2h0Q2FjaGUuZ2V0KCBsaWdodCApO1xuXG4gICAgXHRcdFx0XHR1bmlmb3Jtcy5kaXJlY3Rpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC5tYXRyaXhXb3JsZCApO1xuICAgIFx0XHRcdFx0dW5pZm9ybXMuZGlyZWN0aW9uLnRyYW5zZm9ybURpcmVjdGlvbiggdmlld01hdHJpeCApO1xuICAgIFx0XHRcdFx0dW5pZm9ybXMuZGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xuXG4gICAgXHRcdFx0XHR1bmlmb3Jtcy5za3lDb2xvci5jb3B5KCBsaWdodC5jb2xvciApLm11bHRpcGx5U2NhbGFyKCBpbnRlbnNpdHkgKTtcbiAgICBcdFx0XHRcdHVuaWZvcm1zLmdyb3VuZENvbG9yLmNvcHkoIGxpZ2h0Lmdyb3VuZENvbG9yICkubXVsdGlwbHlTY2FsYXIoIGludGVuc2l0eSApO1xuXG4gICAgXHRcdFx0XHRfbGlnaHRzLmhlbWlbIGhlbWlMZW5ndGggKysgXSA9IHVuaWZvcm1zO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHRfbGlnaHRzLmFtYmllbnRbIDAgXSA9IHI7XG4gICAgXHRcdF9saWdodHMuYW1iaWVudFsgMSBdID0gZztcbiAgICBcdFx0X2xpZ2h0cy5hbWJpZW50WyAyIF0gPSBiO1xuXG4gICAgXHRcdF9saWdodHMuZGlyZWN0aW9uYWwubGVuZ3RoID0gZGlyZWN0aW9uYWxMZW5ndGg7XG4gICAgXHRcdF9saWdodHMuc3BvdC5sZW5ndGggPSBzcG90TGVuZ3RoO1xuICAgIFx0XHRfbGlnaHRzLnBvaW50Lmxlbmd0aCA9IHBvaW50TGVuZ3RoO1xuICAgIFx0XHRfbGlnaHRzLmhlbWkubGVuZ3RoID0gaGVtaUxlbmd0aDtcblxuICAgIFx0XHRfbGlnaHRzLmhhc2ggPSBkaXJlY3Rpb25hbExlbmd0aCArICcsJyArIHBvaW50TGVuZ3RoICsgJywnICsgc3BvdExlbmd0aCArICcsJyArIGhlbWlMZW5ndGggKyAnLCcgKyBfbGlnaHRzLnNoYWRvd3MubGVuZ3RoO1xuXG4gICAgXHR9XG5cbiAgICBcdC8vIEdMIHN0YXRlIHNldHRpbmdcblxuICAgIFx0dGhpcy5zZXRGYWNlQ3VsbGluZyA9IGZ1bmN0aW9uICggY3VsbEZhY2UsIGZyb250RmFjZURpcmVjdGlvbiApIHtcblxuICAgIFx0XHRzdGF0ZS5zZXRDdWxsRmFjZSggY3VsbEZhY2UgKTtcbiAgICBcdFx0c3RhdGUuc2V0RmxpcFNpZGVkKCBmcm9udEZhY2VEaXJlY3Rpb24gPT09IEZyb250RmFjZURpcmVjdGlvbkNXICk7XG5cbiAgICBcdH07XG5cbiAgICBcdC8vIFRleHR1cmVzXG5cbiAgICBcdGZ1bmN0aW9uIGFsbG9jVGV4dHVyZVVuaXQoKSB7XG5cbiAgICBcdFx0dmFyIHRleHR1cmVVbml0ID0gX3VzZWRUZXh0dXJlVW5pdHM7XG5cbiAgICBcdFx0aWYgKCB0ZXh0dXJlVW5pdCA+PSBjYXBhYmlsaXRpZXMubWF4VGV4dHVyZXMgKSB7XG5cbiAgICBcdFx0XHRjb25zb2xlLndhcm4oICdXZWJHTFJlbmRlcmVyOiB0cnlpbmcgdG8gdXNlICcgKyB0ZXh0dXJlVW5pdCArICcgdGV4dHVyZSB1bml0cyB3aGlsZSB0aGlzIEdQVSBzdXBwb3J0cyBvbmx5ICcgKyBjYXBhYmlsaXRpZXMubWF4VGV4dHVyZXMgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0X3VzZWRUZXh0dXJlVW5pdHMgKz0gMTtcblxuICAgIFx0XHRyZXR1cm4gdGV4dHVyZVVuaXQ7XG5cbiAgICBcdH1cblxuICAgIFx0dGhpcy5hbGxvY1RleHR1cmVVbml0ID0gYWxsb2NUZXh0dXJlVW5pdDtcblxuICAgIFx0Ly8gdGhpcy5zZXRUZXh0dXJlMkQgPSBzZXRUZXh0dXJlMkQ7XG4gICAgXHR0aGlzLnNldFRleHR1cmUyRCA9ICggZnVuY3Rpb24oKSB7XG5cbiAgICBcdFx0dmFyIHdhcm5lZCA9IGZhbHNlO1xuXG4gICAgXHRcdC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5OiBwZWVsIHRleHR1cmUudGV4dHVyZVxuICAgIFx0XHRyZXR1cm4gZnVuY3Rpb24gc2V0VGV4dHVyZTJEKCB0ZXh0dXJlLCBzbG90ICkge1xuXG4gICAgXHRcdFx0aWYgKCB0ZXh0dXJlICYmIHRleHR1cmUuaXNXZWJHTFJlbmRlclRhcmdldCApIHtcblxuICAgIFx0XHRcdFx0aWYgKCAhIHdhcm5lZCApIHtcblxuICAgIFx0XHRcdFx0XHRjb25zb2xlLndhcm4oIFwiVEhSRUUuV2ViR0xSZW5kZXJlci5zZXRUZXh0dXJlMkQ6IGRvbid0IHVzZSByZW5kZXIgdGFyZ2V0cyBhcyB0ZXh0dXJlcy4gVXNlIHRoZWlyIC50ZXh0dXJlIHByb3BlcnR5IGluc3RlYWQuXCIgKTtcbiAgICBcdFx0XHRcdFx0d2FybmVkID0gdHJ1ZTtcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHR0ZXh0dXJlID0gdGV4dHVyZS50ZXh0dXJlO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0dGV4dHVyZXMuc2V0VGV4dHVyZTJEKCB0ZXh0dXJlLCBzbG90ICk7XG5cbiAgICBcdFx0fTtcblxuICAgIFx0fSgpICk7XG5cbiAgICBcdHRoaXMuc2V0VGV4dHVyZSA9ICggZnVuY3Rpb24oKSB7XG5cbiAgICBcdFx0dmFyIHdhcm5lZCA9IGZhbHNlO1xuXG4gICAgXHRcdHJldHVybiBmdW5jdGlvbiBzZXRUZXh0dXJlKCB0ZXh0dXJlLCBzbG90ICkge1xuXG4gICAgXHRcdFx0aWYgKCAhIHdhcm5lZCApIHtcblxuICAgIFx0XHRcdFx0Y29uc29sZS53YXJuKCBcIlRIUkVFLldlYkdMUmVuZGVyZXI6IC5zZXRUZXh0dXJlIGlzIGRlcHJlY2F0ZWQsIHVzZSBzZXRUZXh0dXJlMkQgaW5zdGVhZC5cIiApO1xuICAgIFx0XHRcdFx0d2FybmVkID0gdHJ1ZTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdHRleHR1cmVzLnNldFRleHR1cmUyRCggdGV4dHVyZSwgc2xvdCApO1xuXG4gICAgXHRcdH07XG5cbiAgICBcdH0oKSApO1xuXG4gICAgXHR0aGlzLnNldFRleHR1cmVDdWJlID0gKCBmdW5jdGlvbigpIHtcblxuICAgIFx0XHR2YXIgd2FybmVkID0gZmFsc2U7XG5cbiAgICBcdFx0cmV0dXJuIGZ1bmN0aW9uIHNldFRleHR1cmVDdWJlKCB0ZXh0dXJlLCBzbG90ICkge1xuXG4gICAgXHRcdFx0Ly8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHk6IHBlZWwgdGV4dHVyZS50ZXh0dXJlXG4gICAgXHRcdFx0aWYgKCB0ZXh0dXJlICYmIHRleHR1cmUuaXNXZWJHTFJlbmRlclRhcmdldEN1YmUgKSB7XG5cbiAgICBcdFx0XHRcdGlmICggISB3YXJuZWQgKSB7XG5cbiAgICBcdFx0XHRcdFx0Y29uc29sZS53YXJuKCBcIlRIUkVFLldlYkdMUmVuZGVyZXIuc2V0VGV4dHVyZUN1YmU6IGRvbid0IHVzZSBjdWJlIHJlbmRlciB0YXJnZXRzIGFzIHRleHR1cmVzLiBVc2UgdGhlaXIgLnRleHR1cmUgcHJvcGVydHkgaW5zdGVhZC5cIiApO1xuICAgIFx0XHRcdFx0XHR3YXJuZWQgPSB0cnVlO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdHRleHR1cmUgPSB0ZXh0dXJlLnRleHR1cmU7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHQvLyBjdXJyZW50bHkgcmVseWluZyBvbiB0aGUgZmFjdCB0aGF0IFdlYkdMUmVuZGVyVGFyZ2V0Q3ViZS50ZXh0dXJlIGlzIGEgVGV4dHVyZSBhbmQgTk9UIGEgQ3ViZVRleHR1cmVcbiAgICBcdFx0XHQvLyBUT0RPOiB1bmlmeSB0aGVzZSBjb2RlIHBhdGhzXG4gICAgXHRcdFx0aWYgKCAoIHRleHR1cmUgJiYgdGV4dHVyZS5pc0N1YmVUZXh0dXJlICkgfHxcbiAgICBcdFx0XHRcdCAoIEFycmF5LmlzQXJyYXkoIHRleHR1cmUuaW1hZ2UgKSAmJiB0ZXh0dXJlLmltYWdlLmxlbmd0aCA9PT0gNiApICkge1xuXG4gICAgXHRcdFx0XHQvLyBDb21wcmVzc2VkVGV4dHVyZSBjYW4gaGF2ZSBBcnJheSBpbiBpbWFnZSA6L1xuXG4gICAgXHRcdFx0XHQvLyB0aGlzIGZ1bmN0aW9uIGFsb25lIHNob3VsZCB0YWtlIGNhcmUgb2YgY3ViZSB0ZXh0dXJlc1xuICAgIFx0XHRcdFx0dGV4dHVyZXMuc2V0VGV4dHVyZUN1YmUoIHRleHR1cmUsIHNsb3QgKTtcblxuICAgIFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdC8vIGFzc3VtZWQ6IHRleHR1cmUgcHJvcGVydHkgb2YgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXRDdWJlXG5cbiAgICBcdFx0XHRcdHRleHR1cmVzLnNldFRleHR1cmVDdWJlRHluYW1pYyggdGV4dHVyZSwgc2xvdCApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH07XG5cbiAgICBcdH0oKSApO1xuXG4gICAgXHR0aGlzLmdldEN1cnJlbnRSZW5kZXJUYXJnZXQgPSBmdW5jdGlvbigpIHtcblxuICAgIFx0XHRyZXR1cm4gX2N1cnJlbnRSZW5kZXJUYXJnZXQ7XG5cbiAgICBcdH07XG5cbiAgICBcdHRoaXMuc2V0UmVuZGVyVGFyZ2V0ID0gZnVuY3Rpb24gKCByZW5kZXJUYXJnZXQgKSB7XG5cbiAgICBcdFx0X2N1cnJlbnRSZW5kZXJUYXJnZXQgPSByZW5kZXJUYXJnZXQ7XG5cbiAgICBcdFx0aWYgKCByZW5kZXJUYXJnZXQgJiYgcHJvcGVydGllcy5nZXQoIHJlbmRlclRhcmdldCApLl9fd2ViZ2xGcmFtZWJ1ZmZlciA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0dGV4dHVyZXMuc2V0dXBSZW5kZXJUYXJnZXQoIHJlbmRlclRhcmdldCApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHR2YXIgaXNDdWJlID0gKCByZW5kZXJUYXJnZXQgJiYgcmVuZGVyVGFyZ2V0LmlzV2ViR0xSZW5kZXJUYXJnZXRDdWJlICk7XG4gICAgXHRcdHZhciBmcmFtZWJ1ZmZlcjtcblxuICAgIFx0XHRpZiAoIHJlbmRlclRhcmdldCApIHtcblxuICAgIFx0XHRcdHZhciByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIHJlbmRlclRhcmdldCApO1xuXG4gICAgXHRcdFx0aWYgKCBpc0N1YmUgKSB7XG5cbiAgICBcdFx0XHRcdGZyYW1lYnVmZmVyID0gcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXJbIHJlbmRlclRhcmdldC5hY3RpdmVDdWJlRmFjZSBdO1xuXG4gICAgXHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0ZnJhbWVidWZmZXIgPSByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlcjtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdF9jdXJyZW50U2Npc3Nvci5jb3B5KCByZW5kZXJUYXJnZXQuc2Npc3NvciApO1xuICAgIFx0XHRcdF9jdXJyZW50U2Npc3NvclRlc3QgPSByZW5kZXJUYXJnZXQuc2Npc3NvclRlc3Q7XG5cbiAgICBcdFx0XHRfY3VycmVudFZpZXdwb3J0LmNvcHkoIHJlbmRlclRhcmdldC52aWV3cG9ydCApO1xuXG4gICAgXHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRmcmFtZWJ1ZmZlciA9IG51bGw7XG5cbiAgICBcdFx0XHRfY3VycmVudFNjaXNzb3IuY29weSggX3NjaXNzb3IgKS5tdWx0aXBseVNjYWxhciggX3BpeGVsUmF0aW8gKTtcbiAgICBcdFx0XHRfY3VycmVudFNjaXNzb3JUZXN0ID0gX3NjaXNzb3JUZXN0O1xuXG4gICAgXHRcdFx0X2N1cnJlbnRWaWV3cG9ydC5jb3B5KCBfdmlld3BvcnQgKS5tdWx0aXBseVNjYWxhciggX3BpeGVsUmF0aW8gKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0aWYgKCBfY3VycmVudEZyYW1lYnVmZmVyICE9PSBmcmFtZWJ1ZmZlciApIHtcblxuICAgIFx0XHRcdF9nbC5iaW5kRnJhbWVidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgZnJhbWVidWZmZXIgKTtcbiAgICBcdFx0XHRfY3VycmVudEZyYW1lYnVmZmVyID0gZnJhbWVidWZmZXI7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHN0YXRlLnNjaXNzb3IoIF9jdXJyZW50U2Npc3NvciApO1xuICAgIFx0XHRzdGF0ZS5zZXRTY2lzc29yVGVzdCggX2N1cnJlbnRTY2lzc29yVGVzdCApO1xuXG4gICAgXHRcdHN0YXRlLnZpZXdwb3J0KCBfY3VycmVudFZpZXdwb3J0ICk7XG5cbiAgICBcdFx0aWYgKCBpc0N1YmUgKSB7XG5cbiAgICBcdFx0XHR2YXIgdGV4dHVyZVByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0LnRleHR1cmUgKTtcbiAgICBcdFx0XHRfZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoIF9nbC5GUkFNRUJVRkZFUiwgX2dsLkNPTE9SX0FUVEFDSE1FTlQwLCBfZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgcmVuZGVyVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlLCB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSwgcmVuZGVyVGFyZ2V0LmFjdGl2ZU1pcE1hcExldmVsICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9O1xuXG4gICAgXHR0aGlzLnJlYWRSZW5kZXJUYXJnZXRQaXhlbHMgPSBmdW5jdGlvbiAoIHJlbmRlclRhcmdldCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgYnVmZmVyICkge1xuXG4gICAgXHRcdGlmICggKCByZW5kZXJUYXJnZXQgJiYgcmVuZGVyVGFyZ2V0LmlzV2ViR0xSZW5kZXJUYXJnZXQgKSA9PT0gZmFsc2UgKSB7XG5cbiAgICBcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xSZW5kZXJlci5yZWFkUmVuZGVyVGFyZ2V0UGl4ZWxzOiByZW5kZXJUYXJnZXQgaXMgbm90IFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0LicgKTtcbiAgICBcdFx0XHRyZXR1cm47XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHZhciBmcmFtZWJ1ZmZlciA9IHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQgKS5fX3dlYmdsRnJhbWVidWZmZXI7XG5cbiAgICBcdFx0aWYgKCBmcmFtZWJ1ZmZlciApIHtcblxuICAgIFx0XHRcdHZhciByZXN0b3JlID0gZmFsc2U7XG5cbiAgICBcdFx0XHRpZiAoIGZyYW1lYnVmZmVyICE9PSBfY3VycmVudEZyYW1lYnVmZmVyICkge1xuXG4gICAgXHRcdFx0XHRfZ2wuYmluZEZyYW1lYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIGZyYW1lYnVmZmVyICk7XG5cbiAgICBcdFx0XHRcdHJlc3RvcmUgPSB0cnVlO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0dHJ5IHtcblxuICAgIFx0XHRcdFx0dmFyIHRleHR1cmUgPSByZW5kZXJUYXJnZXQudGV4dHVyZTtcbiAgICBcdFx0XHRcdHZhciB0ZXh0dXJlRm9ybWF0ID0gdGV4dHVyZS5mb3JtYXQ7XG4gICAgXHRcdFx0XHR2YXIgdGV4dHVyZVR5cGUgPSB0ZXh0dXJlLnR5cGU7XG5cbiAgICBcdFx0XHRcdGlmICggdGV4dHVyZUZvcm1hdCAhPT0gUkdCQUZvcm1hdCAmJiBwYXJhbVRocmVlVG9HTCggdGV4dHVyZUZvcm1hdCApICE9PSBfZ2wuZ2V0UGFyYW1ldGVyKCBfZ2wuSU1QTEVNRU5UQVRJT05fQ09MT1JfUkVBRF9GT1JNQVQgKSApIHtcblxuICAgIFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xSZW5kZXJlci5yZWFkUmVuZGVyVGFyZ2V0UGl4ZWxzOiByZW5kZXJUYXJnZXQgaXMgbm90IGluIFJHQkEgb3IgaW1wbGVtZW50YXRpb24gZGVmaW5lZCBmb3JtYXQuJyApO1xuICAgIFx0XHRcdFx0XHRyZXR1cm47XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0aWYgKCB0ZXh0dXJlVHlwZSAhPT0gVW5zaWduZWRCeXRlVHlwZSAmJiBwYXJhbVRocmVlVG9HTCggdGV4dHVyZVR5cGUgKSAhPT0gX2dsLmdldFBhcmFtZXRlciggX2dsLklNUExFTUVOVEFUSU9OX0NPTE9SX1JFQURfVFlQRSApICYmIC8vIElFMTEsIEVkZ2UgYW5kIENocm9tZSBNYWMgPCA1MiAoIzk1MTMpXG4gICAgXHRcdFx0XHQgICAgICEgKCB0ZXh0dXJlVHlwZSA9PT0gRmxvYXRUeXBlICYmICggZXh0ZW5zaW9ucy5nZXQoICdPRVNfdGV4dHVyZV9mbG9hdCcgKSB8fCBleHRlbnNpb25zLmdldCggJ1dFQkdMX2NvbG9yX2J1ZmZlcl9mbG9hdCcgKSApICkgJiYgLy8gQ2hyb21lIE1hYyA+PSA1MiBhbmQgRmlyZWZveFxuICAgIFx0XHRcdFx0ICAgICAhICggdGV4dHVyZVR5cGUgPT09IEhhbGZGbG9hdFR5cGUgJiYgZXh0ZW5zaW9ucy5nZXQoICdFWFRfY29sb3JfYnVmZmVyX2hhbGZfZmxvYXQnICkgKSApIHtcblxuICAgIFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xSZW5kZXJlci5yZWFkUmVuZGVyVGFyZ2V0UGl4ZWxzOiByZW5kZXJUYXJnZXQgaXMgbm90IGluIFVuc2lnbmVkQnl0ZVR5cGUgb3IgaW1wbGVtZW50YXRpb24gZGVmaW5lZCB0eXBlLicgKTtcbiAgICBcdFx0XHRcdFx0cmV0dXJuO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdGlmICggX2dsLmNoZWNrRnJhbWVidWZmZXJTdGF0dXMoIF9nbC5GUkFNRUJVRkZFUiApID09PSBfZ2wuRlJBTUVCVUZGRVJfQ09NUExFVEUgKSB7XG5cbiAgICBcdFx0XHRcdFx0Ly8gdGhlIGZvbGxvd2luZyBpZiBzdGF0ZW1lbnQgZW5zdXJlcyB2YWxpZCByZWFkIHJlcXVlc3RzIChubyBvdXQtb2YtYm91bmRzIHBpeGVscywgc2VlICM4NjA0KVxuXG4gICAgXHRcdFx0XHRcdGlmICggKCB4ID49IDAgJiYgeCA8PSAoIHJlbmRlclRhcmdldC53aWR0aCAtIHdpZHRoICkgKSAmJiAoIHkgPj0gMCAmJiB5IDw9ICggcmVuZGVyVGFyZ2V0LmhlaWdodCAtIGhlaWdodCApICkgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHRfZ2wucmVhZFBpeGVscyggeCwgeSwgd2lkdGgsIGhlaWdodCwgcGFyYW1UaHJlZVRvR0woIHRleHR1cmVGb3JtYXQgKSwgcGFyYW1UaHJlZVRvR0woIHRleHR1cmVUeXBlICksIGJ1ZmZlciApO1xuXG4gICAgXHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xSZW5kZXJlci5yZWFkUmVuZGVyVGFyZ2V0UGl4ZWxzOiByZWFkUGl4ZWxzIGZyb20gcmVuZGVyVGFyZ2V0IGZhaWxlZC4gRnJhbWVidWZmZXIgbm90IGNvbXBsZXRlLicgKTtcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0fSBmaW5hbGx5IHtcblxuICAgIFx0XHRcdFx0aWYgKCByZXN0b3JlICkge1xuXG4gICAgXHRcdFx0XHRcdF9nbC5iaW5kRnJhbWVidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgX2N1cnJlbnRGcmFtZWJ1ZmZlciApO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9O1xuXG4gICAgXHQvLyBNYXAgdGhyZWUuanMgY29uc3RhbnRzIHRvIFdlYkdMIGNvbnN0YW50c1xuXG4gICAgXHRmdW5jdGlvbiBwYXJhbVRocmVlVG9HTCggcCApIHtcblxuICAgIFx0XHR2YXIgZXh0ZW5zaW9uO1xuXG4gICAgXHRcdGlmICggcCA9PT0gUmVwZWF0V3JhcHBpbmcgKSByZXR1cm4gX2dsLlJFUEVBVDtcbiAgICBcdFx0aWYgKCBwID09PSBDbGFtcFRvRWRnZVdyYXBwaW5nICkgcmV0dXJuIF9nbC5DTEFNUF9UT19FREdFO1xuICAgIFx0XHRpZiAoIHAgPT09IE1pcnJvcmVkUmVwZWF0V3JhcHBpbmcgKSByZXR1cm4gX2dsLk1JUlJPUkVEX1JFUEVBVDtcblxuICAgIFx0XHRpZiAoIHAgPT09IE5lYXJlc3RGaWx0ZXIgKSByZXR1cm4gX2dsLk5FQVJFU1Q7XG4gICAgXHRcdGlmICggcCA9PT0gTmVhcmVzdE1pcE1hcE5lYXJlc3RGaWx0ZXIgKSByZXR1cm4gX2dsLk5FQVJFU1RfTUlQTUFQX05FQVJFU1Q7XG4gICAgXHRcdGlmICggcCA9PT0gTmVhcmVzdE1pcE1hcExpbmVhckZpbHRlciApIHJldHVybiBfZ2wuTkVBUkVTVF9NSVBNQVBfTElORUFSO1xuXG4gICAgXHRcdGlmICggcCA9PT0gTGluZWFyRmlsdGVyICkgcmV0dXJuIF9nbC5MSU5FQVI7XG4gICAgXHRcdGlmICggcCA9PT0gTGluZWFyTWlwTWFwTmVhcmVzdEZpbHRlciApIHJldHVybiBfZ2wuTElORUFSX01JUE1BUF9ORUFSRVNUO1xuICAgIFx0XHRpZiAoIHAgPT09IExpbmVhck1pcE1hcExpbmVhckZpbHRlciApIHJldHVybiBfZ2wuTElORUFSX01JUE1BUF9MSU5FQVI7XG5cbiAgICBcdFx0aWYgKCBwID09PSBVbnNpZ25lZEJ5dGVUeXBlICkgcmV0dXJuIF9nbC5VTlNJR05FRF9CWVRFO1xuICAgIFx0XHRpZiAoIHAgPT09IFVuc2lnbmVkU2hvcnQ0NDQ0VHlwZSApIHJldHVybiBfZ2wuVU5TSUdORURfU0hPUlRfNF80XzRfNDtcbiAgICBcdFx0aWYgKCBwID09PSBVbnNpZ25lZFNob3J0NTU1MVR5cGUgKSByZXR1cm4gX2dsLlVOU0lHTkVEX1NIT1JUXzVfNV81XzE7XG4gICAgXHRcdGlmICggcCA9PT0gVW5zaWduZWRTaG9ydDU2NVR5cGUgKSByZXR1cm4gX2dsLlVOU0lHTkVEX1NIT1JUXzVfNl81O1xuXG4gICAgXHRcdGlmICggcCA9PT0gQnl0ZVR5cGUgKSByZXR1cm4gX2dsLkJZVEU7XG4gICAgXHRcdGlmICggcCA9PT0gU2hvcnRUeXBlICkgcmV0dXJuIF9nbC5TSE9SVDtcbiAgICBcdFx0aWYgKCBwID09PSBVbnNpZ25lZFNob3J0VHlwZSApIHJldHVybiBfZ2wuVU5TSUdORURfU0hPUlQ7XG4gICAgXHRcdGlmICggcCA9PT0gSW50VHlwZSApIHJldHVybiBfZ2wuSU5UO1xuICAgIFx0XHRpZiAoIHAgPT09IFVuc2lnbmVkSW50VHlwZSApIHJldHVybiBfZ2wuVU5TSUdORURfSU5UO1xuICAgIFx0XHRpZiAoIHAgPT09IEZsb2F0VHlwZSApIHJldHVybiBfZ2wuRkxPQVQ7XG5cbiAgICBcdFx0ZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0JyApO1xuXG4gICAgXHRcdGlmICggZXh0ZW5zaW9uICE9PSBudWxsICkge1xuXG4gICAgXHRcdFx0aWYgKCBwID09PSBIYWxmRmxvYXRUeXBlICkgcmV0dXJuIGV4dGVuc2lvbi5IQUxGX0ZMT0FUX09FUztcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0aWYgKCBwID09PSBBbHBoYUZvcm1hdCApIHJldHVybiBfZ2wuQUxQSEE7XG4gICAgXHRcdGlmICggcCA9PT0gUkdCRm9ybWF0ICkgcmV0dXJuIF9nbC5SR0I7XG4gICAgXHRcdGlmICggcCA9PT0gUkdCQUZvcm1hdCApIHJldHVybiBfZ2wuUkdCQTtcbiAgICBcdFx0aWYgKCBwID09PSBMdW1pbmFuY2VGb3JtYXQgKSByZXR1cm4gX2dsLkxVTUlOQU5DRTtcbiAgICBcdFx0aWYgKCBwID09PSBMdW1pbmFuY2VBbHBoYUZvcm1hdCApIHJldHVybiBfZ2wuTFVNSU5BTkNFX0FMUEhBO1xuICAgIFx0XHRpZiAoIHAgPT09IERlcHRoRm9ybWF0ICkgcmV0dXJuIF9nbC5ERVBUSF9DT01QT05FTlQ7XG4gICAgXHRcdGlmICggcCA9PT0gRGVwdGhTdGVuY2lsRm9ybWF0ICkgcmV0dXJuIF9nbC5ERVBUSF9TVEVOQ0lMO1xuXG4gICAgXHRcdGlmICggcCA9PT0gQWRkRXF1YXRpb24gKSByZXR1cm4gX2dsLkZVTkNfQUREO1xuICAgIFx0XHRpZiAoIHAgPT09IFN1YnRyYWN0RXF1YXRpb24gKSByZXR1cm4gX2dsLkZVTkNfU1VCVFJBQ1Q7XG4gICAgXHRcdGlmICggcCA9PT0gUmV2ZXJzZVN1YnRyYWN0RXF1YXRpb24gKSByZXR1cm4gX2dsLkZVTkNfUkVWRVJTRV9TVUJUUkFDVDtcblxuICAgIFx0XHRpZiAoIHAgPT09IFplcm9GYWN0b3IgKSByZXR1cm4gX2dsLlpFUk87XG4gICAgXHRcdGlmICggcCA9PT0gT25lRmFjdG9yICkgcmV0dXJuIF9nbC5PTkU7XG4gICAgXHRcdGlmICggcCA9PT0gU3JjQ29sb3JGYWN0b3IgKSByZXR1cm4gX2dsLlNSQ19DT0xPUjtcbiAgICBcdFx0aWYgKCBwID09PSBPbmVNaW51c1NyY0NvbG9yRmFjdG9yICkgcmV0dXJuIF9nbC5PTkVfTUlOVVNfU1JDX0NPTE9SO1xuICAgIFx0XHRpZiAoIHAgPT09IFNyY0FscGhhRmFjdG9yICkgcmV0dXJuIF9nbC5TUkNfQUxQSEE7XG4gICAgXHRcdGlmICggcCA9PT0gT25lTWludXNTcmNBbHBoYUZhY3RvciApIHJldHVybiBfZ2wuT05FX01JTlVTX1NSQ19BTFBIQTtcbiAgICBcdFx0aWYgKCBwID09PSBEc3RBbHBoYUZhY3RvciApIHJldHVybiBfZ2wuRFNUX0FMUEhBO1xuICAgIFx0XHRpZiAoIHAgPT09IE9uZU1pbnVzRHN0QWxwaGFGYWN0b3IgKSByZXR1cm4gX2dsLk9ORV9NSU5VU19EU1RfQUxQSEE7XG5cbiAgICBcdFx0aWYgKCBwID09PSBEc3RDb2xvckZhY3RvciApIHJldHVybiBfZ2wuRFNUX0NPTE9SO1xuICAgIFx0XHRpZiAoIHAgPT09IE9uZU1pbnVzRHN0Q29sb3JGYWN0b3IgKSByZXR1cm4gX2dsLk9ORV9NSU5VU19EU1RfQ09MT1I7XG4gICAgXHRcdGlmICggcCA9PT0gU3JjQWxwaGFTYXR1cmF0ZUZhY3RvciApIHJldHVybiBfZ2wuU1JDX0FMUEhBX1NBVFVSQVRFO1xuXG4gICAgXHRcdGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGMnICk7XG5cbiAgICBcdFx0aWYgKCBleHRlbnNpb24gIT09IG51bGwgKSB7XG5cbiAgICBcdFx0XHRpZiAoIHAgPT09IFJHQl9TM1RDX0RYVDFfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQl9TM1RDX0RYVDFfRVhUO1xuICAgIFx0XHRcdGlmICggcCA9PT0gUkdCQV9TM1RDX0RYVDFfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQxX0VYVDtcbiAgICBcdFx0XHRpZiAoIHAgPT09IFJHQkFfUzNUQ19EWFQzX0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUM19FWFQ7XG4gICAgXHRcdFx0aWYgKCBwID09PSBSR0JBX1MzVENfRFhUNV9Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDVfRVhUO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0YycgKTtcblxuICAgIFx0XHRpZiAoIGV4dGVuc2lvbiAhPT0gbnVsbCApIHtcblxuICAgIFx0XHRcdGlmICggcCA9PT0gUkdCX1BWUlRDXzRCUFBWMV9Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCX1BWUlRDXzRCUFBWMV9JTUc7XG4gICAgXHRcdFx0aWYgKCBwID09PSBSR0JfUFZSVENfMkJQUFYxX0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JfUFZSVENfMkJQUFYxX0lNRztcbiAgICBcdFx0XHRpZiAoIHAgPT09IFJHQkFfUFZSVENfNEJQUFYxX0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBX1BWUlRDXzRCUFBWMV9JTUc7XG4gICAgXHRcdFx0aWYgKCBwID09PSBSR0JBX1BWUlRDXzJCUFBWMV9Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9QVlJUQ18yQlBQVjFfSU1HO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9ldGMxJyApO1xuXG4gICAgXHRcdGlmICggZXh0ZW5zaW9uICE9PSBudWxsICkge1xuXG4gICAgXHRcdFx0aWYgKCBwID09PSBSR0JfRVRDMV9Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCX0VUQzFfV0VCR0w7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnRVhUX2JsZW5kX21pbm1heCcgKTtcblxuICAgIFx0XHRpZiAoIGV4dGVuc2lvbiAhPT0gbnVsbCApIHtcblxuICAgIFx0XHRcdGlmICggcCA9PT0gTWluRXF1YXRpb24gKSByZXR1cm4gZXh0ZW5zaW9uLk1JTl9FWFQ7XG4gICAgXHRcdFx0aWYgKCBwID09PSBNYXhFcXVhdGlvbiApIHJldHVybiBleHRlbnNpb24uTUFYX0VYVDtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0ZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9kZXB0aF90ZXh0dXJlJyApO1xuXG4gICAgXHRcdGlmICggZXh0ZW5zaW9uICE9PSBudWxsICl7XG5cbiAgICBcdFx0XHRpZiAoIHAgPT09IFVuc2lnbmVkSW50MjQ4VHlwZSApIHJldHVybiBleHRlbnNpb24uVU5TSUdORURfSU5UXzI0XzhfV0VCR0w7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiAwO1xuXG4gICAgXHR9XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICAgICAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBGb2dFeHAyICggY29sb3IsIGRlbnNpdHkgKSB7XG5cbiAgICBcdHRoaXMubmFtZSA9ICcnO1xuXG4gICAgXHR0aGlzLmNvbG9yID0gbmV3IENvbG9yKCBjb2xvciApO1xuICAgIFx0dGhpcy5kZW5zaXR5ID0gKCBkZW5zaXR5ICE9PSB1bmRlZmluZWQgKSA/IGRlbnNpdHkgOiAwLjAwMDI1O1xuXG4gICAgfVxuXG4gICAgRm9nRXhwMi5wcm90b3R5cGUuaXNGb2dFeHAyID0gdHJ1ZTtcblxuICAgIEZvZ0V4cDIucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuXG4gICAgXHRyZXR1cm4gbmV3IEZvZ0V4cDIoIHRoaXMuY29sb3IuZ2V0SGV4KCksIHRoaXMuZGVuc2l0eSApO1xuXG4gICAgfTtcblxuICAgIEZvZ0V4cDIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICggbWV0YSApIHtcblxuICAgIFx0cmV0dXJuIHtcbiAgICBcdFx0dHlwZTogJ0ZvZ0V4cDInLFxuICAgIFx0XHRjb2xvcjogdGhpcy5jb2xvci5nZXRIZXgoKSxcbiAgICBcdFx0ZGVuc2l0eTogdGhpcy5kZW5zaXR5XG4gICAgXHR9O1xuXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gICAgICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIEZvZyAoIGNvbG9yLCBuZWFyLCBmYXIgKSB7XG5cbiAgICBcdHRoaXMubmFtZSA9ICcnO1xuXG4gICAgXHR0aGlzLmNvbG9yID0gbmV3IENvbG9yKCBjb2xvciApO1xuXG4gICAgXHR0aGlzLm5lYXIgPSAoIG5lYXIgIT09IHVuZGVmaW5lZCApID8gbmVhciA6IDE7XG4gICAgXHR0aGlzLmZhciA9ICggZmFyICE9PSB1bmRlZmluZWQgKSA/IGZhciA6IDEwMDA7XG5cbiAgICB9XG5cbiAgICBGb2cucHJvdG90eXBlLmlzRm9nID0gdHJ1ZTtcblxuICAgIEZvZy5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdHJldHVybiBuZXcgRm9nKCB0aGlzLmNvbG9yLmdldEhleCgpLCB0aGlzLm5lYXIsIHRoaXMuZmFyICk7XG5cbiAgICB9O1xuXG4gICAgRm9nLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoIG1ldGEgKSB7XG5cbiAgICBcdHJldHVybiB7XG4gICAgXHRcdHR5cGU6ICdGb2cnLFxuICAgIFx0XHRjb2xvcjogdGhpcy5jb2xvci5nZXRIZXgoKSxcbiAgICBcdFx0bmVhcjogdGhpcy5uZWFyLFxuICAgIFx0XHRmYXI6IHRoaXMuZmFyXG4gICAgXHR9O1xuXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBTY2VuZSAoKSB7XG5cbiAgICBcdE9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuICAgIFx0dGhpcy50eXBlID0gJ1NjZW5lJztcblxuICAgIFx0dGhpcy5iYWNrZ3JvdW5kID0gbnVsbDtcbiAgICBcdHRoaXMuZm9nID0gbnVsbDtcbiAgICBcdHRoaXMub3ZlcnJpZGVNYXRlcmlhbCA9IG51bGw7XG5cbiAgICBcdHRoaXMuYXV0b1VwZGF0ZSA9IHRydWU7IC8vIGNoZWNrZWQgYnkgdGhlIHJlbmRlcmVyXG5cbiAgICB9XG5cbiAgICBTY2VuZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBPYmplY3QzRC5wcm90b3R5cGUgKTtcblxuICAgIFNjZW5lLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNjZW5lO1xuXG4gICAgU2NlbmUucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSwgcmVjdXJzaXZlICkge1xuXG4gICAgXHRPYmplY3QzRC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UsIHJlY3Vyc2l2ZSApO1xuXG4gICAgXHRpZiAoIHNvdXJjZS5iYWNrZ3JvdW5kICE9PSBudWxsICkgdGhpcy5iYWNrZ3JvdW5kID0gc291cmNlLmJhY2tncm91bmQuY2xvbmUoKTtcbiAgICBcdGlmICggc291cmNlLmZvZyAhPT0gbnVsbCApIHRoaXMuZm9nID0gc291cmNlLmZvZy5jbG9uZSgpO1xuICAgIFx0aWYgKCBzb3VyY2Uub3ZlcnJpZGVNYXRlcmlhbCAhPT0gbnVsbCApIHRoaXMub3ZlcnJpZGVNYXRlcmlhbCA9IHNvdXJjZS5vdmVycmlkZU1hdGVyaWFsLmNsb25lKCk7XG5cbiAgICBcdHRoaXMuYXV0b1VwZGF0ZSA9IHNvdXJjZS5hdXRvVXBkYXRlO1xuICAgIFx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gc291cmNlLm1hdHJpeEF1dG9VcGRhdGU7XG5cbiAgICBcdHJldHVybiB0aGlzO1xuXG4gICAgfTtcblxuICAgIFNjZW5lLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoIG1ldGEgKSB7XG5cbiAgICBcdHZhciBkYXRhID0gT2JqZWN0M0QucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzLCBtZXRhICk7XG5cbiAgICBcdGlmICggdGhpcy5iYWNrZ3JvdW5kICE9PSBudWxsICkgZGF0YS5vYmplY3QuYmFja2dyb3VuZCA9IHRoaXMuYmFja2dyb3VuZC50b0pTT04oIG1ldGEgKTtcbiAgICBcdGlmICggdGhpcy5mb2cgIT09IG51bGwgKSBkYXRhLm9iamVjdC5mb2cgPSB0aGlzLmZvZy50b0pTT04oKTtcblxuICAgIFx0cmV0dXJuIGRhdGE7XG5cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAgICAgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gTGVuc0ZsYXJlKCB0ZXh0dXJlLCBzaXplLCBkaXN0YW5jZSwgYmxlbmRpbmcsIGNvbG9yICkge1xuXG4gICAgXHRPYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cbiAgICBcdHRoaXMubGVuc0ZsYXJlcyA9IFtdO1xuXG4gICAgXHR0aGlzLnBvc2l0aW9uU2NyZWVuID0gbmV3IFZlY3RvcjMoKTtcbiAgICBcdHRoaXMuY3VzdG9tVXBkYXRlQ2FsbGJhY2sgPSB1bmRlZmluZWQ7XG5cbiAgICBcdGlmICggdGV4dHVyZSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdHRoaXMuYWRkKCB0ZXh0dXJlLCBzaXplLCBkaXN0YW5jZSwgYmxlbmRpbmcsIGNvbG9yICk7XG5cbiAgICBcdH1cblxuICAgIH1cblxuICAgIExlbnNGbGFyZS5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBPYmplY3QzRC5wcm90b3R5cGUgKSwge1xuXG4gICAgXHRjb25zdHJ1Y3RvcjogTGVuc0ZsYXJlLFxuXG4gICAgXHRpc0xlbnNGbGFyZTogdHJ1ZSxcblxuICAgIFx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cbiAgICBcdFx0T2JqZWN0M0QucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XG5cbiAgICBcdFx0dGhpcy5wb3NpdGlvblNjcmVlbi5jb3B5KCBzb3VyY2UucG9zaXRpb25TY3JlZW4gKTtcbiAgICBcdFx0dGhpcy5jdXN0b21VcGRhdGVDYWxsYmFjayA9IHNvdXJjZS5jdXN0b21VcGRhdGVDYWxsYmFjaztcblxuICAgIFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBzb3VyY2UubGVuc0ZsYXJlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgXHRcdFx0dGhpcy5sZW5zRmxhcmVzLnB1c2goIHNvdXJjZS5sZW5zRmxhcmVzWyBpIF0gKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGFkZDogZnVuY3Rpb24gKCB0ZXh0dXJlLCBzaXplLCBkaXN0YW5jZSwgYmxlbmRpbmcsIGNvbG9yLCBvcGFjaXR5ICkge1xuXG4gICAgXHRcdGlmICggc2l6ZSA9PT0gdW5kZWZpbmVkICkgc2l6ZSA9IC0gMTtcbiAgICBcdFx0aWYgKCBkaXN0YW5jZSA9PT0gdW5kZWZpbmVkICkgZGlzdGFuY2UgPSAwO1xuICAgIFx0XHRpZiAoIG9wYWNpdHkgPT09IHVuZGVmaW5lZCApIG9wYWNpdHkgPSAxO1xuICAgIFx0XHRpZiAoIGNvbG9yID09PSB1bmRlZmluZWQgKSBjb2xvciA9IG5ldyBDb2xvciggMHhmZmZmZmYgKTtcbiAgICBcdFx0aWYgKCBibGVuZGluZyA9PT0gdW5kZWZpbmVkICkgYmxlbmRpbmcgPSBOb3JtYWxCbGVuZGluZztcblxuICAgIFx0XHRkaXN0YW5jZSA9IE1hdGgubWluKCBkaXN0YW5jZSwgTWF0aC5tYXgoIDAsIGRpc3RhbmNlICkgKTtcblxuICAgIFx0XHR0aGlzLmxlbnNGbGFyZXMucHVzaCgge1xuICAgIFx0XHRcdHRleHR1cmU6IHRleHR1cmUsXHQvLyBUSFJFRS5UZXh0dXJlXG4gICAgXHRcdFx0c2l6ZTogc2l6ZSwgXHRcdC8vIHNpemUgaW4gcGl4ZWxzICgtMSA9IHVzZSB0ZXh0dXJlLndpZHRoKVxuICAgIFx0XHRcdGRpc3RhbmNlOiBkaXN0YW5jZSwgXHQvLyBkaXN0YW5jZSAoMC0xKSBmcm9tIGxpZ2h0IHNvdXJjZSAoMD1hdCBsaWdodCBzb3VyY2UpXG4gICAgXHRcdFx0eDogMCwgeTogMCwgejogMCxcdC8vIHNjcmVlbiBwb3NpdGlvbiAoLTEgPT4gMSkgeiA9IDAgaXMgaW4gZnJvbnQgeiA9IDEgaXMgYmFja1xuICAgIFx0XHRcdHNjYWxlOiAxLCBcdFx0Ly8gc2NhbGVcbiAgICBcdFx0XHRyb3RhdGlvbjogMCwgXHRcdC8vIHJvdGF0aW9uXG4gICAgXHRcdFx0b3BhY2l0eTogb3BhY2l0eSxcdC8vIG9wYWNpdHlcbiAgICBcdFx0XHRjb2xvcjogY29sb3IsXHRcdC8vIGNvbG9yXG4gICAgXHRcdFx0YmxlbmRpbmc6IGJsZW5kaW5nXHQvLyBibGVuZGluZ1xuICAgIFx0XHR9ICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdC8qXG4gICAgXHQgKiBVcGRhdGUgbGVucyBmbGFyZXMgdXBkYXRlIHBvc2l0aW9ucyBvbiBhbGwgZmxhcmVzIGJhc2VkIG9uIHRoZSBzY3JlZW4gcG9zaXRpb25cbiAgICBcdCAqIFNldCBteUxlbnNGbGFyZS5jdXN0b21VcGRhdGVDYWxsYmFjayB0byBhbHRlciB0aGUgZmxhcmVzIGluIHlvdXIgcHJvamVjdCBzcGVjaWZpYyB3YXkuXG4gICAgXHQgKi9cblxuICAgIFx0dXBkYXRlTGVuc0ZsYXJlczogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHZhciBmLCBmbCA9IHRoaXMubGVuc0ZsYXJlcy5sZW5ndGg7XG4gICAgXHRcdHZhciBmbGFyZTtcbiAgICBcdFx0dmFyIHZlY1ggPSAtIHRoaXMucG9zaXRpb25TY3JlZW4ueCAqIDI7XG4gICAgXHRcdHZhciB2ZWNZID0gLSB0aGlzLnBvc2l0aW9uU2NyZWVuLnkgKiAyO1xuXG4gICAgXHRcdGZvciAoIGYgPSAwOyBmIDwgZmw7IGYgKysgKSB7XG5cbiAgICBcdFx0XHRmbGFyZSA9IHRoaXMubGVuc0ZsYXJlc1sgZiBdO1xuXG4gICAgXHRcdFx0ZmxhcmUueCA9IHRoaXMucG9zaXRpb25TY3JlZW4ueCArIHZlY1ggKiBmbGFyZS5kaXN0YW5jZTtcbiAgICBcdFx0XHRmbGFyZS55ID0gdGhpcy5wb3NpdGlvblNjcmVlbi55ICsgdmVjWSAqIGZsYXJlLmRpc3RhbmNlO1xuXG4gICAgXHRcdFx0ZmxhcmUud2FudGVkUm90YXRpb24gPSBmbGFyZS54ICogTWF0aC5QSSAqIDAuMjU7XG4gICAgXHRcdFx0ZmxhcmUucm90YXRpb24gKz0gKCBmbGFyZS53YW50ZWRSb3RhdGlvbiAtIGZsYXJlLnJvdGF0aW9uICkgKiAwLjI1O1xuXG4gICAgXHRcdH1cblxuICAgIFx0fVxuXG4gICAgfSApO1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAgICAgKlxuICAgICAqIHBhcmFtZXRlcnMgPSB7XG4gICAgICogIGNvbG9yOiA8aGV4PixcbiAgICAgKiAgb3BhY2l0eTogPGZsb2F0PixcbiAgICAgKiAgbWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICAgICAqXG4gICAgICpcdHV2T2Zmc2V0OiBuZXcgVEhSRUUuVmVjdG9yMigpLFxuICAgICAqXHR1dlNjYWxlOiBuZXcgVEhSRUUuVmVjdG9yMigpXG4gICAgICogfVxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gU3ByaXRlTWF0ZXJpYWwoIHBhcmFtZXRlcnMgKSB7XG5cbiAgICBcdE1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcblxuICAgIFx0dGhpcy50eXBlID0gJ1Nwcml0ZU1hdGVyaWFsJztcblxuICAgIFx0dGhpcy5jb2xvciA9IG5ldyBDb2xvciggMHhmZmZmZmYgKTtcbiAgICBcdHRoaXMubWFwID0gbnVsbDtcblxuICAgIFx0dGhpcy5yb3RhdGlvbiA9IDA7XG5cbiAgICBcdHRoaXMuZm9nID0gZmFsc2U7XG4gICAgXHR0aGlzLmxpZ2h0cyA9IGZhbHNlO1xuXG4gICAgXHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xuXG4gICAgfVxuXG4gICAgU3ByaXRlTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTWF0ZXJpYWwucHJvdG90eXBlICk7XG4gICAgU3ByaXRlTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3ByaXRlTWF0ZXJpYWw7XG5cbiAgICBTcHJpdGVNYXRlcmlhbC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xuXG4gICAgXHRNYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuICAgIFx0dGhpcy5jb2xvci5jb3B5KCBzb3VyY2UuY29sb3IgKTtcbiAgICBcdHRoaXMubWFwID0gc291cmNlLm1hcDtcblxuICAgIFx0dGhpcy5yb3RhdGlvbiA9IHNvdXJjZS5yb3RhdGlvbjtcblxuICAgIFx0cmV0dXJuIHRoaXM7XG5cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAgICAgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gU3ByaXRlKCBtYXRlcmlhbCApIHtcblxuICAgIFx0T2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG4gICAgXHR0aGlzLnR5cGUgPSAnU3ByaXRlJztcblxuICAgIFx0dGhpcy5tYXRlcmlhbCA9ICggbWF0ZXJpYWwgIT09IHVuZGVmaW5lZCApID8gbWF0ZXJpYWwgOiBuZXcgU3ByaXRlTWF0ZXJpYWwoKTtcblxuICAgIH1cblxuICAgIFNwcml0ZS5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBPYmplY3QzRC5wcm90b3R5cGUgKSwge1xuXG4gICAgXHRjb25zdHJ1Y3RvcjogU3ByaXRlLFxuXG4gICAgXHRpc1Nwcml0ZTogdHJ1ZSxcblxuICAgIFx0cmF5Y2FzdDogKCBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dmFyIG1hdHJpeFBvc2l0aW9uID0gbmV3IFZlY3RvcjMoKTtcblxuICAgIFx0XHRyZXR1cm4gZnVuY3Rpb24gcmF5Y2FzdCggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICkge1xuXG4gICAgXHRcdFx0bWF0cml4UG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLm1hdHJpeFdvcmxkICk7XG5cbiAgICBcdFx0XHR2YXIgZGlzdGFuY2VTcSA9IHJheWNhc3Rlci5yYXkuZGlzdGFuY2VTcVRvUG9pbnQoIG1hdHJpeFBvc2l0aW9uICk7XG4gICAgXHRcdFx0dmFyIGd1ZXNzU2l6ZVNxID0gdGhpcy5zY2FsZS54ICogdGhpcy5zY2FsZS55IC8gNDtcblxuICAgIFx0XHRcdGlmICggZGlzdGFuY2VTcSA+IGd1ZXNzU2l6ZVNxICkge1xuXG4gICAgXHRcdFx0XHRyZXR1cm47XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRpbnRlcnNlY3RzLnB1c2goIHtcblxuICAgIFx0XHRcdFx0ZGlzdGFuY2U6IE1hdGguc3FydCggZGlzdGFuY2VTcSApLFxuICAgIFx0XHRcdFx0cG9pbnQ6IHRoaXMucG9zaXRpb24sXG4gICAgXHRcdFx0XHRmYWNlOiBudWxsLFxuICAgIFx0XHRcdFx0b2JqZWN0OiB0aGlzXG5cbiAgICBcdFx0XHR9ICk7XG5cbiAgICBcdFx0fTtcblxuICAgIFx0fSgpICksXG5cbiAgICBcdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLm1hdGVyaWFsICkuY29weSggdGhpcyApO1xuXG4gICAgXHR9XG5cbiAgICB9ICk7XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICAgICAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gICAgICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIExPRCgpIHtcblxuICAgIFx0T2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG4gICAgXHR0aGlzLnR5cGUgPSAnTE9EJztcblxuICAgIFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIHRoaXMsIHtcbiAgICBcdFx0bGV2ZWxzOiB7XG4gICAgXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBcdFx0XHR2YWx1ZTogW11cbiAgICBcdFx0fVxuICAgIFx0fSApO1xuXG4gICAgfVxuXG5cbiAgICBMT0QucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggT2JqZWN0M0QucHJvdG90eXBlICksIHtcblxuICAgIFx0Y29uc3RydWN0b3I6IExPRCxcblxuICAgIFx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cbiAgICBcdFx0T2JqZWN0M0QucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlLCBmYWxzZSApO1xuXG4gICAgXHRcdHZhciBsZXZlbHMgPSBzb3VyY2UubGV2ZWxzO1xuXG4gICAgXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGxldmVscy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgXHRcdFx0dmFyIGxldmVsID0gbGV2ZWxzWyBpIF07XG5cbiAgICBcdFx0XHR0aGlzLmFkZExldmVsKCBsZXZlbC5vYmplY3QuY2xvbmUoKSwgbGV2ZWwuZGlzdGFuY2UgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGFkZExldmVsOiBmdW5jdGlvbiAoIG9iamVjdCwgZGlzdGFuY2UgKSB7XG5cbiAgICBcdFx0aWYgKCBkaXN0YW5jZSA9PT0gdW5kZWZpbmVkICkgZGlzdGFuY2UgPSAwO1xuXG4gICAgXHRcdGRpc3RhbmNlID0gTWF0aC5hYnMoIGRpc3RhbmNlICk7XG5cbiAgICBcdFx0dmFyIGxldmVscyA9IHRoaXMubGV2ZWxzO1xuXG4gICAgXHRcdGZvciAoIHZhciBsID0gMDsgbCA8IGxldmVscy5sZW5ndGg7IGwgKysgKSB7XG5cbiAgICBcdFx0XHRpZiAoIGRpc3RhbmNlIDwgbGV2ZWxzWyBsIF0uZGlzdGFuY2UgKSB7XG5cbiAgICBcdFx0XHRcdGJyZWFrO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHRsZXZlbHMuc3BsaWNlKCBsLCAwLCB7IGRpc3RhbmNlOiBkaXN0YW5jZSwgb2JqZWN0OiBvYmplY3QgfSApO1xuXG4gICAgXHRcdHRoaXMuYWRkKCBvYmplY3QgKTtcblxuICAgIFx0fSxcblxuICAgIFx0Z2V0T2JqZWN0Rm9yRGlzdGFuY2U6IGZ1bmN0aW9uICggZGlzdGFuY2UgKSB7XG5cbiAgICBcdFx0dmFyIGxldmVscyA9IHRoaXMubGV2ZWxzO1xuXG4gICAgXHRcdGZvciAoIHZhciBpID0gMSwgbCA9IGxldmVscy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgXHRcdFx0aWYgKCBkaXN0YW5jZSA8IGxldmVsc1sgaSBdLmRpc3RhbmNlICkge1xuXG4gICAgXHRcdFx0XHRicmVhaztcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIGxldmVsc1sgaSAtIDEgXS5vYmplY3Q7XG5cbiAgICBcdH0sXG5cbiAgICBcdHJheWNhc3Q6ICggZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHZhciBtYXRyaXhQb3NpdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG5cbiAgICBcdFx0cmV0dXJuIGZ1bmN0aW9uIHJheWNhc3QoIHJheWNhc3RlciwgaW50ZXJzZWN0cyApIHtcblxuICAgIFx0XHRcdG1hdHJpeFBvc2l0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5tYXRyaXhXb3JsZCApO1xuXG4gICAgXHRcdFx0dmFyIGRpc3RhbmNlID0gcmF5Y2FzdGVyLnJheS5vcmlnaW4uZGlzdGFuY2VUbyggbWF0cml4UG9zaXRpb24gKTtcblxuICAgIFx0XHRcdHRoaXMuZ2V0T2JqZWN0Rm9yRGlzdGFuY2UoIGRpc3RhbmNlICkucmF5Y2FzdCggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICk7XG5cbiAgICBcdFx0fTtcblxuICAgIFx0fSgpICksXG5cbiAgICBcdHVwZGF0ZTogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCk7XG4gICAgXHRcdHZhciB2MiA9IG5ldyBWZWN0b3IzKCk7XG5cbiAgICBcdFx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSggY2FtZXJhICkge1xuXG4gICAgXHRcdFx0dmFyIGxldmVscyA9IHRoaXMubGV2ZWxzO1xuXG4gICAgXHRcdFx0aWYgKCBsZXZlbHMubGVuZ3RoID4gMSApIHtcblxuICAgIFx0XHRcdFx0djEuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBjYW1lcmEubWF0cml4V29ybGQgKTtcbiAgICBcdFx0XHRcdHYyLnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5tYXRyaXhXb3JsZCApO1xuXG4gICAgXHRcdFx0XHR2YXIgZGlzdGFuY2UgPSB2MS5kaXN0YW5jZVRvKCB2MiApO1xuXG4gICAgXHRcdFx0XHRsZXZlbHNbIDAgXS5vYmplY3QudmlzaWJsZSA9IHRydWU7XG5cbiAgICBcdFx0XHRcdGZvciAoIHZhciBpID0gMSwgbCA9IGxldmVscy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgXHRcdFx0XHRcdGlmICggZGlzdGFuY2UgPj0gbGV2ZWxzWyBpIF0uZGlzdGFuY2UgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHRsZXZlbHNbIGkgLSAxIF0ub2JqZWN0LnZpc2libGUgPSBmYWxzZTtcbiAgICBcdFx0XHRcdFx0XHRsZXZlbHNbIGkgXS5vYmplY3QudmlzaWJsZSA9IHRydWU7XG5cbiAgICBcdFx0XHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0XHRcdGJyZWFrO1xuXG4gICAgXHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHRmb3IgKCA7IGkgPCBsOyBpICsrICkge1xuXG4gICAgXHRcdFx0XHRcdGxldmVsc1sgaSBdLm9iamVjdC52aXNpYmxlID0gZmFsc2U7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9O1xuXG4gICAgXHR9KCksXG5cbiAgICBcdHRvSlNPTjogZnVuY3Rpb24gKCBtZXRhICkge1xuXG4gICAgXHRcdHZhciBkYXRhID0gT2JqZWN0M0QucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzLCBtZXRhICk7XG5cbiAgICBcdFx0ZGF0YS5vYmplY3QubGV2ZWxzID0gW107XG5cbiAgICBcdFx0dmFyIGxldmVscyA9IHRoaXMubGV2ZWxzO1xuXG4gICAgXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGxldmVscy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgXHRcdFx0dmFyIGxldmVsID0gbGV2ZWxzWyBpIF07XG5cbiAgICBcdFx0XHRkYXRhLm9iamVjdC5sZXZlbHMucHVzaCgge1xuICAgIFx0XHRcdFx0b2JqZWN0OiBsZXZlbC5vYmplY3QudXVpZCxcbiAgICBcdFx0XHRcdGRpc3RhbmNlOiBsZXZlbC5kaXN0YW5jZVxuICAgIFx0XHRcdH0gKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIGRhdGE7XG5cbiAgICBcdH1cblxuICAgIH0gKTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBEYXRhVGV4dHVyZSggZGF0YSwgd2lkdGgsIGhlaWdodCwgZm9ybWF0LCB0eXBlLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBhbmlzb3Ryb3B5LCBlbmNvZGluZyApIHtcblxuICAgIFx0VGV4dHVyZS5jYWxsKCB0aGlzLCBudWxsLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHksIGVuY29kaW5nICk7XG5cbiAgICBcdHRoaXMuaW1hZ2UgPSB7IGRhdGE6IGRhdGEsIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfTtcblxuICAgIFx0dGhpcy5tYWdGaWx0ZXIgPSBtYWdGaWx0ZXIgIT09IHVuZGVmaW5lZCA/IG1hZ0ZpbHRlciA6IE5lYXJlc3RGaWx0ZXI7XG4gICAgXHR0aGlzLm1pbkZpbHRlciA9IG1pbkZpbHRlciAhPT0gdW5kZWZpbmVkID8gbWluRmlsdGVyIDogTmVhcmVzdEZpbHRlcjtcblxuICAgIFx0dGhpcy5mbGlwWSA9IGZhbHNlO1xuICAgIFx0dGhpcy5nZW5lcmF0ZU1pcG1hcHMgID0gZmFsc2U7XG5cbiAgICB9XG5cbiAgICBEYXRhVGV4dHVyZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUZXh0dXJlLnByb3RvdHlwZSApO1xuICAgIERhdGFUZXh0dXJlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IERhdGFUZXh0dXJlO1xuXG4gICAgRGF0YVRleHR1cmUucHJvdG90eXBlLmlzRGF0YVRleHR1cmUgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAgICAgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICAgICAqIEBhdXRob3IgbWljaGFlbCBndWVycmVybyAvIGh0dHA6Ly9yZWFsaXR5bWVsdGRvd24uY29tXG4gICAgICogQGF1dGhvciBpa2VyciAvIGh0dHA6Ly92ZXJvbGQuY29tXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBTa2VsZXRvbiggYm9uZXMsIGJvbmVJbnZlcnNlcywgdXNlVmVydGV4VGV4dHVyZSApIHtcblxuICAgIFx0dGhpcy51c2VWZXJ0ZXhUZXh0dXJlID0gdXNlVmVydGV4VGV4dHVyZSAhPT0gdW5kZWZpbmVkID8gdXNlVmVydGV4VGV4dHVyZSA6IHRydWU7XG5cbiAgICBcdHRoaXMuaWRlbnRpdHlNYXRyaXggPSBuZXcgTWF0cml4NCgpO1xuXG4gICAgXHQvLyBjb3B5IHRoZSBib25lIGFycmF5XG5cbiAgICBcdGJvbmVzID0gYm9uZXMgfHwgW107XG5cbiAgICBcdHRoaXMuYm9uZXMgPSBib25lcy5zbGljZSggMCApO1xuXG4gICAgXHQvLyBjcmVhdGUgYSBib25lIHRleHR1cmUgb3IgYW4gYXJyYXkgb2YgZmxvYXRzXG5cbiAgICBcdGlmICggdGhpcy51c2VWZXJ0ZXhUZXh0dXJlICkge1xuXG4gICAgXHRcdC8vIGxheW91dCAoMSBtYXRyaXggPSA0IHBpeGVscylcbiAgICBcdFx0Ly8gICAgICBSR0JBIFJHQkEgUkdCQSBSR0JBICg9PiBjb2x1bW4xLCBjb2x1bW4yLCBjb2x1bW4zLCBjb2x1bW40KVxuICAgIFx0XHQvLyAgd2l0aCAgOHg4ICBwaXhlbCB0ZXh0dXJlIG1heCAgIDE2IGJvbmVzICogNCBwaXhlbHMgPSAgKDggKiA4KVxuICAgIFx0XHQvLyAgICAgICAxNngxNiBwaXhlbCB0ZXh0dXJlIG1heCAgIDY0IGJvbmVzICogNCBwaXhlbHMgPSAoMTYgKiAxNilcbiAgICBcdFx0Ly8gICAgICAgMzJ4MzIgcGl4ZWwgdGV4dHVyZSBtYXggIDI1NiBib25lcyAqIDQgcGl4ZWxzID0gKDMyICogMzIpXG4gICAgXHRcdC8vICAgICAgIDY0eDY0IHBpeGVsIHRleHR1cmUgbWF4IDEwMjQgYm9uZXMgKiA0IHBpeGVscyA9ICg2NCAqIDY0KVxuXG5cbiAgICBcdFx0dmFyIHNpemUgPSBNYXRoLnNxcnQoIHRoaXMuYm9uZXMubGVuZ3RoICogNCApOyAvLyA0IHBpeGVscyBuZWVkZWQgZm9yIDEgbWF0cml4XG4gICAgXHRcdHNpemUgPSBleHBvcnRzLk1hdGgubmV4dFBvd2VyT2ZUd28oIE1hdGguY2VpbCggc2l6ZSApICk7XG4gICAgXHRcdHNpemUgPSBNYXRoLm1heCggc2l6ZSwgNCApO1xuXG4gICAgXHRcdHRoaXMuYm9uZVRleHR1cmVXaWR0aCA9IHNpemU7XG4gICAgXHRcdHRoaXMuYm9uZVRleHR1cmVIZWlnaHQgPSBzaXplO1xuXG4gICAgXHRcdHRoaXMuYm9uZU1hdHJpY2VzID0gbmV3IEZsb2F0MzJBcnJheSggdGhpcy5ib25lVGV4dHVyZVdpZHRoICogdGhpcy5ib25lVGV4dHVyZUhlaWdodCAqIDQgKTsgLy8gNCBmbG9hdHMgcGVyIFJHQkEgcGl4ZWxcbiAgICBcdFx0dGhpcy5ib25lVGV4dHVyZSA9IG5ldyBEYXRhVGV4dHVyZSggdGhpcy5ib25lTWF0cmljZXMsIHRoaXMuYm9uZVRleHR1cmVXaWR0aCwgdGhpcy5ib25lVGV4dHVyZUhlaWdodCwgUkdCQUZvcm1hdCwgRmxvYXRUeXBlICk7XG5cbiAgICBcdH0gZWxzZSB7XG5cbiAgICBcdFx0dGhpcy5ib25lTWF0cmljZXMgPSBuZXcgRmxvYXQzMkFycmF5KCAxNiAqIHRoaXMuYm9uZXMubGVuZ3RoICk7XG5cbiAgICBcdH1cblxuICAgIFx0Ly8gdXNlIHRoZSBzdXBwbGllZCBib25lIGludmVyc2VzIG9yIGNhbGN1bGF0ZSB0aGUgaW52ZXJzZXNcblxuICAgIFx0aWYgKCBib25lSW52ZXJzZXMgPT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHR0aGlzLmNhbGN1bGF0ZUludmVyc2VzKCk7XG5cbiAgICBcdH0gZWxzZSB7XG5cbiAgICBcdFx0aWYgKCB0aGlzLmJvbmVzLmxlbmd0aCA9PT0gYm9uZUludmVyc2VzLmxlbmd0aCApIHtcblxuICAgIFx0XHRcdHRoaXMuYm9uZUludmVyc2VzID0gYm9uZUludmVyc2VzLnNsaWNlKCAwICk7XG5cbiAgICBcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlNrZWxldG9uIGJvbkludmVyc2VzIGlzIHRoZSB3cm9uZyBsZW5ndGguJyApO1xuXG4gICAgXHRcdFx0dGhpcy5ib25lSW52ZXJzZXMgPSBbXTtcblxuICAgIFx0XHRcdGZvciAoIHZhciBiID0gMCwgYmwgPSB0aGlzLmJvbmVzLmxlbmd0aDsgYiA8IGJsOyBiICsrICkge1xuXG4gICAgXHRcdFx0XHR0aGlzLmJvbmVJbnZlcnNlcy5wdXNoKCBuZXcgTWF0cml4NCgpICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9XG5cbiAgICB9XG5cbiAgICBPYmplY3QuYXNzaWduKCBTa2VsZXRvbi5wcm90b3R5cGUsIHtcblxuICAgIFx0Y2FsY3VsYXRlSW52ZXJzZXM6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR0aGlzLmJvbmVJbnZlcnNlcyA9IFtdO1xuXG4gICAgXHRcdGZvciAoIHZhciBiID0gMCwgYmwgPSB0aGlzLmJvbmVzLmxlbmd0aDsgYiA8IGJsOyBiICsrICkge1xuXG4gICAgXHRcdFx0dmFyIGludmVyc2UgPSBuZXcgTWF0cml4NCgpO1xuXG4gICAgXHRcdFx0aWYgKCB0aGlzLmJvbmVzWyBiIF0gKSB7XG5cbiAgICBcdFx0XHRcdGludmVyc2UuZ2V0SW52ZXJzZSggdGhpcy5ib25lc1sgYiBdLm1hdHJpeFdvcmxkICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHR0aGlzLmJvbmVJbnZlcnNlcy5wdXNoKCBpbnZlcnNlICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9LFxuXG4gICAgXHRwb3NlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dmFyIGJvbmU7XG5cbiAgICBcdFx0Ly8gcmVjb3ZlciB0aGUgYmluZC10aW1lIHdvcmxkIG1hdHJpY2VzXG5cbiAgICBcdFx0Zm9yICggdmFyIGIgPSAwLCBibCA9IHRoaXMuYm9uZXMubGVuZ3RoOyBiIDwgYmw7IGIgKysgKSB7XG5cbiAgICBcdFx0XHRib25lID0gdGhpcy5ib25lc1sgYiBdO1xuXG4gICAgXHRcdFx0aWYgKCBib25lICkge1xuXG4gICAgXHRcdFx0XHRib25lLm1hdHJpeFdvcmxkLmdldEludmVyc2UoIHRoaXMuYm9uZUludmVyc2VzWyBiIF0gKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdFx0Ly8gY29tcHV0ZSB0aGUgbG9jYWwgbWF0cmljZXMsIHBvc2l0aW9ucywgcm90YXRpb25zIGFuZCBzY2FsZXNcblxuICAgIFx0XHRmb3IgKCB2YXIgYiA9IDAsIGJsID0gdGhpcy5ib25lcy5sZW5ndGg7IGIgPCBibDsgYiArKyApIHtcblxuICAgIFx0XHRcdGJvbmUgPSB0aGlzLmJvbmVzWyBiIF07XG5cbiAgICBcdFx0XHRpZiAoIGJvbmUgKSB7XG5cbiAgICBcdFx0XHRcdGlmICggKGJvbmUucGFyZW50ICYmIGJvbmUucGFyZW50LmlzQm9uZSkgKSB7XG5cbiAgICBcdFx0XHRcdFx0Ym9uZS5tYXRyaXguZ2V0SW52ZXJzZSggYm9uZS5wYXJlbnQubWF0cml4V29ybGQgKTtcbiAgICBcdFx0XHRcdFx0Ym9uZS5tYXRyaXgubXVsdGlwbHkoIGJvbmUubWF0cml4V29ybGQgKTtcblxuICAgIFx0XHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0XHRib25lLm1hdHJpeC5jb3B5KCBib25lLm1hdHJpeFdvcmxkICk7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0Ym9uZS5tYXRyaXguZGVjb21wb3NlKCBib25lLnBvc2l0aW9uLCBib25lLnF1YXRlcm5pb24sIGJvbmUuc2NhbGUgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdH0sXG5cbiAgICBcdHVwZGF0ZTogKCBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dmFyIG9mZnNldE1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XG5cbiAgICBcdFx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSgpIHtcblxuICAgIFx0XHRcdC8vIGZsYXR0ZW4gYm9uZSBtYXRyaWNlcyB0byBhcnJheVxuXG4gICAgXHRcdFx0Zm9yICggdmFyIGIgPSAwLCBibCA9IHRoaXMuYm9uZXMubGVuZ3RoOyBiIDwgYmw7IGIgKysgKSB7XG5cbiAgICBcdFx0XHRcdC8vIGNvbXB1dGUgdGhlIG9mZnNldCBiZXR3ZWVuIHRoZSBjdXJyZW50IGFuZCB0aGUgb3JpZ2luYWwgdHJhbnNmb3JtXG5cbiAgICBcdFx0XHRcdHZhciBtYXRyaXggPSB0aGlzLmJvbmVzWyBiIF0gPyB0aGlzLmJvbmVzWyBiIF0ubWF0cml4V29ybGQgOiB0aGlzLmlkZW50aXR5TWF0cml4O1xuXG4gICAgXHRcdFx0XHRvZmZzZXRNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggbWF0cml4LCB0aGlzLmJvbmVJbnZlcnNlc1sgYiBdICk7XG4gICAgXHRcdFx0XHRvZmZzZXRNYXRyaXgudG9BcnJheSggdGhpcy5ib25lTWF0cmljZXMsIGIgKiAxNiApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0aWYgKCB0aGlzLnVzZVZlcnRleFRleHR1cmUgKSB7XG5cbiAgICBcdFx0XHRcdHRoaXMuYm9uZVRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH07XG5cbiAgICBcdH0gKSgpLFxuXG4gICAgXHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHJldHVybiBuZXcgU2tlbGV0b24oIHRoaXMuYm9uZXMsIHRoaXMuYm9uZUludmVyc2VzLCB0aGlzLnVzZVZlcnRleFRleHR1cmUgKTtcblxuICAgIFx0fVxuXG4gICAgfSApO1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAgICAgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICAgICAqIEBhdXRob3IgaWtlcnIgLyBodHRwOi8vdmVyb2xkLmNvbVxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gQm9uZSggc2tpbiApIHtcblxuICAgIFx0T2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG4gICAgXHR0aGlzLnR5cGUgPSAnQm9uZSc7XG5cbiAgICBcdHRoaXMuc2tpbiA9IHNraW47XG5cbiAgICB9XG5cbiAgICBCb25lLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIE9iamVjdDNELnByb3RvdHlwZSApLCB7XG5cbiAgICBcdGNvbnN0cnVjdG9yOiBCb25lLFxuXG4gICAgXHRpc0JvbmU6IHRydWUsXG5cbiAgICBcdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xuXG4gICAgXHRcdE9iamVjdDNELnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG4gICAgXHRcdHRoaXMuc2tpbiA9IHNvdXJjZS5za2luO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9XG5cbiAgICB9ICk7XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICAgICAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gICAgICogQGF1dGhvciBpa2VyciAvIGh0dHA6Ly92ZXJvbGQuY29tXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBTa2lubmVkTWVzaCggZ2VvbWV0cnksIG1hdGVyaWFsLCB1c2VWZXJ0ZXhUZXh0dXJlICkge1xuXG4gICAgXHRNZXNoLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG4gICAgXHR0aGlzLnR5cGUgPSAnU2tpbm5lZE1lc2gnO1xuXG4gICAgXHR0aGlzLmJpbmRNb2RlID0gXCJhdHRhY2hlZFwiO1xuICAgIFx0dGhpcy5iaW5kTWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcbiAgICBcdHRoaXMuYmluZE1hdHJpeEludmVyc2UgPSBuZXcgTWF0cml4NCgpO1xuXG4gICAgXHQvLyBpbml0IGJvbmVzXG5cbiAgICBcdC8vIFRPRE86IHJlbW92ZSBib25lIGNyZWF0aW9uIGFzIHRoZXJlIGlzIG5vIHJlYXNvbiAob3RoZXIgdGhhblxuICAgIFx0Ly8gY29udmVuaWVuY2UpIGZvciBUSFJFRS5Ta2lubmVkTWVzaCB0byBkbyB0aGlzLlxuXG4gICAgXHR2YXIgYm9uZXMgPSBbXTtcblxuICAgIFx0aWYgKCB0aGlzLmdlb21ldHJ5ICYmIHRoaXMuZ2VvbWV0cnkuYm9uZXMgIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHR2YXIgYm9uZSwgZ2JvbmU7XG5cbiAgICBcdFx0Zm9yICggdmFyIGIgPSAwLCBibCA9IHRoaXMuZ2VvbWV0cnkuYm9uZXMubGVuZ3RoOyBiIDwgYmw7ICsrIGIgKSB7XG5cbiAgICBcdFx0XHRnYm9uZSA9IHRoaXMuZ2VvbWV0cnkuYm9uZXNbIGIgXTtcblxuICAgIFx0XHRcdGJvbmUgPSBuZXcgQm9uZSggdGhpcyApO1xuICAgIFx0XHRcdGJvbmVzLnB1c2goIGJvbmUgKTtcblxuICAgIFx0XHRcdGJvbmUubmFtZSA9IGdib25lLm5hbWU7XG4gICAgXHRcdFx0Ym9uZS5wb3NpdGlvbi5mcm9tQXJyYXkoIGdib25lLnBvcyApO1xuICAgIFx0XHRcdGJvbmUucXVhdGVybmlvbi5mcm9tQXJyYXkoIGdib25lLnJvdHEgKTtcbiAgICBcdFx0XHRpZiAoIGdib25lLnNjbCAhPT0gdW5kZWZpbmVkICkgYm9uZS5zY2FsZS5mcm9tQXJyYXkoIGdib25lLnNjbCApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRmb3IgKCB2YXIgYiA9IDAsIGJsID0gdGhpcy5nZW9tZXRyeS5ib25lcy5sZW5ndGg7IGIgPCBibDsgKysgYiApIHtcblxuICAgIFx0XHRcdGdib25lID0gdGhpcy5nZW9tZXRyeS5ib25lc1sgYiBdO1xuXG4gICAgXHRcdFx0aWYgKCBnYm9uZS5wYXJlbnQgIT09IC0gMSAmJiBnYm9uZS5wYXJlbnQgIT09IG51bGwgJiZcbiAgICBcdFx0XHRcdFx0Ym9uZXNbIGdib25lLnBhcmVudCBdICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRcdGJvbmVzWyBnYm9uZS5wYXJlbnQgXS5hZGQoIGJvbmVzWyBiIF0gKTtcblxuICAgIFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdHRoaXMuYWRkKCBib25lc1sgYiBdICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9XG5cbiAgICBcdHRoaXMubm9ybWFsaXplU2tpbldlaWdodHMoKTtcblxuICAgIFx0dGhpcy51cGRhdGVNYXRyaXhXb3JsZCggdHJ1ZSApO1xuICAgIFx0dGhpcy5iaW5kKCBuZXcgU2tlbGV0b24oIGJvbmVzLCB1bmRlZmluZWQsIHVzZVZlcnRleFRleHR1cmUgKSwgdGhpcy5tYXRyaXhXb3JsZCApO1xuXG4gICAgfVxuXG5cbiAgICBTa2lubmVkTWVzaC5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBNZXNoLnByb3RvdHlwZSApLCB7XG5cbiAgICBcdGNvbnN0cnVjdG9yOiBTa2lubmVkTWVzaCxcblxuICAgIFx0aXNTa2lubmVkTWVzaDogdHJ1ZSxcblxuICAgIFx0YmluZDogZnVuY3Rpb24oIHNrZWxldG9uLCBiaW5kTWF0cml4ICkge1xuXG4gICAgXHRcdHRoaXMuc2tlbGV0b24gPSBza2VsZXRvbjtcblxuICAgIFx0XHRpZiAoIGJpbmRNYXRyaXggPT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdHRoaXMudXBkYXRlTWF0cml4V29ybGQoIHRydWUgKTtcblxuICAgIFx0XHRcdHRoaXMuc2tlbGV0b24uY2FsY3VsYXRlSW52ZXJzZXMoKTtcblxuICAgIFx0XHRcdGJpbmRNYXRyaXggPSB0aGlzLm1hdHJpeFdvcmxkO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHR0aGlzLmJpbmRNYXRyaXguY29weSggYmluZE1hdHJpeCApO1xuICAgIFx0XHR0aGlzLmJpbmRNYXRyaXhJbnZlcnNlLmdldEludmVyc2UoIGJpbmRNYXRyaXggKTtcblxuICAgIFx0fSxcblxuICAgIFx0cG9zZTogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHRoaXMuc2tlbGV0b24ucG9zZSgpO1xuXG4gICAgXHR9LFxuXG4gICAgXHRub3JtYWxpemVTa2luV2VpZ2h0czogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdGlmICggKHRoaXMuZ2VvbWV0cnkgJiYgdGhpcy5nZW9tZXRyeS5pc0dlb21ldHJ5KSApIHtcblxuICAgIFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMuZ2VvbWV0cnkuc2tpbldlaWdodHMubGVuZ3RoOyBpICsrICkge1xuXG4gICAgXHRcdFx0XHR2YXIgc3cgPSB0aGlzLmdlb21ldHJ5LnNraW5XZWlnaHRzWyBpIF07XG5cbiAgICBcdFx0XHRcdHZhciBzY2FsZSA9IDEuMCAvIHN3Lmxlbmd0aE1hbmhhdHRhbigpO1xuXG4gICAgXHRcdFx0XHRpZiAoIHNjYWxlICE9PSBJbmZpbml0eSApIHtcblxuICAgIFx0XHRcdFx0XHRzdy5tdWx0aXBseVNjYWxhciggc2NhbGUgKTtcblxuICAgIFx0XHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0XHRzdy5zZXQoIDEsIDAsIDAsIDAgKTsgLy8gZG8gc29tZXRoaW5nIHJlYXNvbmFibGVcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH0gZWxzZSBpZiAoICh0aGlzLmdlb21ldHJ5ICYmIHRoaXMuZ2VvbWV0cnkuaXNCdWZmZXJHZW9tZXRyeSkgKSB7XG5cbiAgICBcdFx0XHR2YXIgdmVjID0gbmV3IFZlY3RvcjQoKTtcblxuICAgIFx0XHRcdHZhciBza2luV2VpZ2h0ID0gdGhpcy5nZW9tZXRyeS5hdHRyaWJ1dGVzLnNraW5XZWlnaHQ7XG5cbiAgICBcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBza2luV2VpZ2h0LmNvdW50OyBpICsrICkge1xuXG4gICAgXHRcdFx0XHR2ZWMueCA9IHNraW5XZWlnaHQuZ2V0WCggaSApO1xuICAgIFx0XHRcdFx0dmVjLnkgPSBza2luV2VpZ2h0LmdldFkoIGkgKTtcbiAgICBcdFx0XHRcdHZlYy56ID0gc2tpbldlaWdodC5nZXRaKCBpICk7XG4gICAgXHRcdFx0XHR2ZWMudyA9IHNraW5XZWlnaHQuZ2V0VyggaSApO1xuXG4gICAgXHRcdFx0XHR2YXIgc2NhbGUgPSAxLjAgLyB2ZWMubGVuZ3RoTWFuaGF0dGFuKCk7XG5cbiAgICBcdFx0XHRcdGlmICggc2NhbGUgIT09IEluZmluaXR5ICkge1xuXG4gICAgXHRcdFx0XHRcdHZlYy5tdWx0aXBseVNjYWxhciggc2NhbGUgKTtcblxuICAgIFx0XHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0XHR2ZWMuc2V0KCAxLCAwLCAwLCAwICk7IC8vIGRvIHNvbWV0aGluZyByZWFzb25hYmxlXG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0c2tpbldlaWdodC5zZXRYWVpXKCBpLCB2ZWMueCwgdmVjLnksIHZlYy56LCB2ZWMudyApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0fSxcblxuICAgIFx0dXBkYXRlTWF0cml4V29ybGQ6IGZ1bmN0aW9uKCBmb3JjZSApIHtcblxuICAgIFx0XHRNZXNoLnByb3RvdHlwZS51cGRhdGVNYXRyaXhXb3JsZC5jYWxsKCB0aGlzLCB0cnVlICk7XG5cbiAgICBcdFx0aWYgKCB0aGlzLmJpbmRNb2RlID09PSBcImF0dGFjaGVkXCIgKSB7XG5cbiAgICBcdFx0XHR0aGlzLmJpbmRNYXRyaXhJbnZlcnNlLmdldEludmVyc2UoIHRoaXMubWF0cml4V29ybGQgKTtcblxuICAgIFx0XHR9IGVsc2UgaWYgKCB0aGlzLmJpbmRNb2RlID09PSBcImRldGFjaGVkXCIgKSB7XG5cbiAgICBcdFx0XHR0aGlzLmJpbmRNYXRyaXhJbnZlcnNlLmdldEludmVyc2UoIHRoaXMuYmluZE1hdHJpeCApO1xuXG4gICAgXHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Ta2lubmVkTWVzaCB1bnJlY29nbml6ZWQgYmluZE1vZGU6ICcgKyB0aGlzLmJpbmRNb2RlICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9LFxuXG4gICAgXHRjbG9uZTogZnVuY3Rpb24oKSB7XG5cbiAgICBcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLmdlb21ldHJ5LCB0aGlzLm1hdGVyaWFsLCB0aGlzLnNrZWxldG9uLnVzZVZlcnRleFRleHR1cmUgKS5jb3B5KCB0aGlzICk7XG5cbiAgICBcdH1cblxuICAgIH0gKTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gICAgICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAgICAgKlxuICAgICAqIHBhcmFtZXRlcnMgPSB7XG4gICAgICogIGNvbG9yOiA8aGV4PixcbiAgICAgKiAgb3BhY2l0eTogPGZsb2F0PixcbiAgICAgKlxuICAgICAqICBsaW5ld2lkdGg6IDxmbG9hdD4sXG4gICAgICogIGxpbmVjYXA6IFwicm91bmRcIixcbiAgICAgKiAgbGluZWpvaW46IFwicm91bmRcIlxuICAgICAqIH1cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIExpbmVCYXNpY01hdGVyaWFsKCBwYXJhbWV0ZXJzICkge1xuXG4gICAgXHRNYXRlcmlhbC5jYWxsKCB0aGlzICk7XG5cbiAgICBcdHRoaXMudHlwZSA9ICdMaW5lQmFzaWNNYXRlcmlhbCc7XG5cbiAgICBcdHRoaXMuY29sb3IgPSBuZXcgQ29sb3IoIDB4ZmZmZmZmICk7XG5cbiAgICBcdHRoaXMubGluZXdpZHRoID0gMTtcbiAgICBcdHRoaXMubGluZWNhcCA9ICdyb3VuZCc7XG4gICAgXHR0aGlzLmxpbmVqb2luID0gJ3JvdW5kJztcblxuICAgIFx0dGhpcy5saWdodHMgPSBmYWxzZTtcblxuICAgIFx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcblxuICAgIH1cblxuICAgIExpbmVCYXNpY01hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE1hdGVyaWFsLnByb3RvdHlwZSApO1xuICAgIExpbmVCYXNpY01hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExpbmVCYXNpY01hdGVyaWFsO1xuXG4gICAgTGluZUJhc2ljTWF0ZXJpYWwucHJvdG90eXBlLmlzTGluZUJhc2ljTWF0ZXJpYWwgPSB0cnVlO1xuXG4gICAgTGluZUJhc2ljTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuICAgIFx0TWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XG5cbiAgICBcdHRoaXMuY29sb3IuY29weSggc291cmNlLmNvbG9yICk7XG5cbiAgICBcdHRoaXMubGluZXdpZHRoID0gc291cmNlLmxpbmV3aWR0aDtcbiAgICBcdHRoaXMubGluZWNhcCA9IHNvdXJjZS5saW5lY2FwO1xuICAgIFx0dGhpcy5saW5lam9pbiA9IHNvdXJjZS5saW5lam9pbjtcblxuICAgIFx0cmV0dXJuIHRoaXM7XG5cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIExpbmUoIGdlb21ldHJ5LCBtYXRlcmlhbCwgbW9kZSApIHtcblxuICAgIFx0aWYgKCBtb2RlID09PSAxICkge1xuXG4gICAgXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkxpbmU6IHBhcmFtZXRlciBUSFJFRS5MaW5lUGllY2VzIG5vIGxvbmdlciBzdXBwb3J0ZWQuIENyZWF0ZWQgVEhSRUUuTGluZVNlZ21lbnRzIGluc3RlYWQuJyApO1xuICAgIFx0XHRyZXR1cm4gbmV3IExpbmVTZWdtZW50cyggZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cbiAgICBcdH1cblxuICAgIFx0T2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG4gICAgXHR0aGlzLnR5cGUgPSAnTGluZSc7XG5cbiAgICBcdHRoaXMuZ2VvbWV0cnkgPSBnZW9tZXRyeSAhPT0gdW5kZWZpbmVkID8gZ2VvbWV0cnkgOiBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcbiAgICBcdHRoaXMubWF0ZXJpYWwgPSBtYXRlcmlhbCAhPT0gdW5kZWZpbmVkID8gbWF0ZXJpYWwgOiBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZiB9ICk7XG5cbiAgICB9XG5cbiAgICBMaW5lLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIE9iamVjdDNELnByb3RvdHlwZSApLCB7XG5cbiAgICBcdGNvbnN0cnVjdG9yOiBMaW5lLFxuXG4gICAgXHRpc0xpbmU6IHRydWUsXG5cbiAgICBcdHJheWNhc3Q6ICggZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHZhciBpbnZlcnNlTWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcbiAgICBcdFx0dmFyIHJheSA9IG5ldyBSYXkoKTtcbiAgICBcdFx0dmFyIHNwaGVyZSA9IG5ldyBTcGhlcmUoKTtcblxuICAgIFx0XHRyZXR1cm4gZnVuY3Rpb24gcmF5Y2FzdCggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICkge1xuXG4gICAgXHRcdFx0dmFyIHByZWNpc2lvbiA9IHJheWNhc3Rlci5saW5lUHJlY2lzaW9uO1xuICAgIFx0XHRcdHZhciBwcmVjaXNpb25TcSA9IHByZWNpc2lvbiAqIHByZWNpc2lvbjtcblxuICAgIFx0XHRcdHZhciBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG4gICAgXHRcdFx0dmFyIG1hdHJpeFdvcmxkID0gdGhpcy5tYXRyaXhXb3JsZDtcblxuICAgIFx0XHRcdC8vIENoZWNraW5nIGJvdW5kaW5nU3BoZXJlIGRpc3RhbmNlIHRvIHJheVxuXG4gICAgXHRcdFx0aWYgKCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCApIGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xuXG4gICAgXHRcdFx0c3BoZXJlLmNvcHkoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlICk7XG4gICAgXHRcdFx0c3BoZXJlLmFwcGx5TWF0cml4NCggbWF0cml4V29ybGQgKTtcblxuICAgIFx0XHRcdGlmICggcmF5Y2FzdGVyLnJheS5pbnRlcnNlY3RzU3BoZXJlKCBzcGhlcmUgKSA9PT0gZmFsc2UgKSByZXR1cm47XG5cbiAgICBcdFx0XHQvL1xuXG4gICAgXHRcdFx0aW52ZXJzZU1hdHJpeC5nZXRJbnZlcnNlKCBtYXRyaXhXb3JsZCApO1xuICAgIFx0XHRcdHJheS5jb3B5KCByYXljYXN0ZXIucmF5ICkuYXBwbHlNYXRyaXg0KCBpbnZlcnNlTWF0cml4ICk7XG5cbiAgICBcdFx0XHR2YXIgdlN0YXJ0ID0gbmV3IFZlY3RvcjMoKTtcbiAgICBcdFx0XHR2YXIgdkVuZCA9IG5ldyBWZWN0b3IzKCk7XG4gICAgXHRcdFx0dmFyIGludGVyU2VnbWVudCA9IG5ldyBWZWN0b3IzKCk7XG4gICAgXHRcdFx0dmFyIGludGVyUmF5ID0gbmV3IFZlY3RvcjMoKTtcbiAgICBcdFx0XHR2YXIgc3RlcCA9ICh0aGlzICYmIHRoaXMuaXNMaW5lU2VnbWVudHMpID8gMiA6IDE7XG5cbiAgICBcdFx0XHRpZiAoIChnZW9tZXRyeSAmJiBnZW9tZXRyeS5pc0J1ZmZlckdlb21ldHJ5KSApIHtcblxuICAgIFx0XHRcdFx0dmFyIGluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XG4gICAgXHRcdFx0XHR2YXIgYXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XG4gICAgXHRcdFx0XHR2YXIgcG9zaXRpb25zID0gYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcblxuICAgIFx0XHRcdFx0aWYgKCBpbmRleCAhPT0gbnVsbCApIHtcblxuICAgIFx0XHRcdFx0XHR2YXIgaW5kaWNlcyA9IGluZGV4LmFycmF5O1xuXG4gICAgXHRcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGluZGljZXMubGVuZ3RoIC0gMTsgaSA8IGw7IGkgKz0gc3RlcCApIHtcblxuICAgIFx0XHRcdFx0XHRcdHZhciBhID0gaW5kaWNlc1sgaSBdO1xuICAgIFx0XHRcdFx0XHRcdHZhciBiID0gaW5kaWNlc1sgaSArIDEgXTtcblxuICAgIFx0XHRcdFx0XHRcdHZTdGFydC5mcm9tQXJyYXkoIHBvc2l0aW9ucywgYSAqIDMgKTtcbiAgICBcdFx0XHRcdFx0XHR2RW5kLmZyb21BcnJheSggcG9zaXRpb25zLCBiICogMyApO1xuXG4gICAgXHRcdFx0XHRcdFx0dmFyIGRpc3RTcSA9IHJheS5kaXN0YW5jZVNxVG9TZWdtZW50KCB2U3RhcnQsIHZFbmQsIGludGVyUmF5LCBpbnRlclNlZ21lbnQgKTtcblxuICAgIFx0XHRcdFx0XHRcdGlmICggZGlzdFNxID4gcHJlY2lzaW9uU3EgKSBjb250aW51ZTtcblxuICAgIFx0XHRcdFx0XHRcdGludGVyUmF5LmFwcGx5TWF0cml4NCggdGhpcy5tYXRyaXhXb3JsZCApOyAvL01vdmUgYmFjayB0byB3b3JsZCBzcGFjZSBmb3IgZGlzdGFuY2UgY2FsY3VsYXRpb25cblxuICAgIFx0XHRcdFx0XHRcdHZhciBkaXN0YW5jZSA9IHJheWNhc3Rlci5yYXkub3JpZ2luLmRpc3RhbmNlVG8oIGludGVyUmF5ICk7XG5cbiAgICBcdFx0XHRcdFx0XHRpZiAoIGRpc3RhbmNlIDwgcmF5Y2FzdGVyLm5lYXIgfHwgZGlzdGFuY2UgPiByYXljYXN0ZXIuZmFyICkgY29udGludWU7XG5cbiAgICBcdFx0XHRcdFx0XHRpbnRlcnNlY3RzLnB1c2goIHtcblxuICAgIFx0XHRcdFx0XHRcdFx0ZGlzdGFuY2U6IGRpc3RhbmNlLFxuICAgIFx0XHRcdFx0XHRcdFx0Ly8gV2hhdCBkbyB3ZSB3YW50PyBpbnRlcnNlY3Rpb24gcG9pbnQgb24gdGhlIHJheSBvciBvbiB0aGUgc2VnbWVudD8/XG4gICAgXHRcdFx0XHRcdFx0XHQvLyBwb2ludDogcmF5Y2FzdGVyLnJheS5hdCggZGlzdGFuY2UgKSxcbiAgICBcdFx0XHRcdFx0XHRcdHBvaW50OiBpbnRlclNlZ21lbnQuY2xvbmUoKS5hcHBseU1hdHJpeDQoIHRoaXMubWF0cml4V29ybGQgKSxcbiAgICBcdFx0XHRcdFx0XHRcdGluZGV4OiBpLFxuICAgIFx0XHRcdFx0XHRcdFx0ZmFjZTogbnVsbCxcbiAgICBcdFx0XHRcdFx0XHRcdGZhY2VJbmRleDogbnVsbCxcbiAgICBcdFx0XHRcdFx0XHRcdG9iamVjdDogdGhpc1xuXG4gICAgXHRcdFx0XHRcdFx0fSApO1xuXG4gICAgXHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBwb3NpdGlvbnMubGVuZ3RoIC8gMyAtIDE7IGkgPCBsOyBpICs9IHN0ZXAgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHR2U3RhcnQuZnJvbUFycmF5KCBwb3NpdGlvbnMsIDMgKiBpICk7XG4gICAgXHRcdFx0XHRcdFx0dkVuZC5mcm9tQXJyYXkoIHBvc2l0aW9ucywgMyAqIGkgKyAzICk7XG5cbiAgICBcdFx0XHRcdFx0XHR2YXIgZGlzdFNxID0gcmF5LmRpc3RhbmNlU3FUb1NlZ21lbnQoIHZTdGFydCwgdkVuZCwgaW50ZXJSYXksIGludGVyU2VnbWVudCApO1xuXG4gICAgXHRcdFx0XHRcdFx0aWYgKCBkaXN0U3EgPiBwcmVjaXNpb25TcSApIGNvbnRpbnVlO1xuXG4gICAgXHRcdFx0XHRcdFx0aW50ZXJSYXkuYXBwbHlNYXRyaXg0KCB0aGlzLm1hdHJpeFdvcmxkICk7IC8vTW92ZSBiYWNrIHRvIHdvcmxkIHNwYWNlIGZvciBkaXN0YW5jZSBjYWxjdWxhdGlvblxuXG4gICAgXHRcdFx0XHRcdFx0dmFyIGRpc3RhbmNlID0gcmF5Y2FzdGVyLnJheS5vcmlnaW4uZGlzdGFuY2VUbyggaW50ZXJSYXkgKTtcblxuICAgIFx0XHRcdFx0XHRcdGlmICggZGlzdGFuY2UgPCByYXljYXN0ZXIubmVhciB8fCBkaXN0YW5jZSA+IHJheWNhc3Rlci5mYXIgKSBjb250aW51ZTtcblxuICAgIFx0XHRcdFx0XHRcdGludGVyc2VjdHMucHVzaCgge1xuXG4gICAgXHRcdFx0XHRcdFx0XHRkaXN0YW5jZTogZGlzdGFuY2UsXG4gICAgXHRcdFx0XHRcdFx0XHQvLyBXaGF0IGRvIHdlIHdhbnQ/IGludGVyc2VjdGlvbiBwb2ludCBvbiB0aGUgcmF5IG9yIG9uIHRoZSBzZWdtZW50Pz9cbiAgICBcdFx0XHRcdFx0XHRcdC8vIHBvaW50OiByYXljYXN0ZXIucmF5LmF0KCBkaXN0YW5jZSApLFxuICAgIFx0XHRcdFx0XHRcdFx0cG9pbnQ6IGludGVyU2VnbWVudC5jbG9uZSgpLmFwcGx5TWF0cml4NCggdGhpcy5tYXRyaXhXb3JsZCApLFxuICAgIFx0XHRcdFx0XHRcdFx0aW5kZXg6IGksXG4gICAgXHRcdFx0XHRcdFx0XHRmYWNlOiBudWxsLFxuICAgIFx0XHRcdFx0XHRcdFx0ZmFjZUluZGV4OiBudWxsLFxuICAgIFx0XHRcdFx0XHRcdFx0b2JqZWN0OiB0aGlzXG5cbiAgICBcdFx0XHRcdFx0XHR9ICk7XG5cbiAgICBcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHR9IGVsc2UgaWYgKCAoZ2VvbWV0cnkgJiYgZ2VvbWV0cnkuaXNHZW9tZXRyeSkgKSB7XG5cbiAgICBcdFx0XHRcdHZhciB2ZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzO1xuICAgIFx0XHRcdFx0dmFyIG5iVmVydGljZXMgPSB2ZXJ0aWNlcy5sZW5ndGg7XG5cbiAgICBcdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IG5iVmVydGljZXMgLSAxOyBpICs9IHN0ZXAgKSB7XG5cbiAgICBcdFx0XHRcdFx0dmFyIGRpc3RTcSA9IHJheS5kaXN0YW5jZVNxVG9TZWdtZW50KCB2ZXJ0aWNlc1sgaSBdLCB2ZXJ0aWNlc1sgaSArIDEgXSwgaW50ZXJSYXksIGludGVyU2VnbWVudCApO1xuXG4gICAgXHRcdFx0XHRcdGlmICggZGlzdFNxID4gcHJlY2lzaW9uU3EgKSBjb250aW51ZTtcblxuICAgIFx0XHRcdFx0XHRpbnRlclJheS5hcHBseU1hdHJpeDQoIHRoaXMubWF0cml4V29ybGQgKTsgLy9Nb3ZlIGJhY2sgdG8gd29ybGQgc3BhY2UgZm9yIGRpc3RhbmNlIGNhbGN1bGF0aW9uXG5cbiAgICBcdFx0XHRcdFx0dmFyIGRpc3RhbmNlID0gcmF5Y2FzdGVyLnJheS5vcmlnaW4uZGlzdGFuY2VUbyggaW50ZXJSYXkgKTtcblxuICAgIFx0XHRcdFx0XHRpZiAoIGRpc3RhbmNlIDwgcmF5Y2FzdGVyLm5lYXIgfHwgZGlzdGFuY2UgPiByYXljYXN0ZXIuZmFyICkgY29udGludWU7XG5cbiAgICBcdFx0XHRcdFx0aW50ZXJzZWN0cy5wdXNoKCB7XG5cbiAgICBcdFx0XHRcdFx0XHRkaXN0YW5jZTogZGlzdGFuY2UsXG4gICAgXHRcdFx0XHRcdFx0Ly8gV2hhdCBkbyB3ZSB3YW50PyBpbnRlcnNlY3Rpb24gcG9pbnQgb24gdGhlIHJheSBvciBvbiB0aGUgc2VnbWVudD8/XG4gICAgXHRcdFx0XHRcdFx0Ly8gcG9pbnQ6IHJheWNhc3Rlci5yYXkuYXQoIGRpc3RhbmNlICksXG4gICAgXHRcdFx0XHRcdFx0cG9pbnQ6IGludGVyU2VnbWVudC5jbG9uZSgpLmFwcGx5TWF0cml4NCggdGhpcy5tYXRyaXhXb3JsZCApLFxuICAgIFx0XHRcdFx0XHRcdGluZGV4OiBpLFxuICAgIFx0XHRcdFx0XHRcdGZhY2U6IG51bGwsXG4gICAgXHRcdFx0XHRcdFx0ZmFjZUluZGV4OiBudWxsLFxuICAgIFx0XHRcdFx0XHRcdG9iamVjdDogdGhpc1xuXG4gICAgXHRcdFx0XHRcdH0gKTtcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH07XG5cbiAgICBcdH0oKSApLFxuXG4gICAgXHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy5nZW9tZXRyeSwgdGhpcy5tYXRlcmlhbCApLmNvcHkoIHRoaXMgKTtcblxuICAgIFx0fVxuXG4gICAgfSApO1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIExpbmVTZWdtZW50cyggZ2VvbWV0cnksIG1hdGVyaWFsICkge1xuXG4gICAgXHRMaW5lLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG4gICAgXHR0aGlzLnR5cGUgPSAnTGluZVNlZ21lbnRzJztcblxuICAgIH1cblxuICAgIExpbmVTZWdtZW50cy5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBMaW5lLnByb3RvdHlwZSApLCB7XG5cbiAgICBcdGNvbnN0cnVjdG9yOiBMaW5lU2VnbWVudHMsXG5cbiAgICBcdGlzTGluZVNlZ21lbnRzOiB0cnVlXG5cbiAgICB9ICk7XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICAgICAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gICAgICpcbiAgICAgKiBwYXJhbWV0ZXJzID0ge1xuICAgICAqICBjb2xvcjogPGhleD4sXG4gICAgICogIG9wYWNpdHk6IDxmbG9hdD4sXG4gICAgICogIG1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAgICAgKlxuICAgICAqICBzaXplOiA8ZmxvYXQ+LFxuICAgICAqICBzaXplQXR0ZW51YXRpb246IDxib29sPlxuICAgICAqIH1cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIFBvaW50c01hdGVyaWFsKCBwYXJhbWV0ZXJzICkge1xuXG4gICAgXHRNYXRlcmlhbC5jYWxsKCB0aGlzICk7XG5cbiAgICBcdHRoaXMudHlwZSA9ICdQb2ludHNNYXRlcmlhbCc7XG5cbiAgICBcdHRoaXMuY29sb3IgPSBuZXcgQ29sb3IoIDB4ZmZmZmZmICk7XG5cbiAgICBcdHRoaXMubWFwID0gbnVsbDtcblxuICAgIFx0dGhpcy5zaXplID0gMTtcbiAgICBcdHRoaXMuc2l6ZUF0dGVudWF0aW9uID0gdHJ1ZTtcblxuICAgIFx0dGhpcy5saWdodHMgPSBmYWxzZTtcblxuICAgIFx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcblxuICAgIH1cblxuICAgIFBvaW50c01hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE1hdGVyaWFsLnByb3RvdHlwZSApO1xuICAgIFBvaW50c01hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBvaW50c01hdGVyaWFsO1xuXG4gICAgUG9pbnRzTWF0ZXJpYWwucHJvdG90eXBlLmlzUG9pbnRzTWF0ZXJpYWwgPSB0cnVlO1xuXG4gICAgUG9pbnRzTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuICAgIFx0TWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XG5cbiAgICBcdHRoaXMuY29sb3IuY29weSggc291cmNlLmNvbG9yICk7XG5cbiAgICBcdHRoaXMubWFwID0gc291cmNlLm1hcDtcblxuICAgIFx0dGhpcy5zaXplID0gc291cmNlLnNpemU7XG4gICAgXHR0aGlzLnNpemVBdHRlbnVhdGlvbiA9IHNvdXJjZS5zaXplQXR0ZW51YXRpb247XG5cbiAgICBcdHJldHVybiB0aGlzO1xuXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBQb2ludHMoIGdlb21ldHJ5LCBtYXRlcmlhbCApIHtcblxuICAgIFx0T2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG4gICAgXHR0aGlzLnR5cGUgPSAnUG9pbnRzJztcblxuICAgIFx0dGhpcy5nZW9tZXRyeSA9IGdlb21ldHJ5ICE9PSB1bmRlZmluZWQgPyBnZW9tZXRyeSA6IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuICAgIFx0dGhpcy5tYXRlcmlhbCA9IG1hdGVyaWFsICE9PSB1bmRlZmluZWQgPyBtYXRlcmlhbCA6IG5ldyBQb2ludHNNYXRlcmlhbCggeyBjb2xvcjogTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmIH0gKTtcblxuICAgIH1cblxuICAgIFBvaW50cy5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBPYmplY3QzRC5wcm90b3R5cGUgKSwge1xuXG4gICAgXHRjb25zdHJ1Y3RvcjogUG9pbnRzLFxuXG4gICAgXHRpc1BvaW50czogdHJ1ZSxcblxuICAgIFx0cmF5Y2FzdDogKCBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dmFyIGludmVyc2VNYXRyaXggPSBuZXcgTWF0cml4NCgpO1xuICAgIFx0XHR2YXIgcmF5ID0gbmV3IFJheSgpO1xuICAgIFx0XHR2YXIgc3BoZXJlID0gbmV3IFNwaGVyZSgpO1xuXG4gICAgXHRcdHJldHVybiBmdW5jdGlvbiByYXljYXN0KCByYXljYXN0ZXIsIGludGVyc2VjdHMgKSB7XG5cbiAgICBcdFx0XHR2YXIgb2JqZWN0ID0gdGhpcztcbiAgICBcdFx0XHR2YXIgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuICAgIFx0XHRcdHZhciBtYXRyaXhXb3JsZCA9IHRoaXMubWF0cml4V29ybGQ7XG4gICAgXHRcdFx0dmFyIHRocmVzaG9sZCA9IHJheWNhc3Rlci5wYXJhbXMuUG9pbnRzLnRocmVzaG9sZDtcblxuICAgIFx0XHRcdC8vIENoZWNraW5nIGJvdW5kaW5nU3BoZXJlIGRpc3RhbmNlIHRvIHJheVxuXG4gICAgXHRcdFx0aWYgKCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCApIGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xuXG4gICAgXHRcdFx0c3BoZXJlLmNvcHkoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlICk7XG4gICAgXHRcdFx0c3BoZXJlLmFwcGx5TWF0cml4NCggbWF0cml4V29ybGQgKTtcblxuICAgIFx0XHRcdGlmICggcmF5Y2FzdGVyLnJheS5pbnRlcnNlY3RzU3BoZXJlKCBzcGhlcmUgKSA9PT0gZmFsc2UgKSByZXR1cm47XG5cbiAgICBcdFx0XHQvL1xuXG4gICAgXHRcdFx0aW52ZXJzZU1hdHJpeC5nZXRJbnZlcnNlKCBtYXRyaXhXb3JsZCApO1xuICAgIFx0XHRcdHJheS5jb3B5KCByYXljYXN0ZXIucmF5ICkuYXBwbHlNYXRyaXg0KCBpbnZlcnNlTWF0cml4ICk7XG5cbiAgICBcdFx0XHR2YXIgbG9jYWxUaHJlc2hvbGQgPSB0aHJlc2hvbGQgLyAoICggdGhpcy5zY2FsZS54ICsgdGhpcy5zY2FsZS55ICsgdGhpcy5zY2FsZS56ICkgLyAzICk7XG4gICAgXHRcdFx0dmFyIGxvY2FsVGhyZXNob2xkU3EgPSBsb2NhbFRocmVzaG9sZCAqIGxvY2FsVGhyZXNob2xkO1xuICAgIFx0XHRcdHZhciBwb3NpdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG5cbiAgICBcdFx0XHRmdW5jdGlvbiB0ZXN0UG9pbnQoIHBvaW50LCBpbmRleCApIHtcblxuICAgIFx0XHRcdFx0dmFyIHJheVBvaW50RGlzdGFuY2VTcSA9IHJheS5kaXN0YW5jZVNxVG9Qb2ludCggcG9pbnQgKTtcblxuICAgIFx0XHRcdFx0aWYgKCByYXlQb2ludERpc3RhbmNlU3EgPCBsb2NhbFRocmVzaG9sZFNxICkge1xuXG4gICAgXHRcdFx0XHRcdHZhciBpbnRlcnNlY3RQb2ludCA9IHJheS5jbG9zZXN0UG9pbnRUb1BvaW50KCBwb2ludCApO1xuICAgIFx0XHRcdFx0XHRpbnRlcnNlY3RQb2ludC5hcHBseU1hdHJpeDQoIG1hdHJpeFdvcmxkICk7XG5cbiAgICBcdFx0XHRcdFx0dmFyIGRpc3RhbmNlID0gcmF5Y2FzdGVyLnJheS5vcmlnaW4uZGlzdGFuY2VUbyggaW50ZXJzZWN0UG9pbnQgKTtcblxuICAgIFx0XHRcdFx0XHRpZiAoIGRpc3RhbmNlIDwgcmF5Y2FzdGVyLm5lYXIgfHwgZGlzdGFuY2UgPiByYXljYXN0ZXIuZmFyICkgcmV0dXJuO1xuXG4gICAgXHRcdFx0XHRcdGludGVyc2VjdHMucHVzaCgge1xuXG4gICAgXHRcdFx0XHRcdFx0ZGlzdGFuY2U6IGRpc3RhbmNlLFxuICAgIFx0XHRcdFx0XHRcdGRpc3RhbmNlVG9SYXk6IE1hdGguc3FydCggcmF5UG9pbnREaXN0YW5jZVNxICksXG4gICAgXHRcdFx0XHRcdFx0cG9pbnQ6IGludGVyc2VjdFBvaW50LmNsb25lKCksXG4gICAgXHRcdFx0XHRcdFx0aW5kZXg6IGluZGV4LFxuICAgIFx0XHRcdFx0XHRcdGZhY2U6IG51bGwsXG4gICAgXHRcdFx0XHRcdFx0b2JqZWN0OiBvYmplY3RcblxuICAgIFx0XHRcdFx0XHR9ICk7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdGlmICggKGdlb21ldHJ5ICYmIGdlb21ldHJ5LmlzQnVmZmVyR2VvbWV0cnkpICkge1xuXG4gICAgXHRcdFx0XHR2YXIgaW5kZXggPSBnZW9tZXRyeS5pbmRleDtcbiAgICBcdFx0XHRcdHZhciBhdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcbiAgICBcdFx0XHRcdHZhciBwb3NpdGlvbnMgPSBhdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xuXG4gICAgXHRcdFx0XHRpZiAoIGluZGV4ICE9PSBudWxsICkge1xuXG4gICAgXHRcdFx0XHRcdHZhciBpbmRpY2VzID0gaW5kZXguYXJyYXk7XG5cbiAgICBcdFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IGluZGljZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHR2YXIgYSA9IGluZGljZXNbIGkgXTtcblxuICAgIFx0XHRcdFx0XHRcdHBvc2l0aW9uLmZyb21BcnJheSggcG9zaXRpb25zLCBhICogMyApO1xuXG4gICAgXHRcdFx0XHRcdFx0dGVzdFBvaW50KCBwb3NpdGlvbiwgYSApO1xuXG4gICAgXHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBwb3NpdGlvbnMubGVuZ3RoIC8gMzsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHRwb3NpdGlvbi5mcm9tQXJyYXkoIHBvc2l0aW9ucywgaSAqIDMgKTtcblxuICAgIFx0XHRcdFx0XHRcdHRlc3RQb2ludCggcG9zaXRpb24sIGkgKTtcblxuICAgIFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdHZhciB2ZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzO1xuXG4gICAgXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB2ZXJ0aWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgXHRcdFx0XHRcdHRlc3RQb2ludCggdmVydGljZXNbIGkgXSwgaSApO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fTtcblxuICAgIFx0fSgpICksXG5cbiAgICBcdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLmdlb21ldHJ5LCB0aGlzLm1hdGVyaWFsICkuY29weSggdGhpcyApO1xuXG4gICAgXHR9XG5cbiAgICB9ICk7XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gR3JvdXAoKSB7XG5cbiAgICBcdE9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuICAgIFx0dGhpcy50eXBlID0gJ0dyb3VwJztcblxuICAgIH1cblxuICAgIEdyb3VwLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIE9iamVjdDNELnByb3RvdHlwZSApLCB7XG5cbiAgICBcdGNvbnN0cnVjdG9yOiBHcm91cFxuXG4gICAgfSApO1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIFZpZGVvVGV4dHVyZSggdmlkZW8sIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSApIHtcblxuICAgIFx0VGV4dHVyZS5jYWxsKCB0aGlzLCB2aWRlbywgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5ICk7XG5cbiAgICBcdHRoaXMuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XG5cbiAgICBcdHZhciBzY29wZSA9IHRoaXM7XG5cbiAgICBcdGZ1bmN0aW9uIHVwZGF0ZSgpIHtcblxuICAgIFx0XHRyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIHVwZGF0ZSApO1xuXG4gICAgXHRcdGlmICggdmlkZW8ucmVhZHlTdGF0ZSA+PSB2aWRlby5IQVZFX0NVUlJFTlRfREFUQSApIHtcblxuICAgIFx0XHRcdHNjb3BlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgIFx0XHR9XG5cbiAgICBcdH1cblxuICAgIFx0dXBkYXRlKCk7XG5cbiAgICB9XG5cbiAgICBWaWRlb1RleHR1cmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVGV4dHVyZS5wcm90b3R5cGUgKTtcbiAgICBWaWRlb1RleHR1cmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVmlkZW9UZXh0dXJlO1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIENvbXByZXNzZWRUZXh0dXJlKCBtaXBtYXBzLCB3aWR0aCwgaGVpZ2h0LCBmb3JtYXQsIHR5cGUsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGFuaXNvdHJvcHksIGVuY29kaW5nICkge1xuXG4gICAgXHRUZXh0dXJlLmNhbGwoIHRoaXMsIG51bGwsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSwgZW5jb2RpbmcgKTtcblxuICAgIFx0dGhpcy5pbWFnZSA9IHsgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9O1xuICAgIFx0dGhpcy5taXBtYXBzID0gbWlwbWFwcztcblxuICAgIFx0Ly8gbm8gZmxpcHBpbmcgZm9yIGN1YmUgdGV4dHVyZXNcbiAgICBcdC8vIChhbHNvIGZsaXBwaW5nIGRvZXNuJ3Qgd29yayBmb3IgY29tcHJlc3NlZCB0ZXh0dXJlcyApXG5cbiAgICBcdHRoaXMuZmxpcFkgPSBmYWxzZTtcblxuICAgIFx0Ly8gY2FuJ3QgZ2VuZXJhdGUgbWlwbWFwcyBmb3IgY29tcHJlc3NlZCB0ZXh0dXJlc1xuICAgIFx0Ly8gbWlwcyBtdXN0IGJlIGVtYmVkZGVkIGluIEREUyBmaWxlc1xuXG4gICAgXHR0aGlzLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuXG4gICAgfVxuXG4gICAgQ29tcHJlc3NlZFRleHR1cmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVGV4dHVyZS5wcm90b3R5cGUgKTtcbiAgICBDb21wcmVzc2VkVGV4dHVyZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb21wcmVzc2VkVGV4dHVyZTtcblxuICAgIENvbXByZXNzZWRUZXh0dXJlLnByb3RvdHlwZS5pc0NvbXByZXNzZWRUZXh0dXJlID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBDYW52YXNUZXh0dXJlKCBjYW52YXMsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSApIHtcblxuICAgIFx0VGV4dHVyZS5jYWxsKCB0aGlzLCBjYW52YXMsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSApO1xuXG4gICAgXHR0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgIH1cblxuICAgIENhbnZhc1RleHR1cmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVGV4dHVyZS5wcm90b3R5cGUgKTtcbiAgICBDYW52YXNUZXh0dXJlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENhbnZhc1RleHR1cmU7XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIE1hdHQgRGVzTGF1cmllcnMgLyBAbWF0dGRlc2xcbiAgICAgKiBAYXV0aG9yIGF0aXggLyBhcnRodXJzaWxiZXIuZGVcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIERlcHRoVGV4dHVyZSggd2lkdGgsIGhlaWdodCwgdHlwZSwgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgYW5pc290cm9weSwgZm9ybWF0ICkge1xuXG4gICAgXHRmb3JtYXQgPSBmb3JtYXQgIT09IHVuZGVmaW5lZCA/IGZvcm1hdCA6IERlcHRoRm9ybWF0O1xuXG4gICAgXHRpZiAoIGZvcm1hdCAhPT0gRGVwdGhGb3JtYXQgJiYgZm9ybWF0ICE9PSBEZXB0aFN0ZW5jaWxGb3JtYXQgKSB7XG5cbiAgICBcdFx0dGhyb3cgbmV3IEVycm9yKCAnRGVwdGhUZXh0dXJlIGZvcm1hdCBtdXN0IGJlIGVpdGhlciBUSFJFRS5EZXB0aEZvcm1hdCBvciBUSFJFRS5EZXB0aFN0ZW5jaWxGb3JtYXQnIClcblxuICAgIFx0fVxuXG4gICAgXHRUZXh0dXJlLmNhbGwoIHRoaXMsIG51bGwsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSApO1xuXG4gICAgXHR0aGlzLmltYWdlID0geyB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH07XG5cbiAgICBcdHRoaXMudHlwZSA9IHR5cGUgIT09IHVuZGVmaW5lZCA/IHR5cGUgOiBVbnNpZ25lZFNob3J0VHlwZTtcblxuICAgIFx0dGhpcy5tYWdGaWx0ZXIgPSBtYWdGaWx0ZXIgIT09IHVuZGVmaW5lZCA/IG1hZ0ZpbHRlciA6IE5lYXJlc3RGaWx0ZXI7XG4gICAgXHR0aGlzLm1pbkZpbHRlciA9IG1pbkZpbHRlciAhPT0gdW5kZWZpbmVkID8gbWluRmlsdGVyIDogTmVhcmVzdEZpbHRlcjtcblxuICAgIFx0dGhpcy5mbGlwWSA9IGZhbHNlO1xuICAgIFx0dGhpcy5nZW5lcmF0ZU1pcG1hcHNcdD0gZmFsc2U7XG5cbiAgICB9XG5cbiAgICBEZXB0aFRleHR1cmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVGV4dHVyZS5wcm90b3R5cGUgKTtcbiAgICBEZXB0aFRleHR1cmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRGVwdGhUZXh0dXJlO1xuICAgIERlcHRoVGV4dHVyZS5wcm90b3R5cGUuaXNEZXB0aFRleHR1cmUgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIFdpcmVmcmFtZUdlb21ldHJ5KCBnZW9tZXRyeSApIHtcblxuICAgIFx0QnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG4gICAgXHR2YXIgZWRnZSA9IFsgMCwgMCBdLCBoYXNoID0ge307XG5cbiAgICBcdGZ1bmN0aW9uIHNvcnRGdW5jdGlvbiggYSwgYiApIHtcblxuICAgIFx0XHRyZXR1cm4gYSAtIGI7XG5cbiAgICBcdH1cblxuICAgIFx0dmFyIGtleXMgPSBbICdhJywgJ2InLCAnYycgXTtcblxuICAgIFx0aWYgKCAoZ2VvbWV0cnkgJiYgZ2VvbWV0cnkuaXNHZW9tZXRyeSkgKSB7XG5cbiAgICBcdFx0dmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXM7XG4gICAgXHRcdHZhciBmYWNlcyA9IGdlb21ldHJ5LmZhY2VzO1xuICAgIFx0XHR2YXIgbnVtRWRnZXMgPSAwO1xuXG4gICAgXHRcdC8vIGFsbG9jYXRlIG1heGltYWwgc2l6ZVxuICAgIFx0XHR2YXIgZWRnZXMgPSBuZXcgVWludDMyQXJyYXkoIDYgKiBmYWNlcy5sZW5ndGggKTtcblxuICAgIFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBmYWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgXHRcdFx0dmFyIGZhY2UgPSBmYWNlc1sgaSBdO1xuXG4gICAgXHRcdFx0Zm9yICggdmFyIGogPSAwOyBqIDwgMzsgaiArKyApIHtcblxuICAgIFx0XHRcdFx0ZWRnZVsgMCBdID0gZmFjZVsga2V5c1sgaiBdIF07XG4gICAgXHRcdFx0XHRlZGdlWyAxIF0gPSBmYWNlWyBrZXlzWyAoIGogKyAxICkgJSAzIF0gXTtcbiAgICBcdFx0XHRcdGVkZ2Uuc29ydCggc29ydEZ1bmN0aW9uICk7XG5cbiAgICBcdFx0XHRcdHZhciBrZXkgPSBlZGdlLnRvU3RyaW5nKCk7XG5cbiAgICBcdFx0XHRcdGlmICggaGFzaFsga2V5IF0gPT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0XHRlZGdlc1sgMiAqIG51bUVkZ2VzIF0gPSBlZGdlWyAwIF07XG4gICAgXHRcdFx0XHRcdGVkZ2VzWyAyICogbnVtRWRnZXMgKyAxIF0gPSBlZGdlWyAxIF07XG4gICAgXHRcdFx0XHRcdGhhc2hbIGtleSBdID0gdHJ1ZTtcbiAgICBcdFx0XHRcdFx0bnVtRWRnZXMgKys7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdFx0dmFyIGNvb3JkcyA9IG5ldyBGbG9hdDMyQXJyYXkoIG51bUVkZ2VzICogMiAqIDMgKTtcblxuICAgIFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBudW1FZGdlczsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICBcdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPCAyOyBqICsrICkge1xuXG4gICAgXHRcdFx0XHR2YXIgdmVydGV4ID0gdmVydGljZXNbIGVkZ2VzIFsgMiAqIGkgKyBqIF0gXTtcblxuICAgIFx0XHRcdFx0dmFyIGluZGV4ID0gNiAqIGkgKyAzICogajtcbiAgICBcdFx0XHRcdGNvb3Jkc1sgaW5kZXggKyAwIF0gPSB2ZXJ0ZXgueDtcbiAgICBcdFx0XHRcdGNvb3Jkc1sgaW5kZXggKyAxIF0gPSB2ZXJ0ZXgueTtcbiAgICBcdFx0XHRcdGNvb3Jkc1sgaW5kZXggKyAyIF0gPSB2ZXJ0ZXguejtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIGNvb3JkcywgMyApICk7XG5cbiAgICBcdH0gZWxzZSBpZiAoIChnZW9tZXRyeSAmJiBnZW9tZXRyeS5pc0J1ZmZlckdlb21ldHJ5KSApIHtcblxuICAgIFx0XHRpZiAoIGdlb21ldHJ5LmluZGV4ICE9PSBudWxsICkge1xuXG4gICAgXHRcdFx0Ly8gSW5kZXhlZCBCdWZmZXJHZW9tZXRyeVxuXG4gICAgXHRcdFx0dmFyIGluZGljZXMgPSBnZW9tZXRyeS5pbmRleC5hcnJheTtcbiAgICBcdFx0XHR2YXIgdmVydGljZXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuICAgIFx0XHRcdHZhciBncm91cHMgPSBnZW9tZXRyeS5ncm91cHM7XG4gICAgXHRcdFx0dmFyIG51bUVkZ2VzID0gMDtcblxuICAgIFx0XHRcdGlmICggZ3JvdXBzLmxlbmd0aCA9PT0gMCApIHtcblxuICAgIFx0XHRcdFx0Z2VvbWV0cnkuYWRkR3JvdXAoIDAsIGluZGljZXMubGVuZ3RoICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHQvLyBhbGxvY2F0ZSBtYXhpbWFsIHNpemVcbiAgICBcdFx0XHR2YXIgZWRnZXMgPSBuZXcgVWludDMyQXJyYXkoIDIgKiBpbmRpY2VzLmxlbmd0aCApO1xuXG4gICAgXHRcdFx0Zm9yICggdmFyIG8gPSAwLCBvbCA9IGdyb3Vwcy5sZW5ndGg7IG8gPCBvbDsgKysgbyApIHtcblxuICAgIFx0XHRcdFx0dmFyIGdyb3VwID0gZ3JvdXBzWyBvIF07XG5cbiAgICBcdFx0XHRcdHZhciBzdGFydCA9IGdyb3VwLnN0YXJ0O1xuICAgIFx0XHRcdFx0dmFyIGNvdW50ID0gZ3JvdXAuY291bnQ7XG5cbiAgICBcdFx0XHRcdGZvciAoIHZhciBpID0gc3RhcnQsIGlsID0gc3RhcnQgKyBjb3VudDsgaSA8IGlsOyBpICs9IDMgKSB7XG5cbiAgICBcdFx0XHRcdFx0Zm9yICggdmFyIGogPSAwOyBqIDwgMzsgaiArKyApIHtcblxuICAgIFx0XHRcdFx0XHRcdGVkZ2VbIDAgXSA9IGluZGljZXNbIGkgKyBqIF07XG4gICAgXHRcdFx0XHRcdFx0ZWRnZVsgMSBdID0gaW5kaWNlc1sgaSArICggaiArIDEgKSAlIDMgXTtcbiAgICBcdFx0XHRcdFx0XHRlZGdlLnNvcnQoIHNvcnRGdW5jdGlvbiApO1xuXG4gICAgXHRcdFx0XHRcdFx0dmFyIGtleSA9IGVkZ2UudG9TdHJpbmcoKTtcblxuICAgIFx0XHRcdFx0XHRcdGlmICggaGFzaFsga2V5IF0gPT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0XHRcdFx0ZWRnZXNbIDIgKiBudW1FZGdlcyBdID0gZWRnZVsgMCBdO1xuICAgIFx0XHRcdFx0XHRcdFx0ZWRnZXNbIDIgKiBudW1FZGdlcyArIDEgXSA9IGVkZ2VbIDEgXTtcbiAgICBcdFx0XHRcdFx0XHRcdGhhc2hbIGtleSBdID0gdHJ1ZTtcbiAgICBcdFx0XHRcdFx0XHRcdG51bUVkZ2VzICsrO1xuXG4gICAgXHRcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0dmFyIGNvb3JkcyA9IG5ldyBGbG9hdDMyQXJyYXkoIG51bUVkZ2VzICogMiAqIDMgKTtcblxuICAgIFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IG51bUVkZ2VzOyBpIDwgbDsgaSArKyApIHtcblxuICAgIFx0XHRcdFx0Zm9yICggdmFyIGogPSAwOyBqIDwgMjsgaiArKyApIHtcblxuICAgIFx0XHRcdFx0XHR2YXIgaW5kZXggPSA2ICogaSArIDMgKiBqO1xuICAgIFx0XHRcdFx0XHR2YXIgaW5kZXgyID0gZWRnZXNbIDIgKiBpICsgaiBdO1xuXG4gICAgXHRcdFx0XHRcdGNvb3Jkc1sgaW5kZXggKyAwIF0gPSB2ZXJ0aWNlcy5nZXRYKCBpbmRleDIgKTtcbiAgICBcdFx0XHRcdFx0Y29vcmRzWyBpbmRleCArIDEgXSA9IHZlcnRpY2VzLmdldFkoIGluZGV4MiApO1xuICAgIFx0XHRcdFx0XHRjb29yZHNbIGluZGV4ICsgMiBdID0gdmVydGljZXMuZ2V0WiggaW5kZXgyICk7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgQnVmZmVyQXR0cmlidXRlKCBjb29yZHMsIDMgKSApO1xuXG4gICAgXHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHQvLyBub24taW5kZXhlZCBCdWZmZXJHZW9tZXRyeVxuXG4gICAgXHRcdFx0dmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcbiAgICBcdFx0XHR2YXIgbnVtRWRnZXMgPSB2ZXJ0aWNlcy5sZW5ndGggLyAzO1xuICAgIFx0XHRcdHZhciBudW1UcmlzID0gbnVtRWRnZXMgLyAzO1xuXG4gICAgXHRcdFx0dmFyIGNvb3JkcyA9IG5ldyBGbG9hdDMyQXJyYXkoIG51bUVkZ2VzICogMiAqIDMgKTtcblxuICAgIFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IG51bVRyaXM7IGkgPCBsOyBpICsrICkge1xuXG4gICAgXHRcdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPCAzOyBqICsrICkge1xuXG4gICAgXHRcdFx0XHRcdHZhciBpbmRleCA9IDE4ICogaSArIDYgKiBqO1xuXG4gICAgXHRcdFx0XHRcdHZhciBpbmRleDEgPSA5ICogaSArIDMgKiBqO1xuICAgIFx0XHRcdFx0XHRjb29yZHNbIGluZGV4ICsgMCBdID0gdmVydGljZXNbIGluZGV4MSBdO1xuICAgIFx0XHRcdFx0XHRjb29yZHNbIGluZGV4ICsgMSBdID0gdmVydGljZXNbIGluZGV4MSArIDEgXTtcbiAgICBcdFx0XHRcdFx0Y29vcmRzWyBpbmRleCArIDIgXSA9IHZlcnRpY2VzWyBpbmRleDEgKyAyIF07XG5cbiAgICBcdFx0XHRcdFx0dmFyIGluZGV4MiA9IDkgKiBpICsgMyAqICggKCBqICsgMSApICUgMyApO1xuICAgIFx0XHRcdFx0XHRjb29yZHNbIGluZGV4ICsgMyBdID0gdmVydGljZXNbIGluZGV4MiBdO1xuICAgIFx0XHRcdFx0XHRjb29yZHNbIGluZGV4ICsgNCBdID0gdmVydGljZXNbIGluZGV4MiArIDEgXTtcbiAgICBcdFx0XHRcdFx0Y29vcmRzWyBpbmRleCArIDUgXSA9IHZlcnRpY2VzWyBpbmRleDIgKyAyIF07XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgQnVmZmVyQXR0cmlidXRlKCBjb29yZHMsIDMgKSApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0fVxuXG4gICAgfVxuXG4gICAgV2lyZWZyYW1lR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XG4gICAgV2lyZWZyYW1lR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gV2lyZWZyYW1lR2VvbWV0cnk7XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIHp6ODUgLyBodHRwczovL2dpdGh1Yi5jb20veno4NVxuICAgICAqIFBhcmFtZXRyaWMgU3VyZmFjZXMgR2VvbWV0cnlcbiAgICAgKiBiYXNlZCBvbiB0aGUgYnJpbGxpYW50IGFydGljbGUgYnkgQHByaWRlb3V0IGh0dHA6Ly9wcmlkZW91dC5uZXQvYmxvZy8/cD00NFxuICAgICAqXG4gICAgICogbmV3IFRIUkVFLlBhcmFtZXRyaWNHZW9tZXRyeSggcGFyYW1ldHJpY0Z1bmN0aW9uLCB1U2VnbWVudHMsIHlTZWdlbWVudHMgKTtcbiAgICAgKlxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gUGFyYW1ldHJpY0dlb21ldHJ5KCBmdW5jLCBzbGljZXMsIHN0YWNrcyApIHtcblxuICAgIFx0R2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG4gICAgXHR0aGlzLnR5cGUgPSAnUGFyYW1ldHJpY0dlb21ldHJ5JztcblxuICAgIFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuICAgIFx0XHRmdW5jOiBmdW5jLFxuICAgIFx0XHRzbGljZXM6IHNsaWNlcyxcbiAgICBcdFx0c3RhY2tzOiBzdGFja3NcbiAgICBcdH07XG5cbiAgICBcdHZhciB2ZXJ0cyA9IHRoaXMudmVydGljZXM7XG4gICAgXHR2YXIgZmFjZXMgPSB0aGlzLmZhY2VzO1xuICAgIFx0dmFyIHV2cyA9IHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdO1xuXG4gICAgXHR2YXIgaSwgaiwgcDtcbiAgICBcdHZhciB1LCB2O1xuXG4gICAgXHR2YXIgc2xpY2VDb3VudCA9IHNsaWNlcyArIDE7XG5cbiAgICBcdGZvciAoIGkgPSAwOyBpIDw9IHN0YWNrczsgaSArKyApIHtcblxuICAgIFx0XHR2ID0gaSAvIHN0YWNrcztcblxuICAgIFx0XHRmb3IgKCBqID0gMDsgaiA8PSBzbGljZXM7IGogKysgKSB7XG5cbiAgICBcdFx0XHR1ID0gaiAvIHNsaWNlcztcblxuICAgIFx0XHRcdHAgPSBmdW5jKCB1LCB2ICk7XG4gICAgXHRcdFx0dmVydHMucHVzaCggcCApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0fVxuXG4gICAgXHR2YXIgYSwgYiwgYywgZDtcbiAgICBcdHZhciB1dmEsIHV2YiwgdXZjLCB1dmQ7XG5cbiAgICBcdGZvciAoIGkgPSAwOyBpIDwgc3RhY2tzOyBpICsrICkge1xuXG4gICAgXHRcdGZvciAoIGogPSAwOyBqIDwgc2xpY2VzOyBqICsrICkge1xuXG4gICAgXHRcdFx0YSA9IGkgKiBzbGljZUNvdW50ICsgajtcbiAgICBcdFx0XHRiID0gaSAqIHNsaWNlQ291bnQgKyBqICsgMTtcbiAgICBcdFx0XHRjID0gKCBpICsgMSApICogc2xpY2VDb3VudCArIGogKyAxO1xuICAgIFx0XHRcdGQgPSAoIGkgKyAxICkgKiBzbGljZUNvdW50ICsgajtcblxuICAgIFx0XHRcdHV2YSA9IG5ldyBWZWN0b3IyKCBqIC8gc2xpY2VzLCBpIC8gc3RhY2tzICk7XG4gICAgXHRcdFx0dXZiID0gbmV3IFZlY3RvcjIoICggaiArIDEgKSAvIHNsaWNlcywgaSAvIHN0YWNrcyApO1xuICAgIFx0XHRcdHV2YyA9IG5ldyBWZWN0b3IyKCAoIGogKyAxICkgLyBzbGljZXMsICggaSArIDEgKSAvIHN0YWNrcyApO1xuICAgIFx0XHRcdHV2ZCA9IG5ldyBWZWN0b3IyKCBqIC8gc2xpY2VzLCAoIGkgKyAxICkgLyBzdGFja3MgKTtcblxuICAgIFx0XHRcdGZhY2VzLnB1c2goIG5ldyBGYWNlMyggYSwgYiwgZCApICk7XG4gICAgXHRcdFx0dXZzLnB1c2goIFsgdXZhLCB1dmIsIHV2ZCBdICk7XG5cbiAgICBcdFx0XHRmYWNlcy5wdXNoKCBuZXcgRmFjZTMoIGIsIGMsIGQgKSApO1xuICAgIFx0XHRcdHV2cy5wdXNoKCBbIHV2Yi5jbG9uZSgpLCB1dmMsIHV2ZC5jbG9uZSgpIF0gKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdH1cblxuICAgIFx0Ly8gY29uc29sZS5sb2codGhpcyk7XG5cbiAgICBcdC8vIG1hZ2ljIGJ1bGxldFxuICAgIFx0Ly8gdmFyIGRpZmYgPSB0aGlzLm1lcmdlVmVydGljZXMoKTtcbiAgICBcdC8vIGNvbnNvbGUubG9nKCdyZW1vdmVkICcsIGRpZmYsICcgdmVydGljZXMgYnkgbWVyZ2luZycpO1xuXG4gICAgXHR0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xuICAgIFx0dGhpcy5jb21wdXRlVmVydGV4Tm9ybWFscygpO1xuXG4gICAgfVxuXG4gICAgUGFyYW1ldHJpY0dlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEdlb21ldHJ5LnByb3RvdHlwZSApO1xuICAgIFBhcmFtZXRyaWNHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQYXJhbWV0cmljR2VvbWV0cnk7XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIGNsb2Nrd29ya2dlZWsgLyBodHRwczovL2dpdGh1Yi5jb20vY2xvY2t3b3JrZ2Vla1xuICAgICAqIEBhdXRob3IgdGltb3RoeXByYXRsZXkgLyBodHRwczovL2dpdGh1Yi5jb20vdGltb3RoeXByYXRsZXlcbiAgICAgKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAgICAqL1xuXG4gICAgZnVuY3Rpb24gUG9seWhlZHJvbkdlb21ldHJ5KCB2ZXJ0aWNlcywgaW5kaWNlcywgcmFkaXVzLCBkZXRhaWwgKSB7XG5cbiAgICBcdEdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuICAgIFx0dGhpcy50eXBlID0gJ1BvbHloZWRyb25HZW9tZXRyeSc7XG5cbiAgICBcdHRoaXMucGFyYW1ldGVycyA9IHtcbiAgICBcdFx0dmVydGljZXM6IHZlcnRpY2VzLFxuICAgIFx0XHRpbmRpY2VzOiBpbmRpY2VzLFxuICAgIFx0XHRyYWRpdXM6IHJhZGl1cyxcbiAgICBcdFx0ZGV0YWlsOiBkZXRhaWxcbiAgICBcdH07XG5cbiAgICBcdHJhZGl1cyA9IHJhZGl1cyB8fCAxO1xuICAgIFx0ZGV0YWlsID0gZGV0YWlsIHx8IDA7XG5cbiAgICBcdHZhciB0aGF0ID0gdGhpcztcblxuICAgIFx0Zm9yICggdmFyIGkgPSAwLCBsID0gdmVydGljZXMubGVuZ3RoOyBpIDwgbDsgaSArPSAzICkge1xuXG4gICAgXHRcdHByZXBhcmUoIG5ldyBWZWN0b3IzKCB2ZXJ0aWNlc1sgaSBdLCB2ZXJ0aWNlc1sgaSArIDEgXSwgdmVydGljZXNbIGkgKyAyIF0gKSApO1xuXG4gICAgXHR9XG5cbiAgICBcdHZhciBwID0gdGhpcy52ZXJ0aWNlcztcblxuICAgIFx0dmFyIGZhY2VzID0gW107XG5cbiAgICBcdGZvciAoIHZhciBpID0gMCwgaiA9IDAsIGwgPSBpbmRpY2VzLmxlbmd0aDsgaSA8IGw7IGkgKz0gMywgaiArKyApIHtcblxuICAgIFx0XHR2YXIgdjEgPSBwWyBpbmRpY2VzWyBpIF0gXTtcbiAgICBcdFx0dmFyIHYyID0gcFsgaW5kaWNlc1sgaSArIDEgXSBdO1xuICAgIFx0XHR2YXIgdjMgPSBwWyBpbmRpY2VzWyBpICsgMiBdIF07XG5cbiAgICBcdFx0ZmFjZXNbIGogXSA9IG5ldyBGYWNlMyggdjEuaW5kZXgsIHYyLmluZGV4LCB2My5pbmRleCwgWyB2MS5jbG9uZSgpLCB2Mi5jbG9uZSgpLCB2My5jbG9uZSgpIF0gKTtcblxuICAgIFx0fVxuXG4gICAgXHR2YXIgY2VudHJvaWQgPSBuZXcgVmVjdG9yMygpO1xuXG4gICAgXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBmYWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgXHRcdHN1YmRpdmlkZSggZmFjZXNbIGkgXSwgZGV0YWlsICk7XG5cbiAgICBcdH1cblxuXG4gICAgXHQvLyBIYW5kbGUgY2FzZSB3aGVuIGZhY2Ugc3RyYWRkbGVzIHRoZSBzZWFtXG5cbiAgICBcdGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICBcdFx0dmFyIHV2cyA9IHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdWyBpIF07XG5cbiAgICBcdFx0dmFyIHgwID0gdXZzWyAwIF0ueDtcbiAgICBcdFx0dmFyIHgxID0gdXZzWyAxIF0ueDtcbiAgICBcdFx0dmFyIHgyID0gdXZzWyAyIF0ueDtcblxuICAgIFx0XHR2YXIgbWF4ID0gTWF0aC5tYXgoIHgwLCB4MSwgeDIgKTtcbiAgICBcdFx0dmFyIG1pbiA9IE1hdGgubWluKCB4MCwgeDEsIHgyICk7XG5cbiAgICBcdFx0aWYgKCBtYXggPiAwLjkgJiYgbWluIDwgMC4xICkge1xuXG4gICAgXHRcdFx0Ly8gMC45IGlzIHNvbWV3aGF0IGFyYml0cmFyeVxuXG4gICAgXHRcdFx0aWYgKCB4MCA8IDAuMiApIHV2c1sgMCBdLnggKz0gMTtcbiAgICBcdFx0XHRpZiAoIHgxIDwgMC4yICkgdXZzWyAxIF0ueCArPSAxO1xuICAgIFx0XHRcdGlmICggeDIgPCAwLjIgKSB1dnNbIDIgXS54ICs9IDE7XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9XG5cblxuICAgIFx0Ly8gQXBwbHkgcmFkaXVzXG5cbiAgICBcdGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMudmVydGljZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgIFx0XHR0aGlzLnZlcnRpY2VzWyBpIF0ubXVsdGlwbHlTY2FsYXIoIHJhZGl1cyApO1xuXG4gICAgXHR9XG5cblxuICAgIFx0Ly8gTWVyZ2UgdmVydGljZXNcblxuICAgIFx0dGhpcy5tZXJnZVZlcnRpY2VzKCk7XG5cbiAgICBcdHRoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XG5cbiAgICBcdHRoaXMuYm91bmRpbmdTcGhlcmUgPSBuZXcgU3BoZXJlKCBuZXcgVmVjdG9yMygpLCByYWRpdXMgKTtcblxuXG4gICAgXHQvLyBQcm9qZWN0IHZlY3RvciBvbnRvIHNwaGVyZSdzIHN1cmZhY2VcblxuICAgIFx0ZnVuY3Rpb24gcHJlcGFyZSggdmVjdG9yICkge1xuXG4gICAgXHRcdHZhciB2ZXJ0ZXggPSB2ZWN0b3Iubm9ybWFsaXplKCkuY2xvbmUoKTtcbiAgICBcdFx0dmVydGV4LmluZGV4ID0gdGhhdC52ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXggKSAtIDE7XG5cbiAgICBcdFx0Ly8gVGV4dHVyZSBjb29yZHMgYXJlIGVxdWl2YWxlbnQgdG8gbWFwIGNvb3JkcywgY2FsY3VsYXRlIGFuZ2xlIGFuZCBjb252ZXJ0IHRvIGZyYWN0aW9uIG9mIGEgY2lyY2xlLlxuXG4gICAgXHRcdHZhciB1ID0gYXppbXV0aCggdmVjdG9yICkgLyAyIC8gTWF0aC5QSSArIDAuNTtcbiAgICBcdFx0dmFyIHYgPSBpbmNsaW5hdGlvbiggdmVjdG9yICkgLyBNYXRoLlBJICsgMC41O1xuICAgIFx0XHR2ZXJ0ZXgudXYgPSBuZXcgVmVjdG9yMiggdSwgMSAtIHYgKTtcblxuICAgIFx0XHRyZXR1cm4gdmVydGV4O1xuXG4gICAgXHR9XG5cblxuICAgIFx0Ly8gQXBwcm94aW1hdGUgYSBjdXJ2ZWQgZmFjZSB3aXRoIHJlY3Vyc2l2ZWx5IHN1Yi1kaXZpZGVkIHRyaWFuZ2xlcy5cblxuICAgIFx0ZnVuY3Rpb24gbWFrZSggdjEsIHYyLCB2MyApIHtcblxuICAgIFx0XHR2YXIgZmFjZSA9IG5ldyBGYWNlMyggdjEuaW5kZXgsIHYyLmluZGV4LCB2My5pbmRleCwgWyB2MS5jbG9uZSgpLCB2Mi5jbG9uZSgpLCB2My5jbG9uZSgpIF0gKTtcbiAgICBcdFx0dGhhdC5mYWNlcy5wdXNoKCBmYWNlICk7XG5cbiAgICBcdFx0Y2VudHJvaWQuY29weSggdjEgKS5hZGQoIHYyICkuYWRkKCB2MyApLmRpdmlkZVNjYWxhciggMyApO1xuXG4gICAgXHRcdHZhciBhemkgPSBhemltdXRoKCBjZW50cm9pZCApO1xuXG4gICAgXHRcdHRoYXQuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFtcbiAgICBcdFx0XHRjb3JyZWN0VVYoIHYxLnV2LCB2MSwgYXppICksXG4gICAgXHRcdFx0Y29ycmVjdFVWKCB2Mi51diwgdjIsIGF6aSApLFxuICAgIFx0XHRcdGNvcnJlY3RVViggdjMudXYsIHYzLCBhemkgKVxuICAgIFx0XHRdICk7XG5cbiAgICBcdH1cblxuXG4gICAgXHQvLyBBbmFseXRpY2FsbHkgc3ViZGl2aWRlIGEgZmFjZSB0byB0aGUgcmVxdWlyZWQgZGV0YWlsIGxldmVsLlxuXG4gICAgXHRmdW5jdGlvbiBzdWJkaXZpZGUoIGZhY2UsIGRldGFpbCApIHtcblxuICAgIFx0XHR2YXIgY29scyA9IE1hdGgucG93KCAyLCBkZXRhaWwgKTtcbiAgICBcdFx0dmFyIGEgPSBwcmVwYXJlKCB0aGF0LnZlcnRpY2VzWyBmYWNlLmEgXSApO1xuICAgIFx0XHR2YXIgYiA9IHByZXBhcmUoIHRoYXQudmVydGljZXNbIGZhY2UuYiBdICk7XG4gICAgXHRcdHZhciBjID0gcHJlcGFyZSggdGhhdC52ZXJ0aWNlc1sgZmFjZS5jIF0gKTtcbiAgICBcdFx0dmFyIHYgPSBbXTtcblxuICAgIFx0XHQvLyBDb25zdHJ1Y3QgYWxsIG9mIHRoZSB2ZXJ0aWNlcyBmb3IgdGhpcyBzdWJkaXZpc2lvbi5cblxuICAgIFx0XHRmb3IgKCB2YXIgaSA9IDAgOyBpIDw9IGNvbHM7IGkgKysgKSB7XG5cbiAgICBcdFx0XHR2WyBpIF0gPSBbXTtcblxuICAgIFx0XHRcdHZhciBhaiA9IHByZXBhcmUoIGEuY2xvbmUoKS5sZXJwKCBjLCBpIC8gY29scyApICk7XG4gICAgXHRcdFx0dmFyIGJqID0gcHJlcGFyZSggYi5jbG9uZSgpLmxlcnAoIGMsIGkgLyBjb2xzICkgKTtcbiAgICBcdFx0XHR2YXIgcm93cyA9IGNvbHMgLSBpO1xuXG4gICAgXHRcdFx0Zm9yICggdmFyIGogPSAwOyBqIDw9IHJvd3M7IGogKysgKSB7XG5cbiAgICBcdFx0XHRcdGlmICggaiA9PT0gMCAmJiBpID09PSBjb2xzICkge1xuXG4gICAgXHRcdFx0XHRcdHZbIGkgXVsgaiBdID0gYWo7XG5cbiAgICBcdFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdFx0dlsgaSBdWyBqIF0gPSBwcmVwYXJlKCBhai5jbG9uZSgpLmxlcnAoIGJqLCBqIC8gcm93cyApICk7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdFx0Ly8gQ29uc3RydWN0IGFsbCBvZiB0aGUgZmFjZXMuXG5cbiAgICBcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgY29scyA7IGkgKysgKSB7XG5cbiAgICBcdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPCAyICogKCBjb2xzIC0gaSApIC0gMTsgaiArKyApIHtcblxuICAgIFx0XHRcdFx0dmFyIGsgPSBNYXRoLmZsb29yKCBqIC8gMiApO1xuXG4gICAgXHRcdFx0XHRpZiAoIGogJSAyID09PSAwICkge1xuXG4gICAgXHRcdFx0XHRcdG1ha2UoXG4gICAgXHRcdFx0XHRcdFx0dlsgaSBdWyBrICsgMSBdLFxuICAgIFx0XHRcdFx0XHRcdHZbIGkgKyAxIF1bIGsgXSxcbiAgICBcdFx0XHRcdFx0XHR2WyBpIF1bIGsgXVxuICAgIFx0XHRcdFx0XHQpO1xuXG4gICAgXHRcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHRcdG1ha2UoXG4gICAgXHRcdFx0XHRcdFx0dlsgaSBdWyBrICsgMSBdLFxuICAgIFx0XHRcdFx0XHRcdHZbIGkgKyAxIF1bIGsgKyAxIF0sXG4gICAgXHRcdFx0XHRcdFx0dlsgaSArIDEgXVsgayBdXG4gICAgXHRcdFx0XHRcdCk7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdH1cblxuXG4gICAgXHQvLyBBbmdsZSBhcm91bmQgdGhlIFkgYXhpcywgY291bnRlci1jbG9ja3dpc2Ugd2hlbiBsb29raW5nIGZyb20gYWJvdmUuXG5cbiAgICBcdGZ1bmN0aW9uIGF6aW11dGgoIHZlY3RvciApIHtcblxuICAgIFx0XHRyZXR1cm4gTWF0aC5hdGFuMiggdmVjdG9yLnosIC0gdmVjdG9yLnggKTtcblxuICAgIFx0fVxuXG5cbiAgICBcdC8vIEFuZ2xlIGFib3ZlIHRoZSBYWiBwbGFuZS5cblxuICAgIFx0ZnVuY3Rpb24gaW5jbGluYXRpb24oIHZlY3RvciApIHtcblxuICAgIFx0XHRyZXR1cm4gTWF0aC5hdGFuMiggLSB2ZWN0b3IueSwgTWF0aC5zcXJ0KCAoIHZlY3Rvci54ICogdmVjdG9yLnggKSArICggdmVjdG9yLnogKiB2ZWN0b3IueiApICkgKTtcblxuICAgIFx0fVxuXG5cbiAgICBcdC8vIFRleHR1cmUgZml4aW5nIGhlbHBlci4gU3BoZXJlcyBoYXZlIHNvbWUgb2RkIGJlaGF2aW91cnMuXG5cbiAgICBcdGZ1bmN0aW9uIGNvcnJlY3RVViggdXYsIHZlY3RvciwgYXppbXV0aCApIHtcblxuICAgIFx0XHRpZiAoICggYXppbXV0aCA8IDAgKSAmJiAoIHV2LnggPT09IDEgKSApIHV2ID0gbmV3IFZlY3RvcjIoIHV2LnggLSAxLCB1di55ICk7XG4gICAgXHRcdGlmICggKCB2ZWN0b3IueCA9PT0gMCApICYmICggdmVjdG9yLnogPT09IDAgKSApIHV2ID0gbmV3IFZlY3RvcjIoIGF6aW11dGggLyAyIC8gTWF0aC5QSSArIDAuNSwgdXYueSApO1xuICAgIFx0XHRyZXR1cm4gdXYuY2xvbmUoKTtcblxuICAgIFx0fVxuXG4gICAgfVxuXG4gICAgUG9seWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEdlb21ldHJ5LnByb3RvdHlwZSApO1xuICAgIFBvbHloZWRyb25HZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQb2x5aGVkcm9uR2VvbWV0cnk7XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIHRpbW90aHlwcmF0bGV5IC8gaHR0cHM6Ly9naXRodWIuY29tL3RpbW90aHlwcmF0bGV5XG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBUZXRyYWhlZHJvbkdlb21ldHJ5KCByYWRpdXMsIGRldGFpbCApIHtcblxuICAgIFx0dmFyIHZlcnRpY2VzID0gW1xuICAgIFx0XHQgMSwgIDEsICAxLCAgIC0gMSwgLSAxLCAgMSwgICAtIDEsICAxLCAtIDEsICAgIDEsIC0gMSwgLSAxXG4gICAgXHRdO1xuXG4gICAgXHR2YXIgaW5kaWNlcyA9IFtcbiAgICBcdFx0IDIsICAxLCAgMCwgICAgMCwgIDMsICAyLCAgICAxLCAgMywgIDAsICAgIDIsICAzLCAgMVxuICAgIFx0XTtcblxuICAgIFx0UG9seWhlZHJvbkdlb21ldHJ5LmNhbGwoIHRoaXMsIHZlcnRpY2VzLCBpbmRpY2VzLCByYWRpdXMsIGRldGFpbCApO1xuXG4gICAgXHR0aGlzLnR5cGUgPSAnVGV0cmFoZWRyb25HZW9tZXRyeSc7XG5cbiAgICBcdHRoaXMucGFyYW1ldGVycyA9IHtcbiAgICBcdFx0cmFkaXVzOiByYWRpdXMsXG4gICAgXHRcdGRldGFpbDogZGV0YWlsXG4gICAgXHR9O1xuXG4gICAgfVxuXG4gICAgVGV0cmFoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBQb2x5aGVkcm9uR2VvbWV0cnkucHJvdG90eXBlICk7XG4gICAgVGV0cmFoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUZXRyYWhlZHJvbkdlb21ldHJ5O1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciB0aW1vdGh5cHJhdGxleSAvIGh0dHBzOi8vZ2l0aHViLmNvbS90aW1vdGh5cHJhdGxleVxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gT2N0YWhlZHJvbkdlb21ldHJ5KCByYWRpdXMsIGRldGFpbCApIHtcblxuICAgIFx0dmFyIHZlcnRpY2VzID0gW1xuICAgIFx0XHQxLCAwLCAwLCAgIC0gMSwgMCwgMCwgICAgMCwgMSwgMCwgICAgMCwgLSAxLCAwLCAgICAwLCAwLCAxLCAgICAwLCAwLCAtIDFcbiAgICBcdF07XG5cbiAgICBcdHZhciBpbmRpY2VzID0gW1xuICAgIFx0XHQwLCAyLCA0LCAgICAwLCA0LCAzLCAgICAwLCAzLCA1LCAgICAwLCA1LCAyLCAgICAxLCAyLCA1LCAgICAxLCA1LCAzLCAgICAxLCAzLCA0LCAgICAxLCA0LCAyXG4gICAgXHRdO1xuXG4gICAgXHRQb2x5aGVkcm9uR2VvbWV0cnkuY2FsbCggdGhpcywgdmVydGljZXMsIGluZGljZXMsIHJhZGl1cywgZGV0YWlsICk7XG5cbiAgICBcdHRoaXMudHlwZSA9ICdPY3RhaGVkcm9uR2VvbWV0cnknO1xuXG4gICAgXHR0aGlzLnBhcmFtZXRlcnMgPSB7XG4gICAgXHRcdHJhZGl1czogcmFkaXVzLFxuICAgIFx0XHRkZXRhaWw6IGRldGFpbFxuICAgIFx0fTtcblxuICAgIH1cblxuICAgIE9jdGFoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBQb2x5aGVkcm9uR2VvbWV0cnkucHJvdG90eXBlICk7XG4gICAgT2N0YWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE9jdGFoZWRyb25HZW9tZXRyeTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgdGltb3RoeXByYXRsZXkgLyBodHRwczovL2dpdGh1Yi5jb20vdGltb3RoeXByYXRsZXlcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIEljb3NhaGVkcm9uR2VvbWV0cnkoIHJhZGl1cywgZGV0YWlsICkge1xuXG4gICAgXHR2YXIgdCA9ICggMSArIE1hdGguc3FydCggNSApICkgLyAyO1xuXG4gICAgXHR2YXIgdmVydGljZXMgPSBbXG4gICAgXHRcdC0gMSwgIHQsICAwLCAgICAxLCAgdCwgIDAsICAgLSAxLCAtIHQsICAwLCAgICAxLCAtIHQsICAwLFxuICAgIFx0XHQgMCwgLSAxLCAgdCwgICAgMCwgIDEsICB0LCAgICAwLCAtIDEsIC0gdCwgICAgMCwgIDEsIC0gdCxcbiAgICBcdFx0IHQsICAwLCAtIDEsICAgIHQsICAwLCAgMSwgICAtIHQsICAwLCAtIDEsICAgLSB0LCAgMCwgIDFcbiAgICBcdF07XG5cbiAgICBcdHZhciBpbmRpY2VzID0gW1xuICAgIFx0XHQgMCwgMTEsICA1LCAgICAwLCAgNSwgIDEsICAgIDAsICAxLCAgNywgICAgMCwgIDcsIDEwLCAgICAwLCAxMCwgMTEsXG4gICAgXHRcdCAxLCAgNSwgIDksICAgIDUsIDExLCAgNCwgICAxMSwgMTAsICAyLCAgIDEwLCAgNywgIDYsICAgIDcsICAxLCAgOCxcbiAgICBcdFx0IDMsICA5LCAgNCwgICAgMywgIDQsICAyLCAgICAzLCAgMiwgIDYsICAgIDMsICA2LCAgOCwgICAgMywgIDgsICA5LFxuICAgIFx0XHQgNCwgIDksICA1LCAgICAyLCAgNCwgMTEsICAgIDYsICAyLCAxMCwgICAgOCwgIDYsICA3LCAgICA5LCAgOCwgIDFcbiAgICBcdF07XG5cbiAgICBcdFBvbHloZWRyb25HZW9tZXRyeS5jYWxsKCB0aGlzLCB2ZXJ0aWNlcywgaW5kaWNlcywgcmFkaXVzLCBkZXRhaWwgKTtcblxuICAgIFx0dGhpcy50eXBlID0gJ0ljb3NhaGVkcm9uR2VvbWV0cnknO1xuXG4gICAgXHR0aGlzLnBhcmFtZXRlcnMgPSB7XG4gICAgXHRcdHJhZGl1czogcmFkaXVzLFxuICAgIFx0XHRkZXRhaWw6IGRldGFpbFxuICAgIFx0fTtcblxuICAgIH1cblxuICAgIEljb3NhaGVkcm9uR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggUG9seWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZSApO1xuICAgIEljb3NhaGVkcm9uR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSWNvc2FoZWRyb25HZW9tZXRyeTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgQWJlIFBhem9zIC8gaHR0cHM6Ly9oYW1vaWQuY29tXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBEb2RlY2FoZWRyb25HZW9tZXRyeSggcmFkaXVzLCBkZXRhaWwgKSB7XG5cbiAgICBcdHZhciB0ID0gKCAxICsgTWF0aC5zcXJ0KCA1ICkgKSAvIDI7XG4gICAgXHR2YXIgciA9IDEgLyB0O1xuXG4gICAgXHR2YXIgdmVydGljZXMgPSBbXG5cbiAgICBcdFx0Ly8gKMKxMSwgwrExLCDCsTEpXG4gICAgXHRcdC0gMSwgLSAxLCAtIDEsICAgIC0gMSwgLSAxLCAgMSxcbiAgICBcdFx0LSAxLCAgMSwgLSAxLCAgICAtIDEsICAxLCAgMSxcbiAgICBcdFx0IDEsIC0gMSwgLSAxLCAgICAgMSwgLSAxLCAgMSxcbiAgICBcdFx0IDEsICAxLCAtIDEsICAgICAxLCAgMSwgIDEsXG5cbiAgICBcdFx0Ly8gKDAsIMKxMS/PhiwgwrHPhilcbiAgICBcdFx0IDAsIC0gciwgLSB0LCAgICAgMCwgLSByLCAgdCxcbiAgICBcdFx0IDAsICByLCAtIHQsICAgICAwLCAgciwgIHQsXG5cbiAgICBcdFx0Ly8gKMKxMS/PhiwgwrHPhiwgMClcbiAgICBcdFx0LSByLCAtIHQsICAwLCAgICAtIHIsICB0LCAgMCxcbiAgICBcdFx0IHIsIC0gdCwgIDAsICAgICByLCAgdCwgIDAsXG5cbiAgICBcdFx0Ly8gKMKxz4YsIDAsIMKxMS/PhilcbiAgICBcdFx0LSB0LCAgMCwgLSByLCAgICAgdCwgIDAsIC0gcixcbiAgICBcdFx0LSB0LCAgMCwgIHIsICAgICB0LCAgMCwgIHJcbiAgICBcdF07XG5cbiAgICBcdHZhciBpbmRpY2VzID0gW1xuICAgIFx0XHQgMywgMTEsICA3LCAgICAgIDMsICA3LCAxNSwgICAgICAzLCAxNSwgMTMsXG4gICAgXHRcdCA3LCAxOSwgMTcsICAgICAgNywgMTcsICA2LCAgICAgIDcsICA2LCAxNSxcbiAgICBcdFx0MTcsICA0LCAgOCwgICAgIDE3LCAgOCwgMTAsICAgICAxNywgMTAsICA2LFxuICAgIFx0XHQgOCwgIDAsIDE2LCAgICAgIDgsIDE2LCAgMiwgICAgICA4LCAgMiwgMTAsXG4gICAgXHRcdCAwLCAxMiwgIDEsICAgICAgMCwgIDEsIDE4LCAgICAgIDAsIDE4LCAxNixcbiAgICBcdFx0IDYsIDEwLCAgMiwgICAgICA2LCAgMiwgMTMsICAgICAgNiwgMTMsIDE1LFxuICAgIFx0XHQgMiwgMTYsIDE4LCAgICAgIDIsIDE4LCAgMywgICAgICAyLCAgMywgMTMsXG4gICAgXHRcdDE4LCAgMSwgIDksICAgICAxOCwgIDksIDExLCAgICAgMTgsIDExLCAgMyxcbiAgICBcdFx0IDQsIDE0LCAxMiwgICAgICA0LCAxMiwgIDAsICAgICAgNCwgIDAsICA4LFxuICAgIFx0XHQxMSwgIDksICA1LCAgICAgMTEsICA1LCAxOSwgICAgIDExLCAxOSwgIDcsXG4gICAgXHRcdDE5LCAgNSwgMTQsICAgICAxOSwgMTQsICA0LCAgICAgMTksICA0LCAxNyxcbiAgICBcdFx0IDEsIDEyLCAxNCwgICAgICAxLCAxNCwgIDUsICAgICAgMSwgIDUsICA5XG4gICAgXHRdO1xuXG4gICAgXHRQb2x5aGVkcm9uR2VvbWV0cnkuY2FsbCggdGhpcywgdmVydGljZXMsIGluZGljZXMsIHJhZGl1cywgZGV0YWlsICk7XG5cbiAgICBcdHRoaXMudHlwZSA9ICdEb2RlY2FoZWRyb25HZW9tZXRyeSc7XG5cbiAgICBcdHRoaXMucGFyYW1ldGVycyA9IHtcbiAgICBcdFx0cmFkaXVzOiByYWRpdXMsXG4gICAgXHRcdGRldGFpbDogZGV0YWlsXG4gICAgXHR9O1xuXG4gICAgfVxuXG4gICAgRG9kZWNhaGVkcm9uR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggUG9seWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZSApO1xuICAgIERvZGVjYWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IERvZGVjYWhlZHJvbkdlb21ldHJ5O1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHBzOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuICAgICAqIEBhdXRob3Igeno4NSAvIGh0dHBzOi8vZ2l0aHViLmNvbS96ejg1XG4gICAgICogQGF1dGhvciBtaW5pbmdvbGQgLyBodHRwczovL2dpdGh1Yi5jb20vbWluaW5nb2xkXG4gICAgICogQGF1dGhvciBqb25vYnIxIC8gaHR0cHM6Ly9naXRodWIuY29tL2pvbm9icjFcbiAgICAgKlxuICAgICAqIE1vZGlmaWVkIGZyb20gdGhlIFRvcnVzS25vdEdlb21ldHJ5IGJ5IEBvb3Ntb3hpZWNvZGVcbiAgICAgKlxuICAgICAqIENyZWF0ZXMgYSB0dWJlIHdoaWNoIGV4dHJ1ZGVzIGFsb25nIGEgM2Qgc3BsaW5lXG4gICAgICpcbiAgICAgKiBVc2VzIHBhcmFsbGVsIHRyYW5zcG9ydCBmcmFtZXMgYXMgZGVzY3JpYmVkIGluXG4gICAgICogaHR0cDovL3d3dy5jcy5pbmRpYW5hLmVkdS9wdWIvdGVjaHJlcG9ydHMvVFI0MjUucGRmXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBUdWJlR2VvbWV0cnkoIHBhdGgsIHNlZ21lbnRzLCByYWRpdXMsIHJhZGlhbFNlZ21lbnRzLCBjbG9zZWQsIHRhcGVyICkge1xuXG4gICAgXHRHZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cbiAgICBcdHRoaXMudHlwZSA9ICdUdWJlR2VvbWV0cnknO1xuXG4gICAgXHR0aGlzLnBhcmFtZXRlcnMgPSB7XG4gICAgXHRcdHBhdGg6IHBhdGgsXG4gICAgXHRcdHNlZ21lbnRzOiBzZWdtZW50cyxcbiAgICBcdFx0cmFkaXVzOiByYWRpdXMsXG4gICAgXHRcdHJhZGlhbFNlZ21lbnRzOiByYWRpYWxTZWdtZW50cyxcbiAgICBcdFx0Y2xvc2VkOiBjbG9zZWQsXG4gICAgXHRcdHRhcGVyOiB0YXBlclxuICAgIFx0fTtcblxuICAgIFx0c2VnbWVudHMgPSBzZWdtZW50cyB8fCA2NDtcbiAgICBcdHJhZGl1cyA9IHJhZGl1cyB8fCAxO1xuICAgIFx0cmFkaWFsU2VnbWVudHMgPSByYWRpYWxTZWdtZW50cyB8fCA4O1xuICAgIFx0Y2xvc2VkID0gY2xvc2VkIHx8IGZhbHNlO1xuICAgIFx0dGFwZXIgPSB0YXBlciB8fCBUdWJlR2VvbWV0cnkuTm9UYXBlcjtcblxuICAgIFx0dmFyIGdyaWQgPSBbXTtcblxuICAgIFx0dmFyIHNjb3BlID0gdGhpcyxcblxuICAgIFx0XHR0YW5nZW50LFxuICAgIFx0XHRub3JtYWwsXG4gICAgXHRcdGJpbm9ybWFsLFxuXG4gICAgXHRcdG51bXBvaW50cyA9IHNlZ21lbnRzICsgMSxcblxuICAgIFx0XHR1LCB2LCByLFxuXG4gICAgXHRcdGN4LCBjeSxcbiAgICBcdFx0cG9zLCBwb3MyID0gbmV3IFZlY3RvcjMoKSxcbiAgICBcdFx0aSwgaixcbiAgICBcdFx0aXAsIGpwLFxuICAgIFx0XHRhLCBiLCBjLCBkLFxuICAgIFx0XHR1dmEsIHV2YiwgdXZjLCB1dmQ7XG5cbiAgICBcdHZhciBmcmFtZXMgPSBuZXcgVHViZUdlb21ldHJ5LkZyZW5ldEZyYW1lcyggcGF0aCwgc2VnbWVudHMsIGNsb3NlZCApLFxuICAgIFx0XHR0YW5nZW50cyA9IGZyYW1lcy50YW5nZW50cyxcbiAgICBcdFx0bm9ybWFscyA9IGZyYW1lcy5ub3JtYWxzLFxuICAgIFx0XHRiaW5vcm1hbHMgPSBmcmFtZXMuYmlub3JtYWxzO1xuXG4gICAgXHQvLyBwcm94eSBpbnRlcm5hbHNcbiAgICBcdHRoaXMudGFuZ2VudHMgPSB0YW5nZW50cztcbiAgICBcdHRoaXMubm9ybWFscyA9IG5vcm1hbHM7XG4gICAgXHR0aGlzLmJpbm9ybWFscyA9IGJpbm9ybWFscztcblxuICAgIFx0ZnVuY3Rpb24gdmVydCggeCwgeSwgeiApIHtcblxuICAgIFx0XHRyZXR1cm4gc2NvcGUudmVydGljZXMucHVzaCggbmV3IFZlY3RvcjMoIHgsIHksIHogKSApIC0gMTtcblxuICAgIFx0fVxuXG4gICAgXHQvLyBjb25zdHJ1Y3QgdGhlIGdyaWRcblxuICAgIFx0Zm9yICggaSA9IDA7IGkgPCBudW1wb2ludHM7IGkgKysgKSB7XG5cbiAgICBcdFx0Z3JpZFsgaSBdID0gW107XG5cbiAgICBcdFx0dSA9IGkgLyAoIG51bXBvaW50cyAtIDEgKTtcblxuICAgIFx0XHRwb3MgPSBwYXRoLmdldFBvaW50QXQoIHUgKTtcblxuICAgIFx0XHR0YW5nZW50ID0gdGFuZ2VudHNbIGkgXTtcbiAgICBcdFx0bm9ybWFsID0gbm9ybWFsc1sgaSBdO1xuICAgIFx0XHRiaW5vcm1hbCA9IGJpbm9ybWFsc1sgaSBdO1xuXG4gICAgXHRcdHIgPSByYWRpdXMgKiB0YXBlciggdSApO1xuXG4gICAgXHRcdGZvciAoIGogPSAwOyBqIDwgcmFkaWFsU2VnbWVudHM7IGogKysgKSB7XG5cbiAgICBcdFx0XHR2ID0gaiAvIHJhZGlhbFNlZ21lbnRzICogMiAqIE1hdGguUEk7XG5cbiAgICBcdFx0XHRjeCA9IC0gciAqIE1hdGguY29zKCB2ICk7IC8vIFRPRE86IEhhY2s6IE5lZ2F0aW5nIGl0IHNvIGl0IGZhY2VzIG91dHNpZGUuXG4gICAgXHRcdFx0Y3kgPSByICogTWF0aC5zaW4oIHYgKTtcblxuICAgIFx0XHRcdHBvczIuY29weSggcG9zICk7XG4gICAgXHRcdFx0cG9zMi54ICs9IGN4ICogbm9ybWFsLnggKyBjeSAqIGJpbm9ybWFsLng7XG4gICAgXHRcdFx0cG9zMi55ICs9IGN4ICogbm9ybWFsLnkgKyBjeSAqIGJpbm9ybWFsLnk7XG4gICAgXHRcdFx0cG9zMi56ICs9IGN4ICogbm9ybWFsLnogKyBjeSAqIGJpbm9ybWFsLno7XG5cbiAgICBcdFx0XHRncmlkWyBpIF1bIGogXSA9IHZlcnQoIHBvczIueCwgcG9zMi55LCBwb3MyLnogKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdH1cblxuXG4gICAgXHQvLyBjb25zdHJ1Y3QgdGhlIG1lc2hcblxuICAgIFx0Zm9yICggaSA9IDA7IGkgPCBzZWdtZW50czsgaSArKyApIHtcblxuICAgIFx0XHRmb3IgKCBqID0gMDsgaiA8IHJhZGlhbFNlZ21lbnRzOyBqICsrICkge1xuXG4gICAgXHRcdFx0aXAgPSAoIGNsb3NlZCApID8gKCBpICsgMSApICUgc2VnbWVudHMgOiBpICsgMTtcbiAgICBcdFx0XHRqcCA9ICggaiArIDEgKSAlIHJhZGlhbFNlZ21lbnRzO1xuXG4gICAgXHRcdFx0YSA9IGdyaWRbIGkgXVsgaiBdO1x0XHQvLyAqKiogTk9UIE5FQ0VTU0FSSUxZIFBMQU5BUiAhICoqKlxuICAgIFx0XHRcdGIgPSBncmlkWyBpcCBdWyBqIF07XG4gICAgXHRcdFx0YyA9IGdyaWRbIGlwIF1bIGpwIF07XG4gICAgXHRcdFx0ZCA9IGdyaWRbIGkgXVsganAgXTtcblxuICAgIFx0XHRcdHV2YSA9IG5ldyBWZWN0b3IyKCBpIC8gc2VnbWVudHMsIGogLyByYWRpYWxTZWdtZW50cyApO1xuICAgIFx0XHRcdHV2YiA9IG5ldyBWZWN0b3IyKCAoIGkgKyAxICkgLyBzZWdtZW50cywgaiAvIHJhZGlhbFNlZ21lbnRzICk7XG4gICAgXHRcdFx0dXZjID0gbmV3IFZlY3RvcjIoICggaSArIDEgKSAvIHNlZ21lbnRzLCAoIGogKyAxICkgLyByYWRpYWxTZWdtZW50cyApO1xuICAgIFx0XHRcdHV2ZCA9IG5ldyBWZWN0b3IyKCBpIC8gc2VnbWVudHMsICggaiArIDEgKSAvIHJhZGlhbFNlZ21lbnRzICk7XG5cbiAgICBcdFx0XHR0aGlzLmZhY2VzLnB1c2goIG5ldyBGYWNlMyggYSwgYiwgZCApICk7XG4gICAgXHRcdFx0dGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1dmEsIHV2YiwgdXZkIF0gKTtcblxuICAgIFx0XHRcdHRoaXMuZmFjZXMucHVzaCggbmV3IEZhY2UzKCBiLCBjLCBkICkgKTtcbiAgICBcdFx0XHR0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2Yi5jbG9uZSgpLCB1dmMsIHV2ZC5jbG9uZSgpIF0gKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdH1cblxuICAgIFx0dGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcbiAgICBcdHRoaXMuY29tcHV0ZVZlcnRleE5vcm1hbHMoKTtcblxuICAgIH1cblxuICAgIFR1YmVHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBHZW9tZXRyeS5wcm90b3R5cGUgKTtcbiAgICBUdWJlR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVHViZUdlb21ldHJ5O1xuXG4gICAgVHViZUdlb21ldHJ5Lk5vVGFwZXIgPSBmdW5jdGlvbiAoIHUgKSB7XG5cbiAgICBcdHJldHVybiAxO1xuXG4gICAgfTtcblxuICAgIFR1YmVHZW9tZXRyeS5TaW51c29pZGFsVGFwZXIgPSBmdW5jdGlvbiAoIHUgKSB7XG5cbiAgICBcdHJldHVybiBNYXRoLnNpbiggTWF0aC5QSSAqIHUgKTtcblxuICAgIH07XG5cbiAgICAvLyBGb3IgY29tcHV0aW5nIG9mIEZyZW5ldCBmcmFtZXMsIGV4cG9zaW5nIHRoZSB0YW5nZW50cywgbm9ybWFscyBhbmQgYmlub3JtYWxzIHRoZSBzcGxpbmVcbiAgICBUdWJlR2VvbWV0cnkuRnJlbmV0RnJhbWVzID0gZnVuY3Rpb24gKCBwYXRoLCBzZWdtZW50cywgY2xvc2VkICkge1xuXG4gICAgXHR2YXJcdG5vcm1hbCA9IG5ldyBWZWN0b3IzKCksXG5cbiAgICBcdFx0dGFuZ2VudHMgPSBbXSxcbiAgICBcdFx0bm9ybWFscyA9IFtdLFxuICAgIFx0XHRiaW5vcm1hbHMgPSBbXSxcblxuICAgIFx0XHR2ZWMgPSBuZXcgVmVjdG9yMygpLFxuICAgIFx0XHRtYXQgPSBuZXcgTWF0cml4NCgpLFxuXG4gICAgXHRcdG51bXBvaW50cyA9IHNlZ21lbnRzICsgMSxcbiAgICBcdFx0dGhldGEsXG4gICAgXHRcdHNtYWxsZXN0LFxuXG4gICAgXHRcdHR4LCB0eSwgdHosXG4gICAgXHRcdGksIHU7XG5cblxuICAgIFx0Ly8gZXhwb3NlIGludGVybmFsc1xuICAgIFx0dGhpcy50YW5nZW50cyA9IHRhbmdlbnRzO1xuICAgIFx0dGhpcy5ub3JtYWxzID0gbm9ybWFscztcbiAgICBcdHRoaXMuYmlub3JtYWxzID0gYmlub3JtYWxzO1xuXG4gICAgXHQvLyBjb21wdXRlIHRoZSB0YW5nZW50IHZlY3RvcnMgZm9yIGVhY2ggc2VnbWVudCBvbiB0aGUgcGF0aFxuXG4gICAgXHRmb3IgKCBpID0gMDsgaSA8IG51bXBvaW50czsgaSArKyApIHtcblxuICAgIFx0XHR1ID0gaSAvICggbnVtcG9pbnRzIC0gMSApO1xuXG4gICAgXHRcdHRhbmdlbnRzWyBpIF0gPSBwYXRoLmdldFRhbmdlbnRBdCggdSApO1xuICAgIFx0XHR0YW5nZW50c1sgaSBdLm5vcm1hbGl6ZSgpO1xuXG4gICAgXHR9XG5cbiAgICBcdGluaXRpYWxOb3JtYWwzKCk7XG5cbiAgICBcdC8qXG4gICAgXHRmdW5jdGlvbiBpbml0aWFsTm9ybWFsMShsYXN0Qmlub3JtYWwpIHtcbiAgICBcdFx0Ly8gZml4ZWQgc3RhcnQgYmlub3JtYWwuIEhhcyBkYW5nZXJzIG9mIDAgdmVjdG9yc1xuICAgIFx0XHRub3JtYWxzWyAwIF0gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIFx0XHRiaW5vcm1hbHNbIDAgXSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgXHRcdGlmIChsYXN0Qmlub3JtYWw9PT11bmRlZmluZWQpIGxhc3RCaW5vcm1hbCA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAwLCAxICk7XG4gICAgXHRcdG5vcm1hbHNbIDAgXS5jcm9zc1ZlY3RvcnMoIGxhc3RCaW5vcm1hbCwgdGFuZ2VudHNbIDAgXSApLm5vcm1hbGl6ZSgpO1xuICAgIFx0XHRiaW5vcm1hbHNbIDAgXS5jcm9zc1ZlY3RvcnMoIHRhbmdlbnRzWyAwIF0sIG5vcm1hbHNbIDAgXSApLm5vcm1hbGl6ZSgpO1xuICAgIFx0fVxuXG4gICAgXHRmdW5jdGlvbiBpbml0aWFsTm9ybWFsMigpIHtcblxuICAgIFx0XHQvLyBUaGlzIHVzZXMgdGhlIEZyZW5ldC1TZXJyZXQgZm9ybXVsYSBmb3IgZGVyaXZpbmcgYmlub3JtYWxcbiAgICBcdFx0dmFyIHQyID0gcGF0aC5nZXRUYW5nZW50QXQoIGVwc2lsb24gKTtcblxuICAgIFx0XHRub3JtYWxzWyAwIF0gPSBuZXcgVEhSRUUuVmVjdG9yMygpLnN1YlZlY3RvcnMoIHQyLCB0YW5nZW50c1sgMCBdICkubm9ybWFsaXplKCk7XG4gICAgXHRcdGJpbm9ybWFsc1sgMCBdID0gbmV3IFRIUkVFLlZlY3RvcjMoKS5jcm9zc1ZlY3RvcnMoIHRhbmdlbnRzWyAwIF0sIG5vcm1hbHNbIDAgXSApO1xuXG4gICAgXHRcdG5vcm1hbHNbIDAgXS5jcm9zc1ZlY3RvcnMoIGJpbm9ybWFsc1sgMCBdLCB0YW5nZW50c1sgMCBdICkubm9ybWFsaXplKCk7IC8vIGxhc3QgYmlub3JtYWwgeCB0YW5nZW50XG4gICAgXHRcdGJpbm9ybWFsc1sgMCBdLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIDAgXSwgbm9ybWFsc1sgMCBdICkubm9ybWFsaXplKCk7XG5cbiAgICBcdH1cbiAgICBcdCovXG5cbiAgICBcdGZ1bmN0aW9uIGluaXRpYWxOb3JtYWwzKCkge1xuXG4gICAgXHRcdC8vIHNlbGVjdCBhbiBpbml0aWFsIG5vcm1hbCB2ZWN0b3IgcGVycGVuZGljdWxhciB0byB0aGUgZmlyc3QgdGFuZ2VudCB2ZWN0b3IsXG4gICAgXHRcdC8vIGFuZCBpbiB0aGUgZGlyZWN0aW9uIG9mIHRoZSBzbWFsbGVzdCB0YW5nZW50IHh5eiBjb21wb25lbnRcblxuICAgIFx0XHRub3JtYWxzWyAwIF0gPSBuZXcgVmVjdG9yMygpO1xuICAgIFx0XHRiaW5vcm1hbHNbIDAgXSA9IG5ldyBWZWN0b3IzKCk7XG4gICAgXHRcdHNtYWxsZXN0ID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICBcdFx0dHggPSBNYXRoLmFicyggdGFuZ2VudHNbIDAgXS54ICk7XG4gICAgXHRcdHR5ID0gTWF0aC5hYnMoIHRhbmdlbnRzWyAwIF0ueSApO1xuICAgIFx0XHR0eiA9IE1hdGguYWJzKCB0YW5nZW50c1sgMCBdLnogKTtcblxuICAgIFx0XHRpZiAoIHR4IDw9IHNtYWxsZXN0ICkge1xuXG4gICAgXHRcdFx0c21hbGxlc3QgPSB0eDtcbiAgICBcdFx0XHRub3JtYWwuc2V0KCAxLCAwLCAwICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGlmICggdHkgPD0gc21hbGxlc3QgKSB7XG5cbiAgICBcdFx0XHRzbWFsbGVzdCA9IHR5O1xuICAgIFx0XHRcdG5vcm1hbC5zZXQoIDAsIDEsIDAgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0aWYgKCB0eiA8PSBzbWFsbGVzdCApIHtcblxuICAgIFx0XHRcdG5vcm1hbC5zZXQoIDAsIDAsIDEgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0dmVjLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIDAgXSwgbm9ybWFsICkubm9ybWFsaXplKCk7XG5cbiAgICBcdFx0bm9ybWFsc1sgMCBdLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIDAgXSwgdmVjICk7XG4gICAgXHRcdGJpbm9ybWFsc1sgMCBdLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIDAgXSwgbm9ybWFsc1sgMCBdICk7XG5cbiAgICBcdH1cblxuXG4gICAgXHQvLyBjb21wdXRlIHRoZSBzbG93bHktdmFyeWluZyBub3JtYWwgYW5kIGJpbm9ybWFsIHZlY3RvcnMgZm9yIGVhY2ggc2VnbWVudCBvbiB0aGUgcGF0aFxuXG4gICAgXHRmb3IgKCBpID0gMTsgaSA8IG51bXBvaW50czsgaSArKyApIHtcblxuICAgIFx0XHRub3JtYWxzWyBpIF0gPSBub3JtYWxzWyBpIC0gMSBdLmNsb25lKCk7XG5cbiAgICBcdFx0Ymlub3JtYWxzWyBpIF0gPSBiaW5vcm1hbHNbIGkgLSAxIF0uY2xvbmUoKTtcblxuICAgIFx0XHR2ZWMuY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgaSAtIDEgXSwgdGFuZ2VudHNbIGkgXSApO1xuXG4gICAgXHRcdGlmICggdmVjLmxlbmd0aCgpID4gTnVtYmVyLkVQU0lMT04gKSB7XG5cbiAgICBcdFx0XHR2ZWMubm9ybWFsaXplKCk7XG5cbiAgICBcdFx0XHR0aGV0YSA9IE1hdGguYWNvcyggZXhwb3J0cy5NYXRoLmNsYW1wKCB0YW5nZW50c1sgaSAtIDEgXS5kb3QoIHRhbmdlbnRzWyBpIF0gKSwgLSAxLCAxICkgKTsgLy8gY2xhbXAgZm9yIGZsb2F0aW5nIHB0IGVycm9yc1xuXG4gICAgXHRcdFx0bm9ybWFsc1sgaSBdLmFwcGx5TWF0cml4NCggbWF0Lm1ha2VSb3RhdGlvbkF4aXMoIHZlYywgdGhldGEgKSApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRiaW5vcm1hbHNbIGkgXS5jcm9zc1ZlY3RvcnMoIHRhbmdlbnRzWyBpIF0sIG5vcm1hbHNbIGkgXSApO1xuXG4gICAgXHR9XG5cblxuICAgIFx0Ly8gaWYgdGhlIGN1cnZlIGlzIGNsb3NlZCwgcG9zdHByb2Nlc3MgdGhlIHZlY3RvcnMgc28gdGhlIGZpcnN0IGFuZCBsYXN0IG5vcm1hbCB2ZWN0b3JzIGFyZSB0aGUgc2FtZVxuXG4gICAgXHRpZiAoIGNsb3NlZCApIHtcblxuICAgIFx0XHR0aGV0YSA9IE1hdGguYWNvcyggZXhwb3J0cy5NYXRoLmNsYW1wKCBub3JtYWxzWyAwIF0uZG90KCBub3JtYWxzWyBudW1wb2ludHMgLSAxIF0gKSwgLSAxLCAxICkgKTtcbiAgICBcdFx0dGhldGEgLz0gKCBudW1wb2ludHMgLSAxICk7XG5cbiAgICBcdFx0aWYgKCB0YW5nZW50c1sgMCBdLmRvdCggdmVjLmNyb3NzVmVjdG9ycyggbm9ybWFsc1sgMCBdLCBub3JtYWxzWyBudW1wb2ludHMgLSAxIF0gKSApID4gMCApIHtcblxuICAgIFx0XHRcdHRoZXRhID0gLSB0aGV0YTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0Zm9yICggaSA9IDE7IGkgPCBudW1wb2ludHM7IGkgKysgKSB7XG5cbiAgICBcdFx0XHQvLyB0d2lzdCBhIGxpdHRsZS4uLlxuICAgIFx0XHRcdG5vcm1hbHNbIGkgXS5hcHBseU1hdHJpeDQoIG1hdC5tYWtlUm90YXRpb25BeGlzKCB0YW5nZW50c1sgaSBdLCB0aGV0YSAqIGkgKSApO1xuICAgIFx0XHRcdGJpbm9ybWFsc1sgaSBdLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIGkgXSwgbm9ybWFsc1sgaSBdICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9XG5cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBNdWdlbjg3IC8gaHR0cHM6Ly9naXRodWIuY29tL011Z2VuODdcbiAgICAgKlxuICAgICAqIHNlZTogaHR0cDovL3d3dy5ibGFja3Bhd24uY29tL3RleHRzL3BxdG9ydXMvXG4gICAgICovXG4gICAgZnVuY3Rpb24gVG9ydXNLbm90QnVmZmVyR2VvbWV0cnkoIHJhZGl1cywgdHViZSwgdHVidWxhclNlZ21lbnRzLCByYWRpYWxTZWdtZW50cywgcCwgcSApIHtcblxuICAgIFx0QnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG4gICAgXHR0aGlzLnR5cGUgPSAnVG9ydXNLbm90QnVmZmVyR2VvbWV0cnknO1xuXG4gICAgXHR0aGlzLnBhcmFtZXRlcnMgPSB7XG4gICAgXHRcdHJhZGl1czogcmFkaXVzLFxuICAgIFx0XHR0dWJlOiB0dWJlLFxuICAgIFx0XHR0dWJ1bGFyU2VnbWVudHM6IHR1YnVsYXJTZWdtZW50cyxcbiAgICBcdFx0cmFkaWFsU2VnbWVudHM6IHJhZGlhbFNlZ21lbnRzLFxuICAgIFx0XHRwOiBwLFxuICAgIFx0XHRxOiBxXG4gICAgXHR9O1xuXG4gICAgXHRyYWRpdXMgPSByYWRpdXMgfHwgMTAwO1xuICAgIFx0dHViZSA9IHR1YmUgfHwgNDA7XG4gICAgXHR0dWJ1bGFyU2VnbWVudHMgPSBNYXRoLmZsb29yKCB0dWJ1bGFyU2VnbWVudHMgKSB8fCA2NDtcbiAgICBcdHJhZGlhbFNlZ21lbnRzID0gTWF0aC5mbG9vciggcmFkaWFsU2VnbWVudHMgKSB8fCA4O1xuICAgIFx0cCA9IHAgfHwgMjtcbiAgICBcdHEgPSBxIHx8IDM7XG5cbiAgICBcdC8vIHVzZWQgdG8gY2FsY3VsYXRlIGJ1ZmZlciBsZW5ndGhcbiAgICBcdHZhciB2ZXJ0ZXhDb3VudCA9ICggKCByYWRpYWxTZWdtZW50cyArIDEgKSAqICggdHVidWxhclNlZ21lbnRzICsgMSApICk7XG4gICAgXHR2YXIgaW5kZXhDb3VudCA9IHJhZGlhbFNlZ21lbnRzICogdHVidWxhclNlZ21lbnRzICogMiAqIDM7XG5cbiAgICBcdC8vIGJ1ZmZlcnNcbiAgICBcdHZhciBpbmRpY2VzID0gbmV3IEJ1ZmZlckF0dHJpYnV0ZSggbmV3ICggaW5kZXhDb3VudCA+IDY1NTM1ID8gVWludDMyQXJyYXkgOiBVaW50MTZBcnJheSApKCBpbmRleENvdW50ICkgLCAxICk7XG4gICAgXHR2YXIgdmVydGljZXMgPSBuZXcgQnVmZmVyQXR0cmlidXRlKCBuZXcgRmxvYXQzMkFycmF5KCB2ZXJ0ZXhDb3VudCAqIDMgKSwgMyApO1xuICAgIFx0dmFyIG5vcm1hbHMgPSBuZXcgQnVmZmVyQXR0cmlidXRlKCBuZXcgRmxvYXQzMkFycmF5KCB2ZXJ0ZXhDb3VudCAqIDMgKSwgMyApO1xuICAgIFx0dmFyIHV2cyA9IG5ldyBCdWZmZXJBdHRyaWJ1dGUoIG5ldyBGbG9hdDMyQXJyYXkoIHZlcnRleENvdW50ICogMiApLCAyICk7XG5cbiAgICBcdC8vIGhlbHBlciB2YXJpYWJsZXNcbiAgICBcdHZhciBpLCBqLCBpbmRleCA9IDAsIGluZGV4T2Zmc2V0ID0gMDtcblxuICAgIFx0dmFyIHZlcnRleCA9IG5ldyBWZWN0b3IzKCk7XG4gICAgXHR2YXIgbm9ybWFsID0gbmV3IFZlY3RvcjMoKTtcbiAgICBcdHZhciB1diA9IG5ldyBWZWN0b3IyKCk7XG5cbiAgICBcdHZhciBQMSA9IG5ldyBWZWN0b3IzKCk7XG4gICAgXHR2YXIgUDIgPSBuZXcgVmVjdG9yMygpO1xuXG4gICAgXHR2YXIgQiA9IG5ldyBWZWN0b3IzKCk7XG4gICAgXHR2YXIgVCA9IG5ldyBWZWN0b3IzKCk7XG4gICAgXHR2YXIgTiA9IG5ldyBWZWN0b3IzKCk7XG5cbiAgICBcdC8vIGdlbmVyYXRlIHZlcnRpY2VzLCBub3JtYWxzIGFuZCB1dnNcblxuICAgIFx0Zm9yICggaSA9IDA7IGkgPD0gdHVidWxhclNlZ21lbnRzOyArKyBpICkge1xuXG4gICAgXHRcdC8vIHRoZSByYWRpYW4gXCJ1XCIgaXMgdXNlZCB0byBjYWxjdWxhdGUgdGhlIHBvc2l0aW9uIG9uIHRoZSB0b3J1cyBjdXJ2ZSBvZiB0aGUgY3VycmVudCB0dWJ1bGFyIHNlZ2VtZW50XG5cbiAgICBcdFx0dmFyIHUgPSBpIC8gdHVidWxhclNlZ21lbnRzICogcCAqIE1hdGguUEkgKiAyO1xuXG4gICAgXHRcdC8vIG5vdyB3ZSBjYWxjdWxhdGUgdHdvIHBvaW50cy4gUDEgaXMgb3VyIGN1cnJlbnQgcG9zaXRpb24gb24gdGhlIGN1cnZlLCBQMiBpcyBhIGxpdHRsZSBmYXJ0aGVyIGFoZWFkLlxuICAgIFx0XHQvLyB0aGVzZSBwb2ludHMgYXJlIHVzZWQgdG8gY3JlYXRlIGEgc3BlY2lhbCBcImNvb3JkaW5hdGUgc3BhY2VcIiwgd2hpY2ggaXMgbmVjZXNzYXJ5IHRvIGNhbGN1bGF0ZSB0aGUgY29ycmVjdCB2ZXJ0ZXggcG9zaXRpb25zXG5cbiAgICBcdFx0Y2FsY3VsYXRlUG9zaXRpb25PbkN1cnZlKCB1LCBwLCBxLCByYWRpdXMsIFAxICk7XG4gICAgXHRcdGNhbGN1bGF0ZVBvc2l0aW9uT25DdXJ2ZSggdSArIDAuMDEsIHAsIHEsIHJhZGl1cywgUDIgKTtcblxuICAgIFx0XHQvLyBjYWxjdWxhdGUgb3J0aG9ub3JtYWwgYmFzaXNcblxuICAgIFx0XHRULnN1YlZlY3RvcnMoIFAyLCBQMSApO1xuICAgIFx0XHROLmFkZFZlY3RvcnMoIFAyLCBQMSApO1xuICAgIFx0XHRCLmNyb3NzVmVjdG9ycyggVCwgTiApO1xuICAgIFx0XHROLmNyb3NzVmVjdG9ycyggQiwgVCApO1xuXG4gICAgXHRcdC8vIG5vcm1hbGl6ZSBCLCBOLiBUIGNhbiBiZSBpZ25vcmVkLCB3ZSBkb24ndCB1c2UgaXRcblxuICAgIFx0XHRCLm5vcm1hbGl6ZSgpO1xuICAgIFx0XHROLm5vcm1hbGl6ZSgpO1xuXG4gICAgXHRcdGZvciAoIGogPSAwOyBqIDw9IHJhZGlhbFNlZ21lbnRzOyArKyBqICkge1xuXG4gICAgXHRcdFx0Ly8gbm93IGNhbGN1bGF0ZSB0aGUgdmVydGljZXMuIHRoZXkgYXJlIG5vdGhpbmcgbW9yZSB0aGFuIGFuIGV4dHJ1c2lvbiBvZiB0aGUgdG9ydXMgY3VydmUuXG4gICAgXHRcdFx0Ly8gYmVjYXVzZSB3ZSBleHRydWRlIGEgc2hhcGUgaW4gdGhlIHh5LXBsYW5lLCB0aGVyZSBpcyBubyBuZWVkIHRvIGNhbGN1bGF0ZSBhIHotdmFsdWUuXG5cbiAgICBcdFx0XHR2YXIgdiA9IGogLyByYWRpYWxTZWdtZW50cyAqIE1hdGguUEkgKiAyO1xuICAgIFx0XHRcdHZhciBjeCA9IC0gdHViZSAqIE1hdGguY29zKCB2ICk7XG4gICAgXHRcdFx0dmFyIGN5ID0gdHViZSAqIE1hdGguc2luKCB2ICk7XG5cbiAgICBcdFx0XHQvLyBub3cgY2FsY3VsYXRlIHRoZSBmaW5hbCB2ZXJ0ZXggcG9zaXRpb24uXG4gICAgXHRcdFx0Ly8gZmlyc3Qgd2Ugb3JpZW50IHRoZSBleHRydXNpb24gd2l0aCBvdXIgYmFzaXMgdmVjdG9zLCB0aGVuIHdlIGFkZCBpdCB0byB0aGUgY3VycmVudCBwb3NpdGlvbiBvbiB0aGUgY3VydmVcblxuICAgIFx0XHRcdHZlcnRleC54ID0gUDEueCArICggY3ggKiBOLnggKyBjeSAqIEIueCApO1xuICAgIFx0XHRcdHZlcnRleC55ID0gUDEueSArICggY3ggKiBOLnkgKyBjeSAqIEIueSApO1xuICAgIFx0XHRcdHZlcnRleC56ID0gUDEueiArICggY3ggKiBOLnogKyBjeSAqIEIueiApO1xuXG4gICAgXHRcdFx0Ly8gdmVydGV4XG4gICAgXHRcdFx0dmVydGljZXMuc2V0WFlaKCBpbmRleCwgdmVydGV4LngsIHZlcnRleC55LCB2ZXJ0ZXgueiApO1xuXG4gICAgXHRcdFx0Ly8gbm9ybWFsIChQMSBpcyBhbHdheXMgdGhlIGNlbnRlci9vcmlnaW4gb2YgdGhlIGV4dHJ1c2lvbiwgdGh1cyB3ZSBjYW4gdXNlIGl0IHRvIGNhbGN1bGF0ZSB0aGUgbm9ybWFsKVxuICAgIFx0XHRcdG5vcm1hbC5zdWJWZWN0b3JzKCB2ZXJ0ZXgsIFAxICkubm9ybWFsaXplKCk7XG4gICAgXHRcdFx0bm9ybWFscy5zZXRYWVooIGluZGV4LCBub3JtYWwueCwgbm9ybWFsLnksIG5vcm1hbC56ICk7XG5cbiAgICBcdFx0XHQvLyB1dlxuICAgIFx0XHRcdHV2LnggPSBpIC8gdHVidWxhclNlZ21lbnRzO1xuICAgIFx0XHRcdHV2LnkgPSBqIC8gcmFkaWFsU2VnbWVudHM7XG4gICAgXHRcdFx0dXZzLnNldFhZKCBpbmRleCwgdXYueCwgdXYueSApO1xuXG4gICAgXHRcdFx0Ly8gaW5jcmVhc2UgaW5kZXhcbiAgICBcdFx0XHRpbmRleCArKztcblxuICAgIFx0XHR9XG5cbiAgICBcdH1cblxuICAgIFx0Ly8gZ2VuZXJhdGUgaW5kaWNlc1xuXG4gICAgXHRmb3IgKCBqID0gMTsgaiA8PSB0dWJ1bGFyU2VnbWVudHM7IGogKysgKSB7XG5cbiAgICBcdFx0Zm9yICggaSA9IDE7IGkgPD0gcmFkaWFsU2VnbWVudHM7IGkgKysgKSB7XG5cbiAgICBcdFx0XHQvLyBpbmRpY2VzXG4gICAgXHRcdFx0dmFyIGEgPSAoIHJhZGlhbFNlZ21lbnRzICsgMSApICogKCBqIC0gMSApICsgKCBpIC0gMSApO1xuICAgIFx0XHRcdHZhciBiID0gKCByYWRpYWxTZWdtZW50cyArIDEgKSAqIGogKyAoIGkgLSAxICk7XG4gICAgXHRcdFx0dmFyIGMgPSAoIHJhZGlhbFNlZ21lbnRzICsgMSApICogaiArIGk7XG4gICAgXHRcdFx0dmFyIGQgPSAoIHJhZGlhbFNlZ21lbnRzICsgMSApICogKCBqIC0gMSApICsgaTtcblxuICAgIFx0XHRcdC8vIGZhY2Ugb25lXG4gICAgXHRcdFx0aW5kaWNlcy5zZXRYKCBpbmRleE9mZnNldCwgYSApOyBpbmRleE9mZnNldCsrO1xuICAgIFx0XHRcdGluZGljZXMuc2V0WCggaW5kZXhPZmZzZXQsIGIgKTsgaW5kZXhPZmZzZXQrKztcbiAgICBcdFx0XHRpbmRpY2VzLnNldFgoIGluZGV4T2Zmc2V0LCBkICk7IGluZGV4T2Zmc2V0Kys7XG5cbiAgICBcdFx0XHQvLyBmYWNlIHR3b1xuICAgIFx0XHRcdGluZGljZXMuc2V0WCggaW5kZXhPZmZzZXQsIGIgKTsgaW5kZXhPZmZzZXQrKztcbiAgICBcdFx0XHRpbmRpY2VzLnNldFgoIGluZGV4T2Zmc2V0LCBjICk7IGluZGV4T2Zmc2V0Kys7XG4gICAgXHRcdFx0aW5kaWNlcy5zZXRYKCBpbmRleE9mZnNldCwgZCApOyBpbmRleE9mZnNldCsrO1xuXG4gICAgXHRcdH1cblxuICAgIFx0fVxuXG4gICAgXHQvLyBidWlsZCBnZW9tZXRyeVxuXG4gICAgXHR0aGlzLnNldEluZGV4KCBpbmRpY2VzICk7XG4gICAgXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgdmVydGljZXMgKTtcbiAgICBcdHRoaXMuYWRkQXR0cmlidXRlKCAnbm9ybWFsJywgbm9ybWFscyApO1xuICAgIFx0dGhpcy5hZGRBdHRyaWJ1dGUoICd1dicsIHV2cyApO1xuXG4gICAgXHQvLyB0aGlzIGZ1bmN0aW9uIGNhbGN1bGF0ZXMgdGhlIGN1cnJlbnQgcG9zaXRpb24gb24gdGhlIHRvcnVzIGN1cnZlXG5cbiAgICBcdGZ1bmN0aW9uIGNhbGN1bGF0ZVBvc2l0aW9uT25DdXJ2ZSggdSwgcCwgcSwgcmFkaXVzLCBwb3NpdGlvbiApIHtcblxuICAgIFx0XHR2YXIgY3UgPSBNYXRoLmNvcyggdSApO1xuICAgIFx0XHR2YXIgc3UgPSBNYXRoLnNpbiggdSApO1xuICAgIFx0XHR2YXIgcXVPdmVyUCA9IHEgLyBwICogdTtcbiAgICBcdFx0dmFyIGNzID0gTWF0aC5jb3MoIHF1T3ZlclAgKTtcblxuICAgIFx0XHRwb3NpdGlvbi54ID0gcmFkaXVzICogKCAyICsgY3MgKSAqIDAuNSAqIGN1O1xuICAgIFx0XHRwb3NpdGlvbi55ID0gcmFkaXVzICogKCAyICsgY3MgKSAqIHN1ICogMC41O1xuICAgIFx0XHRwb3NpdGlvbi56ID0gcmFkaXVzICogTWF0aC5zaW4oIHF1T3ZlclAgKSAqIDAuNTtcblxuICAgIFx0fVxuXG4gICAgfVxuXG4gICAgVG9ydXNLbm90QnVmZmVyR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XG4gICAgVG9ydXNLbm90QnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVG9ydXNLbm90QnVmZmVyR2VvbWV0cnk7XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIG9vc21veGllY29kZVxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gVG9ydXNLbm90R2VvbWV0cnkoIHJhZGl1cywgdHViZSwgdHVidWxhclNlZ21lbnRzLCByYWRpYWxTZWdtZW50cywgcCwgcSwgaGVpZ2h0U2NhbGUgKSB7XG5cbiAgICBcdEdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuICAgIFx0dGhpcy50eXBlID0gJ1RvcnVzS25vdEdlb21ldHJ5JztcblxuICAgIFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuICAgIFx0XHRyYWRpdXM6IHJhZGl1cyxcbiAgICBcdFx0dHViZTogdHViZSxcbiAgICBcdFx0dHVidWxhclNlZ21lbnRzOiB0dWJ1bGFyU2VnbWVudHMsXG4gICAgXHRcdHJhZGlhbFNlZ21lbnRzOiByYWRpYWxTZWdtZW50cyxcbiAgICBcdFx0cDogcCxcbiAgICBcdFx0cTogcVxuICAgIFx0fTtcblxuICAgIFx0aWYoIGhlaWdodFNjYWxlICE9PSB1bmRlZmluZWQgKSBjb25zb2xlLndhcm4oICdUSFJFRS5Ub3J1c0tub3RHZW9tZXRyeTogaGVpZ2h0U2NhbGUgaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIC5zY2FsZSggeCwgeSwgeiApIGluc3RlYWQuJyApO1xuXG4gICAgXHR0aGlzLmZyb21CdWZmZXJHZW9tZXRyeSggbmV3IFRvcnVzS25vdEJ1ZmZlckdlb21ldHJ5KCByYWRpdXMsIHR1YmUsIHR1YnVsYXJTZWdtZW50cywgcmFkaWFsU2VnbWVudHMsIHAsIHEgKSApO1xuICAgIFx0dGhpcy5tZXJnZVZlcnRpY2VzKCk7XG5cbiAgICB9XG5cbiAgICBUb3J1c0tub3RHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBHZW9tZXRyeS5wcm90b3R5cGUgKTtcbiAgICBUb3J1c0tub3RHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUb3J1c0tub3RHZW9tZXRyeTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgTXVnZW44NyAvIGh0dHBzOi8vZ2l0aHViLmNvbS9NdWdlbjg3XG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBUb3J1c0J1ZmZlckdlb21ldHJ5KCByYWRpdXMsIHR1YmUsIHJhZGlhbFNlZ21lbnRzLCB0dWJ1bGFyU2VnbWVudHMsIGFyYyApIHtcblxuICAgIFx0QnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG4gICAgXHR0aGlzLnR5cGUgPSAnVG9ydXNCdWZmZXJHZW9tZXRyeSc7XG5cbiAgICBcdHRoaXMucGFyYW1ldGVycyA9IHtcbiAgICBcdFx0cmFkaXVzOiByYWRpdXMsXG4gICAgXHRcdHR1YmU6IHR1YmUsXG4gICAgXHRcdHJhZGlhbFNlZ21lbnRzOiByYWRpYWxTZWdtZW50cyxcbiAgICBcdFx0dHVidWxhclNlZ21lbnRzOiB0dWJ1bGFyU2VnbWVudHMsXG4gICAgXHRcdGFyYzogYXJjXG4gICAgXHR9O1xuXG4gICAgXHRyYWRpdXMgPSByYWRpdXMgfHwgMTAwO1xuICAgIFx0dHViZSA9IHR1YmUgfHwgNDA7XG4gICAgXHRyYWRpYWxTZWdtZW50cyA9IE1hdGguZmxvb3IoIHJhZGlhbFNlZ21lbnRzICkgfHwgODtcbiAgICBcdHR1YnVsYXJTZWdtZW50cyA9IE1hdGguZmxvb3IoIHR1YnVsYXJTZWdtZW50cyApIHx8IDY7XG4gICAgXHRhcmMgPSBhcmMgfHwgTWF0aC5QSSAqIDI7XG5cbiAgICBcdC8vIHVzZWQgdG8gY2FsY3VsYXRlIGJ1ZmZlciBsZW5ndGhcbiAgICBcdHZhciB2ZXJ0ZXhDb3VudCA9ICggKCByYWRpYWxTZWdtZW50cyArIDEgKSAqICggdHVidWxhclNlZ21lbnRzICsgMSApICk7XG4gICAgXHR2YXIgaW5kZXhDb3VudCA9IHJhZGlhbFNlZ21lbnRzICogdHVidWxhclNlZ21lbnRzICogMiAqIDM7XG5cbiAgICBcdC8vIGJ1ZmZlcnNcbiAgICBcdHZhciBpbmRpY2VzID0gbmV3ICggaW5kZXhDb3VudCA+IDY1NTM1ID8gVWludDMyQXJyYXkgOiBVaW50MTZBcnJheSApKCBpbmRleENvdW50ICk7XG4gICAgXHR2YXIgdmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KCB2ZXJ0ZXhDb3VudCAqIDMgKTtcbiAgICBcdHZhciBub3JtYWxzID0gbmV3IEZsb2F0MzJBcnJheSggdmVydGV4Q291bnQgKiAzICk7XG4gICAgXHR2YXIgdXZzID0gbmV3IEZsb2F0MzJBcnJheSggdmVydGV4Q291bnQgKiAyICk7XG5cbiAgICBcdC8vIG9mZnNldCB2YXJpYWJsZXNcbiAgICBcdHZhciB2ZXJ0ZXhCdWZmZXJPZmZzZXQgPSAwO1xuICAgIFx0dmFyIHV2QnVmZmVyT2Zmc2V0ID0gMDtcbiAgICBcdHZhciBpbmRleEJ1ZmZlck9mZnNldCA9IDA7XG5cbiAgICBcdC8vIGhlbHBlciB2YXJpYWJsZXNcbiAgICBcdHZhciBjZW50ZXIgPSBuZXcgVmVjdG9yMygpO1xuICAgIFx0dmFyIHZlcnRleCA9IG5ldyBWZWN0b3IzKCk7XG4gICAgXHR2YXIgbm9ybWFsID0gbmV3IFZlY3RvcjMoKTtcblxuICAgIFx0dmFyIGosIGk7XG5cbiAgICBcdC8vIGdlbmVyYXRlIHZlcnRpY2VzLCBub3JtYWxzIGFuZCB1dnNcblxuICAgIFx0Zm9yICggaiA9IDA7IGogPD0gcmFkaWFsU2VnbWVudHM7IGogKysgKSB7XG5cbiAgICBcdFx0Zm9yICggaSA9IDA7IGkgPD0gdHVidWxhclNlZ21lbnRzOyBpICsrICkge1xuXG4gICAgXHRcdFx0dmFyIHUgPSBpIC8gdHVidWxhclNlZ21lbnRzICogYXJjO1xuICAgIFx0XHRcdHZhciB2ID0gaiAvIHJhZGlhbFNlZ21lbnRzICogTWF0aC5QSSAqIDI7XG5cbiAgICBcdFx0XHQvLyB2ZXJ0ZXhcbiAgICBcdFx0XHR2ZXJ0ZXgueCA9ICggcmFkaXVzICsgdHViZSAqIE1hdGguY29zKCB2ICkgKSAqIE1hdGguY29zKCB1ICk7XG4gICAgXHRcdFx0dmVydGV4LnkgPSAoIHJhZGl1cyArIHR1YmUgKiBNYXRoLmNvcyggdiApICkgKiBNYXRoLnNpbiggdSApO1xuICAgIFx0XHRcdHZlcnRleC56ID0gdHViZSAqIE1hdGguc2luKCB2ICk7XG5cbiAgICBcdFx0XHR2ZXJ0aWNlc1sgdmVydGV4QnVmZmVyT2Zmc2V0IF0gPSB2ZXJ0ZXgueDtcbiAgICBcdFx0XHR2ZXJ0aWNlc1sgdmVydGV4QnVmZmVyT2Zmc2V0ICsgMSBdID0gdmVydGV4Lnk7XG4gICAgXHRcdFx0dmVydGljZXNbIHZlcnRleEJ1ZmZlck9mZnNldCArIDIgXSA9IHZlcnRleC56O1xuXG4gICAgXHRcdFx0Ly8gdGhpcyB2ZWN0b3IgaXMgdXNlZCB0byBjYWxjdWxhdGUgdGhlIG5vcm1hbFxuICAgIFx0XHRcdGNlbnRlci54ID0gcmFkaXVzICogTWF0aC5jb3MoIHUgKTtcbiAgICBcdFx0XHRjZW50ZXIueSA9IHJhZGl1cyAqIE1hdGguc2luKCB1ICk7XG5cbiAgICBcdFx0XHQvLyBub3JtYWxcbiAgICBcdFx0XHRub3JtYWwuc3ViVmVjdG9ycyggdmVydGV4LCBjZW50ZXIgKS5ub3JtYWxpemUoKTtcblxuICAgIFx0XHRcdG5vcm1hbHNbIHZlcnRleEJ1ZmZlck9mZnNldCBdID0gbm9ybWFsLng7XG4gICAgXHRcdFx0bm9ybWFsc1sgdmVydGV4QnVmZmVyT2Zmc2V0ICsgMSBdID0gbm9ybWFsLnk7XG4gICAgXHRcdFx0bm9ybWFsc1sgdmVydGV4QnVmZmVyT2Zmc2V0ICsgMiBdID0gbm9ybWFsLno7XG5cbiAgICBcdFx0XHQvLyB1dlxuICAgIFx0XHRcdHV2c1sgdXZCdWZmZXJPZmZzZXQgXSA9IGkgLyB0dWJ1bGFyU2VnbWVudHM7XG4gICAgXHRcdFx0dXZzWyB1dkJ1ZmZlck9mZnNldCArIDEgXSA9IGogLyByYWRpYWxTZWdtZW50cztcblxuICAgIFx0XHRcdC8vIHVwZGF0ZSBvZmZzZXRzXG4gICAgXHRcdFx0dmVydGV4QnVmZmVyT2Zmc2V0ICs9IDM7XG4gICAgXHRcdFx0dXZCdWZmZXJPZmZzZXQgKz0gMjtcblxuICAgIFx0XHR9XG5cbiAgICBcdH1cblxuICAgIFx0Ly8gZ2VuZXJhdGUgaW5kaWNlc1xuXG4gICAgXHRmb3IgKCBqID0gMTsgaiA8PSByYWRpYWxTZWdtZW50czsgaiArKyApIHtcblxuICAgIFx0XHRmb3IgKCBpID0gMTsgaSA8PSB0dWJ1bGFyU2VnbWVudHM7IGkgKysgKSB7XG5cbiAgICBcdFx0XHQvLyBpbmRpY2VzXG4gICAgXHRcdFx0dmFyIGEgPSAoIHR1YnVsYXJTZWdtZW50cyArIDEgKSAqIGogKyBpIC0gMTtcbiAgICBcdFx0XHR2YXIgYiA9ICggdHVidWxhclNlZ21lbnRzICsgMSApICogKCBqIC0gMSApICsgaSAtIDE7XG4gICAgXHRcdFx0dmFyIGMgPSAoIHR1YnVsYXJTZWdtZW50cyArIDEgKSAqICggaiAtIDEgKSArIGk7XG4gICAgXHRcdFx0dmFyIGQgPSAoIHR1YnVsYXJTZWdtZW50cyArIDEgKSAqIGogKyBpO1xuXG4gICAgXHRcdFx0Ly8gZmFjZSBvbmVcbiAgICBcdFx0XHRpbmRpY2VzWyBpbmRleEJ1ZmZlck9mZnNldCBdID0gYTtcbiAgICBcdFx0XHRpbmRpY2VzWyBpbmRleEJ1ZmZlck9mZnNldCArIDEgXSA9IGI7XG4gICAgXHRcdFx0aW5kaWNlc1sgaW5kZXhCdWZmZXJPZmZzZXQgKyAyIF0gPSBkO1xuXG4gICAgXHRcdFx0Ly8gZmFjZSB0d29cbiAgICBcdFx0XHRpbmRpY2VzWyBpbmRleEJ1ZmZlck9mZnNldCArIDMgXSA9IGI7XG4gICAgXHRcdFx0aW5kaWNlc1sgaW5kZXhCdWZmZXJPZmZzZXQgKyA0IF0gPSBjO1xuICAgIFx0XHRcdGluZGljZXNbIGluZGV4QnVmZmVyT2Zmc2V0ICsgNSBdID0gZDtcblxuICAgIFx0XHRcdC8vIHVwZGF0ZSBvZmZzZXRcbiAgICBcdFx0XHRpbmRleEJ1ZmZlck9mZnNldCArPSA2O1xuXG4gICAgXHRcdH1cblxuICAgIFx0fVxuXG4gICAgXHQvLyBidWlsZCBnZW9tZXRyeVxuICAgIFx0dGhpcy5zZXRJbmRleCggbmV3IEJ1ZmZlckF0dHJpYnV0ZSggaW5kaWNlcywgMSApICk7XG4gICAgXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xuICAgIFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgQnVmZmVyQXR0cmlidXRlKCBub3JtYWxzLCAzICkgKTtcbiAgICBcdHRoaXMuYWRkQXR0cmlidXRlKCAndXYnLCBuZXcgQnVmZmVyQXR0cmlidXRlKCB1dnMsIDIgKSApO1xuXG4gICAgfVxuXG4gICAgVG9ydXNCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcbiAgICBUb3J1c0J1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRvcnVzQnVmZmVyR2VvbWV0cnk7XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIG9vc21veGllY29kZVxuICAgICAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gICAgICogYmFzZWQgb24gaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2F3YXkzZC9zb3VyY2UvYnJvd3NlL3RydW5rL2ZwMTAvQXdheTNETGl0ZS9zcmMvYXdheTNkbGl0ZS9wcmltaXRpdmVzL1RvcnVzLmFzP3I9Mjg4OFxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gVG9ydXNHZW9tZXRyeSggcmFkaXVzLCB0dWJlLCByYWRpYWxTZWdtZW50cywgdHVidWxhclNlZ21lbnRzLCBhcmMgKSB7XG5cbiAgICBcdEdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuICAgIFx0dGhpcy50eXBlID0gJ1RvcnVzR2VvbWV0cnknO1xuXG4gICAgXHR0aGlzLnBhcmFtZXRlcnMgPSB7XG4gICAgXHRcdHJhZGl1czogcmFkaXVzLFxuICAgIFx0XHR0dWJlOiB0dWJlLFxuICAgIFx0XHRyYWRpYWxTZWdtZW50czogcmFkaWFsU2VnbWVudHMsXG4gICAgXHRcdHR1YnVsYXJTZWdtZW50czogdHVidWxhclNlZ21lbnRzLFxuICAgIFx0XHRhcmM6IGFyY1xuICAgIFx0fTtcblxuICAgIFx0dGhpcy5mcm9tQnVmZmVyR2VvbWV0cnkoIG5ldyBUb3J1c0J1ZmZlckdlb21ldHJ5KCByYWRpdXMsIHR1YmUsIHJhZGlhbFNlZ21lbnRzLCB0dWJ1bGFyU2VnbWVudHMsIGFyYyApICk7XG5cbiAgICB9XG5cbiAgICBUb3J1c0dlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEdlb21ldHJ5LnByb3RvdHlwZSApO1xuICAgIFRvcnVzR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVG9ydXNHZW9tZXRyeTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcbiAgICAgKi9cblxuICAgIGV4cG9ydHMuU2hhcGVVdGlscyA9IHtcblxuICAgIFx0Ly8gY2FsY3VsYXRlIGFyZWEgb2YgdGhlIGNvbnRvdXIgcG9seWdvblxuXG4gICAgXHRhcmVhOiBmdW5jdGlvbiAoIGNvbnRvdXIgKSB7XG5cbiAgICBcdFx0dmFyIG4gPSBjb250b3VyLmxlbmd0aDtcbiAgICBcdFx0dmFyIGEgPSAwLjA7XG5cbiAgICBcdFx0Zm9yICggdmFyIHAgPSBuIC0gMSwgcSA9IDA7IHEgPCBuOyBwID0gcSArKyApIHtcblxuICAgIFx0XHRcdGEgKz0gY29udG91clsgcCBdLnggKiBjb250b3VyWyBxIF0ueSAtIGNvbnRvdXJbIHEgXS54ICogY29udG91clsgcCBdLnk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiBhICogMC41O1xuXG4gICAgXHR9LFxuXG4gICAgXHR0cmlhbmd1bGF0ZTogKCBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0LyoqXG4gICAgXHRcdCAqIFRoaXMgY29kZSBpcyBhIHF1aWNrIHBvcnQgb2YgY29kZSB3cml0dGVuIGluIEMrKyB3aGljaCB3YXMgc3VibWl0dGVkIHRvXG4gICAgXHRcdCAqIGZsaXBjb2RlLmNvbSBieSBKb2huIFcuIFJhdGNsaWZmICAvLyBKdWx5IDIyLCAyMDAwXG4gICAgXHRcdCAqIFNlZSBvcmlnaW5hbCBjb2RlIGFuZCBtb3JlIGluZm9ybWF0aW9uIGhlcmU6XG4gICAgXHRcdCAqIGh0dHA6Ly93d3cuZmxpcGNvZGUuY29tL2FyY2hpdmVzL0VmZmljaWVudF9Qb2x5Z29uX1RyaWFuZ3VsYXRpb24uc2h0bWxcbiAgICBcdFx0ICpcbiAgICBcdFx0ICogcG9ydGVkIHRvIGFjdGlvbnNjcmlwdCBieSBaZXZhbiBSb3NzZXJcbiAgICBcdFx0ICogd3d3LmFjdGlvbnNuaXBwZXQuY29tXG4gICAgXHRcdCAqXG4gICAgXHRcdCAqIHBvcnRlZCB0byBqYXZhc2NyaXB0IGJ5IEpvc2h1YSBLb29cbiAgICBcdFx0ICogaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xuICAgIFx0XHQgKlxuICAgIFx0XHQgKi9cblxuICAgIFx0XHRmdW5jdGlvbiBzbmlwKCBjb250b3VyLCB1LCB2LCB3LCBuLCB2ZXJ0cyApIHtcblxuICAgIFx0XHRcdHZhciBwO1xuICAgIFx0XHRcdHZhciBheCwgYXksIGJ4LCBieTtcbiAgICBcdFx0XHR2YXIgY3gsIGN5LCBweCwgcHk7XG5cbiAgICBcdFx0XHRheCA9IGNvbnRvdXJbIHZlcnRzWyB1IF0gXS54O1xuICAgIFx0XHRcdGF5ID0gY29udG91clsgdmVydHNbIHUgXSBdLnk7XG5cbiAgICBcdFx0XHRieCA9IGNvbnRvdXJbIHZlcnRzWyB2IF0gXS54O1xuICAgIFx0XHRcdGJ5ID0gY29udG91clsgdmVydHNbIHYgXSBdLnk7XG5cbiAgICBcdFx0XHRjeCA9IGNvbnRvdXJbIHZlcnRzWyB3IF0gXS54O1xuICAgIFx0XHRcdGN5ID0gY29udG91clsgdmVydHNbIHcgXSBdLnk7XG5cbiAgICBcdFx0XHRpZiAoIE51bWJlci5FUFNJTE9OID4gKCAoICggYnggLSBheCApICogKCBjeSAtIGF5ICkgKSAtICggKCBieSAtIGF5ICkgKiAoIGN4IC0gYXggKSApICkgKSByZXR1cm4gZmFsc2U7XG5cbiAgICBcdFx0XHR2YXIgYVgsIGFZLCBiWCwgYlksIGNYLCBjWTtcbiAgICBcdFx0XHR2YXIgYXB4LCBhcHksIGJweCwgYnB5LCBjcHgsIGNweTtcbiAgICBcdFx0XHR2YXIgY0NST1NTYXAsIGJDUk9TU2NwLCBhQ1JPU1NicDtcblxuICAgIFx0XHRcdGFYID0gY3ggLSBieDsgIGFZID0gY3kgLSBieTtcbiAgICBcdFx0XHRiWCA9IGF4IC0gY3g7ICBiWSA9IGF5IC0gY3k7XG4gICAgXHRcdFx0Y1ggPSBieCAtIGF4OyAgY1kgPSBieSAtIGF5O1xuXG4gICAgXHRcdFx0Zm9yICggcCA9IDA7IHAgPCBuOyBwICsrICkge1xuXG4gICAgXHRcdFx0XHRweCA9IGNvbnRvdXJbIHZlcnRzWyBwIF0gXS54O1xuICAgIFx0XHRcdFx0cHkgPSBjb250b3VyWyB2ZXJ0c1sgcCBdIF0ueTtcblxuICAgIFx0XHRcdFx0aWYgKCAoICggcHggPT09IGF4ICkgJiYgKCBweSA9PT0gYXkgKSApIHx8XG4gICAgXHRcdFx0XHRcdCAoICggcHggPT09IGJ4ICkgJiYgKCBweSA9PT0gYnkgKSApIHx8XG4gICAgXHRcdFx0XHRcdCAoICggcHggPT09IGN4ICkgJiYgKCBweSA9PT0gY3kgKSApIClcdGNvbnRpbnVlO1xuXG4gICAgXHRcdFx0XHRhcHggPSBweCAtIGF4OyAgYXB5ID0gcHkgLSBheTtcbiAgICBcdFx0XHRcdGJweCA9IHB4IC0gYng7ICBicHkgPSBweSAtIGJ5O1xuICAgIFx0XHRcdFx0Y3B4ID0gcHggLSBjeDsgIGNweSA9IHB5IC0gY3k7XG5cbiAgICBcdFx0XHRcdC8vIHNlZSBpZiBwIGlzIGluc2lkZSB0cmlhbmdsZSBhYmNcblxuICAgIFx0XHRcdFx0YUNST1NTYnAgPSBhWCAqIGJweSAtIGFZICogYnB4O1xuICAgIFx0XHRcdFx0Y0NST1NTYXAgPSBjWCAqIGFweSAtIGNZICogYXB4O1xuICAgIFx0XHRcdFx0YkNST1NTY3AgPSBiWCAqIGNweSAtIGJZICogY3B4O1xuXG4gICAgXHRcdFx0XHRpZiAoICggYUNST1NTYnAgPj0gLSBOdW1iZXIuRVBTSUxPTiApICYmICggYkNST1NTY3AgPj0gLSBOdW1iZXIuRVBTSUxPTiApICYmICggY0NST1NTYXAgPj0gLSBOdW1iZXIuRVBTSUxPTiApICkgcmV0dXJuIGZhbHNlO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0cmV0dXJuIHRydWU7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdC8vIHRha2VzIGluIGFuIGNvbnRvdXIgYXJyYXkgYW5kIHJldHVybnNcblxuICAgIFx0XHRyZXR1cm4gZnVuY3Rpb24gdHJpYW5ndWxhdGUoIGNvbnRvdXIsIGluZGljZXMgKSB7XG5cbiAgICBcdFx0XHR2YXIgbiA9IGNvbnRvdXIubGVuZ3RoO1xuXG4gICAgXHRcdFx0aWYgKCBuIDwgMyApIHJldHVybiBudWxsO1xuXG4gICAgXHRcdFx0dmFyIHJlc3VsdCA9IFtdLFxuICAgIFx0XHRcdFx0dmVydHMgPSBbXSxcbiAgICBcdFx0XHRcdHZlcnRJbmRpY2VzID0gW107XG5cbiAgICBcdFx0XHQvKiB3ZSB3YW50IGEgY291bnRlci1jbG9ja3dpc2UgcG9seWdvbiBpbiB2ZXJ0cyAqL1xuXG4gICAgXHRcdFx0dmFyIHUsIHYsIHc7XG5cbiAgICBcdFx0XHRpZiAoIGV4cG9ydHMuU2hhcGVVdGlscy5hcmVhKCBjb250b3VyICkgPiAwLjAgKSB7XG5cbiAgICBcdFx0XHRcdGZvciAoIHYgPSAwOyB2IDwgbjsgdiArKyApIHZlcnRzWyB2IF0gPSB2O1xuXG4gICAgXHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0Zm9yICggdiA9IDA7IHYgPCBuOyB2ICsrICkgdmVydHNbIHYgXSA9ICggbiAtIDEgKSAtIHY7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHR2YXIgbnYgPSBuO1xuXG4gICAgXHRcdFx0LyogIHJlbW92ZSBudiAtIDIgdmVydGljZXMsIGNyZWF0aW5nIDEgdHJpYW5nbGUgZXZlcnkgdGltZSAqL1xuXG4gICAgXHRcdFx0dmFyIGNvdW50ID0gMiAqIG52OyAgIC8qIGVycm9yIGRldGVjdGlvbiAqL1xuXG4gICAgXHRcdFx0Zm9yICggdiA9IG52IC0gMTsgbnYgPiAyOyApIHtcblxuICAgIFx0XHRcdFx0LyogaWYgd2UgbG9vcCwgaXQgaXMgcHJvYmFibHkgYSBub24tc2ltcGxlIHBvbHlnb24gKi9cblxuICAgIFx0XHRcdFx0aWYgKCAoIGNvdW50IC0tICkgPD0gMCApIHtcblxuICAgIFx0XHRcdFx0XHQvLyoqIFRyaWFuZ3VsYXRlOiBFUlJPUiAtIHByb2JhYmxlIGJhZCBwb2x5Z29uIVxuXG4gICAgXHRcdFx0XHRcdC8vdGhyb3cgKCBcIldhcm5pbmcsIHVuYWJsZSB0byB0cmlhbmd1bGF0ZSBwb2x5Z29uIVwiICk7XG4gICAgXHRcdFx0XHRcdC8vcmV0dXJuIG51bGw7XG4gICAgXHRcdFx0XHRcdC8vIFNvbWV0aW1lcyB3YXJuaW5nIGlzIGZpbmUsIGVzcGVjaWFsbHkgcG9seWdvbnMgYXJlIHRyaWFuZ3VsYXRlZCBpbiByZXZlcnNlLlxuICAgIFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5TaGFwZVV0aWxzOiBVbmFibGUgdG8gdHJpYW5ndWxhdGUgcG9seWdvbiEgaW4gdHJpYW5ndWxhdGUoKScgKTtcblxuICAgIFx0XHRcdFx0XHRpZiAoIGluZGljZXMgKSByZXR1cm4gdmVydEluZGljZXM7XG4gICAgXHRcdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0LyogdGhyZWUgY29uc2VjdXRpdmUgdmVydGljZXMgaW4gY3VycmVudCBwb2x5Z29uLCA8dSx2LHc+ICovXG5cbiAgICBcdFx0XHRcdHUgPSB2OyBcdCBcdGlmICggbnYgPD0gdSApIHUgPSAwOyAgICAgLyogcHJldmlvdXMgKi9cbiAgICBcdFx0XHRcdHYgPSB1ICsgMTsgIGlmICggbnYgPD0gdiApIHYgPSAwOyAgICAgLyogbmV3IHYgICAgKi9cbiAgICBcdFx0XHRcdHcgPSB2ICsgMTsgIGlmICggbnYgPD0gdyApIHcgPSAwOyAgICAgLyogbmV4dCAgICAgKi9cblxuICAgIFx0XHRcdFx0aWYgKCBzbmlwKCBjb250b3VyLCB1LCB2LCB3LCBudiwgdmVydHMgKSApIHtcblxuICAgIFx0XHRcdFx0XHR2YXIgYSwgYiwgYywgcywgdDtcblxuICAgIFx0XHRcdFx0XHQvKiB0cnVlIG5hbWVzIG9mIHRoZSB2ZXJ0aWNlcyAqL1xuXG4gICAgXHRcdFx0XHRcdGEgPSB2ZXJ0c1sgdSBdO1xuICAgIFx0XHRcdFx0XHRiID0gdmVydHNbIHYgXTtcbiAgICBcdFx0XHRcdFx0YyA9IHZlcnRzWyB3IF07XG5cbiAgICBcdFx0XHRcdFx0Lyogb3V0cHV0IFRyaWFuZ2xlICovXG5cbiAgICBcdFx0XHRcdFx0cmVzdWx0LnB1c2goIFsgY29udG91clsgYSBdLFxuICAgIFx0XHRcdFx0XHRcdGNvbnRvdXJbIGIgXSxcbiAgICBcdFx0XHRcdFx0XHRjb250b3VyWyBjIF0gXSApO1xuXG5cbiAgICBcdFx0XHRcdFx0dmVydEluZGljZXMucHVzaCggWyB2ZXJ0c1sgdSBdLCB2ZXJ0c1sgdiBdLCB2ZXJ0c1sgdyBdIF0gKTtcblxuICAgIFx0XHRcdFx0XHQvKiByZW1vdmUgdiBmcm9tIHRoZSByZW1haW5pbmcgcG9seWdvbiAqL1xuXG4gICAgXHRcdFx0XHRcdGZvciAoIHMgPSB2LCB0ID0gdiArIDE7IHQgPCBudjsgcyArKywgdCArKyApIHtcblxuICAgIFx0XHRcdFx0XHRcdHZlcnRzWyBzIF0gPSB2ZXJ0c1sgdCBdO1xuXG4gICAgXHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0XHRudiAtLTtcblxuICAgIFx0XHRcdFx0XHQvKiByZXNldCBlcnJvciBkZXRlY3Rpb24gY291bnRlciAqL1xuXG4gICAgXHRcdFx0XHRcdGNvdW50ID0gMiAqIG52O1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRpZiAoIGluZGljZXMgKSByZXR1cm4gdmVydEluZGljZXM7XG4gICAgXHRcdFx0cmV0dXJuIHJlc3VsdDtcblxuICAgIFx0XHR9XG5cbiAgICBcdH0gKSgpLFxuXG4gICAgXHR0cmlhbmd1bGF0ZVNoYXBlOiBmdW5jdGlvbiAoIGNvbnRvdXIsIGhvbGVzICkge1xuXG4gICAgXHRcdGZ1bmN0aW9uIHJlbW92ZUR1cEVuZFB0cyhwb2ludHMpIHtcblxuICAgIFx0XHRcdHZhciBsID0gcG9pbnRzLmxlbmd0aDtcblxuICAgIFx0XHRcdGlmICggbCA+IDIgJiYgcG9pbnRzWyBsIC0gMSBdLmVxdWFscyggcG9pbnRzWyAwIF0gKSApIHtcblxuICAgIFx0XHRcdFx0cG9pbnRzLnBvcCgpO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZW1vdmVEdXBFbmRQdHMoIGNvbnRvdXIgKTtcbiAgICBcdFx0aG9sZXMuZm9yRWFjaCggcmVtb3ZlRHVwRW5kUHRzICk7XG5cbiAgICBcdFx0ZnVuY3Rpb24gcG9pbnRfaW5fc2VnbWVudF8yRF9jb2xpbiggaW5TZWdQdDEsIGluU2VnUHQyLCBpbk90aGVyUHQgKSB7XG5cbiAgICBcdFx0XHQvLyBpbk90aGVyUHQgbmVlZHMgdG8gYmUgY29sbGluZWFyIHRvIHRoZSBpblNlZ21lbnRcbiAgICBcdFx0XHRpZiAoIGluU2VnUHQxLnggIT09IGluU2VnUHQyLnggKSB7XG5cbiAgICBcdFx0XHRcdGlmICggaW5TZWdQdDEueCA8IGluU2VnUHQyLnggKSB7XG5cbiAgICBcdFx0XHRcdFx0cmV0dXJuXHQoICggaW5TZWdQdDEueCA8PSBpbk90aGVyUHQueCApICYmICggaW5PdGhlclB0LnggPD0gaW5TZWdQdDIueCApICk7XG5cbiAgICBcdFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdFx0cmV0dXJuXHQoICggaW5TZWdQdDIueCA8PSBpbk90aGVyUHQueCApICYmICggaW5PdGhlclB0LnggPD0gaW5TZWdQdDEueCApICk7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdGlmICggaW5TZWdQdDEueSA8IGluU2VnUHQyLnkgKSB7XG5cbiAgICBcdFx0XHRcdFx0cmV0dXJuXHQoICggaW5TZWdQdDEueSA8PSBpbk90aGVyUHQueSApICYmICggaW5PdGhlclB0LnkgPD0gaW5TZWdQdDIueSApICk7XG5cbiAgICBcdFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdFx0cmV0dXJuXHQoICggaW5TZWdQdDIueSA8PSBpbk90aGVyUHQueSApICYmICggaW5PdGhlclB0LnkgPD0gaW5TZWdQdDEueSApICk7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdFx0ZnVuY3Rpb24gaW50ZXJzZWN0X3NlZ21lbnRzXzJEKCBpblNlZzFQdDEsIGluU2VnMVB0MiwgaW5TZWcyUHQxLCBpblNlZzJQdDIsIGluRXhjbHVkZUFkamFjZW50U2VncyApIHtcblxuICAgIFx0XHRcdHZhciBzZWcxZHggPSBpblNlZzFQdDIueCAtIGluU2VnMVB0MS54LCAgIHNlZzFkeSA9IGluU2VnMVB0Mi55IC0gaW5TZWcxUHQxLnk7XG4gICAgXHRcdFx0dmFyIHNlZzJkeCA9IGluU2VnMlB0Mi54IC0gaW5TZWcyUHQxLngsICAgc2VnMmR5ID0gaW5TZWcyUHQyLnkgLSBpblNlZzJQdDEueTtcblxuICAgIFx0XHRcdHZhciBzZWcxc2VnMmR4ID0gaW5TZWcxUHQxLnggLSBpblNlZzJQdDEueDtcbiAgICBcdFx0XHR2YXIgc2VnMXNlZzJkeSA9IGluU2VnMVB0MS55IC0gaW5TZWcyUHQxLnk7XG5cbiAgICBcdFx0XHR2YXIgbGltaXRcdFx0PSBzZWcxZHkgKiBzZWcyZHggLSBzZWcxZHggKiBzZWcyZHk7XG4gICAgXHRcdFx0dmFyIHBlcnBTZWcxXHQ9IHNlZzFkeSAqIHNlZzFzZWcyZHggLSBzZWcxZHggKiBzZWcxc2VnMmR5O1xuXG4gICAgXHRcdFx0aWYgKCBNYXRoLmFicyggbGltaXQgKSA+IE51bWJlci5FUFNJTE9OICkge1xuXG4gICAgXHRcdFx0XHQvLyBub3QgcGFyYWxsZWxcblxuICAgIFx0XHRcdFx0dmFyIHBlcnBTZWcyO1xuICAgIFx0XHRcdFx0aWYgKCBsaW1pdCA+IDAgKSB7XG5cbiAgICBcdFx0XHRcdFx0aWYgKCAoIHBlcnBTZWcxIDwgMCApIHx8ICggcGVycFNlZzEgPiBsaW1pdCApICkgXHRcdHJldHVybiBbXTtcbiAgICBcdFx0XHRcdFx0cGVycFNlZzIgPSBzZWcyZHkgKiBzZWcxc2VnMmR4IC0gc2VnMmR4ICogc2VnMXNlZzJkeTtcbiAgICBcdFx0XHRcdFx0aWYgKCAoIHBlcnBTZWcyIDwgMCApIHx8ICggcGVycFNlZzIgPiBsaW1pdCApICkgXHRcdHJldHVybiBbXTtcblxuICAgIFx0XHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0XHRpZiAoICggcGVycFNlZzEgPiAwICkgfHwgKCBwZXJwU2VnMSA8IGxpbWl0ICkgKSBcdFx0cmV0dXJuIFtdO1xuICAgIFx0XHRcdFx0XHRwZXJwU2VnMiA9IHNlZzJkeSAqIHNlZzFzZWcyZHggLSBzZWcyZHggKiBzZWcxc2VnMmR5O1xuICAgIFx0XHRcdFx0XHRpZiAoICggcGVycFNlZzIgPiAwICkgfHwgKCBwZXJwU2VnMiA8IGxpbWl0ICkgKSBcdFx0cmV0dXJuIFtdO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdC8vIGkuZS4gdG8gcmVkdWNlIHJvdW5kaW5nIGVycm9yc1xuICAgIFx0XHRcdFx0Ly8gaW50ZXJzZWN0aW9uIGF0IGVuZHBvaW50IG9mIHNlZ21lbnQjMT9cbiAgICBcdFx0XHRcdGlmICggcGVycFNlZzIgPT09IDAgKSB7XG5cbiAgICBcdFx0XHRcdFx0aWYgKCAoIGluRXhjbHVkZUFkamFjZW50U2VncyApICYmXG4gICAgXHRcdFx0XHRcdFx0ICggKCBwZXJwU2VnMSA9PT0gMCApIHx8ICggcGVycFNlZzEgPT09IGxpbWl0ICkgKSApXHRcdHJldHVybiBbXTtcbiAgICBcdFx0XHRcdFx0cmV0dXJuIFsgaW5TZWcxUHQxIF07XG5cbiAgICBcdFx0XHRcdH1cbiAgICBcdFx0XHRcdGlmICggcGVycFNlZzIgPT09IGxpbWl0ICkge1xuXG4gICAgXHRcdFx0XHRcdGlmICggKCBpbkV4Y2x1ZGVBZGphY2VudFNlZ3MgKSAmJlxuICAgIFx0XHRcdFx0XHRcdCAoICggcGVycFNlZzEgPT09IDAgKSB8fCAoIHBlcnBTZWcxID09PSBsaW1pdCApICkgKVx0XHRyZXR1cm4gW107XG4gICAgXHRcdFx0XHRcdHJldHVybiBbIGluU2VnMVB0MiBdO1xuXG4gICAgXHRcdFx0XHR9XG4gICAgXHRcdFx0XHQvLyBpbnRlcnNlY3Rpb24gYXQgZW5kcG9pbnQgb2Ygc2VnbWVudCMyP1xuICAgIFx0XHRcdFx0aWYgKCBwZXJwU2VnMSA9PT0gMCApXHRcdHJldHVybiBbIGluU2VnMlB0MSBdO1xuICAgIFx0XHRcdFx0aWYgKCBwZXJwU2VnMSA9PT0gbGltaXQgKVx0cmV0dXJuIFsgaW5TZWcyUHQyIF07XG5cbiAgICBcdFx0XHRcdC8vIHJldHVybiByZWFsIGludGVyc2VjdGlvbiBwb2ludFxuICAgIFx0XHRcdFx0dmFyIGZhY3RvclNlZzEgPSBwZXJwU2VnMiAvIGxpbWl0O1xuICAgIFx0XHRcdFx0cmV0dXJuXHRbIHsgeDogaW5TZWcxUHQxLnggKyBmYWN0b3JTZWcxICogc2VnMWR4LFxuICAgIFx0XHRcdFx0XHRcdFx0eTogaW5TZWcxUHQxLnkgKyBmYWN0b3JTZWcxICogc2VnMWR5IH0gXTtcblxuICAgIFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdC8vIHBhcmFsbGVsIG9yIGNvbGxpbmVhclxuICAgIFx0XHRcdFx0aWYgKCAoIHBlcnBTZWcxICE9PSAwICkgfHxcbiAgICBcdFx0XHRcdFx0ICggc2VnMmR5ICogc2VnMXNlZzJkeCAhPT0gc2VnMmR4ICogc2VnMXNlZzJkeSApICkgXHRcdFx0cmV0dXJuIFtdO1xuXG4gICAgXHRcdFx0XHQvLyB0aGV5IGFyZSBjb2xsaW5lYXIgb3IgZGVnZW5lcmF0ZVxuICAgIFx0XHRcdFx0dmFyIHNlZzFQdCA9ICggKCBzZWcxZHggPT09IDAgKSAmJiAoIHNlZzFkeSA9PT0gMCApICk7XHQvLyBzZWdtZW50MSBpcyBqdXN0IGEgcG9pbnQ/XG4gICAgXHRcdFx0XHR2YXIgc2VnMlB0ID0gKCAoIHNlZzJkeCA9PT0gMCApICYmICggc2VnMmR5ID09PSAwICkgKTtcdC8vIHNlZ21lbnQyIGlzIGp1c3QgYSBwb2ludD9cbiAgICBcdFx0XHRcdC8vIGJvdGggc2VnbWVudHMgYXJlIHBvaW50c1xuICAgIFx0XHRcdFx0aWYgKCBzZWcxUHQgJiYgc2VnMlB0ICkge1xuXG4gICAgXHRcdFx0XHRcdGlmICggKCBpblNlZzFQdDEueCAhPT0gaW5TZWcyUHQxLnggKSB8fFxuICAgIFx0XHRcdFx0XHRcdCAoIGluU2VnMVB0MS55ICE9PSBpblNlZzJQdDEueSApIClcdFx0cmV0dXJuIFtdO1x0Ly8gdGhleSBhcmUgZGlzdGluY3QgIHBvaW50c1xuICAgIFx0XHRcdFx0XHRyZXR1cm4gWyBpblNlZzFQdDEgXTsgICAgICAgICAgICAgICAgIFx0XHRcdFx0XHRcdC8vIHRoZXkgYXJlIHRoZSBzYW1lIHBvaW50XG5cbiAgICBcdFx0XHRcdH1cbiAgICBcdFx0XHRcdC8vIHNlZ21lbnQjMSAgaXMgYSBzaW5nbGUgcG9pbnRcbiAgICBcdFx0XHRcdGlmICggc2VnMVB0ICkge1xuXG4gICAgXHRcdFx0XHRcdGlmICggISBwb2ludF9pbl9zZWdtZW50XzJEX2NvbGluKCBpblNlZzJQdDEsIGluU2VnMlB0MiwgaW5TZWcxUHQxICkgKVx0XHRyZXR1cm4gW107XHRcdC8vIGJ1dCBub3QgaW4gc2VnbWVudCMyXG4gICAgXHRcdFx0XHRcdHJldHVybiBbIGluU2VnMVB0MSBdO1xuXG4gICAgXHRcdFx0XHR9XG4gICAgXHRcdFx0XHQvLyBzZWdtZW50IzIgIGlzIGEgc2luZ2xlIHBvaW50XG4gICAgXHRcdFx0XHRpZiAoIHNlZzJQdCApIHtcblxuICAgIFx0XHRcdFx0XHRpZiAoICEgcG9pbnRfaW5fc2VnbWVudF8yRF9jb2xpbiggaW5TZWcxUHQxLCBpblNlZzFQdDIsIGluU2VnMlB0MSApIClcdFx0cmV0dXJuIFtdO1x0XHQvLyBidXQgbm90IGluIHNlZ21lbnQjMVxuICAgIFx0XHRcdFx0XHRyZXR1cm4gWyBpblNlZzJQdDEgXTtcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHQvLyB0aGV5IGFyZSBjb2xsaW5lYXIgc2VnbWVudHMsIHdoaWNoIG1pZ2h0IG92ZXJsYXBcbiAgICBcdFx0XHRcdHZhciBzZWcxbWluLCBzZWcxbWF4LCBzZWcxbWluVmFsLCBzZWcxbWF4VmFsO1xuICAgIFx0XHRcdFx0dmFyIHNlZzJtaW4sIHNlZzJtYXgsIHNlZzJtaW5WYWwsIHNlZzJtYXhWYWw7XG4gICAgXHRcdFx0XHRpZiAoIHNlZzFkeCAhPT0gMCApIHtcblxuICAgIFx0XHRcdFx0XHQvLyB0aGUgc2VnbWVudHMgYXJlIE5PVCBvbiBhIHZlcnRpY2FsIGxpbmVcbiAgICBcdFx0XHRcdFx0aWYgKCBpblNlZzFQdDEueCA8IGluU2VnMVB0Mi54ICkge1xuXG4gICAgXHRcdFx0XHRcdFx0c2VnMW1pbiA9IGluU2VnMVB0MTsgc2VnMW1pblZhbCA9IGluU2VnMVB0MS54O1xuICAgIFx0XHRcdFx0XHRcdHNlZzFtYXggPSBpblNlZzFQdDI7IHNlZzFtYXhWYWwgPSBpblNlZzFQdDIueDtcblxuICAgIFx0XHRcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHRcdFx0c2VnMW1pbiA9IGluU2VnMVB0Mjsgc2VnMW1pblZhbCA9IGluU2VnMVB0Mi54O1xuICAgIFx0XHRcdFx0XHRcdHNlZzFtYXggPSBpblNlZzFQdDE7IHNlZzFtYXhWYWwgPSBpblNlZzFQdDEueDtcblxuICAgIFx0XHRcdFx0XHR9XG4gICAgXHRcdFx0XHRcdGlmICggaW5TZWcyUHQxLnggPCBpblNlZzJQdDIueCApIHtcblxuICAgIFx0XHRcdFx0XHRcdHNlZzJtaW4gPSBpblNlZzJQdDE7IHNlZzJtaW5WYWwgPSBpblNlZzJQdDEueDtcbiAgICBcdFx0XHRcdFx0XHRzZWcybWF4ID0gaW5TZWcyUHQyOyBzZWcybWF4VmFsID0gaW5TZWcyUHQyLng7XG5cbiAgICBcdFx0XHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0XHRcdHNlZzJtaW4gPSBpblNlZzJQdDI7IHNlZzJtaW5WYWwgPSBpblNlZzJQdDIueDtcbiAgICBcdFx0XHRcdFx0XHRzZWcybWF4ID0gaW5TZWcyUHQxOyBzZWcybWF4VmFsID0gaW5TZWcyUHQxLng7XG5cbiAgICBcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHRcdC8vIHRoZSBzZWdtZW50cyBhcmUgb24gYSB2ZXJ0aWNhbCBsaW5lXG4gICAgXHRcdFx0XHRcdGlmICggaW5TZWcxUHQxLnkgPCBpblNlZzFQdDIueSApIHtcblxuICAgIFx0XHRcdFx0XHRcdHNlZzFtaW4gPSBpblNlZzFQdDE7IHNlZzFtaW5WYWwgPSBpblNlZzFQdDEueTtcbiAgICBcdFx0XHRcdFx0XHRzZWcxbWF4ID0gaW5TZWcxUHQyOyBzZWcxbWF4VmFsID0gaW5TZWcxUHQyLnk7XG5cbiAgICBcdFx0XHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0XHRcdHNlZzFtaW4gPSBpblNlZzFQdDI7IHNlZzFtaW5WYWwgPSBpblNlZzFQdDIueTtcbiAgICBcdFx0XHRcdFx0XHRzZWcxbWF4ID0gaW5TZWcxUHQxOyBzZWcxbWF4VmFsID0gaW5TZWcxUHQxLnk7XG5cbiAgICBcdFx0XHRcdFx0fVxuICAgIFx0XHRcdFx0XHRpZiAoIGluU2VnMlB0MS55IDwgaW5TZWcyUHQyLnkgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHRzZWcybWluID0gaW5TZWcyUHQxOyBzZWcybWluVmFsID0gaW5TZWcyUHQxLnk7XG4gICAgXHRcdFx0XHRcdFx0c2VnMm1heCA9IGluU2VnMlB0Mjsgc2VnMm1heFZhbCA9IGluU2VnMlB0Mi55O1xuXG4gICAgXHRcdFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdFx0XHRzZWcybWluID0gaW5TZWcyUHQyOyBzZWcybWluVmFsID0gaW5TZWcyUHQyLnk7XG4gICAgXHRcdFx0XHRcdFx0c2VnMm1heCA9IGluU2VnMlB0MTsgc2VnMm1heFZhbCA9IGluU2VnMlB0MS55O1xuXG4gICAgXHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0fVxuICAgIFx0XHRcdFx0aWYgKCBzZWcxbWluVmFsIDw9IHNlZzJtaW5WYWwgKSB7XG5cbiAgICBcdFx0XHRcdFx0aWYgKCBzZWcxbWF4VmFsIDwgIHNlZzJtaW5WYWwgKVx0cmV0dXJuIFtdO1xuICAgIFx0XHRcdFx0XHRpZiAoIHNlZzFtYXhWYWwgPT09IHNlZzJtaW5WYWwgKVx0e1xuXG4gICAgXHRcdFx0XHRcdFx0aWYgKCBpbkV4Y2x1ZGVBZGphY2VudFNlZ3MgKVx0XHRyZXR1cm4gW107XG4gICAgXHRcdFx0XHRcdFx0cmV0dXJuIFsgc2VnMm1pbiBdO1xuXG4gICAgXHRcdFx0XHRcdH1cbiAgICBcdFx0XHRcdFx0aWYgKCBzZWcxbWF4VmFsIDw9IHNlZzJtYXhWYWwgKVx0cmV0dXJuIFsgc2VnMm1pbiwgc2VnMW1heCBdO1xuICAgIFx0XHRcdFx0XHRyZXR1cm5cdFsgc2VnMm1pbiwgc2VnMm1heCBdO1xuXG4gICAgXHRcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHRcdGlmICggc2VnMW1pblZhbCA+ICBzZWcybWF4VmFsIClcdHJldHVybiBbXTtcbiAgICBcdFx0XHRcdFx0aWYgKCBzZWcxbWluVmFsID09PSBzZWcybWF4VmFsIClcdHtcblxuICAgIFx0XHRcdFx0XHRcdGlmICggaW5FeGNsdWRlQWRqYWNlbnRTZWdzIClcdFx0cmV0dXJuIFtdO1xuICAgIFx0XHRcdFx0XHRcdHJldHVybiBbIHNlZzFtaW4gXTtcblxuICAgIFx0XHRcdFx0XHR9XG4gICAgXHRcdFx0XHRcdGlmICggc2VnMW1heFZhbCA8PSBzZWcybWF4VmFsIClcdHJldHVybiBbIHNlZzFtaW4sIHNlZzFtYXggXTtcbiAgICBcdFx0XHRcdFx0cmV0dXJuXHRbIHNlZzFtaW4sIHNlZzJtYXggXTtcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHRmdW5jdGlvbiBpc1BvaW50SW5zaWRlQW5nbGUoIGluVmVydGV4LCBpbkxlZ0Zyb21QdCwgaW5MZWdUb1B0LCBpbk90aGVyUHQgKSB7XG5cbiAgICBcdFx0XHQvLyBUaGUgb3JkZXIgb2YgbGVncyBpcyBpbXBvcnRhbnRcblxuICAgIFx0XHRcdC8vIHRyYW5zbGF0aW9uIG9mIGFsbCBwb2ludHMsIHNvIHRoYXQgVmVydGV4IGlzIGF0ICgwLDApXG4gICAgXHRcdFx0dmFyIGxlZ0Zyb21QdFhcdD0gaW5MZWdGcm9tUHQueCAtIGluVmVydGV4LngsICBsZWdGcm9tUHRZXHQ9IGluTGVnRnJvbVB0LnkgLSBpblZlcnRleC55O1xuICAgIFx0XHRcdHZhciBsZWdUb1B0WFx0PSBpbkxlZ1RvUHQueFx0LSBpblZlcnRleC54LCAgbGVnVG9QdFlcdFx0PSBpbkxlZ1RvUHQueVx0LSBpblZlcnRleC55O1xuICAgIFx0XHRcdHZhciBvdGhlclB0WFx0PSBpbk90aGVyUHQueFx0LSBpblZlcnRleC54LCAgb3RoZXJQdFlcdFx0PSBpbk90aGVyUHQueVx0LSBpblZlcnRleC55O1xuXG4gICAgXHRcdFx0Ly8gbWFpbiBhbmdsZSA+MDogPCAxODAgZGVnLjsgMDogMTgwIGRlZy47IDwwOiA+IDE4MCBkZWcuXG4gICAgXHRcdFx0dmFyIGZyb20ydG9BbmdsZVx0PSBsZWdGcm9tUHRYICogbGVnVG9QdFkgLSBsZWdGcm9tUHRZICogbGVnVG9QdFg7XG4gICAgXHRcdFx0dmFyIGZyb20yb3RoZXJBbmdsZVx0PSBsZWdGcm9tUHRYICogb3RoZXJQdFkgLSBsZWdGcm9tUHRZICogb3RoZXJQdFg7XG5cbiAgICBcdFx0XHRpZiAoIE1hdGguYWJzKCBmcm9tMnRvQW5nbGUgKSA+IE51bWJlci5FUFNJTE9OICkge1xuXG4gICAgXHRcdFx0XHQvLyBhbmdsZSAhPSAxODAgZGVnLlxuXG4gICAgXHRcdFx0XHR2YXIgb3RoZXIydG9BbmdsZVx0XHQ9IG90aGVyUHRYICogbGVnVG9QdFkgLSBvdGhlclB0WSAqIGxlZ1RvUHRYO1xuICAgIFx0XHRcdFx0Ly8gY29uc29sZS5sb2coIFwiZnJvbTJ0bzogXCIgKyBmcm9tMnRvQW5nbGUgKyBcIiwgZnJvbTJvdGhlcjogXCIgKyBmcm9tMm90aGVyQW5nbGUgKyBcIiwgb3RoZXIydG86IFwiICsgb3RoZXIydG9BbmdsZSApO1xuXG4gICAgXHRcdFx0XHRpZiAoIGZyb20ydG9BbmdsZSA+IDAgKSB7XG5cbiAgICBcdFx0XHRcdFx0Ly8gbWFpbiBhbmdsZSA8IDE4MCBkZWcuXG4gICAgXHRcdFx0XHRcdHJldHVyblx0KCAoIGZyb20yb3RoZXJBbmdsZSA+PSAwICkgJiYgKCBvdGhlcjJ0b0FuZ2xlID49IDAgKSApO1xuXG4gICAgXHRcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHRcdC8vIG1haW4gYW5nbGUgPiAxODAgZGVnLlxuICAgIFx0XHRcdFx0XHRyZXR1cm5cdCggKCBmcm9tMm90aGVyQW5nbGUgPj0gMCApIHx8ICggb3RoZXIydG9BbmdsZSA+PSAwICkgKTtcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0Ly8gYW5nbGUgPT0gMTgwIGRlZy5cbiAgICBcdFx0XHRcdC8vIGNvbnNvbGUubG9nKCBcImZyb20ydG86IDE4MCBkZWcuLCBmcm9tMm90aGVyOiBcIiArIGZyb20yb3RoZXJBbmdsZSAgKTtcbiAgICBcdFx0XHRcdHJldHVyblx0KCBmcm9tMm90aGVyQW5nbGUgPiAwICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG5cbiAgICBcdFx0ZnVuY3Rpb24gcmVtb3ZlSG9sZXMoIGNvbnRvdXIsIGhvbGVzICkge1xuXG4gICAgXHRcdFx0dmFyIHNoYXBlID0gY29udG91ci5jb25jYXQoKTsgLy8gd29yayBvbiB0aGlzIHNoYXBlXG4gICAgXHRcdFx0dmFyIGhvbGU7XG5cbiAgICBcdFx0XHRmdW5jdGlvbiBpc0N1dExpbmVJbnNpZGVBbmdsZXMoIGluU2hhcGVJZHgsIGluSG9sZUlkeCApIHtcblxuICAgIFx0XHRcdFx0Ly8gQ2hlY2sgaWYgaG9sZSBwb2ludCBsaWVzIHdpdGhpbiBhbmdsZSBhcm91bmQgc2hhcGUgcG9pbnRcbiAgICBcdFx0XHRcdHZhciBsYXN0U2hhcGVJZHggPSBzaGFwZS5sZW5ndGggLSAxO1xuXG4gICAgXHRcdFx0XHR2YXIgcHJldlNoYXBlSWR4ID0gaW5TaGFwZUlkeCAtIDE7XG4gICAgXHRcdFx0XHRpZiAoIHByZXZTaGFwZUlkeCA8IDAgKVx0XHRcdHByZXZTaGFwZUlkeCA9IGxhc3RTaGFwZUlkeDtcblxuICAgIFx0XHRcdFx0dmFyIG5leHRTaGFwZUlkeCA9IGluU2hhcGVJZHggKyAxO1xuICAgIFx0XHRcdFx0aWYgKCBuZXh0U2hhcGVJZHggPiBsYXN0U2hhcGVJZHggKVx0bmV4dFNoYXBlSWR4ID0gMDtcblxuICAgIFx0XHRcdFx0dmFyIGluc2lkZUFuZ2xlID0gaXNQb2ludEluc2lkZUFuZ2xlKCBzaGFwZVsgaW5TaGFwZUlkeCBdLCBzaGFwZVsgcHJldlNoYXBlSWR4IF0sIHNoYXBlWyBuZXh0U2hhcGVJZHggXSwgaG9sZVsgaW5Ib2xlSWR4IF0gKTtcbiAgICBcdFx0XHRcdGlmICggISBpbnNpZGVBbmdsZSApIHtcblxuICAgIFx0XHRcdFx0XHQvLyBjb25zb2xlLmxvZyggXCJWZXJ0ZXggKFNoYXBlKTogXCIgKyBpblNoYXBlSWR4ICsgXCIsIFBvaW50OiBcIiArIGhvbGVbaW5Ib2xlSWR4XS54ICsgXCIvXCIgKyBob2xlW2luSG9sZUlkeF0ueSApO1xuICAgIFx0XHRcdFx0XHRyZXR1cm5cdGZhbHNlO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdC8vIENoZWNrIGlmIHNoYXBlIHBvaW50IGxpZXMgd2l0aGluIGFuZ2xlIGFyb3VuZCBob2xlIHBvaW50XG4gICAgXHRcdFx0XHR2YXIgbGFzdEhvbGVJZHggPSBob2xlLmxlbmd0aCAtIDE7XG5cbiAgICBcdFx0XHRcdHZhciBwcmV2SG9sZUlkeCA9IGluSG9sZUlkeCAtIDE7XG4gICAgXHRcdFx0XHRpZiAoIHByZXZIb2xlSWR4IDwgMCApXHRcdFx0cHJldkhvbGVJZHggPSBsYXN0SG9sZUlkeDtcblxuICAgIFx0XHRcdFx0dmFyIG5leHRIb2xlSWR4ID0gaW5Ib2xlSWR4ICsgMTtcbiAgICBcdFx0XHRcdGlmICggbmV4dEhvbGVJZHggPiBsYXN0SG9sZUlkeCApXHRuZXh0SG9sZUlkeCA9IDA7XG5cbiAgICBcdFx0XHRcdGluc2lkZUFuZ2xlID0gaXNQb2ludEluc2lkZUFuZ2xlKCBob2xlWyBpbkhvbGVJZHggXSwgaG9sZVsgcHJldkhvbGVJZHggXSwgaG9sZVsgbmV4dEhvbGVJZHggXSwgc2hhcGVbIGluU2hhcGVJZHggXSApO1xuICAgIFx0XHRcdFx0aWYgKCAhIGluc2lkZUFuZ2xlICkge1xuXG4gICAgXHRcdFx0XHRcdC8vIGNvbnNvbGUubG9nKCBcIlZlcnRleCAoSG9sZSk6IFwiICsgaW5Ib2xlSWR4ICsgXCIsIFBvaW50OiBcIiArIHNoYXBlW2luU2hhcGVJZHhdLnggKyBcIi9cIiArIHNoYXBlW2luU2hhcGVJZHhdLnkgKTtcbiAgICBcdFx0XHRcdFx0cmV0dXJuXHRmYWxzZTtcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHRyZXR1cm5cdHRydWU7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRmdW5jdGlvbiBpbnRlcnNlY3RzU2hhcGVFZGdlKCBpblNoYXBlUHQsIGluSG9sZVB0ICkge1xuXG4gICAgXHRcdFx0XHQvLyBjaGVja3MgZm9yIGludGVyc2VjdGlvbnMgd2l0aCBzaGFwZSBlZGdlc1xuICAgIFx0XHRcdFx0dmFyIHNJZHgsIG5leHRJZHgsIGludGVyc2VjdGlvbjtcbiAgICBcdFx0XHRcdGZvciAoIHNJZHggPSAwOyBzSWR4IDwgc2hhcGUubGVuZ3RoOyBzSWR4ICsrICkge1xuXG4gICAgXHRcdFx0XHRcdG5leHRJZHggPSBzSWR4ICsgMTsgbmV4dElkeCAlPSBzaGFwZS5sZW5ndGg7XG4gICAgXHRcdFx0XHRcdGludGVyc2VjdGlvbiA9IGludGVyc2VjdF9zZWdtZW50c18yRCggaW5TaGFwZVB0LCBpbkhvbGVQdCwgc2hhcGVbIHNJZHggXSwgc2hhcGVbIG5leHRJZHggXSwgdHJ1ZSApO1xuICAgIFx0XHRcdFx0XHRpZiAoIGludGVyc2VjdGlvbi5sZW5ndGggPiAwIClcdFx0cmV0dXJuXHR0cnVlO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdHJldHVyblx0ZmFsc2U7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHR2YXIgaW5kZXBIb2xlcyA9IFtdO1xuXG4gICAgXHRcdFx0ZnVuY3Rpb24gaW50ZXJzZWN0c0hvbGVFZGdlKCBpblNoYXBlUHQsIGluSG9sZVB0ICkge1xuXG4gICAgXHRcdFx0XHQvLyBjaGVja3MgZm9yIGludGVyc2VjdGlvbnMgd2l0aCBob2xlIGVkZ2VzXG4gICAgXHRcdFx0XHR2YXIgaWhJZHgsIGNoa0hvbGUsXG4gICAgXHRcdFx0XHRcdGhJZHgsIG5leHRJZHgsIGludGVyc2VjdGlvbjtcbiAgICBcdFx0XHRcdGZvciAoIGloSWR4ID0gMDsgaWhJZHggPCBpbmRlcEhvbGVzLmxlbmd0aDsgaWhJZHggKysgKSB7XG5cbiAgICBcdFx0XHRcdFx0Y2hrSG9sZSA9IGhvbGVzWyBpbmRlcEhvbGVzWyBpaElkeCBdXTtcbiAgICBcdFx0XHRcdFx0Zm9yICggaElkeCA9IDA7IGhJZHggPCBjaGtIb2xlLmxlbmd0aDsgaElkeCArKyApIHtcblxuICAgIFx0XHRcdFx0XHRcdG5leHRJZHggPSBoSWR4ICsgMTsgbmV4dElkeCAlPSBjaGtIb2xlLmxlbmd0aDtcbiAgICBcdFx0XHRcdFx0XHRpbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3Rfc2VnbWVudHNfMkQoIGluU2hhcGVQdCwgaW5Ib2xlUHQsIGNoa0hvbGVbIGhJZHggXSwgY2hrSG9sZVsgbmV4dElkeCBdLCB0cnVlICk7XG4gICAgXHRcdFx0XHRcdFx0aWYgKCBpbnRlcnNlY3Rpb24ubGVuZ3RoID4gMCApXHRcdHJldHVyblx0dHJ1ZTtcblxuICAgIFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdH1cbiAgICBcdFx0XHRcdHJldHVyblx0ZmFsc2U7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHR2YXIgaG9sZUluZGV4LCBzaGFwZUluZGV4LFxuICAgIFx0XHRcdFx0c2hhcGVQdCwgaG9sZVB0LFxuICAgIFx0XHRcdFx0aG9sZUlkeCwgY3V0S2V5LCBmYWlsZWRDdXRzID0gW10sXG4gICAgXHRcdFx0XHR0bXBTaGFwZTEsIHRtcFNoYXBlMixcbiAgICBcdFx0XHRcdHRtcEhvbGUxLCB0bXBIb2xlMjtcblxuICAgIFx0XHRcdGZvciAoIHZhciBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcblxuICAgIFx0XHRcdFx0aW5kZXBIb2xlcy5wdXNoKCBoICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHR2YXIgbWluU2hhcGVJbmRleCA9IDA7XG4gICAgXHRcdFx0dmFyIGNvdW50ZXIgPSBpbmRlcEhvbGVzLmxlbmd0aCAqIDI7XG4gICAgXHRcdFx0d2hpbGUgKCBpbmRlcEhvbGVzLmxlbmd0aCA+IDAgKSB7XG5cbiAgICBcdFx0XHRcdGNvdW50ZXIgLS07XG4gICAgXHRcdFx0XHRpZiAoIGNvdW50ZXIgPCAwICkge1xuXG4gICAgXHRcdFx0XHRcdGNvbnNvbGUubG9nKCBcIkluZmluaXRlIExvb3AhIEhvbGVzIGxlZnQ6XCIgKyBpbmRlcEhvbGVzLmxlbmd0aCArIFwiLCBQcm9iYWJseSBIb2xlIG91dHNpZGUgU2hhcGUhXCIgKTtcbiAgICBcdFx0XHRcdFx0YnJlYWs7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0Ly8gc2VhcmNoIGZvciBzaGFwZS12ZXJ0ZXggYW5kIGhvbGUtdmVydGV4LFxuICAgIFx0XHRcdFx0Ly8gd2hpY2ggY2FuIGJlIGNvbm5lY3RlZCB3aXRob3V0IGludGVyc2VjdGlvbnNcbiAgICBcdFx0XHRcdGZvciAoIHNoYXBlSW5kZXggPSBtaW5TaGFwZUluZGV4OyBzaGFwZUluZGV4IDwgc2hhcGUubGVuZ3RoOyBzaGFwZUluZGV4ICsrICkge1xuXG4gICAgXHRcdFx0XHRcdHNoYXBlUHQgPSBzaGFwZVsgc2hhcGVJbmRleCBdO1xuICAgIFx0XHRcdFx0XHRob2xlSW5kZXhcdD0gLSAxO1xuXG4gICAgXHRcdFx0XHRcdC8vIHNlYXJjaCBmb3IgaG9sZSB3aGljaCBjYW4gYmUgcmVhY2hlZCB3aXRob3V0IGludGVyc2VjdGlvbnNcbiAgICBcdFx0XHRcdFx0Zm9yICggdmFyIGggPSAwOyBoIDwgaW5kZXBIb2xlcy5sZW5ndGg7IGggKysgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHRob2xlSWR4ID0gaW5kZXBIb2xlc1sgaCBdO1xuXG4gICAgXHRcdFx0XHRcdFx0Ly8gcHJldmVudCBtdWx0aXBsZSBjaGVja3NcbiAgICBcdFx0XHRcdFx0XHRjdXRLZXkgPSBzaGFwZVB0LnggKyBcIjpcIiArIHNoYXBlUHQueSArIFwiOlwiICsgaG9sZUlkeDtcbiAgICBcdFx0XHRcdFx0XHRpZiAoIGZhaWxlZEN1dHNbIGN1dEtleSBdICE9PSB1bmRlZmluZWQgKVx0XHRcdGNvbnRpbnVlO1xuXG4gICAgXHRcdFx0XHRcdFx0aG9sZSA9IGhvbGVzWyBob2xlSWR4IF07XG4gICAgXHRcdFx0XHRcdFx0Zm9yICggdmFyIGgyID0gMDsgaDIgPCBob2xlLmxlbmd0aDsgaDIgKysgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHRcdGhvbGVQdCA9IGhvbGVbIGgyIF07XG4gICAgXHRcdFx0XHRcdFx0XHRpZiAoICEgaXNDdXRMaW5lSW5zaWRlQW5nbGVzKCBzaGFwZUluZGV4LCBoMiApIClcdFx0Y29udGludWU7XG4gICAgXHRcdFx0XHRcdFx0XHRpZiAoIGludGVyc2VjdHNTaGFwZUVkZ2UoIHNoYXBlUHQsIGhvbGVQdCApIClcdFx0Y29udGludWU7XG4gICAgXHRcdFx0XHRcdFx0XHRpZiAoIGludGVyc2VjdHNIb2xlRWRnZSggc2hhcGVQdCwgaG9sZVB0ICkgKVx0XHRjb250aW51ZTtcblxuICAgIFx0XHRcdFx0XHRcdFx0aG9sZUluZGV4ID0gaDI7XG4gICAgXHRcdFx0XHRcdFx0XHRpbmRlcEhvbGVzLnNwbGljZSggaCwgMSApO1xuXG4gICAgXHRcdFx0XHRcdFx0XHR0bXBTaGFwZTEgPSBzaGFwZS5zbGljZSggMCwgc2hhcGVJbmRleCArIDEgKTtcbiAgICBcdFx0XHRcdFx0XHRcdHRtcFNoYXBlMiA9IHNoYXBlLnNsaWNlKCBzaGFwZUluZGV4ICk7XG4gICAgXHRcdFx0XHRcdFx0XHR0bXBIb2xlMSA9IGhvbGUuc2xpY2UoIGhvbGVJbmRleCApO1xuICAgIFx0XHRcdFx0XHRcdFx0dG1wSG9sZTIgPSBob2xlLnNsaWNlKCAwLCBob2xlSW5kZXggKyAxICk7XG5cbiAgICBcdFx0XHRcdFx0XHRcdHNoYXBlID0gdG1wU2hhcGUxLmNvbmNhdCggdG1wSG9sZTEgKS5jb25jYXQoIHRtcEhvbGUyICkuY29uY2F0KCB0bXBTaGFwZTIgKTtcblxuICAgIFx0XHRcdFx0XHRcdFx0bWluU2hhcGVJbmRleCA9IHNoYXBlSW5kZXg7XG5cbiAgICBcdFx0XHRcdFx0XHRcdC8vIERlYnVnIG9ubHksIHRvIHNob3cgdGhlIHNlbGVjdGVkIGN1dHNcbiAgICBcdFx0XHRcdFx0XHRcdC8vIGdsb2JfQ3V0TGluZXMucHVzaCggWyBzaGFwZVB0LCBob2xlUHQgXSApO1xuXG4gICAgXHRcdFx0XHRcdFx0XHRicmVhaztcblxuICAgIFx0XHRcdFx0XHRcdH1cbiAgICBcdFx0XHRcdFx0XHRpZiAoIGhvbGVJbmRleCA+PSAwIClcdGJyZWFrO1x0XHQvLyBob2xlLXZlcnRleCBmb3VuZFxuXG4gICAgXHRcdFx0XHRcdFx0ZmFpbGVkQ3V0c1sgY3V0S2V5IF0gPSB0cnVlO1x0XHRcdC8vIHJlbWVtYmVyIGZhaWx1cmVcblxuICAgIFx0XHRcdFx0XHR9XG4gICAgXHRcdFx0XHRcdGlmICggaG9sZUluZGV4ID49IDAgKVx0YnJlYWs7XHRcdC8vIGhvbGUtdmVydGV4IGZvdW5kXG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdHJldHVybiBzaGFwZTsgXHRcdFx0Lyogc2hhcGUgd2l0aCBubyBob2xlcyAqL1xuXG4gICAgXHRcdH1cblxuXG4gICAgXHRcdHZhciBpLCBpbCwgZiwgZmFjZSxcbiAgICBcdFx0XHRrZXksIGluZGV4LFxuICAgIFx0XHRcdGFsbFBvaW50c01hcCA9IHt9O1xuXG4gICAgXHRcdC8vIFRvIG1haW50YWluIHJlZmVyZW5jZSB0byBvbGQgc2hhcGUsIG9uZSBtdXN0IG1hdGNoIGNvb3JkaW5hdGVzLCBvciBvZmZzZXQgdGhlIGluZGljZXMgZnJvbSBvcmlnaW5hbCBhcnJheXMuIEl0J3MgcHJvYmFibHkgZWFzaWVyIHRvIGRvIHRoZSBmaXJzdC5cblxuICAgIFx0XHR2YXIgYWxscG9pbnRzID0gY29udG91ci5jb25jYXQoKTtcblxuICAgIFx0XHRmb3IgKCB2YXIgaCA9IDAsIGhsID0gaG9sZXMubGVuZ3RoOyBoIDwgaGw7IGggKysgKSB7XG5cbiAgICBcdFx0XHRBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseSggYWxscG9pbnRzLCBob2xlc1sgaCBdICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdC8vY29uc29sZS5sb2coIFwiYWxscG9pbnRzXCIsYWxscG9pbnRzLCBhbGxwb2ludHMubGVuZ3RoICk7XG5cbiAgICBcdFx0Ly8gcHJlcGFyZSBhbGwgcG9pbnRzIG1hcFxuXG4gICAgXHRcdGZvciAoIGkgPSAwLCBpbCA9IGFsbHBvaW50cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuICAgIFx0XHRcdGtleSA9IGFsbHBvaW50c1sgaSBdLnggKyBcIjpcIiArIGFsbHBvaW50c1sgaSBdLnk7XG5cbiAgICBcdFx0XHRpZiAoIGFsbFBvaW50c01hcFsga2V5IF0gIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0Y29uc29sZS53YXJuKCBcIlRIUkVFLlNoYXBlVXRpbHM6IER1cGxpY2F0ZSBwb2ludFwiLCBrZXksIGkgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdGFsbFBvaW50c01hcFsga2V5IF0gPSBpO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHQvLyByZW1vdmUgaG9sZXMgYnkgY3V0dGluZyBwYXRocyB0byBob2xlcyBhbmQgYWRkaW5nIHRoZW0gdG8gdGhlIHNoYXBlXG4gICAgXHRcdHZhciBzaGFwZVdpdGhvdXRIb2xlcyA9IHJlbW92ZUhvbGVzKCBjb250b3VyLCBob2xlcyApO1xuXG4gICAgXHRcdHZhciB0cmlhbmdsZXMgPSBleHBvcnRzLlNoYXBlVXRpbHMudHJpYW5ndWxhdGUoIHNoYXBlV2l0aG91dEhvbGVzLCBmYWxzZSApOyAvLyBUcnVlIHJldHVybnMgaW5kaWNlcyBmb3IgcG9pbnRzIG9mIHNwb29sZWQgc2hhcGVcbiAgICBcdFx0Ly9jb25zb2xlLmxvZyggXCJ0cmlhbmdsZXNcIix0cmlhbmdsZXMsIHRyaWFuZ2xlcy5sZW5ndGggKTtcblxuICAgIFx0XHQvLyBjaGVjayBhbGwgZmFjZSB2ZXJ0aWNlcyBhZ2FpbnN0IGFsbCBwb2ludHMgbWFwXG5cbiAgICBcdFx0Zm9yICggaSA9IDAsIGlsID0gdHJpYW5nbGVzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgXHRcdFx0ZmFjZSA9IHRyaWFuZ2xlc1sgaSBdO1xuXG4gICAgXHRcdFx0Zm9yICggZiA9IDA7IGYgPCAzOyBmICsrICkge1xuXG4gICAgXHRcdFx0XHRrZXkgPSBmYWNlWyBmIF0ueCArIFwiOlwiICsgZmFjZVsgZiBdLnk7XG5cbiAgICBcdFx0XHRcdGluZGV4ID0gYWxsUG9pbnRzTWFwWyBrZXkgXTtcblxuICAgIFx0XHRcdFx0aWYgKCBpbmRleCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0XHRcdGZhY2VbIGYgXSA9IGluZGV4O1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiB0cmlhbmdsZXMuY29uY2F0KCk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGlzQ2xvY2tXaXNlOiBmdW5jdGlvbiAoIHB0cyApIHtcblxuICAgIFx0XHRyZXR1cm4gZXhwb3J0cy5TaGFwZVV0aWxzLmFyZWEoIHB0cyApIDwgMDtcblxuICAgIFx0fSxcblxuICAgIFx0Ly8gQmV6aWVyIEN1cnZlcyBmb3JtdWxhcyBvYnRhaW5lZCBmcm9tXG4gICAgXHQvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0IlQzMlQTl6aWVyX2N1cnZlXG5cbiAgICBcdC8vIFF1YWQgQmV6aWVyIEZ1bmN0aW9uc1xuXG4gICAgXHRiMjogKCBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0ZnVuY3Rpb24gYjJwMCggdCwgcCApIHtcblxuICAgIFx0XHRcdHZhciBrID0gMSAtIHQ7XG4gICAgXHRcdFx0cmV0dXJuIGsgKiBrICogcDtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0ZnVuY3Rpb24gYjJwMSggdCwgcCApIHtcblxuICAgIFx0XHRcdHJldHVybiAyICogKCAxIC0gdCApICogdCAqIHA7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGZ1bmN0aW9uIGIycDIoIHQsIHAgKSB7XG5cbiAgICBcdFx0XHRyZXR1cm4gdCAqIHQgKiBwO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gZnVuY3Rpb24gYjIoIHQsIHAwLCBwMSwgcDIgKSB7XG5cbiAgICBcdFx0XHRyZXR1cm4gYjJwMCggdCwgcDAgKSArIGIycDEoIHQsIHAxICkgKyBiMnAyKCB0LCBwMiApO1xuXG4gICAgXHRcdH07XG5cbiAgICBcdH0gKSgpLFxuXG4gICAgXHQvLyBDdWJpYyBCZXppZXIgRnVuY3Rpb25zXG5cbiAgICBcdGIzOiAoIGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHRmdW5jdGlvbiBiM3AwKCB0LCBwICkge1xuXG4gICAgXHRcdFx0dmFyIGsgPSAxIC0gdDtcbiAgICBcdFx0XHRyZXR1cm4gayAqIGsgKiBrICogcDtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0ZnVuY3Rpb24gYjNwMSggdCwgcCApIHtcblxuICAgIFx0XHRcdHZhciBrID0gMSAtIHQ7XG4gICAgXHRcdFx0cmV0dXJuIDMgKiBrICogayAqIHQgKiBwO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRmdW5jdGlvbiBiM3AyKCB0LCBwICkge1xuXG4gICAgXHRcdFx0dmFyIGsgPSAxIC0gdDtcbiAgICBcdFx0XHRyZXR1cm4gMyAqIGsgKiB0ICogdCAqIHA7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGZ1bmN0aW9uIGIzcDMoIHQsIHAgKSB7XG5cbiAgICBcdFx0XHRyZXR1cm4gdCAqIHQgKiB0ICogcDtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIGZ1bmN0aW9uIGIzKCB0LCBwMCwgcDEsIHAyLCBwMyApIHtcblxuICAgIFx0XHRcdHJldHVybiBiM3AwKCB0LCBwMCApICsgYjNwMSggdCwgcDEgKSArIGIzcDIoIHQsIHAyICkgKyBiM3AzKCB0LCBwMyApO1xuXG4gICAgXHRcdH07XG5cbiAgICBcdH0gKSgpXG5cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xuICAgICAqXG4gICAgICogQ3JlYXRlcyBleHRydWRlZCBnZW9tZXRyeSBmcm9tIGEgcGF0aCBzaGFwZS5cbiAgICAgKlxuICAgICAqIHBhcmFtZXRlcnMgPSB7XG4gICAgICpcbiAgICAgKiAgY3VydmVTZWdtZW50czogPGludD4sIC8vIG51bWJlciBvZiBwb2ludHMgb24gdGhlIGN1cnZlc1xuICAgICAqICBzdGVwczogPGludD4sIC8vIG51bWJlciBvZiBwb2ludHMgZm9yIHotc2lkZSBleHRydXNpb25zIC8gdXNlZCBmb3Igc3ViZGl2aWRpbmcgc2VnbWVudHMgb2YgZXh0cnVkZSBzcGxpbmUgdG9vXG4gICAgICogIGFtb3VudDogPGludD4sIC8vIERlcHRoIHRvIGV4dHJ1ZGUgdGhlIHNoYXBlXG4gICAgICpcbiAgICAgKiAgYmV2ZWxFbmFibGVkOiA8Ym9vbD4sIC8vIHR1cm4gb24gYmV2ZWxcbiAgICAgKiAgYmV2ZWxUaGlja25lc3M6IDxmbG9hdD4sIC8vIGhvdyBkZWVwIGludG8gdGhlIG9yaWdpbmFsIHNoYXBlIGJldmVsIGdvZXNcbiAgICAgKiAgYmV2ZWxTaXplOiA8ZmxvYXQ+LCAvLyBob3cgZmFyIGZyb20gc2hhcGUgb3V0bGluZSBpcyBiZXZlbFxuICAgICAqICBiZXZlbFNlZ21lbnRzOiA8aW50PiwgLy8gbnVtYmVyIG9mIGJldmVsIGxheWVyc1xuICAgICAqXG4gICAgICogIGV4dHJ1ZGVQYXRoOiA8VEhSRUUuQ3VydmVQYXRoPiAvLyAzZCBzcGxpbmUgcGF0aCB0byBleHRydWRlIHNoYXBlIGFsb25nLiAoY3JlYXRlcyBGcmFtZXMgaWYgLmZyYW1lcyBhcmVuJ3QgZGVmaW5lZClcbiAgICAgKiAgZnJhbWVzOiA8VEhSRUUuVHViZUdlb21ldHJ5LkZyZW5ldEZyYW1lcz4gLy8gY29udGFpbmluZyBhcnJheXMgb2YgdGFuZ2VudHMsIG5vcm1hbHMsIGJpbm9ybWFsc1xuICAgICAqXG4gICAgICogIHV2R2VuZXJhdG9yOiA8T2JqZWN0PiAvLyBvYmplY3QgdGhhdCBwcm92aWRlcyBVViBnZW5lcmF0b3IgZnVuY3Rpb25zXG4gICAgICpcbiAgICAgKiB9XG4gICAgICoqL1xuXG4gICAgZnVuY3Rpb24gRXh0cnVkZUdlb21ldHJ5KCBzaGFwZXMsIG9wdGlvbnMgKSB7XG5cbiAgICBcdGlmICggdHlwZW9mKCBzaGFwZXMgKSA9PT0gXCJ1bmRlZmluZWRcIiApIHtcblxuICAgIFx0XHRzaGFwZXMgPSBbXTtcbiAgICBcdFx0cmV0dXJuO1xuXG4gICAgXHR9XG5cbiAgICBcdEdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuICAgIFx0dGhpcy50eXBlID0gJ0V4dHJ1ZGVHZW9tZXRyeSc7XG5cbiAgICBcdHNoYXBlcyA9IEFycmF5LmlzQXJyYXkoIHNoYXBlcyApID8gc2hhcGVzIDogWyBzaGFwZXMgXTtcblxuICAgIFx0dGhpcy5hZGRTaGFwZUxpc3QoIHNoYXBlcywgb3B0aW9ucyApO1xuXG4gICAgXHR0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xuXG4gICAgXHQvLyBjYW4ndCByZWFsbHkgdXNlIGF1dG9tYXRpYyB2ZXJ0ZXggbm9ybWFsc1xuICAgIFx0Ly8gYXMgdGhlbiBmcm9udCBhbmQgYmFjayBzaWRlcyBnZXQgc21vb3RoZWQgdG9vXG4gICAgXHQvLyBzaG91bGQgZG8gc2VwYXJhdGUgc21vb3RoaW5nIGp1c3QgZm9yIHNpZGVzXG5cbiAgICBcdC8vdGhpcy5jb21wdXRlVmVydGV4Tm9ybWFscygpO1xuXG4gICAgXHQvL2NvbnNvbGUubG9nKCBcInRvb2tcIiwgKCBEYXRlLm5vdygpIC0gc3RhcnRUaW1lICkgKTtcblxuICAgIH1cblxuICAgIEV4dHJ1ZGVHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBHZW9tZXRyeS5wcm90b3R5cGUgKTtcbiAgICBFeHRydWRlR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRXh0cnVkZUdlb21ldHJ5O1xuXG4gICAgRXh0cnVkZUdlb21ldHJ5LnByb3RvdHlwZS5hZGRTaGFwZUxpc3QgPSBmdW5jdGlvbiAoIHNoYXBlcywgb3B0aW9ucyApIHtcblxuICAgIFx0dmFyIHNsID0gc2hhcGVzLmxlbmd0aDtcblxuICAgIFx0Zm9yICggdmFyIHMgPSAwOyBzIDwgc2w7IHMgKysgKSB7XG5cbiAgICBcdFx0dmFyIHNoYXBlID0gc2hhcGVzWyBzIF07XG4gICAgXHRcdHRoaXMuYWRkU2hhcGUoIHNoYXBlLCBvcHRpb25zICk7XG5cbiAgICBcdH1cblxuICAgIH07XG5cbiAgICBFeHRydWRlR2VvbWV0cnkucHJvdG90eXBlLmFkZFNoYXBlID0gZnVuY3Rpb24gKCBzaGFwZSwgb3B0aW9ucyApIHtcblxuICAgIFx0dmFyIGFtb3VudCA9IG9wdGlvbnMuYW1vdW50ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmFtb3VudCA6IDEwMDtcblxuICAgIFx0dmFyIGJldmVsVGhpY2tuZXNzID0gb3B0aW9ucy5iZXZlbFRoaWNrbmVzcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5iZXZlbFRoaWNrbmVzcyA6IDY7IC8vIDEwXG4gICAgXHR2YXIgYmV2ZWxTaXplID0gb3B0aW9ucy5iZXZlbFNpemUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYmV2ZWxTaXplIDogYmV2ZWxUaGlja25lc3MgLSAyOyAvLyA4XG4gICAgXHR2YXIgYmV2ZWxTZWdtZW50cyA9IG9wdGlvbnMuYmV2ZWxTZWdtZW50cyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5iZXZlbFNlZ21lbnRzIDogMztcblxuICAgIFx0dmFyIGJldmVsRW5hYmxlZCA9IG9wdGlvbnMuYmV2ZWxFbmFibGVkICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmJldmVsRW5hYmxlZCA6IHRydWU7IC8vIGZhbHNlXG5cbiAgICBcdHZhciBjdXJ2ZVNlZ21lbnRzID0gb3B0aW9ucy5jdXJ2ZVNlZ21lbnRzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmN1cnZlU2VnbWVudHMgOiAxMjtcblxuICAgIFx0dmFyIHN0ZXBzID0gb3B0aW9ucy5zdGVwcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5zdGVwcyA6IDE7XG5cbiAgICBcdHZhciBleHRydWRlUGF0aCA9IG9wdGlvbnMuZXh0cnVkZVBhdGg7XG4gICAgXHR2YXIgZXh0cnVkZVB0cywgZXh0cnVkZUJ5UGF0aCA9IGZhbHNlO1xuXG4gICAgXHQvLyBVc2UgZGVmYXVsdCBXb3JsZFVWR2VuZXJhdG9yIGlmIG5vIFVWIGdlbmVyYXRvcnMgYXJlIHNwZWNpZmllZC5cbiAgICBcdHZhciB1dmdlbiA9IG9wdGlvbnMuVVZHZW5lcmF0b3IgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuVVZHZW5lcmF0b3IgOiBFeHRydWRlR2VvbWV0cnkuV29ybGRVVkdlbmVyYXRvcjtcblxuICAgIFx0dmFyIHNwbGluZVR1YmUsIGJpbm9ybWFsLCBub3JtYWwsIHBvc2l0aW9uMjtcbiAgICBcdGlmICggZXh0cnVkZVBhdGggKSB7XG5cbiAgICBcdFx0ZXh0cnVkZVB0cyA9IGV4dHJ1ZGVQYXRoLmdldFNwYWNlZFBvaW50cyggc3RlcHMgKTtcblxuICAgIFx0XHRleHRydWRlQnlQYXRoID0gdHJ1ZTtcbiAgICBcdFx0YmV2ZWxFbmFibGVkID0gZmFsc2U7IC8vIGJldmVscyBub3Qgc3VwcG9ydGVkIGZvciBwYXRoIGV4dHJ1c2lvblxuXG4gICAgXHRcdC8vIFNFVFVQIFROQiB2YXJpYWJsZXNcblxuICAgIFx0XHQvLyBSZXVzZSBUTkIgZnJvbSBUdWJlR2VvbXRyeSBmb3Igbm93LlxuICAgIFx0XHQvLyBUT0RPMSAtIGhhdmUgYSAuaXNDbG9zZWQgaW4gc3BsaW5lP1xuXG4gICAgXHRcdHNwbGluZVR1YmUgPSBvcHRpb25zLmZyYW1lcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5mcmFtZXMgOiBuZXcgVHViZUdlb21ldHJ5LkZyZW5ldEZyYW1lcyggZXh0cnVkZVBhdGgsIHN0ZXBzLCBmYWxzZSApO1xuXG4gICAgXHRcdC8vIGNvbnNvbGUubG9nKHNwbGluZVR1YmUsICdzcGxpbmVUdWJlJywgc3BsaW5lVHViZS5ub3JtYWxzLmxlbmd0aCwgJ3N0ZXBzJywgc3RlcHMsICdleHRydWRlUHRzJywgZXh0cnVkZVB0cy5sZW5ndGgpO1xuXG4gICAgXHRcdGJpbm9ybWFsID0gbmV3IFZlY3RvcjMoKTtcbiAgICBcdFx0bm9ybWFsID0gbmV3IFZlY3RvcjMoKTtcbiAgICBcdFx0cG9zaXRpb24yID0gbmV3IFZlY3RvcjMoKTtcblxuICAgIFx0fVxuXG4gICAgXHQvLyBTYWZlZ3VhcmRzIGlmIGJldmVscyBhcmUgbm90IGVuYWJsZWRcblxuICAgIFx0aWYgKCAhIGJldmVsRW5hYmxlZCApIHtcblxuICAgIFx0XHRiZXZlbFNlZ21lbnRzID0gMDtcbiAgICBcdFx0YmV2ZWxUaGlja25lc3MgPSAwO1xuICAgIFx0XHRiZXZlbFNpemUgPSAwO1xuXG4gICAgXHR9XG5cbiAgICBcdC8vIFZhcmlhYmxlcyBpbml0aWFsaXphdGlvblxuXG4gICAgXHR2YXIgYWhvbGUsIGgsIGhsOyAvLyBsb29waW5nIG9mIGhvbGVzXG4gICAgXHR2YXIgc2NvcGUgPSB0aGlzO1xuXG4gICAgXHR2YXIgc2hhcGVzT2Zmc2V0ID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7XG5cbiAgICBcdHZhciBzaGFwZVBvaW50cyA9IHNoYXBlLmV4dHJhY3RQb2ludHMoIGN1cnZlU2VnbWVudHMgKTtcblxuICAgIFx0dmFyIHZlcnRpY2VzID0gc2hhcGVQb2ludHMuc2hhcGU7XG4gICAgXHR2YXIgaG9sZXMgPSBzaGFwZVBvaW50cy5ob2xlcztcblxuICAgIFx0dmFyIHJldmVyc2UgPSAhIGV4cG9ydHMuU2hhcGVVdGlscy5pc0Nsb2NrV2lzZSggdmVydGljZXMgKTtcblxuICAgIFx0aWYgKCByZXZlcnNlICkge1xuXG4gICAgXHRcdHZlcnRpY2VzID0gdmVydGljZXMucmV2ZXJzZSgpO1xuXG4gICAgXHRcdC8vIE1heWJlIHdlIHNob3VsZCBhbHNvIGNoZWNrIGlmIGhvbGVzIGFyZSBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uLCBqdXN0IHRvIGJlIHNhZmUgLi4uXG5cbiAgICBcdFx0Zm9yICggaCA9IDAsIGhsID0gaG9sZXMubGVuZ3RoOyBoIDwgaGw7IGggKysgKSB7XG5cbiAgICBcdFx0XHRhaG9sZSA9IGhvbGVzWyBoIF07XG5cbiAgICBcdFx0XHRpZiAoIGV4cG9ydHMuU2hhcGVVdGlscy5pc0Nsb2NrV2lzZSggYWhvbGUgKSApIHtcblxuICAgIFx0XHRcdFx0aG9sZXNbIGggXSA9IGFob2xlLnJldmVyc2UoKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV2ZXJzZSA9IGZhbHNlOyAvLyBJZiB2ZXJ0aWNlcyBhcmUgaW4gb3JkZXIgbm93LCB3ZSBzaG91bGRuJ3QgbmVlZCB0byB3b3JyeSBhYm91dCB0aGVtIGFnYWluIChob3BlZnVsbHkpIVxuXG4gICAgXHR9XG5cblxuICAgIFx0dmFyIGZhY2VzID0gZXhwb3J0cy5TaGFwZVV0aWxzLnRyaWFuZ3VsYXRlU2hhcGUoIHZlcnRpY2VzLCBob2xlcyApO1xuXG4gICAgXHQvKiBWZXJ0aWNlcyAqL1xuXG4gICAgXHR2YXIgY29udG91ciA9IHZlcnRpY2VzOyAvLyB2ZXJ0aWNlcyBoYXMgYWxsIHBvaW50cyBidXQgY29udG91ciBoYXMgb25seSBwb2ludHMgb2YgY2lyY3VtZmVyZW5jZVxuXG4gICAgXHRmb3IgKCBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcblxuICAgIFx0XHRhaG9sZSA9IGhvbGVzWyBoIF07XG5cbiAgICBcdFx0dmVydGljZXMgPSB2ZXJ0aWNlcy5jb25jYXQoIGFob2xlICk7XG5cbiAgICBcdH1cblxuXG4gICAgXHRmdW5jdGlvbiBzY2FsZVB0MiggcHQsIHZlYywgc2l6ZSApIHtcblxuICAgIFx0XHRpZiAoICEgdmVjICkgY29uc29sZS5lcnJvciggXCJUSFJFRS5FeHRydWRlR2VvbWV0cnk6IHZlYyBkb2VzIG5vdCBleGlzdFwiICk7XG5cbiAgICBcdFx0cmV0dXJuIHZlYy5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKCBzaXplICkuYWRkKCBwdCApO1xuXG4gICAgXHR9XG5cbiAgICBcdHZhciBiLCBicywgdCwgeixcbiAgICBcdFx0dmVydCwgdmxlbiA9IHZlcnRpY2VzLmxlbmd0aCxcbiAgICBcdFx0ZmFjZSwgZmxlbiA9IGZhY2VzLmxlbmd0aDtcblxuXG4gICAgXHQvLyBGaW5kIGRpcmVjdGlvbnMgZm9yIHBvaW50IG1vdmVtZW50XG5cblxuICAgIFx0ZnVuY3Rpb24gZ2V0QmV2ZWxWZWMoIGluUHQsIGluUHJldiwgaW5OZXh0ICkge1xuXG4gICAgXHRcdC8vIGNvbXB1dGVzIGZvciBpblB0IHRoZSBjb3JyZXNwb25kaW5nIHBvaW50IGluUHQnIG9uIGEgbmV3IGNvbnRvdXJcbiAgICBcdFx0Ly8gICBzaGlmdGVkIGJ5IDEgdW5pdCAobGVuZ3RoIG9mIG5vcm1hbGl6ZWQgdmVjdG9yKSB0byB0aGUgbGVmdFxuICAgIFx0XHQvLyBpZiB3ZSB3YWxrIGFsb25nIGNvbnRvdXIgY2xvY2t3aXNlLCB0aGlzIG5ldyBjb250b3VyIGlzIG91dHNpZGUgdGhlIG9sZCBvbmVcbiAgICBcdFx0Ly9cbiAgICBcdFx0Ly8gaW5QdCcgaXMgdGhlIGludGVyc2VjdGlvbiBvZiB0aGUgdHdvIGxpbmVzIHBhcmFsbGVsIHRvIHRoZSB0d29cbiAgICBcdFx0Ly8gIGFkamFjZW50IGVkZ2VzIG9mIGluUHQgYXQgYSBkaXN0YW5jZSBvZiAxIHVuaXQgb24gdGhlIGxlZnQgc2lkZS5cblxuICAgIFx0XHR2YXIgdl90cmFuc194LCB2X3RyYW5zX3ksIHNocmlua19ieSA9IDE7XHRcdC8vIHJlc3VsdGluZyB0cmFuc2xhdGlvbiB2ZWN0b3IgZm9yIGluUHRcblxuICAgIFx0XHQvLyBnb29kIHJlYWRpbmcgZm9yIGdlb21ldHJ5IGFsZ29yaXRobXMgKGhlcmU6IGxpbmUtbGluZSBpbnRlcnNlY3Rpb24pXG4gICAgXHRcdC8vIGh0dHA6Ly9nZW9tYWxnb3JpdGhtcy5jb20vYTA1LV9pbnRlcnNlY3QtMS5odG1sXG5cbiAgICBcdFx0dmFyIHZfcHJldl94ID0gaW5QdC54IC0gaW5QcmV2LngsIHZfcHJldl95ID0gaW5QdC55IC0gaW5QcmV2Lnk7XG4gICAgXHRcdHZhciB2X25leHRfeCA9IGluTmV4dC54IC0gaW5QdC54LCB2X25leHRfeSA9IGluTmV4dC55IC0gaW5QdC55O1xuXG4gICAgXHRcdHZhciB2X3ByZXZfbGVuc3EgPSAoIHZfcHJldl94ICogdl9wcmV2X3ggKyB2X3ByZXZfeSAqIHZfcHJldl95ICk7XG5cbiAgICBcdFx0Ly8gY2hlY2sgZm9yIGNvbGxpbmVhciBlZGdlc1xuICAgIFx0XHR2YXIgY29sbGluZWFyMCA9ICggdl9wcmV2X3ggKiB2X25leHRfeSAtIHZfcHJldl95ICogdl9uZXh0X3ggKTtcblxuICAgIFx0XHRpZiAoIE1hdGguYWJzKCBjb2xsaW5lYXIwICkgPiBOdW1iZXIuRVBTSUxPTiApIHtcblxuICAgIFx0XHRcdC8vIG5vdCBjb2xsaW5lYXJcblxuICAgIFx0XHRcdC8vIGxlbmd0aCBvZiB2ZWN0b3JzIGZvciBub3JtYWxpemluZ1xuXG4gICAgXHRcdFx0dmFyIHZfcHJldl9sZW4gPSBNYXRoLnNxcnQoIHZfcHJldl9sZW5zcSApO1xuICAgIFx0XHRcdHZhciB2X25leHRfbGVuID0gTWF0aC5zcXJ0KCB2X25leHRfeCAqIHZfbmV4dF94ICsgdl9uZXh0X3kgKiB2X25leHRfeSApO1xuXG4gICAgXHRcdFx0Ly8gc2hpZnQgYWRqYWNlbnQgcG9pbnRzIGJ5IHVuaXQgdmVjdG9ycyB0byB0aGUgbGVmdFxuXG4gICAgXHRcdFx0dmFyIHB0UHJldlNoaWZ0X3ggPSAoIGluUHJldi54IC0gdl9wcmV2X3kgLyB2X3ByZXZfbGVuICk7XG4gICAgXHRcdFx0dmFyIHB0UHJldlNoaWZ0X3kgPSAoIGluUHJldi55ICsgdl9wcmV2X3ggLyB2X3ByZXZfbGVuICk7XG5cbiAgICBcdFx0XHR2YXIgcHROZXh0U2hpZnRfeCA9ICggaW5OZXh0LnggLSB2X25leHRfeSAvIHZfbmV4dF9sZW4gKTtcbiAgICBcdFx0XHR2YXIgcHROZXh0U2hpZnRfeSA9ICggaW5OZXh0LnkgKyB2X25leHRfeCAvIHZfbmV4dF9sZW4gKTtcblxuICAgIFx0XHRcdC8vIHNjYWxpbmcgZmFjdG9yIGZvciB2X3ByZXYgdG8gaW50ZXJzZWN0aW9uIHBvaW50XG5cbiAgICBcdFx0XHR2YXIgc2YgPSAoICAoIHB0TmV4dFNoaWZ0X3ggLSBwdFByZXZTaGlmdF94ICkgKiB2X25leHRfeSAtXG4gICAgXHRcdFx0XHRcdFx0KCBwdE5leHRTaGlmdF95IC0gcHRQcmV2U2hpZnRfeSApICogdl9uZXh0X3ggICAgKSAvXG4gICAgXHRcdFx0XHRcdCAgKCB2X3ByZXZfeCAqIHZfbmV4dF95IC0gdl9wcmV2X3kgKiB2X25leHRfeCApO1xuXG4gICAgXHRcdFx0Ly8gdmVjdG9yIGZyb20gaW5QdCB0byBpbnRlcnNlY3Rpb24gcG9pbnRcblxuICAgIFx0XHRcdHZfdHJhbnNfeCA9ICggcHRQcmV2U2hpZnRfeCArIHZfcHJldl94ICogc2YgLSBpblB0LnggKTtcbiAgICBcdFx0XHR2X3RyYW5zX3kgPSAoIHB0UHJldlNoaWZ0X3kgKyB2X3ByZXZfeSAqIHNmIC0gaW5QdC55ICk7XG5cbiAgICBcdFx0XHQvLyBEb24ndCBub3JtYWxpemUhLCBvdGhlcndpc2Ugc2hhcnAgY29ybmVycyBiZWNvbWUgdWdseVxuICAgIFx0XHRcdC8vICBidXQgcHJldmVudCBjcmF6eSBzcGlrZXNcbiAgICBcdFx0XHR2YXIgdl90cmFuc19sZW5zcSA9ICggdl90cmFuc194ICogdl90cmFuc194ICsgdl90cmFuc195ICogdl90cmFuc195ICk7XG4gICAgXHRcdFx0aWYgKCB2X3RyYW5zX2xlbnNxIDw9IDIgKSB7XG5cbiAgICBcdFx0XHRcdHJldHVyblx0bmV3IFZlY3RvcjIoIHZfdHJhbnNfeCwgdl90cmFuc195ICk7XG5cbiAgICBcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHRzaHJpbmtfYnkgPSBNYXRoLnNxcnQoIHZfdHJhbnNfbGVuc3EgLyAyICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdC8vIGhhbmRsZSBzcGVjaWFsIGNhc2Ugb2YgY29sbGluZWFyIGVkZ2VzXG5cbiAgICBcdFx0XHR2YXIgZGlyZWN0aW9uX2VxID0gZmFsc2U7XHRcdC8vIGFzc3VtZXM6IG9wcG9zaXRlXG4gICAgXHRcdFx0aWYgKCB2X3ByZXZfeCA+IE51bWJlci5FUFNJTE9OICkge1xuXG4gICAgXHRcdFx0XHRpZiAoIHZfbmV4dF94ID4gTnVtYmVyLkVQU0lMT04gKSB7XG5cbiAgICBcdFx0XHRcdFx0ZGlyZWN0aW9uX2VxID0gdHJ1ZTtcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0aWYgKCB2X3ByZXZfeCA8IC0gTnVtYmVyLkVQU0lMT04gKSB7XG5cbiAgICBcdFx0XHRcdFx0aWYgKCB2X25leHRfeCA8IC0gTnVtYmVyLkVQU0lMT04gKSB7XG5cbiAgICBcdFx0XHRcdFx0XHRkaXJlY3Rpb25fZXEgPSB0cnVlO1xuXG4gICAgXHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0XHRpZiAoIE1hdGguc2lnbiggdl9wcmV2X3kgKSA9PT0gTWF0aC5zaWduKCB2X25leHRfeSApICkge1xuXG4gICAgXHRcdFx0XHRcdFx0ZGlyZWN0aW9uX2VxID0gdHJ1ZTtcblxuICAgIFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdGlmICggZGlyZWN0aW9uX2VxICkge1xuXG4gICAgXHRcdFx0XHQvLyBjb25zb2xlLmxvZyhcIldhcm5pbmc6IGxpbmVzIGFyZSBhIHN0cmFpZ2h0IHNlcXVlbmNlXCIpO1xuICAgIFx0XHRcdFx0dl90cmFuc194ID0gLSB2X3ByZXZfeTtcbiAgICBcdFx0XHRcdHZfdHJhbnNfeSA9ICB2X3ByZXZfeDtcbiAgICBcdFx0XHRcdHNocmlua19ieSA9IE1hdGguc3FydCggdl9wcmV2X2xlbnNxICk7XG5cbiAgICBcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHQvLyBjb25zb2xlLmxvZyhcIldhcm5pbmc6IGxpbmVzIGFyZSBhIHN0cmFpZ2h0IHNwaWtlXCIpO1xuICAgIFx0XHRcdFx0dl90cmFuc194ID0gdl9wcmV2X3g7XG4gICAgXHRcdFx0XHR2X3RyYW5zX3kgPSB2X3ByZXZfeTtcbiAgICBcdFx0XHRcdHNocmlua19ieSA9IE1hdGguc3FydCggdl9wcmV2X2xlbnNxIC8gMiApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm5cdG5ldyBWZWN0b3IyKCB2X3RyYW5zX3ggLyBzaHJpbmtfYnksIHZfdHJhbnNfeSAvIHNocmlua19ieSApO1xuXG4gICAgXHR9XG5cblxuICAgIFx0dmFyIGNvbnRvdXJNb3ZlbWVudHMgPSBbXTtcblxuICAgIFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IGNvbnRvdXIubGVuZ3RoLCBqID0gaWwgLSAxLCBrID0gaSArIDE7IGkgPCBpbDsgaSArKywgaiArKywgayArKyApIHtcblxuICAgIFx0XHRpZiAoIGogPT09IGlsICkgaiA9IDA7XG4gICAgXHRcdGlmICggayA9PT0gaWwgKSBrID0gMDtcblxuICAgIFx0XHQvLyAgKGopLS0tKGkpLS0tKGspXG4gICAgXHRcdC8vIGNvbnNvbGUubG9nKCdpLGosaycsIGksIGogLCBrKVxuXG4gICAgXHRcdGNvbnRvdXJNb3ZlbWVudHNbIGkgXSA9IGdldEJldmVsVmVjKCBjb250b3VyWyBpIF0sIGNvbnRvdXJbIGogXSwgY29udG91clsgayBdICk7XG5cbiAgICBcdH1cblxuICAgIFx0dmFyIGhvbGVzTW92ZW1lbnRzID0gW10sIG9uZUhvbGVNb3ZlbWVudHMsIHZlcnRpY2VzTW92ZW1lbnRzID0gY29udG91ck1vdmVtZW50cy5jb25jYXQoKTtcblxuICAgIFx0Zm9yICggaCA9IDAsIGhsID0gaG9sZXMubGVuZ3RoOyBoIDwgaGw7IGggKysgKSB7XG5cbiAgICBcdFx0YWhvbGUgPSBob2xlc1sgaCBdO1xuXG4gICAgXHRcdG9uZUhvbGVNb3ZlbWVudHMgPSBbXTtcblxuICAgIFx0XHRmb3IgKCBpID0gMCwgaWwgPSBhaG9sZS5sZW5ndGgsIGogPSBpbCAtIDEsIGsgPSBpICsgMTsgaSA8IGlsOyBpICsrLCBqICsrLCBrICsrICkge1xuXG4gICAgXHRcdFx0aWYgKCBqID09PSBpbCApIGogPSAwO1xuICAgIFx0XHRcdGlmICggayA9PT0gaWwgKSBrID0gMDtcblxuICAgIFx0XHRcdC8vICAoaiktLS0oaSktLS0oaylcbiAgICBcdFx0XHRvbmVIb2xlTW92ZW1lbnRzWyBpIF0gPSBnZXRCZXZlbFZlYyggYWhvbGVbIGkgXSwgYWhvbGVbIGogXSwgYWhvbGVbIGsgXSApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRob2xlc01vdmVtZW50cy5wdXNoKCBvbmVIb2xlTW92ZW1lbnRzICk7XG4gICAgXHRcdHZlcnRpY2VzTW92ZW1lbnRzID0gdmVydGljZXNNb3ZlbWVudHMuY29uY2F0KCBvbmVIb2xlTW92ZW1lbnRzICk7XG5cbiAgICBcdH1cblxuXG4gICAgXHQvLyBMb29wIGJldmVsU2VnbWVudHMsIDEgZm9yIHRoZSBmcm9udCwgMSBmb3IgdGhlIGJhY2tcblxuICAgIFx0Zm9yICggYiA9IDA7IGIgPCBiZXZlbFNlZ21lbnRzOyBiICsrICkge1xuXG4gICAgXHRcdC8vZm9yICggYiA9IGJldmVsU2VnbWVudHM7IGIgPiAwOyBiIC0tICkge1xuXG4gICAgXHRcdHQgPSBiIC8gYmV2ZWxTZWdtZW50cztcbiAgICBcdFx0eiA9IGJldmVsVGhpY2tuZXNzICogTWF0aC5jb3MoIHQgKiBNYXRoLlBJIC8gMiApO1xuICAgIFx0XHRicyA9IGJldmVsU2l6ZSAqIE1hdGguc2luKCB0ICogTWF0aC5QSSAvIDIgKTtcblxuICAgIFx0XHQvLyBjb250cmFjdCBzaGFwZVxuXG4gICAgXHRcdGZvciAoIGkgPSAwLCBpbCA9IGNvbnRvdXIubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICBcdFx0XHR2ZXJ0ID0gc2NhbGVQdDIoIGNvbnRvdXJbIGkgXSwgY29udG91ck1vdmVtZW50c1sgaSBdLCBicyApO1xuXG4gICAgXHRcdFx0diggdmVydC54LCB2ZXJ0LnksICAtIHogKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0Ly8gZXhwYW5kIGhvbGVzXG5cbiAgICBcdFx0Zm9yICggaCA9IDAsIGhsID0gaG9sZXMubGVuZ3RoOyBoIDwgaGw7IGggKysgKSB7XG5cbiAgICBcdFx0XHRhaG9sZSA9IGhvbGVzWyBoIF07XG4gICAgXHRcdFx0b25lSG9sZU1vdmVtZW50cyA9IGhvbGVzTW92ZW1lbnRzWyBoIF07XG5cbiAgICBcdFx0XHRmb3IgKCBpID0gMCwgaWwgPSBhaG9sZS5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuICAgIFx0XHRcdFx0dmVydCA9IHNjYWxlUHQyKCBhaG9sZVsgaSBdLCBvbmVIb2xlTW92ZW1lbnRzWyBpIF0sIGJzICk7XG5cbiAgICBcdFx0XHRcdHYoIHZlcnQueCwgdmVydC55LCAgLSB6ICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9XG5cbiAgICBcdGJzID0gYmV2ZWxTaXplO1xuXG4gICAgXHQvLyBCYWNrIGZhY2luZyB2ZXJ0aWNlc1xuXG4gICAgXHRmb3IgKCBpID0gMDsgaSA8IHZsZW47IGkgKysgKSB7XG5cbiAgICBcdFx0dmVydCA9IGJldmVsRW5hYmxlZCA/IHNjYWxlUHQyKCB2ZXJ0aWNlc1sgaSBdLCB2ZXJ0aWNlc01vdmVtZW50c1sgaSBdLCBicyApIDogdmVydGljZXNbIGkgXTtcblxuICAgIFx0XHRpZiAoICEgZXh0cnVkZUJ5UGF0aCApIHtcblxuICAgIFx0XHRcdHYoIHZlcnQueCwgdmVydC55LCAwICk7XG5cbiAgICBcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdC8vIHYoIHZlcnQueCwgdmVydC55ICsgZXh0cnVkZVB0c1sgMCBdLnksIGV4dHJ1ZGVQdHNbIDAgXS54ICk7XG5cbiAgICBcdFx0XHRub3JtYWwuY29weSggc3BsaW5lVHViZS5ub3JtYWxzWyAwIF0gKS5tdWx0aXBseVNjYWxhciggdmVydC54ICk7XG4gICAgXHRcdFx0Ymlub3JtYWwuY29weSggc3BsaW5lVHViZS5iaW5vcm1hbHNbIDAgXSApLm11bHRpcGx5U2NhbGFyKCB2ZXJ0LnkgKTtcblxuICAgIFx0XHRcdHBvc2l0aW9uMi5jb3B5KCBleHRydWRlUHRzWyAwIF0gKS5hZGQoIG5vcm1hbCApLmFkZCggYmlub3JtYWwgKTtcblxuICAgIFx0XHRcdHYoIHBvc2l0aW9uMi54LCBwb3NpdGlvbjIueSwgcG9zaXRpb24yLnogKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdH1cblxuICAgIFx0Ly8gQWRkIHN0ZXBwZWQgdmVydGljZXMuLi5cbiAgICBcdC8vIEluY2x1ZGluZyBmcm9udCBmYWNpbmcgdmVydGljZXNcblxuICAgIFx0dmFyIHM7XG5cbiAgICBcdGZvciAoIHMgPSAxOyBzIDw9IHN0ZXBzOyBzICsrICkge1xuXG4gICAgXHRcdGZvciAoIGkgPSAwOyBpIDwgdmxlbjsgaSArKyApIHtcblxuICAgIFx0XHRcdHZlcnQgPSBiZXZlbEVuYWJsZWQgPyBzY2FsZVB0MiggdmVydGljZXNbIGkgXSwgdmVydGljZXNNb3ZlbWVudHNbIGkgXSwgYnMgKSA6IHZlcnRpY2VzWyBpIF07XG5cbiAgICBcdFx0XHRpZiAoICEgZXh0cnVkZUJ5UGF0aCApIHtcblxuICAgIFx0XHRcdFx0diggdmVydC54LCB2ZXJ0LnksIGFtb3VudCAvIHN0ZXBzICogcyApO1xuXG4gICAgXHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0Ly8gdiggdmVydC54LCB2ZXJ0LnkgKyBleHRydWRlUHRzWyBzIC0gMSBdLnksIGV4dHJ1ZGVQdHNbIHMgLSAxIF0ueCApO1xuXG4gICAgXHRcdFx0XHRub3JtYWwuY29weSggc3BsaW5lVHViZS5ub3JtYWxzWyBzIF0gKS5tdWx0aXBseVNjYWxhciggdmVydC54ICk7XG4gICAgXHRcdFx0XHRiaW5vcm1hbC5jb3B5KCBzcGxpbmVUdWJlLmJpbm9ybWFsc1sgcyBdICkubXVsdGlwbHlTY2FsYXIoIHZlcnQueSApO1xuXG4gICAgXHRcdFx0XHRwb3NpdGlvbjIuY29weSggZXh0cnVkZVB0c1sgcyBdICkuYWRkKCBub3JtYWwgKS5hZGQoIGJpbm9ybWFsICk7XG5cbiAgICBcdFx0XHRcdHYoIHBvc2l0aW9uMi54LCBwb3NpdGlvbjIueSwgcG9zaXRpb24yLnogKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdH1cblxuXG4gICAgXHQvLyBBZGQgYmV2ZWwgc2VnbWVudHMgcGxhbmVzXG5cbiAgICBcdC8vZm9yICggYiA9IDE7IGIgPD0gYmV2ZWxTZWdtZW50czsgYiArKyApIHtcbiAgICBcdGZvciAoIGIgPSBiZXZlbFNlZ21lbnRzIC0gMTsgYiA+PSAwOyBiIC0tICkge1xuXG4gICAgXHRcdHQgPSBiIC8gYmV2ZWxTZWdtZW50cztcbiAgICBcdFx0eiA9IGJldmVsVGhpY2tuZXNzICogTWF0aC5jb3MgKCB0ICogTWF0aC5QSSAvIDIgKTtcbiAgICBcdFx0YnMgPSBiZXZlbFNpemUgKiBNYXRoLnNpbiggdCAqIE1hdGguUEkgLyAyICk7XG5cbiAgICBcdFx0Ly8gY29udHJhY3Qgc2hhcGVcblxuICAgIFx0XHRmb3IgKCBpID0gMCwgaWwgPSBjb250b3VyLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgXHRcdFx0dmVydCA9IHNjYWxlUHQyKCBjb250b3VyWyBpIF0sIGNvbnRvdXJNb3ZlbWVudHNbIGkgXSwgYnMgKTtcbiAgICBcdFx0XHR2KCB2ZXJ0LngsIHZlcnQueSwgIGFtb3VudCArIHogKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0Ly8gZXhwYW5kIGhvbGVzXG5cbiAgICBcdFx0Zm9yICggaCA9IDAsIGhsID0gaG9sZXMubGVuZ3RoOyBoIDwgaGw7IGggKysgKSB7XG5cbiAgICBcdFx0XHRhaG9sZSA9IGhvbGVzWyBoIF07XG4gICAgXHRcdFx0b25lSG9sZU1vdmVtZW50cyA9IGhvbGVzTW92ZW1lbnRzWyBoIF07XG5cbiAgICBcdFx0XHRmb3IgKCBpID0gMCwgaWwgPSBhaG9sZS5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuICAgIFx0XHRcdFx0dmVydCA9IHNjYWxlUHQyKCBhaG9sZVsgaSBdLCBvbmVIb2xlTW92ZW1lbnRzWyBpIF0sIGJzICk7XG5cbiAgICBcdFx0XHRcdGlmICggISBleHRydWRlQnlQYXRoICkge1xuXG4gICAgXHRcdFx0XHRcdHYoIHZlcnQueCwgdmVydC55LCAgYW1vdW50ICsgeiApO1xuXG4gICAgXHRcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHRcdHYoIHZlcnQueCwgdmVydC55ICsgZXh0cnVkZVB0c1sgc3RlcHMgLSAxIF0ueSwgZXh0cnVkZVB0c1sgc3RlcHMgLSAxIF0ueCArIHogKTtcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0fVxuXG4gICAgXHQvKiBGYWNlcyAqL1xuXG4gICAgXHQvLyBUb3AgYW5kIGJvdHRvbSBmYWNlc1xuXG4gICAgXHRidWlsZExpZEZhY2VzKCk7XG5cbiAgICBcdC8vIFNpZGVzIGZhY2VzXG5cbiAgICBcdGJ1aWxkU2lkZUZhY2VzKCk7XG5cblxuICAgIFx0Ly8vLy8gIEludGVybmFsIGZ1bmN0aW9uc1xuXG4gICAgXHRmdW5jdGlvbiBidWlsZExpZEZhY2VzKCkge1xuXG4gICAgXHRcdGlmICggYmV2ZWxFbmFibGVkICkge1xuXG4gICAgXHRcdFx0dmFyIGxheWVyID0gMDsgLy8gc3RlcHMgKyAxXG4gICAgXHRcdFx0dmFyIG9mZnNldCA9IHZsZW4gKiBsYXllcjtcblxuICAgIFx0XHRcdC8vIEJvdHRvbSBmYWNlc1xuXG4gICAgXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBmbGVuOyBpICsrICkge1xuXG4gICAgXHRcdFx0XHRmYWNlID0gZmFjZXNbIGkgXTtcbiAgICBcdFx0XHRcdGYzKCBmYWNlWyAyIF0gKyBvZmZzZXQsIGZhY2VbIDEgXSArIG9mZnNldCwgZmFjZVsgMCBdICsgb2Zmc2V0ICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRsYXllciA9IHN0ZXBzICsgYmV2ZWxTZWdtZW50cyAqIDI7XG4gICAgXHRcdFx0b2Zmc2V0ID0gdmxlbiAqIGxheWVyO1xuXG4gICAgXHRcdFx0Ly8gVG9wIGZhY2VzXG5cbiAgICBcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGZsZW47IGkgKysgKSB7XG5cbiAgICBcdFx0XHRcdGZhY2UgPSBmYWNlc1sgaSBdO1xuICAgIFx0XHRcdFx0ZjMoIGZhY2VbIDAgXSArIG9mZnNldCwgZmFjZVsgMSBdICsgb2Zmc2V0LCBmYWNlWyAyIF0gKyBvZmZzZXQgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0Ly8gQm90dG9tIGZhY2VzXG5cbiAgICBcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGZsZW47IGkgKysgKSB7XG5cbiAgICBcdFx0XHRcdGZhY2UgPSBmYWNlc1sgaSBdO1xuICAgIFx0XHRcdFx0ZjMoIGZhY2VbIDIgXSwgZmFjZVsgMSBdLCBmYWNlWyAwIF0gKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdC8vIFRvcCBmYWNlc1xuXG4gICAgXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBmbGVuOyBpICsrICkge1xuXG4gICAgXHRcdFx0XHRmYWNlID0gZmFjZXNbIGkgXTtcbiAgICBcdFx0XHRcdGYzKCBmYWNlWyAwIF0gKyB2bGVuICogc3RlcHMsIGZhY2VbIDEgXSArIHZsZW4gKiBzdGVwcywgZmFjZVsgMiBdICsgdmxlbiAqIHN0ZXBzICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9XG5cbiAgICBcdC8vIENyZWF0ZSBmYWNlcyBmb3IgdGhlIHotc2lkZXMgb2YgdGhlIHNoYXBlXG5cbiAgICBcdGZ1bmN0aW9uIGJ1aWxkU2lkZUZhY2VzKCkge1xuXG4gICAgXHRcdHZhciBsYXllcm9mZnNldCA9IDA7XG4gICAgXHRcdHNpZGV3YWxscyggY29udG91ciwgbGF5ZXJvZmZzZXQgKTtcbiAgICBcdFx0bGF5ZXJvZmZzZXQgKz0gY29udG91ci5sZW5ndGg7XG5cbiAgICBcdFx0Zm9yICggaCA9IDAsIGhsID0gaG9sZXMubGVuZ3RoOyBoIDwgaGw7IGggKysgKSB7XG5cbiAgICBcdFx0XHRhaG9sZSA9IGhvbGVzWyBoIF07XG4gICAgXHRcdFx0c2lkZXdhbGxzKCBhaG9sZSwgbGF5ZXJvZmZzZXQgKTtcblxuICAgIFx0XHRcdC8vLCB0cnVlXG4gICAgXHRcdFx0bGF5ZXJvZmZzZXQgKz0gYWhvbGUubGVuZ3RoO1xuXG4gICAgXHRcdH1cblxuICAgIFx0fVxuXG4gICAgXHRmdW5jdGlvbiBzaWRld2FsbHMoIGNvbnRvdXIsIGxheWVyb2Zmc2V0ICkge1xuXG4gICAgXHRcdHZhciBqLCBrO1xuICAgIFx0XHRpID0gY29udG91ci5sZW5ndGg7XG5cbiAgICBcdFx0d2hpbGUgKCAtLSBpID49IDAgKSB7XG5cbiAgICBcdFx0XHRqID0gaTtcbiAgICBcdFx0XHRrID0gaSAtIDE7XG4gICAgXHRcdFx0aWYgKCBrIDwgMCApIGsgPSBjb250b3VyLmxlbmd0aCAtIDE7XG5cbiAgICBcdFx0XHQvL2NvbnNvbGUubG9nKCdiJywgaSxqLCBpLTEsIGssdmVydGljZXMubGVuZ3RoKTtcblxuICAgIFx0XHRcdHZhciBzID0gMCwgc2wgPSBzdGVwcyAgKyBiZXZlbFNlZ21lbnRzICogMjtcblxuICAgIFx0XHRcdGZvciAoIHMgPSAwOyBzIDwgc2w7IHMgKysgKSB7XG5cbiAgICBcdFx0XHRcdHZhciBzbGVuMSA9IHZsZW4gKiBzO1xuICAgIFx0XHRcdFx0dmFyIHNsZW4yID0gdmxlbiAqICggcyArIDEgKTtcblxuICAgIFx0XHRcdFx0dmFyIGEgPSBsYXllcm9mZnNldCArIGogKyBzbGVuMSxcbiAgICBcdFx0XHRcdFx0YiA9IGxheWVyb2Zmc2V0ICsgayArIHNsZW4xLFxuICAgIFx0XHRcdFx0XHRjID0gbGF5ZXJvZmZzZXQgKyBrICsgc2xlbjIsXG4gICAgXHRcdFx0XHRcdGQgPSBsYXllcm9mZnNldCArIGogKyBzbGVuMjtcblxuICAgIFx0XHRcdFx0ZjQoIGEsIGIsIGMsIGQsIGNvbnRvdXIsIHMsIHNsLCBqLCBrICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9XG5cblxuICAgIFx0ZnVuY3Rpb24gdiggeCwgeSwgeiApIHtcblxuICAgIFx0XHRzY29wZS52ZXJ0aWNlcy5wdXNoKCBuZXcgVmVjdG9yMyggeCwgeSwgeiApICk7XG5cbiAgICBcdH1cblxuICAgIFx0ZnVuY3Rpb24gZjMoIGEsIGIsIGMgKSB7XG5cbiAgICBcdFx0YSArPSBzaGFwZXNPZmZzZXQ7XG4gICAgXHRcdGIgKz0gc2hhcGVzT2Zmc2V0O1xuICAgIFx0XHRjICs9IHNoYXBlc09mZnNldDtcblxuICAgIFx0XHRzY29wZS5mYWNlcy5wdXNoKCBuZXcgRmFjZTMoIGEsIGIsIGMsIG51bGwsIG51bGwsIDAgKSApO1xuXG4gICAgXHRcdHZhciB1dnMgPSB1dmdlbi5nZW5lcmF0ZVRvcFVWKCBzY29wZSwgYSwgYiwgYyApO1xuXG4gICAgXHRcdHNjb3BlLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCB1dnMgKTtcblxuICAgIFx0fVxuXG4gICAgXHRmdW5jdGlvbiBmNCggYSwgYiwgYywgZCwgd2FsbENvbnRvdXIsIHN0ZXBJbmRleCwgc3RlcHNMZW5ndGgsIGNvbnRvdXJJbmRleDEsIGNvbnRvdXJJbmRleDIgKSB7XG5cbiAgICBcdFx0YSArPSBzaGFwZXNPZmZzZXQ7XG4gICAgXHRcdGIgKz0gc2hhcGVzT2Zmc2V0O1xuICAgIFx0XHRjICs9IHNoYXBlc09mZnNldDtcbiAgICBcdFx0ZCArPSBzaGFwZXNPZmZzZXQ7XG5cbiAgICBcdFx0c2NvcGUuZmFjZXMucHVzaCggbmV3IEZhY2UzKCBhLCBiLCBkLCBudWxsLCBudWxsLCAxICkgKTtcbiAgICBcdFx0c2NvcGUuZmFjZXMucHVzaCggbmV3IEZhY2UzKCBiLCBjLCBkLCBudWxsLCBudWxsLCAxICkgKTtcblxuICAgIFx0XHR2YXIgdXZzID0gdXZnZW4uZ2VuZXJhdGVTaWRlV2FsbFVWKCBzY29wZSwgYSwgYiwgYywgZCApO1xuXG4gICAgXHRcdHNjb3BlLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2c1sgMCBdLCB1dnNbIDEgXSwgdXZzWyAzIF0gXSApO1xuICAgIFx0XHRzY29wZS5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1dnNbIDEgXSwgdXZzWyAyIF0sIHV2c1sgMyBdIF0gKTtcblxuICAgIFx0fVxuXG4gICAgfTtcblxuICAgIEV4dHJ1ZGVHZW9tZXRyeS5Xb3JsZFVWR2VuZXJhdG9yID0ge1xuXG4gICAgXHRnZW5lcmF0ZVRvcFVWOiBmdW5jdGlvbiAoIGdlb21ldHJ5LCBpbmRleEEsIGluZGV4QiwgaW5kZXhDICkge1xuXG4gICAgXHRcdHZhciB2ZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzO1xuXG4gICAgXHRcdHZhciBhID0gdmVydGljZXNbIGluZGV4QSBdO1xuICAgIFx0XHR2YXIgYiA9IHZlcnRpY2VzWyBpbmRleEIgXTtcbiAgICBcdFx0dmFyIGMgPSB2ZXJ0aWNlc1sgaW5kZXhDIF07XG5cbiAgICBcdFx0cmV0dXJuIFtcbiAgICBcdFx0XHRuZXcgVmVjdG9yMiggYS54LCBhLnkgKSxcbiAgICBcdFx0XHRuZXcgVmVjdG9yMiggYi54LCBiLnkgKSxcbiAgICBcdFx0XHRuZXcgVmVjdG9yMiggYy54LCBjLnkgKVxuICAgIFx0XHRdO1xuXG4gICAgXHR9LFxuXG4gICAgXHRnZW5lcmF0ZVNpZGVXYWxsVVY6IGZ1bmN0aW9uICggZ2VvbWV0cnksIGluZGV4QSwgaW5kZXhCLCBpbmRleEMsIGluZGV4RCApIHtcblxuICAgIFx0XHR2YXIgdmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlcztcblxuICAgIFx0XHR2YXIgYSA9IHZlcnRpY2VzWyBpbmRleEEgXTtcbiAgICBcdFx0dmFyIGIgPSB2ZXJ0aWNlc1sgaW5kZXhCIF07XG4gICAgXHRcdHZhciBjID0gdmVydGljZXNbIGluZGV4QyBdO1xuICAgIFx0XHR2YXIgZCA9IHZlcnRpY2VzWyBpbmRleEQgXTtcblxuICAgIFx0XHRpZiAoIE1hdGguYWJzKCBhLnkgLSBiLnkgKSA8IDAuMDEgKSB7XG5cbiAgICBcdFx0XHRyZXR1cm4gW1xuICAgIFx0XHRcdFx0bmV3IFZlY3RvcjIoIGEueCwgMSAtIGEueiApLFxuICAgIFx0XHRcdFx0bmV3IFZlY3RvcjIoIGIueCwgMSAtIGIueiApLFxuICAgIFx0XHRcdFx0bmV3IFZlY3RvcjIoIGMueCwgMSAtIGMueiApLFxuICAgIFx0XHRcdFx0bmV3IFZlY3RvcjIoIGQueCwgMSAtIGQueiApXG4gICAgXHRcdFx0XTtcblxuICAgIFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0cmV0dXJuIFtcbiAgICBcdFx0XHRcdG5ldyBWZWN0b3IyKCBhLnksIDEgLSBhLnogKSxcbiAgICBcdFx0XHRcdG5ldyBWZWN0b3IyKCBiLnksIDEgLSBiLnogKSxcbiAgICBcdFx0XHRcdG5ldyBWZWN0b3IyKCBjLnksIDEgLSBjLnogKSxcbiAgICBcdFx0XHRcdG5ldyBWZWN0b3IyKCBkLnksIDEgLSBkLnogKVxuICAgIFx0XHRcdF07XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcbiAgICAgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICAgICAqXG4gICAgICogVGV4dCA9IDNEIFRleHRcbiAgICAgKlxuICAgICAqIHBhcmFtZXRlcnMgPSB7XG4gICAgICogIGZvbnQ6IDxUSFJFRS5Gb250PiwgLy8gZm9udFxuICAgICAqXG4gICAgICogIHNpemU6IDxmbG9hdD4sIC8vIHNpemUgb2YgdGhlIHRleHRcbiAgICAgKiAgaGVpZ2h0OiA8ZmxvYXQ+LCAvLyB0aGlja25lc3MgdG8gZXh0cnVkZSB0ZXh0XG4gICAgICogIGN1cnZlU2VnbWVudHM6IDxpbnQ+LCAvLyBudW1iZXIgb2YgcG9pbnRzIG9uIHRoZSBjdXJ2ZXNcbiAgICAgKlxuICAgICAqICBiZXZlbEVuYWJsZWQ6IDxib29sPiwgLy8gdHVybiBvbiBiZXZlbFxuICAgICAqICBiZXZlbFRoaWNrbmVzczogPGZsb2F0PiwgLy8gaG93IGRlZXAgaW50byB0ZXh0IGJldmVsIGdvZXNcbiAgICAgKiAgYmV2ZWxTaXplOiA8ZmxvYXQ+IC8vIGhvdyBmYXIgZnJvbSB0ZXh0IG91dGxpbmUgaXMgYmV2ZWxcbiAgICAgKiB9XG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBUZXh0R2VvbWV0cnkoIHRleHQsIHBhcmFtZXRlcnMgKSB7XG5cbiAgICBcdHBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzIHx8IHt9O1xuXG4gICAgXHR2YXIgZm9udCA9IHBhcmFtZXRlcnMuZm9udDtcblxuICAgIFx0aWYgKCAoZm9udCAmJiBmb250LmlzRm9udCkgPT09IGZhbHNlICkge1xuXG4gICAgXHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5UZXh0R2VvbWV0cnk6IGZvbnQgcGFyYW1ldGVyIGlzIG5vdCBhbiBpbnN0YW5jZSBvZiBUSFJFRS5Gb250LicgKTtcbiAgICBcdFx0cmV0dXJuIG5ldyBHZW9tZXRyeSgpO1xuXG4gICAgXHR9XG5cbiAgICBcdHZhciBzaGFwZXMgPSBmb250LmdlbmVyYXRlU2hhcGVzKCB0ZXh0LCBwYXJhbWV0ZXJzLnNpemUsIHBhcmFtZXRlcnMuY3VydmVTZWdtZW50cyApO1xuXG4gICAgXHQvLyB0cmFuc2xhdGUgcGFyYW1ldGVycyB0byBFeHRydWRlR2VvbWV0cnkgQVBJXG5cbiAgICBcdHBhcmFtZXRlcnMuYW1vdW50ID0gcGFyYW1ldGVycy5oZWlnaHQgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuaGVpZ2h0IDogNTA7XG5cbiAgICBcdC8vIGRlZmF1bHRzXG5cbiAgICBcdGlmICggcGFyYW1ldGVycy5iZXZlbFRoaWNrbmVzcyA9PT0gdW5kZWZpbmVkICkgcGFyYW1ldGVycy5iZXZlbFRoaWNrbmVzcyA9IDEwO1xuICAgIFx0aWYgKCBwYXJhbWV0ZXJzLmJldmVsU2l6ZSA9PT0gdW5kZWZpbmVkICkgcGFyYW1ldGVycy5iZXZlbFNpemUgPSA4O1xuICAgIFx0aWYgKCBwYXJhbWV0ZXJzLmJldmVsRW5hYmxlZCA9PT0gdW5kZWZpbmVkICkgcGFyYW1ldGVycy5iZXZlbEVuYWJsZWQgPSBmYWxzZTtcblxuICAgIFx0RXh0cnVkZUdlb21ldHJ5LmNhbGwoIHRoaXMsIHNoYXBlcywgcGFyYW1ldGVycyApO1xuXG4gICAgXHR0aGlzLnR5cGUgPSAnVGV4dEdlb21ldHJ5JztcblxuICAgIH1cblxuICAgIFRleHRHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBFeHRydWRlR2VvbWV0cnkucHJvdG90eXBlICk7XG4gICAgVGV4dEdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRleHRHZW9tZXRyeTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgYmVuYWFkYW1zIC8gaHR0cHM6Ly90d2l0dGVyLmNvbS9iZW5fYV9hZGFtc1xuICAgICAqIGJhc2VkIG9uIFRIUkVFLlNwaGVyZUdlb21ldHJ5XG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBTcGhlcmVCdWZmZXJHZW9tZXRyeSggcmFkaXVzLCB3aWR0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgcGhpU3RhcnQsIHBoaUxlbmd0aCwgdGhldGFTdGFydCwgdGhldGFMZW5ndGggKSB7XG5cbiAgICBcdEJ1ZmZlckdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuICAgIFx0dGhpcy50eXBlID0gJ1NwaGVyZUJ1ZmZlckdlb21ldHJ5JztcblxuICAgIFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuICAgIFx0XHRyYWRpdXM6IHJhZGl1cyxcbiAgICBcdFx0d2lkdGhTZWdtZW50czogd2lkdGhTZWdtZW50cyxcbiAgICBcdFx0aGVpZ2h0U2VnbWVudHM6IGhlaWdodFNlZ21lbnRzLFxuICAgIFx0XHRwaGlTdGFydDogcGhpU3RhcnQsXG4gICAgXHRcdHBoaUxlbmd0aDogcGhpTGVuZ3RoLFxuICAgIFx0XHR0aGV0YVN0YXJ0OiB0aGV0YVN0YXJ0LFxuICAgIFx0XHR0aGV0YUxlbmd0aDogdGhldGFMZW5ndGhcbiAgICBcdH07XG5cbiAgICBcdHJhZGl1cyA9IHJhZGl1cyB8fCA1MDtcblxuICAgIFx0d2lkdGhTZWdtZW50cyA9IE1hdGgubWF4KCAzLCBNYXRoLmZsb29yKCB3aWR0aFNlZ21lbnRzICkgfHwgOCApO1xuICAgIFx0aGVpZ2h0U2VnbWVudHMgPSBNYXRoLm1heCggMiwgTWF0aC5mbG9vciggaGVpZ2h0U2VnbWVudHMgKSB8fCA2ICk7XG5cbiAgICBcdHBoaVN0YXJ0ID0gcGhpU3RhcnQgIT09IHVuZGVmaW5lZCA/IHBoaVN0YXJ0IDogMDtcbiAgICBcdHBoaUxlbmd0aCA9IHBoaUxlbmd0aCAhPT0gdW5kZWZpbmVkID8gcGhpTGVuZ3RoIDogTWF0aC5QSSAqIDI7XG5cbiAgICBcdHRoZXRhU3RhcnQgPSB0aGV0YVN0YXJ0ICE9PSB1bmRlZmluZWQgPyB0aGV0YVN0YXJ0IDogMDtcbiAgICBcdHRoZXRhTGVuZ3RoID0gdGhldGFMZW5ndGggIT09IHVuZGVmaW5lZCA/IHRoZXRhTGVuZ3RoIDogTWF0aC5QSTtcblxuICAgIFx0dmFyIHRoZXRhRW5kID0gdGhldGFTdGFydCArIHRoZXRhTGVuZ3RoO1xuXG4gICAgXHR2YXIgdmVydGV4Q291bnQgPSAoICggd2lkdGhTZWdtZW50cyArIDEgKSAqICggaGVpZ2h0U2VnbWVudHMgKyAxICkgKTtcblxuICAgIFx0dmFyIHBvc2l0aW9ucyA9IG5ldyBCdWZmZXJBdHRyaWJ1dGUoIG5ldyBGbG9hdDMyQXJyYXkoIHZlcnRleENvdW50ICogMyApLCAzICk7XG4gICAgXHR2YXIgbm9ybWFscyA9IG5ldyBCdWZmZXJBdHRyaWJ1dGUoIG5ldyBGbG9hdDMyQXJyYXkoIHZlcnRleENvdW50ICogMyApLCAzICk7XG4gICAgXHR2YXIgdXZzID0gbmV3IEJ1ZmZlckF0dHJpYnV0ZSggbmV3IEZsb2F0MzJBcnJheSggdmVydGV4Q291bnQgKiAyICksIDIgKTtcblxuICAgIFx0dmFyIGluZGV4ID0gMCwgdmVydGljZXMgPSBbXSwgbm9ybWFsID0gbmV3IFZlY3RvcjMoKTtcblxuICAgIFx0Zm9yICggdmFyIHkgPSAwOyB5IDw9IGhlaWdodFNlZ21lbnRzOyB5ICsrICkge1xuXG4gICAgXHRcdHZhciB2ZXJ0aWNlc1JvdyA9IFtdO1xuXG4gICAgXHRcdHZhciB2ID0geSAvIGhlaWdodFNlZ21lbnRzO1xuXG4gICAgXHRcdGZvciAoIHZhciB4ID0gMDsgeCA8PSB3aWR0aFNlZ21lbnRzOyB4ICsrICkge1xuXG4gICAgXHRcdFx0dmFyIHUgPSB4IC8gd2lkdGhTZWdtZW50cztcblxuICAgIFx0XHRcdHZhciBweCA9IC0gcmFkaXVzICogTWF0aC5jb3MoIHBoaVN0YXJ0ICsgdSAqIHBoaUxlbmd0aCApICogTWF0aC5zaW4oIHRoZXRhU3RhcnQgKyB2ICogdGhldGFMZW5ndGggKTtcbiAgICBcdFx0XHR2YXIgcHkgPSByYWRpdXMgKiBNYXRoLmNvcyggdGhldGFTdGFydCArIHYgKiB0aGV0YUxlbmd0aCApO1xuICAgIFx0XHRcdHZhciBweiA9IHJhZGl1cyAqIE1hdGguc2luKCBwaGlTdGFydCArIHUgKiBwaGlMZW5ndGggKSAqIE1hdGguc2luKCB0aGV0YVN0YXJ0ICsgdiAqIHRoZXRhTGVuZ3RoICk7XG5cbiAgICBcdFx0XHRub3JtYWwuc2V0KCBweCwgcHksIHB6ICkubm9ybWFsaXplKCk7XG5cbiAgICBcdFx0XHRwb3NpdGlvbnMuc2V0WFlaKCBpbmRleCwgcHgsIHB5LCBweiApO1xuICAgIFx0XHRcdG5vcm1hbHMuc2V0WFlaKCBpbmRleCwgbm9ybWFsLngsIG5vcm1hbC55LCBub3JtYWwueiApO1xuICAgIFx0XHRcdHV2cy5zZXRYWSggaW5kZXgsIHUsIDEgLSB2ICk7XG5cbiAgICBcdFx0XHR2ZXJ0aWNlc1Jvdy5wdXNoKCBpbmRleCApO1xuXG4gICAgXHRcdFx0aW5kZXggKys7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHZlcnRpY2VzLnB1c2goIHZlcnRpY2VzUm93ICk7XG5cbiAgICBcdH1cblxuICAgIFx0dmFyIGluZGljZXMgPSBbXTtcblxuICAgIFx0Zm9yICggdmFyIHkgPSAwOyB5IDwgaGVpZ2h0U2VnbWVudHM7IHkgKysgKSB7XG5cbiAgICBcdFx0Zm9yICggdmFyIHggPSAwOyB4IDwgd2lkdGhTZWdtZW50czsgeCArKyApIHtcblxuICAgIFx0XHRcdHZhciB2MSA9IHZlcnRpY2VzWyB5IF1bIHggKyAxIF07XG4gICAgXHRcdFx0dmFyIHYyID0gdmVydGljZXNbIHkgXVsgeCBdO1xuICAgIFx0XHRcdHZhciB2MyA9IHZlcnRpY2VzWyB5ICsgMSBdWyB4IF07XG4gICAgXHRcdFx0dmFyIHY0ID0gdmVydGljZXNbIHkgKyAxIF1bIHggKyAxIF07XG5cbiAgICBcdFx0XHRpZiAoIHkgIT09IDAgfHwgdGhldGFTdGFydCA+IDAgKSBpbmRpY2VzLnB1c2goIHYxLCB2MiwgdjQgKTtcbiAgICBcdFx0XHRpZiAoIHkgIT09IGhlaWdodFNlZ21lbnRzIC0gMSB8fCB0aGV0YUVuZCA8IE1hdGguUEkgKSBpbmRpY2VzLnB1c2goIHYyLCB2MywgdjQgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdH1cblxuICAgIFx0dGhpcy5zZXRJbmRleCggbmV3ICggcG9zaXRpb25zLmNvdW50ID4gNjU1MzUgPyBVaW50MzJBdHRyaWJ1dGUgOiBVaW50MTZBdHRyaWJ1dGUgKSggaW5kaWNlcywgMSApICk7XG4gICAgXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgcG9zaXRpb25zICk7XG4gICAgXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5vcm1hbHMgKTtcbiAgICBcdHRoaXMuYWRkQXR0cmlidXRlKCAndXYnLCB1dnMgKTtcblxuICAgIFx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IG5ldyBTcGhlcmUoIG5ldyBWZWN0b3IzKCksIHJhZGl1cyApO1xuXG4gICAgfVxuXG4gICAgU3BoZXJlQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XG4gICAgU3BoZXJlQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3BoZXJlQnVmZmVyR2VvbWV0cnk7XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gU3BoZXJlR2VvbWV0cnkoIHJhZGl1cywgd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIHBoaVN0YXJ0LCBwaGlMZW5ndGgsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICkge1xuXG4gICAgXHRHZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cbiAgICBcdHRoaXMudHlwZSA9ICdTcGhlcmVHZW9tZXRyeSc7XG5cbiAgICBcdHRoaXMucGFyYW1ldGVycyA9IHtcbiAgICBcdFx0cmFkaXVzOiByYWRpdXMsXG4gICAgXHRcdHdpZHRoU2VnbWVudHM6IHdpZHRoU2VnbWVudHMsXG4gICAgXHRcdGhlaWdodFNlZ21lbnRzOiBoZWlnaHRTZWdtZW50cyxcbiAgICBcdFx0cGhpU3RhcnQ6IHBoaVN0YXJ0LFxuICAgIFx0XHRwaGlMZW5ndGg6IHBoaUxlbmd0aCxcbiAgICBcdFx0dGhldGFTdGFydDogdGhldGFTdGFydCxcbiAgICBcdFx0dGhldGFMZW5ndGg6IHRoZXRhTGVuZ3RoXG4gICAgXHR9O1xuXG4gICAgXHR0aGlzLmZyb21CdWZmZXJHZW9tZXRyeSggbmV3IFNwaGVyZUJ1ZmZlckdlb21ldHJ5KCByYWRpdXMsIHdpZHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCBwaGlTdGFydCwgcGhpTGVuZ3RoLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCApICk7XG5cbiAgICB9XG5cbiAgICBTcGhlcmVHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBHZW9tZXRyeS5wcm90b3R5cGUgKTtcbiAgICBTcGhlcmVHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTcGhlcmVHZW9tZXRyeTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgTXVnZW44NyAvIGh0dHBzOi8vZ2l0aHViLmNvbS9NdWdlbjg3XG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBSaW5nQnVmZmVyR2VvbWV0cnkoIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cywgdGhldGFTZWdtZW50cywgcGhpU2VnbWVudHMsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICkge1xuXG4gICAgXHRCdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cbiAgICBcdHRoaXMudHlwZSA9ICdSaW5nQnVmZmVyR2VvbWV0cnknO1xuXG4gICAgXHR0aGlzLnBhcmFtZXRlcnMgPSB7XG4gICAgXHRcdGlubmVyUmFkaXVzOiBpbm5lclJhZGl1cyxcbiAgICBcdFx0b3V0ZXJSYWRpdXM6IG91dGVyUmFkaXVzLFxuICAgIFx0XHR0aGV0YVNlZ21lbnRzOiB0aGV0YVNlZ21lbnRzLFxuICAgIFx0XHRwaGlTZWdtZW50czogcGhpU2VnbWVudHMsXG4gICAgXHRcdHRoZXRhU3RhcnQ6IHRoZXRhU3RhcnQsXG4gICAgXHRcdHRoZXRhTGVuZ3RoOiB0aGV0YUxlbmd0aFxuICAgIFx0fTtcblxuICAgIFx0aW5uZXJSYWRpdXMgPSBpbm5lclJhZGl1cyB8fCAyMDtcbiAgICBcdG91dGVyUmFkaXVzID0gb3V0ZXJSYWRpdXMgfHwgNTA7XG5cbiAgICBcdHRoZXRhU3RhcnQgPSB0aGV0YVN0YXJ0ICE9PSB1bmRlZmluZWQgPyB0aGV0YVN0YXJ0IDogMDtcbiAgICBcdHRoZXRhTGVuZ3RoID0gdGhldGFMZW5ndGggIT09IHVuZGVmaW5lZCA/IHRoZXRhTGVuZ3RoIDogTWF0aC5QSSAqIDI7XG5cbiAgICBcdHRoZXRhU2VnbWVudHMgPSB0aGV0YVNlZ21lbnRzICE9PSB1bmRlZmluZWQgPyBNYXRoLm1heCggMywgdGhldGFTZWdtZW50cyApIDogODtcbiAgICBcdHBoaVNlZ21lbnRzID0gcGhpU2VnbWVudHMgIT09IHVuZGVmaW5lZCA/IE1hdGgubWF4KCAxLCBwaGlTZWdtZW50cyApIDogMTtcblxuICAgIFx0Ly8gdGhlc2UgYXJlIHVzZWQgdG8gY2FsY3VsYXRlIGJ1ZmZlciBsZW5ndGhcbiAgICBcdHZhciB2ZXJ0ZXhDb3VudCA9ICggdGhldGFTZWdtZW50cyArIDEgKSAqICggcGhpU2VnbWVudHMgKyAxICk7XG4gICAgXHR2YXIgaW5kZXhDb3VudCA9IHRoZXRhU2VnbWVudHMgKiBwaGlTZWdtZW50cyAqIDIgKiAzO1xuXG4gICAgXHQvLyBidWZmZXJzXG4gICAgXHR2YXIgaW5kaWNlcyA9IG5ldyBCdWZmZXJBdHRyaWJ1dGUoIG5ldyAoIGluZGV4Q291bnQgPiA2NTUzNSA/IFVpbnQzMkFycmF5IDogVWludDE2QXJyYXkgKSggaW5kZXhDb3VudCApICwgMSApO1xuICAgIFx0dmFyIHZlcnRpY2VzID0gbmV3IEJ1ZmZlckF0dHJpYnV0ZSggbmV3IEZsb2F0MzJBcnJheSggdmVydGV4Q291bnQgKiAzICksIDMgKTtcbiAgICBcdHZhciBub3JtYWxzID0gbmV3IEJ1ZmZlckF0dHJpYnV0ZSggbmV3IEZsb2F0MzJBcnJheSggdmVydGV4Q291bnQgKiAzICksIDMgKTtcbiAgICBcdHZhciB1dnMgPSBuZXcgQnVmZmVyQXR0cmlidXRlKCBuZXcgRmxvYXQzMkFycmF5KCB2ZXJ0ZXhDb3VudCAqIDIgKSwgMiApO1xuXG4gICAgXHQvLyBzb21lIGhlbHBlciB2YXJpYWJsZXNcbiAgICBcdHZhciBpbmRleCA9IDAsIGluZGV4T2Zmc2V0ID0gMCwgc2VnbWVudDtcbiAgICBcdHZhciByYWRpdXMgPSBpbm5lclJhZGl1cztcbiAgICBcdHZhciByYWRpdXNTdGVwID0gKCAoIG91dGVyUmFkaXVzIC0gaW5uZXJSYWRpdXMgKSAvIHBoaVNlZ21lbnRzICk7XG4gICAgXHR2YXIgdmVydGV4ID0gbmV3IFZlY3RvcjMoKTtcbiAgICBcdHZhciB1diA9IG5ldyBWZWN0b3IyKCk7XG4gICAgXHR2YXIgaiwgaTtcblxuICAgIFx0Ly8gZ2VuZXJhdGUgdmVydGljZXMsIG5vcm1hbHMgYW5kIHV2c1xuXG4gICAgXHQvLyB2YWx1ZXMgYXJlIGdlbmVyYXRlIGZyb20gdGhlIGluc2lkZSBvZiB0aGUgcmluZyB0byB0aGUgb3V0c2lkZVxuXG4gICAgXHRmb3IgKCBqID0gMDsgaiA8PSBwaGlTZWdtZW50czsgaiArKyApIHtcblxuICAgIFx0XHRmb3IgKCBpID0gMDsgaSA8PSB0aGV0YVNlZ21lbnRzOyBpICsrICkge1xuXG4gICAgXHRcdFx0c2VnbWVudCA9IHRoZXRhU3RhcnQgKyBpIC8gdGhldGFTZWdtZW50cyAqIHRoZXRhTGVuZ3RoO1xuXG4gICAgXHRcdFx0Ly8gdmVydGV4XG4gICAgXHRcdFx0dmVydGV4LnggPSByYWRpdXMgKiBNYXRoLmNvcyggc2VnbWVudCApO1xuICAgIFx0XHRcdHZlcnRleC55ID0gcmFkaXVzICogTWF0aC5zaW4oIHNlZ21lbnQgKTtcbiAgICBcdFx0XHR2ZXJ0aWNlcy5zZXRYWVooIGluZGV4LCB2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56ICk7XG5cbiAgICBcdFx0XHQvLyBub3JtYWxcbiAgICBcdFx0XHRub3JtYWxzLnNldFhZWiggaW5kZXgsIDAsIDAsIDEgKTtcblxuICAgIFx0XHRcdC8vIHV2XG4gICAgXHRcdFx0dXYueCA9ICggdmVydGV4LnggLyBvdXRlclJhZGl1cyArIDEgKSAvIDI7XG4gICAgXHRcdFx0dXYueSA9ICggdmVydGV4LnkgLyBvdXRlclJhZGl1cyArIDEgKSAvIDI7XG4gICAgXHRcdFx0dXZzLnNldFhZKCBpbmRleCwgdXYueCwgdXYueSApO1xuXG4gICAgXHRcdFx0Ly8gaW5jcmVhc2UgaW5kZXhcbiAgICBcdFx0XHRpbmRleCsrO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHQvLyBpbmNyZWFzZSB0aGUgcmFkaXVzIGZvciBuZXh0IHJvdyBvZiB2ZXJ0aWNlc1xuICAgIFx0XHRyYWRpdXMgKz0gcmFkaXVzU3RlcDtcblxuICAgIFx0fVxuXG4gICAgXHQvLyBnZW5lcmF0ZSBpbmRpY2VzXG5cbiAgICBcdGZvciAoIGogPSAwOyBqIDwgcGhpU2VnbWVudHM7IGogKysgKSB7XG5cbiAgICBcdFx0dmFyIHRoZXRhU2VnbWVudExldmVsID0gaiAqICggdGhldGFTZWdtZW50cyArIDEgKTtcblxuICAgIFx0XHRmb3IgKCBpID0gMDsgaSA8IHRoZXRhU2VnbWVudHM7IGkgKysgKSB7XG5cbiAgICBcdFx0XHRzZWdtZW50ID0gaSArIHRoZXRhU2VnbWVudExldmVsO1xuXG4gICAgXHRcdFx0Ly8gaW5kaWNlc1xuICAgIFx0XHRcdHZhciBhID0gc2VnbWVudDtcbiAgICBcdFx0XHR2YXIgYiA9IHNlZ21lbnQgKyB0aGV0YVNlZ21lbnRzICsgMTtcbiAgICBcdFx0XHR2YXIgYyA9IHNlZ21lbnQgKyB0aGV0YVNlZ21lbnRzICsgMjtcbiAgICBcdFx0XHR2YXIgZCA9IHNlZ21lbnQgKyAxO1xuXG4gICAgXHRcdFx0Ly8gZmFjZSBvbmVcbiAgICBcdFx0XHRpbmRpY2VzLnNldFgoIGluZGV4T2Zmc2V0LCBhICk7IGluZGV4T2Zmc2V0Kys7XG4gICAgXHRcdFx0aW5kaWNlcy5zZXRYKCBpbmRleE9mZnNldCwgYiApOyBpbmRleE9mZnNldCsrO1xuICAgIFx0XHRcdGluZGljZXMuc2V0WCggaW5kZXhPZmZzZXQsIGMgKTsgaW5kZXhPZmZzZXQrKztcblxuICAgIFx0XHRcdC8vIGZhY2UgdHdvXG4gICAgXHRcdFx0aW5kaWNlcy5zZXRYKCBpbmRleE9mZnNldCwgYSApOyBpbmRleE9mZnNldCsrO1xuICAgIFx0XHRcdGluZGljZXMuc2V0WCggaW5kZXhPZmZzZXQsIGMgKTsgaW5kZXhPZmZzZXQrKztcbiAgICBcdFx0XHRpbmRpY2VzLnNldFgoIGluZGV4T2Zmc2V0LCBkICk7IGluZGV4T2Zmc2V0Kys7XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9XG5cbiAgICBcdC8vIGJ1aWxkIGdlb21ldHJ5XG5cbiAgICBcdHRoaXMuc2V0SW5kZXgoIGluZGljZXMgKTtcbiAgICBcdHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCB2ZXJ0aWNlcyApO1xuICAgIFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdub3JtYWwnLCBub3JtYWxzICk7XG4gICAgXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3V2JywgdXZzICk7XG5cbiAgICB9XG5cbiAgICBSaW5nQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XG4gICAgUmluZ0J1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJpbmdCdWZmZXJHZW9tZXRyeTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgS2FsZWIgTXVycGh5XG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBSaW5nR2VvbWV0cnkoIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cywgdGhldGFTZWdtZW50cywgcGhpU2VnbWVudHMsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICkge1xuXG4gICAgXHRHZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cbiAgICBcdHRoaXMudHlwZSA9ICdSaW5nR2VvbWV0cnknO1xuXG4gICAgXHR0aGlzLnBhcmFtZXRlcnMgPSB7XG4gICAgXHRcdGlubmVyUmFkaXVzOiBpbm5lclJhZGl1cyxcbiAgICBcdFx0b3V0ZXJSYWRpdXM6IG91dGVyUmFkaXVzLFxuICAgIFx0XHR0aGV0YVNlZ21lbnRzOiB0aGV0YVNlZ21lbnRzLFxuICAgIFx0XHRwaGlTZWdtZW50czogcGhpU2VnbWVudHMsXG4gICAgXHRcdHRoZXRhU3RhcnQ6IHRoZXRhU3RhcnQsXG4gICAgXHRcdHRoZXRhTGVuZ3RoOiB0aGV0YUxlbmd0aFxuICAgIFx0fTtcblxuICAgIFx0dGhpcy5mcm9tQnVmZmVyR2VvbWV0cnkoIG5ldyBSaW5nQnVmZmVyR2VvbWV0cnkoIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cywgdGhldGFTZWdtZW50cywgcGhpU2VnbWVudHMsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICkgKTtcblxuICAgIH1cblxuICAgIFJpbmdHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBHZW9tZXRyeS5wcm90b3R5cGUgKTtcbiAgICBSaW5nR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmluZ0dlb21ldHJ5O1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAgICAgKiBiYXNlZCBvbiBodHRwOi8vcGFwZXJ2aXNpb24zZC5nb29nbGVjb2RlLmNvbS9zdm4vdHJ1bmsvYXMzL3RydW5rL3NyYy9vcmcvcGFwZXJ2aXNpb24zZC9vYmplY3RzL3ByaW1pdGl2ZXMvUGxhbmUuYXNcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIFBsYW5lR2VvbWV0cnkoIHdpZHRoLCBoZWlnaHQsIHdpZHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzICkge1xuXG4gICAgXHRHZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cbiAgICBcdHRoaXMudHlwZSA9ICdQbGFuZUdlb21ldHJ5JztcblxuICAgIFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuICAgIFx0XHR3aWR0aDogd2lkdGgsXG4gICAgXHRcdGhlaWdodDogaGVpZ2h0LFxuICAgIFx0XHR3aWR0aFNlZ21lbnRzOiB3aWR0aFNlZ21lbnRzLFxuICAgIFx0XHRoZWlnaHRTZWdtZW50czogaGVpZ2h0U2VnbWVudHNcbiAgICBcdH07XG5cbiAgICBcdHRoaXMuZnJvbUJ1ZmZlckdlb21ldHJ5KCBuZXcgUGxhbmVCdWZmZXJHZW9tZXRyeSggd2lkdGgsIGhlaWdodCwgd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMgKSApO1xuXG4gICAgfVxuXG4gICAgUGxhbmVHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBHZW9tZXRyeS5wcm90b3R5cGUgKTtcbiAgICBQbGFuZUdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBsYW5lR2VvbWV0cnk7XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIE11Z2VuODcgLyBodHRwczovL2dpdGh1Yi5jb20vTXVnZW44N1xuICAgICAqL1xuXG4gICAgIC8vIHBvaW50cyAtIHRvIGNyZWF0ZSBhIGNsb3NlZCB0b3J1cywgb25lIG11c3QgdXNlIGEgc2V0IG9mIHBvaW50c1xuICAgICAvLyAgICBsaWtlIHNvOiBbIGEsIGIsIGMsIGQsIGEgXSwgc2VlIGZpcnN0IGlzIHRoZSBzYW1lIGFzIGxhc3QuXG4gICAgIC8vIHNlZ21lbnRzIC0gdGhlIG51bWJlciBvZiBjaXJjdW1mZXJlbmNlIHNlZ21lbnRzIHRvIGNyZWF0ZVxuICAgICAvLyBwaGlTdGFydCAtIHRoZSBzdGFydGluZyByYWRpYW5cbiAgICAgLy8gcGhpTGVuZ3RoIC0gdGhlIHJhZGlhbiAoMCB0byAyUEkpIHJhbmdlIG9mIHRoZSBsYXRoZWQgc2VjdGlvblxuICAgICAvLyAgICAyUEkgaXMgYSBjbG9zZWQgbGF0aGUsIGxlc3MgdGhhbiAyUEkgaXMgYSBwb3J0aW9uLlxuXG4gICAgZnVuY3Rpb24gTGF0aGVCdWZmZXJHZW9tZXRyeSggcG9pbnRzLCBzZWdtZW50cywgcGhpU3RhcnQsIHBoaUxlbmd0aCApIHtcblxuICAgIFx0QnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG4gICAgXHR0aGlzLnR5cGUgPSAnTGF0aGVCdWZmZXJHZW9tZXRyeSc7XG5cbiAgICBcdHRoaXMucGFyYW1ldGVycyA9IHtcbiAgICBcdFx0cG9pbnRzOiBwb2ludHMsXG4gICAgXHRcdHNlZ21lbnRzOiBzZWdtZW50cyxcbiAgICBcdFx0cGhpU3RhcnQ6IHBoaVN0YXJ0LFxuICAgIFx0XHRwaGlMZW5ndGg6IHBoaUxlbmd0aFxuICAgIFx0fTtcblxuICAgIFx0c2VnbWVudHMgPSBNYXRoLmZsb29yKCBzZWdtZW50cyApIHx8IDEyO1xuICAgIFx0cGhpU3RhcnQgPSBwaGlTdGFydCB8fCAwO1xuICAgIFx0cGhpTGVuZ3RoID0gcGhpTGVuZ3RoIHx8IE1hdGguUEkgKiAyO1xuXG4gICAgXHQvLyBjbGFtcCBwaGlMZW5ndGggc28gaXQncyBpbiByYW5nZSBvZiBbIDAsIDJQSSBdXG4gICAgXHRwaGlMZW5ndGggPSBleHBvcnRzLk1hdGguY2xhbXAoIHBoaUxlbmd0aCwgMCwgTWF0aC5QSSAqIDIgKTtcblxuICAgIFx0Ly8gdGhlc2UgYXJlIHVzZWQgdG8gY2FsY3VsYXRlIGJ1ZmZlciBsZW5ndGhcbiAgICBcdHZhciB2ZXJ0ZXhDb3VudCA9ICggc2VnbWVudHMgKyAxICkgKiBwb2ludHMubGVuZ3RoO1xuICAgIFx0dmFyIGluZGV4Q291bnQgPSBzZWdtZW50cyAqIHBvaW50cy5sZW5ndGggKiAyICogMztcblxuICAgIFx0Ly8gYnVmZmVyc1xuICAgIFx0dmFyIGluZGljZXMgPSBuZXcgQnVmZmVyQXR0cmlidXRlKCBuZXcgKCBpbmRleENvdW50ID4gNjU1MzUgPyBVaW50MzJBcnJheSA6IFVpbnQxNkFycmF5ICkoIGluZGV4Q291bnQgKSAsIDEgKTtcbiAgICBcdHZhciB2ZXJ0aWNlcyA9IG5ldyBCdWZmZXJBdHRyaWJ1dGUoIG5ldyBGbG9hdDMyQXJyYXkoIHZlcnRleENvdW50ICogMyApLCAzICk7XG4gICAgXHR2YXIgdXZzID0gbmV3IEJ1ZmZlckF0dHJpYnV0ZSggbmV3IEZsb2F0MzJBcnJheSggdmVydGV4Q291bnQgKiAyICksIDIgKTtcblxuICAgIFx0Ly8gaGVscGVyIHZhcmlhYmxlc1xuICAgIFx0dmFyIGluZGV4ID0gMCwgaW5kZXhPZmZzZXQgPSAwLCBiYXNlO1xuICAgIFx0dmFyIGludmVyc2VTZWdtZW50cyA9IDEuMCAvIHNlZ21lbnRzO1xuICAgIFx0dmFyIHZlcnRleCA9IG5ldyBWZWN0b3IzKCk7XG4gICAgXHR2YXIgdXYgPSBuZXcgVmVjdG9yMigpO1xuICAgIFx0dmFyIGksIGo7XG5cbiAgICBcdC8vIGdlbmVyYXRlIHZlcnRpY2VzIGFuZCB1dnNcblxuICAgIFx0Zm9yICggaSA9IDA7IGkgPD0gc2VnbWVudHM7IGkgKysgKSB7XG5cbiAgICBcdFx0dmFyIHBoaSA9IHBoaVN0YXJ0ICsgaSAqIGludmVyc2VTZWdtZW50cyAqIHBoaUxlbmd0aDtcblxuICAgIFx0XHR2YXIgc2luID0gTWF0aC5zaW4oIHBoaSApO1xuICAgIFx0XHR2YXIgY29zID0gTWF0aC5jb3MoIHBoaSApO1xuXG4gICAgXHRcdGZvciAoIGogPSAwOyBqIDw9ICggcG9pbnRzLmxlbmd0aCAtIDEgKTsgaiArKyApIHtcblxuICAgIFx0XHRcdC8vIHZlcnRleFxuICAgIFx0XHRcdHZlcnRleC54ID0gcG9pbnRzWyBqIF0ueCAqIHNpbjtcbiAgICBcdFx0XHR2ZXJ0ZXgueSA9IHBvaW50c1sgaiBdLnk7XG4gICAgXHRcdFx0dmVydGV4LnogPSBwb2ludHNbIGogXS54ICogY29zO1xuICAgIFx0XHRcdHZlcnRpY2VzLnNldFhZWiggaW5kZXgsIHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnogKTtcblxuICAgIFx0XHRcdC8vIHV2XG4gICAgXHRcdFx0dXYueCA9IGkgLyBzZWdtZW50cztcbiAgICBcdFx0XHR1di55ID0gaiAvICggcG9pbnRzLmxlbmd0aCAtIDEgKTtcbiAgICBcdFx0XHR1dnMuc2V0WFkoIGluZGV4LCB1di54LCB1di55ICk7XG5cbiAgICBcdFx0XHQvLyBpbmNyZWFzZSBpbmRleFxuICAgIFx0XHRcdGluZGV4ICsrO1xuXG4gICAgXHRcdH1cblxuICAgIFx0fVxuXG4gICAgXHQvLyBnZW5lcmF0ZSBpbmRpY2VzXG5cbiAgICBcdGZvciAoIGkgPSAwOyBpIDwgc2VnbWVudHM7IGkgKysgKSB7XG5cbiAgICBcdFx0Zm9yICggaiA9IDA7IGogPCAoIHBvaW50cy5sZW5ndGggLSAxICk7IGogKysgKSB7XG5cbiAgICBcdFx0XHRiYXNlID0gaiArIGkgKiBwb2ludHMubGVuZ3RoO1xuXG4gICAgXHRcdFx0Ly8gaW5kaWNlc1xuICAgIFx0XHRcdHZhciBhID0gYmFzZTtcbiAgICBcdFx0XHR2YXIgYiA9IGJhc2UgKyBwb2ludHMubGVuZ3RoO1xuICAgIFx0XHRcdHZhciBjID0gYmFzZSArIHBvaW50cy5sZW5ndGggKyAxO1xuICAgIFx0XHRcdHZhciBkID0gYmFzZSArIDE7XG5cbiAgICBcdFx0XHQvLyBmYWNlIG9uZVxuICAgIFx0XHRcdGluZGljZXMuc2V0WCggaW5kZXhPZmZzZXQsIGEgKTsgaW5kZXhPZmZzZXQrKztcbiAgICBcdFx0XHRpbmRpY2VzLnNldFgoIGluZGV4T2Zmc2V0LCBiICk7IGluZGV4T2Zmc2V0Kys7XG4gICAgXHRcdFx0aW5kaWNlcy5zZXRYKCBpbmRleE9mZnNldCwgZCApOyBpbmRleE9mZnNldCsrO1xuXG4gICAgXHRcdFx0Ly8gZmFjZSB0d29cbiAgICBcdFx0XHRpbmRpY2VzLnNldFgoIGluZGV4T2Zmc2V0LCBiICk7IGluZGV4T2Zmc2V0Kys7XG4gICAgXHRcdFx0aW5kaWNlcy5zZXRYKCBpbmRleE9mZnNldCwgYyApOyBpbmRleE9mZnNldCsrO1xuICAgIFx0XHRcdGluZGljZXMuc2V0WCggaW5kZXhPZmZzZXQsIGQgKTsgaW5kZXhPZmZzZXQrKztcblxuICAgIFx0XHR9XG5cbiAgICBcdH1cblxuICAgIFx0Ly8gYnVpbGQgZ2VvbWV0cnlcblxuICAgIFx0dGhpcy5zZXRJbmRleCggaW5kaWNlcyApO1xuICAgIFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIHZlcnRpY2VzICk7XG4gICAgXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3V2JywgdXZzICk7XG5cbiAgICBcdC8vIGdlbmVyYXRlIG5vcm1hbHNcblxuICAgIFx0dGhpcy5jb21wdXRlVmVydGV4Tm9ybWFscygpO1xuXG4gICAgXHQvLyBpZiB0aGUgZ2VvbWV0cnkgaXMgY2xvc2VkLCB3ZSBuZWVkIHRvIGF2ZXJhZ2UgdGhlIG5vcm1hbHMgYWxvbmcgdGhlIHNlYW0uXG4gICAgXHQvLyBiZWNhdXNlIHRoZSBjb3JyZXNwb25kaW5nIHZlcnRpY2VzIGFyZSBpZGVudGljYWwgKGJ1dCBzdGlsbCBoYXZlIGRpZmZlcmVudCBVVnMpLlxuXG4gICAgXHRpZiggcGhpTGVuZ3RoID09PSBNYXRoLlBJICogMiApIHtcblxuICAgIFx0XHR2YXIgbm9ybWFscyA9IHRoaXMuYXR0cmlidXRlcy5ub3JtYWwuYXJyYXk7XG4gICAgXHRcdHZhciBuMSA9IG5ldyBWZWN0b3IzKCk7XG4gICAgXHRcdHZhciBuMiA9IG5ldyBWZWN0b3IzKCk7XG4gICAgXHRcdHZhciBuID0gbmV3IFZlY3RvcjMoKTtcblxuICAgIFx0XHQvLyB0aGlzIGlzIHRoZSBidWZmZXIgb2Zmc2V0IGZvciB0aGUgbGFzdCBsaW5lIG9mIHZlcnRpY2VzXG4gICAgXHRcdGJhc2UgPSBzZWdtZW50cyAqIHBvaW50cy5sZW5ndGggKiAzO1xuXG4gICAgXHRcdGZvciggaSA9IDAsIGogPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSArKywgaiArPSAzICkge1xuXG4gICAgXHRcdFx0Ly8gc2VsZWN0IHRoZSBub3JtYWwgb2YgdGhlIHZlcnRleCBpbiB0aGUgZmlyc3QgbGluZVxuICAgIFx0XHRcdG4xLnggPSBub3JtYWxzWyBqICsgMCBdO1xuICAgIFx0XHRcdG4xLnkgPSBub3JtYWxzWyBqICsgMSBdO1xuICAgIFx0XHRcdG4xLnogPSBub3JtYWxzWyBqICsgMiBdO1xuXG4gICAgXHRcdFx0Ly8gc2VsZWN0IHRoZSBub3JtYWwgb2YgdGhlIHZlcnRleCBpbiB0aGUgbGFzdCBsaW5lXG4gICAgXHRcdFx0bjIueCA9IG5vcm1hbHNbIGJhc2UgKyBqICsgMCBdO1xuICAgIFx0XHRcdG4yLnkgPSBub3JtYWxzWyBiYXNlICsgaiArIDEgXTtcbiAgICBcdFx0XHRuMi56ID0gbm9ybWFsc1sgYmFzZSArIGogKyAyIF07XG5cbiAgICBcdFx0XHQvLyBhdmVyYWdlIG5vcm1hbHNcbiAgICBcdFx0XHRuLmFkZFZlY3RvcnMoIG4xLCBuMiApLm5vcm1hbGl6ZSgpO1xuXG4gICAgXHRcdFx0Ly8gYXNzaWduIHRoZSBuZXcgdmFsdWVzIHRvIGJvdGggbm9ybWFsc1xuICAgIFx0XHRcdG5vcm1hbHNbIGogKyAwIF0gPSBub3JtYWxzWyBiYXNlICsgaiArIDAgXSA9IG4ueDtcbiAgICBcdFx0XHRub3JtYWxzWyBqICsgMSBdID0gbm9ybWFsc1sgYmFzZSArIGogKyAxIF0gPSBuLnk7XG4gICAgXHRcdFx0bm9ybWFsc1sgaiArIDIgXSA9IG5vcm1hbHNbIGJhc2UgKyBqICsgMiBdID0gbi56O1xuXG4gICAgXHRcdH0gLy8gbmV4dCByb3dcblxuICAgIFx0fVxuXG4gICAgfVxuXG4gICAgTGF0aGVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcbiAgICBMYXRoZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExhdGhlQnVmZmVyR2VvbWV0cnk7XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIGFzdHJvZHVkIC8gaHR0cDovL2FzdHJvZHVkLmlzZ3JlYXQub3JnL1xuICAgICAqIEBhdXRob3Igeno4NSAvIGh0dHBzOi8vZ2l0aHViLmNvbS96ejg1XG4gICAgICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pb1xuICAgICAqL1xuXG4gICAgLy8gcG9pbnRzIC0gdG8gY3JlYXRlIGEgY2xvc2VkIHRvcnVzLCBvbmUgbXVzdCB1c2UgYSBzZXQgb2YgcG9pbnRzXG4gICAgLy8gICAgbGlrZSBzbzogWyBhLCBiLCBjLCBkLCBhIF0sIHNlZSBmaXJzdCBpcyB0aGUgc2FtZSBhcyBsYXN0LlxuICAgIC8vIHNlZ21lbnRzIC0gdGhlIG51bWJlciBvZiBjaXJjdW1mZXJlbmNlIHNlZ21lbnRzIHRvIGNyZWF0ZVxuICAgIC8vIHBoaVN0YXJ0IC0gdGhlIHN0YXJ0aW5nIHJhZGlhblxuICAgIC8vIHBoaUxlbmd0aCAtIHRoZSByYWRpYW4gKDAgdG8gMlBJKSByYW5nZSBvZiB0aGUgbGF0aGVkIHNlY3Rpb25cbiAgICAvLyAgICAyUEkgaXMgYSBjbG9zZWQgbGF0aGUsIGxlc3MgdGhhbiAyUEkgaXMgYSBwb3J0aW9uLlxuXG4gICAgZnVuY3Rpb24gTGF0aGVHZW9tZXRyeSggcG9pbnRzLCBzZWdtZW50cywgcGhpU3RhcnQsIHBoaUxlbmd0aCApIHtcblxuICAgIFx0R2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG4gICAgXHR0aGlzLnR5cGUgPSAnTGF0aGVHZW9tZXRyeSc7XG5cbiAgICBcdHRoaXMucGFyYW1ldGVycyA9IHtcbiAgICBcdFx0cG9pbnRzOiBwb2ludHMsXG4gICAgXHRcdHNlZ21lbnRzOiBzZWdtZW50cyxcbiAgICBcdFx0cGhpU3RhcnQ6IHBoaVN0YXJ0LFxuICAgIFx0XHRwaGlMZW5ndGg6IHBoaUxlbmd0aFxuICAgIFx0fTtcblxuICAgIFx0dGhpcy5mcm9tQnVmZmVyR2VvbWV0cnkoIG5ldyBMYXRoZUJ1ZmZlckdlb21ldHJ5KCBwb2ludHMsIHNlZ21lbnRzLCBwaGlTdGFydCwgcGhpTGVuZ3RoICkgKTtcbiAgICBcdHRoaXMubWVyZ2VWZXJ0aWNlcygpO1xuXG4gICAgfVxuXG4gICAgTGF0aGVHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBHZW9tZXRyeS5wcm90b3R5cGUgKTtcbiAgICBMYXRoZUdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExhdGhlR2VvbWV0cnk7XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIGpvbm9icjEgLyBodHRwOi8vam9ub2JyMS5jb21cbiAgICAgKlxuICAgICAqIENyZWF0ZXMgYSBvbmUtc2lkZWQgcG9seWdvbmFsIGdlb21ldHJ5IGZyb20gYSBwYXRoIHNoYXBlLiBTaW1pbGFyIHRvXG4gICAgICogRXh0cnVkZUdlb21ldHJ5LlxuICAgICAqXG4gICAgICogcGFyYW1ldGVycyA9IHtcbiAgICAgKlxuICAgICAqXHRjdXJ2ZVNlZ21lbnRzOiA8aW50PiwgLy8gbnVtYmVyIG9mIHBvaW50cyBvbiB0aGUgY3VydmVzLiBOT1QgVVNFRCBBVCBUSEUgTU9NRU5ULlxuICAgICAqXG4gICAgICpcdG1hdGVyaWFsOiA8aW50PiAvLyBtYXRlcmlhbCBpbmRleCBmb3IgZnJvbnQgYW5kIGJhY2sgZmFjZXNcbiAgICAgKlx0dXZHZW5lcmF0b3I6IDxPYmplY3Q+IC8vIG9iamVjdCB0aGF0IHByb3ZpZGVzIFVWIGdlbmVyYXRvciBmdW5jdGlvbnNcbiAgICAgKlxuICAgICAqIH1cbiAgICAgKiovXG5cbiAgICBmdW5jdGlvbiBTaGFwZUdlb21ldHJ5KCBzaGFwZXMsIG9wdGlvbnMgKSB7XG5cbiAgICBcdEdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuICAgIFx0dGhpcy50eXBlID0gJ1NoYXBlR2VvbWV0cnknO1xuXG4gICAgXHRpZiAoIEFycmF5LmlzQXJyYXkoIHNoYXBlcyApID09PSBmYWxzZSApIHNoYXBlcyA9IFsgc2hhcGVzIF07XG5cbiAgICBcdHRoaXMuYWRkU2hhcGVMaXN0KCBzaGFwZXMsIG9wdGlvbnMgKTtcblxuICAgIFx0dGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcblxuICAgIH1cblxuICAgIFNoYXBlR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggR2VvbWV0cnkucHJvdG90eXBlICk7XG4gICAgU2hhcGVHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTaGFwZUdlb21ldHJ5O1xuXG4gICAgLyoqXG4gICAgICogQWRkIGFuIGFycmF5IG9mIHNoYXBlcyB0byBUSFJFRS5TaGFwZUdlb21ldHJ5LlxuICAgICAqL1xuICAgIFNoYXBlR2VvbWV0cnkucHJvdG90eXBlLmFkZFNoYXBlTGlzdCA9IGZ1bmN0aW9uICggc2hhcGVzLCBvcHRpb25zICkge1xuXG4gICAgXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBzaGFwZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgIFx0XHR0aGlzLmFkZFNoYXBlKCBzaGFwZXNbIGkgXSwgb3B0aW9ucyApO1xuXG4gICAgXHR9XG5cbiAgICBcdHJldHVybiB0aGlzO1xuXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBzaGFwZSB0byBUSFJFRS5TaGFwZUdlb21ldHJ5LCBiYXNlZCBvbiBUSFJFRS5FeHRydWRlR2VvbWV0cnkuXG4gICAgICovXG4gICAgU2hhcGVHZW9tZXRyeS5wcm90b3R5cGUuYWRkU2hhcGUgPSBmdW5jdGlvbiAoIHNoYXBlLCBvcHRpb25zICkge1xuXG4gICAgXHRpZiAoIG9wdGlvbnMgPT09IHVuZGVmaW5lZCApIG9wdGlvbnMgPSB7fTtcbiAgICBcdHZhciBjdXJ2ZVNlZ21lbnRzID0gb3B0aW9ucy5jdXJ2ZVNlZ21lbnRzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmN1cnZlU2VnbWVudHMgOiAxMjtcblxuICAgIFx0dmFyIG1hdGVyaWFsID0gb3B0aW9ucy5tYXRlcmlhbDtcbiAgICBcdHZhciB1dmdlbiA9IG9wdGlvbnMuVVZHZW5lcmF0b3IgPT09IHVuZGVmaW5lZCA/IEV4dHJ1ZGVHZW9tZXRyeS5Xb3JsZFVWR2VuZXJhdG9yIDogb3B0aW9ucy5VVkdlbmVyYXRvcjtcblxuICAgIFx0Ly9cblxuICAgIFx0dmFyIGksIGwsIGhvbGU7XG5cbiAgICBcdHZhciBzaGFwZXNPZmZzZXQgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDtcbiAgICBcdHZhciBzaGFwZVBvaW50cyA9IHNoYXBlLmV4dHJhY3RQb2ludHMoIGN1cnZlU2VnbWVudHMgKTtcblxuICAgIFx0dmFyIHZlcnRpY2VzID0gc2hhcGVQb2ludHMuc2hhcGU7XG4gICAgXHR2YXIgaG9sZXMgPSBzaGFwZVBvaW50cy5ob2xlcztcblxuICAgIFx0dmFyIHJldmVyc2UgPSAhIGV4cG9ydHMuU2hhcGVVdGlscy5pc0Nsb2NrV2lzZSggdmVydGljZXMgKTtcblxuICAgIFx0aWYgKCByZXZlcnNlICkge1xuXG4gICAgXHRcdHZlcnRpY2VzID0gdmVydGljZXMucmV2ZXJzZSgpO1xuXG4gICAgXHRcdC8vIE1heWJlIHdlIHNob3VsZCBhbHNvIGNoZWNrIGlmIGhvbGVzIGFyZSBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uLCBqdXN0IHRvIGJlIHNhZmUuLi5cblxuICAgIFx0XHRmb3IgKCBpID0gMCwgbCA9IGhvbGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICBcdFx0XHRob2xlID0gaG9sZXNbIGkgXTtcblxuICAgIFx0XHRcdGlmICggZXhwb3J0cy5TaGFwZVV0aWxzLmlzQ2xvY2tXaXNlKCBob2xlICkgKSB7XG5cbiAgICBcdFx0XHRcdGhvbGVzWyBpIF0gPSBob2xlLnJldmVyc2UoKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV2ZXJzZSA9IGZhbHNlO1xuXG4gICAgXHR9XG5cbiAgICBcdHZhciBmYWNlcyA9IGV4cG9ydHMuU2hhcGVVdGlscy50cmlhbmd1bGF0ZVNoYXBlKCB2ZXJ0aWNlcywgaG9sZXMgKTtcblxuICAgIFx0Ly8gVmVydGljZXNcblxuICAgIFx0Zm9yICggaSA9IDAsIGwgPSBob2xlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgXHRcdGhvbGUgPSBob2xlc1sgaSBdO1xuICAgIFx0XHR2ZXJ0aWNlcyA9IHZlcnRpY2VzLmNvbmNhdCggaG9sZSApO1xuXG4gICAgXHR9XG5cbiAgICBcdC8vXG5cbiAgICBcdHZhciB2ZXJ0LCB2bGVuID0gdmVydGljZXMubGVuZ3RoO1xuICAgIFx0dmFyIGZhY2UsIGZsZW4gPSBmYWNlcy5sZW5ndGg7XG5cbiAgICBcdGZvciAoIGkgPSAwOyBpIDwgdmxlbjsgaSArKyApIHtcblxuICAgIFx0XHR2ZXJ0ID0gdmVydGljZXNbIGkgXTtcblxuICAgIFx0XHR0aGlzLnZlcnRpY2VzLnB1c2goIG5ldyBWZWN0b3IzKCB2ZXJ0LngsIHZlcnQueSwgMCApICk7XG5cbiAgICBcdH1cblxuICAgIFx0Zm9yICggaSA9IDA7IGkgPCBmbGVuOyBpICsrICkge1xuXG4gICAgXHRcdGZhY2UgPSBmYWNlc1sgaSBdO1xuXG4gICAgXHRcdHZhciBhID0gZmFjZVsgMCBdICsgc2hhcGVzT2Zmc2V0O1xuICAgIFx0XHR2YXIgYiA9IGZhY2VbIDEgXSArIHNoYXBlc09mZnNldDtcbiAgICBcdFx0dmFyIGMgPSBmYWNlWyAyIF0gKyBzaGFwZXNPZmZzZXQ7XG5cbiAgICBcdFx0dGhpcy5mYWNlcy5wdXNoKCBuZXcgRmFjZTMoIGEsIGIsIGMsIG51bGwsIG51bGwsIG1hdGVyaWFsICkgKTtcbiAgICBcdFx0dGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggdXZnZW4uZ2VuZXJhdGVUb3BVViggdGhpcywgYSwgYiwgYyApICk7XG5cbiAgICBcdH1cblxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIEVkZ2VzR2VvbWV0cnkoIGdlb21ldHJ5LCB0aHJlc2hvbGRBbmdsZSApIHtcblxuICAgIFx0QnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG4gICAgXHR0aHJlc2hvbGRBbmdsZSA9ICggdGhyZXNob2xkQW5nbGUgIT09IHVuZGVmaW5lZCApID8gdGhyZXNob2xkQW5nbGUgOiAxO1xuXG4gICAgXHR2YXIgdGhyZXNob2xkRG90ID0gTWF0aC5jb3MoIGV4cG9ydHMuTWF0aC5ERUcyUkFEICogdGhyZXNob2xkQW5nbGUgKTtcblxuICAgIFx0dmFyIGVkZ2UgPSBbIDAsIDAgXSwgaGFzaCA9IHt9O1xuXG4gICAgXHRmdW5jdGlvbiBzb3J0RnVuY3Rpb24oIGEsIGIgKSB7XG5cbiAgICBcdFx0cmV0dXJuIGEgLSBiO1xuXG4gICAgXHR9XG5cbiAgICBcdHZhciBrZXlzID0gWyAnYScsICdiJywgJ2MnIF07XG5cbiAgICBcdHZhciBnZW9tZXRyeTI7XG5cbiAgICBcdGlmICggKGdlb21ldHJ5ICYmIGdlb21ldHJ5LmlzQnVmZmVyR2VvbWV0cnkpICkge1xuXG4gICAgXHRcdGdlb21ldHJ5MiA9IG5ldyBHZW9tZXRyeSgpO1xuICAgIFx0XHRnZW9tZXRyeTIuZnJvbUJ1ZmZlckdlb21ldHJ5KCBnZW9tZXRyeSApO1xuXG4gICAgXHR9IGVsc2Uge1xuXG4gICAgXHRcdGdlb21ldHJ5MiA9IGdlb21ldHJ5LmNsb25lKCk7XG5cbiAgICBcdH1cblxuICAgIFx0Z2VvbWV0cnkyLm1lcmdlVmVydGljZXMoKTtcbiAgICBcdGdlb21ldHJ5Mi5jb21wdXRlRmFjZU5vcm1hbHMoKTtcblxuICAgIFx0dmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkyLnZlcnRpY2VzO1xuICAgIFx0dmFyIGZhY2VzID0gZ2VvbWV0cnkyLmZhY2VzO1xuXG4gICAgXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBmYWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgXHRcdHZhciBmYWNlID0gZmFjZXNbIGkgXTtcblxuICAgIFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPCAzOyBqICsrICkge1xuXG4gICAgXHRcdFx0ZWRnZVsgMCBdID0gZmFjZVsga2V5c1sgaiBdIF07XG4gICAgXHRcdFx0ZWRnZVsgMSBdID0gZmFjZVsga2V5c1sgKCBqICsgMSApICUgMyBdIF07XG4gICAgXHRcdFx0ZWRnZS5zb3J0KCBzb3J0RnVuY3Rpb24gKTtcblxuICAgIFx0XHRcdHZhciBrZXkgPSBlZGdlLnRvU3RyaW5nKCk7XG5cbiAgICBcdFx0XHRpZiAoIGhhc2hbIGtleSBdID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRcdGhhc2hbIGtleSBdID0geyB2ZXJ0MTogZWRnZVsgMCBdLCB2ZXJ0MjogZWRnZVsgMSBdLCBmYWNlMTogaSwgZmFjZTI6IHVuZGVmaW5lZCB9O1xuXG4gICAgXHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0aGFzaFsga2V5IF0uZmFjZTIgPSBpO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0fVxuXG4gICAgXHR2YXIgY29vcmRzID0gW107XG5cbiAgICBcdGZvciAoIHZhciBrZXkgaW4gaGFzaCApIHtcblxuICAgIFx0XHR2YXIgaCA9IGhhc2hbIGtleSBdO1xuXG4gICAgXHRcdGlmICggaC5mYWNlMiA9PT0gdW5kZWZpbmVkIHx8IGZhY2VzWyBoLmZhY2UxIF0ubm9ybWFsLmRvdCggZmFjZXNbIGguZmFjZTIgXS5ub3JtYWwgKSA8PSB0aHJlc2hvbGREb3QgKSB7XG5cbiAgICBcdFx0XHR2YXIgdmVydGV4ID0gdmVydGljZXNbIGgudmVydDEgXTtcbiAgICBcdFx0XHRjb29yZHMucHVzaCggdmVydGV4LnggKTtcbiAgICBcdFx0XHRjb29yZHMucHVzaCggdmVydGV4LnkgKTtcbiAgICBcdFx0XHRjb29yZHMucHVzaCggdmVydGV4LnogKTtcblxuICAgIFx0XHRcdHZlcnRleCA9IHZlcnRpY2VzWyBoLnZlcnQyIF07XG4gICAgXHRcdFx0Y29vcmRzLnB1c2goIHZlcnRleC54ICk7XG4gICAgXHRcdFx0Y29vcmRzLnB1c2goIHZlcnRleC55ICk7XG4gICAgXHRcdFx0Y29vcmRzLnB1c2goIHZlcnRleC56ICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9XG5cbiAgICBcdHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgQnVmZmVyQXR0cmlidXRlKCBuZXcgRmxvYXQzMkFycmF5KCBjb29yZHMgKSwgMyApICk7XG5cbiAgICB9XG5cbiAgICBFZGdlc0dlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xuICAgIEVkZ2VzR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRWRnZXNHZW9tZXRyeTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgTXVnZW44NyAvIGh0dHBzOi8vZ2l0aHViLmNvbS9NdWdlbjg3XG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBDeWxpbmRlckJ1ZmZlckdlb21ldHJ5KCByYWRpdXNUb3AsIHJhZGl1c0JvdHRvbSwgaGVpZ2h0LCByYWRpYWxTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIG9wZW5FbmRlZCwgdGhldGFTdGFydCwgdGhldGFMZW5ndGggKSB7XG5cbiAgICBcdEJ1ZmZlckdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuICAgIFx0dGhpcy50eXBlID0gJ0N5bGluZGVyQnVmZmVyR2VvbWV0cnknO1xuXG4gICAgXHR0aGlzLnBhcmFtZXRlcnMgPSB7XG4gICAgXHRcdHJhZGl1c1RvcDogcmFkaXVzVG9wLFxuICAgIFx0XHRyYWRpdXNCb3R0b206IHJhZGl1c0JvdHRvbSxcbiAgICBcdFx0aGVpZ2h0OiBoZWlnaHQsXG4gICAgXHRcdHJhZGlhbFNlZ21lbnRzOiByYWRpYWxTZWdtZW50cyxcbiAgICBcdFx0aGVpZ2h0U2VnbWVudHM6IGhlaWdodFNlZ21lbnRzLFxuICAgIFx0XHRvcGVuRW5kZWQ6IG9wZW5FbmRlZCxcbiAgICBcdFx0dGhldGFTdGFydDogdGhldGFTdGFydCxcbiAgICBcdFx0dGhldGFMZW5ndGg6IHRoZXRhTGVuZ3RoXG4gICAgXHR9O1xuXG4gICAgXHR2YXIgc2NvcGUgPSB0aGlzO1xuXG4gICAgXHRyYWRpdXNUb3AgPSByYWRpdXNUb3AgIT09IHVuZGVmaW5lZCA/IHJhZGl1c1RvcCA6IDIwO1xuICAgIFx0cmFkaXVzQm90dG9tID0gcmFkaXVzQm90dG9tICE9PSB1bmRlZmluZWQgPyByYWRpdXNCb3R0b20gOiAyMDtcbiAgICBcdGhlaWdodCA9IGhlaWdodCAhPT0gdW5kZWZpbmVkID8gaGVpZ2h0IDogMTAwO1xuXG4gICAgXHRyYWRpYWxTZWdtZW50cyA9IE1hdGguZmxvb3IoIHJhZGlhbFNlZ21lbnRzICkgfHwgODtcbiAgICBcdGhlaWdodFNlZ21lbnRzID0gTWF0aC5mbG9vciggaGVpZ2h0U2VnbWVudHMgKSB8fCAxO1xuXG4gICAgXHRvcGVuRW5kZWQgPSBvcGVuRW5kZWQgIT09IHVuZGVmaW5lZCA/IG9wZW5FbmRlZCA6IGZhbHNlO1xuICAgIFx0dGhldGFTdGFydCA9IHRoZXRhU3RhcnQgIT09IHVuZGVmaW5lZCA/IHRoZXRhU3RhcnQgOiAwLjA7XG4gICAgXHR0aGV0YUxlbmd0aCA9IHRoZXRhTGVuZ3RoICE9PSB1bmRlZmluZWQgPyB0aGV0YUxlbmd0aCA6IDIuMCAqIE1hdGguUEk7XG5cbiAgICBcdC8vIHVzZWQgdG8gY2FsY3VsYXRlIGJ1ZmZlciBsZW5ndGhcblxuICAgIFx0dmFyIG5iQ2FwID0gMDtcblxuICAgIFx0aWYgKCBvcGVuRW5kZWQgPT09IGZhbHNlICkge1xuXG4gICAgXHRcdGlmICggcmFkaXVzVG9wID4gMCApIG5iQ2FwICsrO1xuICAgIFx0XHRpZiAoIHJhZGl1c0JvdHRvbSA+IDAgKSBuYkNhcCArKztcblxuICAgIFx0fVxuXG4gICAgXHR2YXIgdmVydGV4Q291bnQgPSBjYWxjdWxhdGVWZXJ0ZXhDb3VudCgpO1xuICAgIFx0dmFyIGluZGV4Q291bnQgPSBjYWxjdWxhdGVJbmRleENvdW50KCk7XG5cbiAgICBcdC8vIGJ1ZmZlcnNcblxuICAgIFx0dmFyIGluZGljZXMgPSBuZXcgQnVmZmVyQXR0cmlidXRlKCBuZXcgKCBpbmRleENvdW50ID4gNjU1MzUgPyBVaW50MzJBcnJheSA6IFVpbnQxNkFycmF5ICkoIGluZGV4Q291bnQgKSwgMSApO1xuICAgIFx0dmFyIHZlcnRpY2VzID0gbmV3IEJ1ZmZlckF0dHJpYnV0ZSggbmV3IEZsb2F0MzJBcnJheSggdmVydGV4Q291bnQgKiAzICksIDMgKTtcbiAgICBcdHZhciBub3JtYWxzID0gbmV3IEJ1ZmZlckF0dHJpYnV0ZSggbmV3IEZsb2F0MzJBcnJheSggdmVydGV4Q291bnQgKiAzICksIDMgKTtcbiAgICBcdHZhciB1dnMgPSBuZXcgQnVmZmVyQXR0cmlidXRlKCBuZXcgRmxvYXQzMkFycmF5KCB2ZXJ0ZXhDb3VudCAqIDIgKSwgMiApO1xuXG4gICAgXHQvLyBoZWxwZXIgdmFyaWFibGVzXG5cbiAgICBcdHZhciBpbmRleCA9IDAsXG4gICAgXHQgICAgaW5kZXhPZmZzZXQgPSAwLFxuICAgIFx0ICAgIGluZGV4QXJyYXkgPSBbXSxcbiAgICBcdCAgICBoYWxmSGVpZ2h0ID0gaGVpZ2h0IC8gMjtcblxuICAgIFx0Ly8gZ3JvdXAgdmFyaWFibGVzXG4gICAgXHR2YXIgZ3JvdXBTdGFydCA9IDA7XG5cbiAgICBcdC8vIGdlbmVyYXRlIGdlb21ldHJ5XG5cbiAgICBcdGdlbmVyYXRlVG9yc28oKTtcblxuICAgIFx0aWYgKCBvcGVuRW5kZWQgPT09IGZhbHNlICkge1xuXG4gICAgXHRcdGlmICggcmFkaXVzVG9wID4gMCApIGdlbmVyYXRlQ2FwKCB0cnVlICk7XG4gICAgXHRcdGlmICggcmFkaXVzQm90dG9tID4gMCApIGdlbmVyYXRlQ2FwKCBmYWxzZSApO1xuXG4gICAgXHR9XG5cbiAgICBcdC8vIGJ1aWxkIGdlb21ldHJ5XG5cbiAgICBcdHRoaXMuc2V0SW5kZXgoIGluZGljZXMgKTtcbiAgICBcdHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCB2ZXJ0aWNlcyApO1xuICAgIFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdub3JtYWwnLCBub3JtYWxzICk7XG4gICAgXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3V2JywgdXZzICk7XG5cbiAgICBcdC8vIGhlbHBlciBmdW5jdGlvbnNcblxuICAgIFx0ZnVuY3Rpb24gY2FsY3VsYXRlVmVydGV4Q291bnQoKSB7XG5cbiAgICBcdFx0dmFyIGNvdW50ID0gKCByYWRpYWxTZWdtZW50cyArIDEgKSAqICggaGVpZ2h0U2VnbWVudHMgKyAxICk7XG5cbiAgICBcdFx0aWYgKCBvcGVuRW5kZWQgPT09IGZhbHNlICkge1xuXG4gICAgXHRcdFx0Y291bnQgKz0gKCAoIHJhZGlhbFNlZ21lbnRzICsgMSApICogbmJDYXAgKSArICggcmFkaWFsU2VnbWVudHMgKiBuYkNhcCApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gY291bnQ7XG5cbiAgICBcdH1cblxuICAgIFx0ZnVuY3Rpb24gY2FsY3VsYXRlSW5kZXhDb3VudCgpIHtcblxuICAgIFx0XHR2YXIgY291bnQgPSByYWRpYWxTZWdtZW50cyAqIGhlaWdodFNlZ21lbnRzICogMiAqIDM7XG5cbiAgICBcdFx0aWYgKCBvcGVuRW5kZWQgPT09IGZhbHNlICkge1xuXG4gICAgXHRcdFx0Y291bnQgKz0gcmFkaWFsU2VnbWVudHMgKiBuYkNhcCAqIDM7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiBjb3VudDtcblxuICAgIFx0fVxuXG4gICAgXHRmdW5jdGlvbiBnZW5lcmF0ZVRvcnNvKCkge1xuXG4gICAgXHRcdHZhciB4LCB5O1xuICAgIFx0XHR2YXIgbm9ybWFsID0gbmV3IFZlY3RvcjMoKTtcbiAgICBcdFx0dmFyIHZlcnRleCA9IG5ldyBWZWN0b3IzKCk7XG5cbiAgICBcdFx0dmFyIGdyb3VwQ291bnQgPSAwO1xuXG4gICAgXHRcdC8vIHRoaXMgd2lsbCBiZSB1c2VkIHRvIGNhbGN1bGF0ZSB0aGUgbm9ybWFsXG4gICAgXHRcdHZhciBzbG9wZSA9ICggcmFkaXVzQm90dG9tIC0gcmFkaXVzVG9wICkgLyBoZWlnaHQ7XG5cbiAgICBcdFx0Ly8gZ2VuZXJhdGUgdmVydGljZXMsIG5vcm1hbHMgYW5kIHV2c1xuXG4gICAgXHRcdGZvciAoIHkgPSAwOyB5IDw9IGhlaWdodFNlZ21lbnRzOyB5ICsrICkge1xuXG4gICAgXHRcdFx0dmFyIGluZGV4Um93ID0gW107XG5cbiAgICBcdFx0XHR2YXIgdiA9IHkgLyBoZWlnaHRTZWdtZW50cztcblxuICAgIFx0XHRcdC8vIGNhbGN1bGF0ZSB0aGUgcmFkaXVzIG9mIHRoZSBjdXJyZW50IHJvd1xuICAgIFx0XHRcdHZhciByYWRpdXMgPSB2ICogKCByYWRpdXNCb3R0b20gLSByYWRpdXNUb3AgKSArIHJhZGl1c1RvcDtcblxuICAgIFx0XHRcdGZvciAoIHggPSAwOyB4IDw9IHJhZGlhbFNlZ21lbnRzOyB4ICsrICkge1xuXG4gICAgXHRcdFx0XHR2YXIgdSA9IHggLyByYWRpYWxTZWdtZW50cztcblxuICAgIFx0XHRcdFx0dmFyIHRoZXRhID0gdSAqIHRoZXRhTGVuZ3RoICsgdGhldGFTdGFydDtcblxuICAgIFx0XHRcdFx0dmFyIHNpblRoZXRhID0gTWF0aC5zaW4oIHRoZXRhICk7XG4gICAgXHRcdFx0XHR2YXIgY29zVGhldGEgPSBNYXRoLmNvcyggdGhldGEgKTtcblxuICAgIFx0XHRcdFx0Ly8gdmVydGV4XG4gICAgXHRcdFx0XHR2ZXJ0ZXgueCA9IHJhZGl1cyAqIHNpblRoZXRhO1xuICAgIFx0XHRcdFx0dmVydGV4LnkgPSAtIHYgKiBoZWlnaHQgKyBoYWxmSGVpZ2h0O1xuICAgIFx0XHRcdFx0dmVydGV4LnogPSByYWRpdXMgKiBjb3NUaGV0YTtcbiAgICBcdFx0XHRcdHZlcnRpY2VzLnNldFhZWiggaW5kZXgsIHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnogKTtcblxuICAgIFx0XHRcdFx0Ly8gbm9ybWFsXG4gICAgXHRcdFx0XHRub3JtYWwuc2V0KCBzaW5UaGV0YSwgc2xvcGUsIGNvc1RoZXRhICkubm9ybWFsaXplKCk7XG4gICAgXHRcdFx0XHRub3JtYWxzLnNldFhZWiggaW5kZXgsIG5vcm1hbC54LCBub3JtYWwueSwgbm9ybWFsLnogKTtcblxuICAgIFx0XHRcdFx0Ly8gdXZcbiAgICBcdFx0XHRcdHV2cy5zZXRYWSggaW5kZXgsIHUsIDEgLSB2ICk7XG5cbiAgICBcdFx0XHRcdC8vIHNhdmUgaW5kZXggb2YgdmVydGV4IGluIHJlc3BlY3RpdmUgcm93XG4gICAgXHRcdFx0XHRpbmRleFJvdy5wdXNoKCBpbmRleCApO1xuXG4gICAgXHRcdFx0XHQvLyBpbmNyZWFzZSBpbmRleFxuICAgIFx0XHRcdFx0aW5kZXggKys7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHQvLyBub3cgc2F2ZSB2ZXJ0aWNlcyBvZiB0aGUgcm93IGluIG91ciBpbmRleCBhcnJheVxuICAgIFx0XHRcdGluZGV4QXJyYXkucHVzaCggaW5kZXhSb3cgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0Ly8gZ2VuZXJhdGUgaW5kaWNlc1xuXG4gICAgXHRcdGZvciAoIHggPSAwOyB4IDwgcmFkaWFsU2VnbWVudHM7IHggKysgKSB7XG5cbiAgICBcdFx0XHRmb3IgKCB5ID0gMDsgeSA8IGhlaWdodFNlZ21lbnRzOyB5ICsrICkge1xuXG4gICAgXHRcdFx0XHQvLyB3ZSB1c2UgdGhlIGluZGV4IGFycmF5IHRvIGFjY2VzcyB0aGUgY29ycmVjdCBpbmRpY2VzXG4gICAgXHRcdFx0XHR2YXIgaTEgPSBpbmRleEFycmF5WyB5IF1bIHggXTtcbiAgICBcdFx0XHRcdHZhciBpMiA9IGluZGV4QXJyYXlbIHkgKyAxIF1bIHggXTtcbiAgICBcdFx0XHRcdHZhciBpMyA9IGluZGV4QXJyYXlbIHkgKyAxIF1bIHggKyAxIF07XG4gICAgXHRcdFx0XHR2YXIgaTQgPSBpbmRleEFycmF5WyB5IF1bIHggKyAxIF07XG5cbiAgICBcdFx0XHRcdC8vIGZhY2Ugb25lXG4gICAgXHRcdFx0XHRpbmRpY2VzLnNldFgoIGluZGV4T2Zmc2V0LCBpMSApOyBpbmRleE9mZnNldCArKztcbiAgICBcdFx0XHRcdGluZGljZXMuc2V0WCggaW5kZXhPZmZzZXQsIGkyICk7IGluZGV4T2Zmc2V0ICsrO1xuICAgIFx0XHRcdFx0aW5kaWNlcy5zZXRYKCBpbmRleE9mZnNldCwgaTQgKTsgaW5kZXhPZmZzZXQgKys7XG5cbiAgICBcdFx0XHRcdC8vIGZhY2UgdHdvXG4gICAgXHRcdFx0XHRpbmRpY2VzLnNldFgoIGluZGV4T2Zmc2V0LCBpMiApOyBpbmRleE9mZnNldCArKztcbiAgICBcdFx0XHRcdGluZGljZXMuc2V0WCggaW5kZXhPZmZzZXQsIGkzICk7IGluZGV4T2Zmc2V0ICsrO1xuICAgIFx0XHRcdFx0aW5kaWNlcy5zZXRYKCBpbmRleE9mZnNldCwgaTQgKTsgaW5kZXhPZmZzZXQgKys7XG5cbiAgICBcdFx0XHRcdC8vIHVwZGF0ZSBjb3VudGVyc1xuICAgIFx0XHRcdFx0Z3JvdXBDb3VudCArPSA2O1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHQvLyBhZGQgYSBncm91cCB0byB0aGUgZ2VvbWV0cnkuIHRoaXMgd2lsbCBlbnN1cmUgbXVsdGkgbWF0ZXJpYWwgc3VwcG9ydFxuICAgIFx0XHRzY29wZS5hZGRHcm91cCggZ3JvdXBTdGFydCwgZ3JvdXBDb3VudCwgMCApO1xuXG4gICAgXHRcdC8vIGNhbGN1bGF0ZSBuZXcgc3RhcnQgdmFsdWUgZm9yIGdyb3Vwc1xuICAgIFx0XHRncm91cFN0YXJ0ICs9IGdyb3VwQ291bnQ7XG5cbiAgICBcdH1cblxuICAgIFx0ZnVuY3Rpb24gZ2VuZXJhdGVDYXAoIHRvcCApIHtcblxuICAgIFx0XHR2YXIgeCwgY2VudGVySW5kZXhTdGFydCwgY2VudGVySW5kZXhFbmQ7XG5cbiAgICBcdFx0dmFyIHV2ID0gbmV3IFZlY3RvcjIoKTtcbiAgICBcdFx0dmFyIHZlcnRleCA9IG5ldyBWZWN0b3IzKCk7XG5cbiAgICBcdFx0dmFyIGdyb3VwQ291bnQgPSAwO1xuXG4gICAgXHRcdHZhciByYWRpdXMgPSAoIHRvcCA9PT0gdHJ1ZSApID8gcmFkaXVzVG9wIDogcmFkaXVzQm90dG9tO1xuICAgIFx0XHR2YXIgc2lnbiA9ICggdG9wID09PSB0cnVlICkgPyAxIDogLSAxO1xuXG4gICAgXHRcdC8vIHNhdmUgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBjZW50ZXIgdmVydGV4XG4gICAgXHRcdGNlbnRlckluZGV4U3RhcnQgPSBpbmRleDtcblxuICAgIFx0XHQvLyBmaXJzdCB3ZSBnZW5lcmF0ZSB0aGUgY2VudGVyIHZlcnRleCBkYXRhIG9mIHRoZSBjYXAuXG4gICAgXHRcdC8vIGJlY2F1c2UgdGhlIGdlb21ldHJ5IG5lZWRzIG9uZSBzZXQgb2YgdXZzIHBlciBmYWNlLFxuICAgIFx0XHQvLyB3ZSBtdXN0IGdlbmVyYXRlIGEgY2VudGVyIHZlcnRleCBwZXIgZmFjZS9zZWdtZW50XG5cbiAgICBcdFx0Zm9yICggeCA9IDE7IHggPD0gcmFkaWFsU2VnbWVudHM7IHggKysgKSB7XG5cbiAgICBcdFx0XHQvLyB2ZXJ0ZXhcbiAgICBcdFx0XHR2ZXJ0aWNlcy5zZXRYWVooIGluZGV4LCAwLCBoYWxmSGVpZ2h0ICogc2lnbiwgMCApO1xuXG4gICAgXHRcdFx0Ly8gbm9ybWFsXG4gICAgXHRcdFx0bm9ybWFscy5zZXRYWVooIGluZGV4LCAwLCBzaWduLCAwICk7XG5cbiAgICBcdFx0XHQvLyB1dlxuICAgIFx0XHRcdHV2LnggPSAwLjU7XG4gICAgXHRcdFx0dXYueSA9IDAuNTtcblxuICAgIFx0XHRcdHV2cy5zZXRYWSggaW5kZXgsIHV2LngsIHV2LnkgKTtcblxuICAgIFx0XHRcdC8vIGluY3JlYXNlIGluZGV4XG4gICAgXHRcdFx0aW5kZXggKys7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdC8vIHNhdmUgdGhlIGluZGV4IG9mIHRoZSBsYXN0IGNlbnRlciB2ZXJ0ZXhcbiAgICBcdFx0Y2VudGVySW5kZXhFbmQgPSBpbmRleDtcblxuICAgIFx0XHQvLyBub3cgd2UgZ2VuZXJhdGUgdGhlIHN1cnJvdW5kaW5nIHZlcnRpY2VzLCBub3JtYWxzIGFuZCB1dnNcblxuICAgIFx0XHRmb3IgKCB4ID0gMDsgeCA8PSByYWRpYWxTZWdtZW50czsgeCArKyApIHtcblxuICAgIFx0XHRcdHZhciB1ID0geCAvIHJhZGlhbFNlZ21lbnRzO1xuICAgIFx0XHRcdHZhciB0aGV0YSA9IHUgKiB0aGV0YUxlbmd0aCArIHRoZXRhU3RhcnQ7XG5cbiAgICBcdFx0XHR2YXIgY29zVGhldGEgPSBNYXRoLmNvcyggdGhldGEgKTtcbiAgICBcdFx0XHR2YXIgc2luVGhldGEgPSBNYXRoLnNpbiggdGhldGEgKTtcblxuICAgIFx0XHRcdC8vIHZlcnRleFxuICAgIFx0XHRcdHZlcnRleC54ID0gcmFkaXVzICogc2luVGhldGE7XG4gICAgXHRcdFx0dmVydGV4LnkgPSBoYWxmSGVpZ2h0ICogc2lnbjtcbiAgICBcdFx0XHR2ZXJ0ZXgueiA9IHJhZGl1cyAqIGNvc1RoZXRhO1xuICAgIFx0XHRcdHZlcnRpY2VzLnNldFhZWiggaW5kZXgsIHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnogKTtcblxuICAgIFx0XHRcdC8vIG5vcm1hbFxuICAgIFx0XHRcdG5vcm1hbHMuc2V0WFlaKCBpbmRleCwgMCwgc2lnbiwgMCApO1xuXG4gICAgXHRcdFx0Ly8gdXZcbiAgICBcdFx0XHR1di54ID0gKCBjb3NUaGV0YSAqIDAuNSApICsgMC41O1xuICAgIFx0XHRcdHV2LnkgPSAoIHNpblRoZXRhICogMC41ICogc2lnbiApICsgMC41O1xuICAgIFx0XHRcdHV2cy5zZXRYWSggaW5kZXgsIHV2LngsIHV2LnkgKTtcblxuICAgIFx0XHRcdC8vIGluY3JlYXNlIGluZGV4XG4gICAgXHRcdFx0aW5kZXggKys7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdC8vIGdlbmVyYXRlIGluZGljZXNcblxuICAgIFx0XHRmb3IgKCB4ID0gMDsgeCA8IHJhZGlhbFNlZ21lbnRzOyB4ICsrICkge1xuXG4gICAgXHRcdFx0dmFyIGMgPSBjZW50ZXJJbmRleFN0YXJ0ICsgeDtcbiAgICBcdFx0XHR2YXIgaSA9IGNlbnRlckluZGV4RW5kICsgeDtcblxuICAgIFx0XHRcdGlmICggdG9wID09PSB0cnVlICkge1xuXG4gICAgXHRcdFx0XHQvLyBmYWNlIHRvcFxuICAgIFx0XHRcdFx0aW5kaWNlcy5zZXRYKCBpbmRleE9mZnNldCwgaSApOyBpbmRleE9mZnNldCArKztcbiAgICBcdFx0XHRcdGluZGljZXMuc2V0WCggaW5kZXhPZmZzZXQsIGkgKyAxICk7IGluZGV4T2Zmc2V0ICsrO1xuICAgIFx0XHRcdFx0aW5kaWNlcy5zZXRYKCBpbmRleE9mZnNldCwgYyApOyBpbmRleE9mZnNldCArKztcblxuICAgIFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdC8vIGZhY2UgYm90dG9tXG4gICAgXHRcdFx0XHRpbmRpY2VzLnNldFgoIGluZGV4T2Zmc2V0LCBpICsgMSApOyBpbmRleE9mZnNldCArKztcbiAgICBcdFx0XHRcdGluZGljZXMuc2V0WCggaW5kZXhPZmZzZXQsIGkgKTsgaW5kZXhPZmZzZXQgKys7XG4gICAgXHRcdFx0XHRpbmRpY2VzLnNldFgoIGluZGV4T2Zmc2V0LCBjICk7IGluZGV4T2Zmc2V0ICsrO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0Ly8gdXBkYXRlIGNvdW50ZXJzXG4gICAgXHRcdFx0Z3JvdXBDb3VudCArPSAzO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHQvLyBhZGQgYSBncm91cCB0byB0aGUgZ2VvbWV0cnkuIHRoaXMgd2lsbCBlbnN1cmUgbXVsdGkgbWF0ZXJpYWwgc3VwcG9ydFxuICAgIFx0XHRzY29wZS5hZGRHcm91cCggZ3JvdXBTdGFydCwgZ3JvdXBDb3VudCwgdG9wID09PSB0cnVlID8gMSA6IDIgKTtcblxuICAgIFx0XHQvLyBjYWxjdWxhdGUgbmV3IHN0YXJ0IHZhbHVlIGZvciBncm91cHNcbiAgICBcdFx0Z3JvdXBTdGFydCArPSBncm91cENvdW50O1xuXG4gICAgXHR9XG5cbiAgICB9XG5cbiAgICBDeWxpbmRlckJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xuICAgIEN5bGluZGVyQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ3lsaW5kZXJCdWZmZXJHZW9tZXRyeTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBDeWxpbmRlckdlb21ldHJ5KCByYWRpdXNUb3AsIHJhZGl1c0JvdHRvbSwgaGVpZ2h0LCByYWRpYWxTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIG9wZW5FbmRlZCwgdGhldGFTdGFydCwgdGhldGFMZW5ndGggKSB7XG5cbiAgICBcdEdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuICAgIFx0dGhpcy50eXBlID0gJ0N5bGluZGVyR2VvbWV0cnknO1xuXG4gICAgXHR0aGlzLnBhcmFtZXRlcnMgPSB7XG4gICAgXHRcdHJhZGl1c1RvcDogcmFkaXVzVG9wLFxuICAgIFx0XHRyYWRpdXNCb3R0b206IHJhZGl1c0JvdHRvbSxcbiAgICBcdFx0aGVpZ2h0OiBoZWlnaHQsXG4gICAgXHRcdHJhZGlhbFNlZ21lbnRzOiByYWRpYWxTZWdtZW50cyxcbiAgICBcdFx0aGVpZ2h0U2VnbWVudHM6IGhlaWdodFNlZ21lbnRzLFxuICAgIFx0XHRvcGVuRW5kZWQ6IG9wZW5FbmRlZCxcbiAgICBcdFx0dGhldGFTdGFydDogdGhldGFTdGFydCxcbiAgICBcdFx0dGhldGFMZW5ndGg6IHRoZXRhTGVuZ3RoXG4gICAgXHR9O1xuXG4gICAgXHR0aGlzLmZyb21CdWZmZXJHZW9tZXRyeSggbmV3IEN5bGluZGVyQnVmZmVyR2VvbWV0cnkoIHJhZGl1c1RvcCwgcmFkaXVzQm90dG9tLCBoZWlnaHQsIHJhZGlhbFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgb3BlbkVuZGVkLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCApICk7XG4gICAgXHR0aGlzLm1lcmdlVmVydGljZXMoKTtcblxuICAgIH1cblxuICAgIEN5bGluZGVyR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggR2VvbWV0cnkucHJvdG90eXBlICk7XG4gICAgQ3lsaW5kZXJHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDeWxpbmRlckdlb21ldHJ5O1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBhYmVsbmF0aW9uIC8gaHR0cDovL2dpdGh1Yi5jb20vYWJlbG5hdGlvblxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gQ29uZUdlb21ldHJ5KFxuICAgIFx0cmFkaXVzLCBoZWlnaHQsXG4gICAgXHRyYWRpYWxTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsXG4gICAgXHRvcGVuRW5kZWQsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICkge1xuXG4gICAgXHRDeWxpbmRlckdlb21ldHJ5LmNhbGwoIHRoaXMsXG4gICAgXHRcdDAsIHJhZGl1cywgaGVpZ2h0LFxuICAgIFx0XHRyYWRpYWxTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsXG4gICAgXHRcdG9wZW5FbmRlZCwgdGhldGFTdGFydCwgdGhldGFMZW5ndGggKTtcblxuICAgIFx0dGhpcy50eXBlID0gJ0NvbmVHZW9tZXRyeSc7XG5cbiAgICBcdHRoaXMucGFyYW1ldGVycyA9IHtcbiAgICBcdFx0cmFkaXVzOiByYWRpdXMsXG4gICAgXHRcdGhlaWdodDogaGVpZ2h0LFxuICAgIFx0XHRyYWRpYWxTZWdtZW50czogcmFkaWFsU2VnbWVudHMsXG4gICAgXHRcdGhlaWdodFNlZ21lbnRzOiBoZWlnaHRTZWdtZW50cyxcbiAgICBcdFx0b3BlbkVuZGVkOiBvcGVuRW5kZWQsXG4gICAgXHRcdHRoZXRhU3RhcnQ6IHRoZXRhU3RhcnQsXG4gICAgXHRcdHRoZXRhTGVuZ3RoOiB0aGV0YUxlbmd0aFxuICAgIFx0fTtcblxuICAgIH1cblxuICAgIENvbmVHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBDeWxpbmRlckdlb21ldHJ5LnByb3RvdHlwZSApO1xuICAgIENvbmVHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb25lR2VvbWV0cnk7XG5cbiAgICAvKlxuICAgICAqIEBhdXRob3I6IGFiZWxuYXRpb24gLyBodHRwOi8vZ2l0aHViLmNvbS9hYmVsbmF0aW9uXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBDb25lQnVmZmVyR2VvbWV0cnkoXG4gICAgXHRyYWRpdXMsIGhlaWdodCxcbiAgICBcdHJhZGlhbFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cyxcbiAgICBcdG9wZW5FbmRlZCwgdGhldGFTdGFydCwgdGhldGFMZW5ndGggKSB7XG5cbiAgICBcdEN5bGluZGVyQnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcyxcbiAgICBcdFx0MCwgcmFkaXVzLCBoZWlnaHQsXG4gICAgXHRcdHJhZGlhbFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cyxcbiAgICBcdFx0b3BlbkVuZGVkLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCApO1xuXG4gICAgXHR0aGlzLnR5cGUgPSAnQ29uZUJ1ZmZlckdlb21ldHJ5JztcblxuICAgIFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xuICAgIFx0XHRyYWRpdXM6IHJhZGl1cyxcbiAgICBcdFx0aGVpZ2h0OiBoZWlnaHQsXG4gICAgXHRcdHJhZGlhbFNlZ21lbnRzOiByYWRpYWxTZWdtZW50cyxcbiAgICBcdFx0aGVpZ2h0U2VnbWVudHM6IGhlaWdodFNlZ21lbnRzLFxuICAgIFx0XHR0aGV0YVN0YXJ0OiB0aGV0YVN0YXJ0LFxuICAgIFx0XHR0aGV0YUxlbmd0aDogdGhldGFMZW5ndGhcbiAgICBcdH07XG5cbiAgICB9XG5cbiAgICBDb25lQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XG4gICAgQ29uZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbmVCdWZmZXJHZW9tZXRyeTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgYmVuYWFkYW1zIC8gaHR0cHM6Ly90d2l0dGVyLmNvbS9iZW5fYV9hZGFtc1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gQ2lyY2xlQnVmZmVyR2VvbWV0cnkoIHJhZGl1cywgc2VnbWVudHMsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICkge1xuXG4gICAgXHRCdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cbiAgICBcdHRoaXMudHlwZSA9ICdDaXJjbGVCdWZmZXJHZW9tZXRyeSc7XG5cbiAgICBcdHRoaXMucGFyYW1ldGVycyA9IHtcbiAgICBcdFx0cmFkaXVzOiByYWRpdXMsXG4gICAgXHRcdHNlZ21lbnRzOiBzZWdtZW50cyxcbiAgICBcdFx0dGhldGFTdGFydDogdGhldGFTdGFydCxcbiAgICBcdFx0dGhldGFMZW5ndGg6IHRoZXRhTGVuZ3RoXG4gICAgXHR9O1xuXG4gICAgXHRyYWRpdXMgPSByYWRpdXMgfHwgNTA7XG4gICAgXHRzZWdtZW50cyA9IHNlZ21lbnRzICE9PSB1bmRlZmluZWQgPyBNYXRoLm1heCggMywgc2VnbWVudHMgKSA6IDg7XG5cbiAgICBcdHRoZXRhU3RhcnQgPSB0aGV0YVN0YXJ0ICE9PSB1bmRlZmluZWQgPyB0aGV0YVN0YXJ0IDogMDtcbiAgICBcdHRoZXRhTGVuZ3RoID0gdGhldGFMZW5ndGggIT09IHVuZGVmaW5lZCA/IHRoZXRhTGVuZ3RoIDogTWF0aC5QSSAqIDI7XG5cbiAgICBcdHZhciB2ZXJ0aWNlcyA9IHNlZ21lbnRzICsgMjtcblxuICAgIFx0dmFyIHBvc2l0aW9ucyA9IG5ldyBGbG9hdDMyQXJyYXkoIHZlcnRpY2VzICogMyApO1xuICAgIFx0dmFyIG5vcm1hbHMgPSBuZXcgRmxvYXQzMkFycmF5KCB2ZXJ0aWNlcyAqIDMgKTtcbiAgICBcdHZhciB1dnMgPSBuZXcgRmxvYXQzMkFycmF5KCB2ZXJ0aWNlcyAqIDIgKTtcblxuICAgIFx0Ly8gY2VudGVyIGRhdGEgaXMgYWxyZWFkeSB6ZXJvLCBidXQgbmVlZCB0byBzZXQgYSBmZXcgZXh0cmFzXG4gICAgXHRub3JtYWxzWyAyIF0gPSAxLjA7XG4gICAgXHR1dnNbIDAgXSA9IDAuNTtcbiAgICBcdHV2c1sgMSBdID0gMC41O1xuXG4gICAgXHRmb3IgKCB2YXIgcyA9IDAsIGkgPSAzLCBpaSA9IDIgOyBzIDw9IHNlZ21lbnRzOyBzICsrLCBpICs9IDMsIGlpICs9IDIgKSB7XG5cbiAgICBcdFx0dmFyIHNlZ21lbnQgPSB0aGV0YVN0YXJ0ICsgcyAvIHNlZ21lbnRzICogdGhldGFMZW5ndGg7XG5cbiAgICBcdFx0cG9zaXRpb25zWyBpIF0gPSByYWRpdXMgKiBNYXRoLmNvcyggc2VnbWVudCApO1xuICAgIFx0XHRwb3NpdGlvbnNbIGkgKyAxIF0gPSByYWRpdXMgKiBNYXRoLnNpbiggc2VnbWVudCApO1xuXG4gICAgXHRcdG5vcm1hbHNbIGkgKyAyIF0gPSAxOyAvLyBub3JtYWwgelxuXG4gICAgXHRcdHV2c1sgaWkgXSA9ICggcG9zaXRpb25zWyBpIF0gLyByYWRpdXMgKyAxICkgLyAyO1xuICAgIFx0XHR1dnNbIGlpICsgMSBdID0gKCBwb3NpdGlvbnNbIGkgKyAxIF0gLyByYWRpdXMgKyAxICkgLyAyO1xuXG4gICAgXHR9XG5cbiAgICBcdHZhciBpbmRpY2VzID0gW107XG5cbiAgICBcdGZvciAoIHZhciBpID0gMTsgaSA8PSBzZWdtZW50czsgaSArKyApIHtcblxuICAgIFx0XHRpbmRpY2VzLnB1c2goIGksIGkgKyAxLCAwICk7XG5cbiAgICBcdH1cblxuICAgIFx0dGhpcy5zZXRJbmRleCggbmV3IEJ1ZmZlckF0dHJpYnV0ZSggbmV3IFVpbnQxNkFycmF5KCBpbmRpY2VzICksIDEgKSApO1xuICAgIFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9ucywgMyApICk7XG4gICAgXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbHMsIDMgKSApO1xuICAgIFx0dGhpcy5hZGRBdHRyaWJ1dGUoICd1dicsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIHV2cywgMiApICk7XG5cbiAgICBcdHRoaXMuYm91bmRpbmdTcGhlcmUgPSBuZXcgU3BoZXJlKCBuZXcgVmVjdG9yMygpLCByYWRpdXMgKTtcblxuICAgIH1cblxuICAgIENpcmNsZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xuICAgIENpcmNsZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENpcmNsZUJ1ZmZlckdlb21ldHJ5O1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBodWdoZXNcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIENpcmNsZUdlb21ldHJ5KCByYWRpdXMsIHNlZ21lbnRzLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCApIHtcblxuICAgIFx0R2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG4gICAgXHR0aGlzLnR5cGUgPSAnQ2lyY2xlR2VvbWV0cnknO1xuXG4gICAgXHR0aGlzLnBhcmFtZXRlcnMgPSB7XG4gICAgXHRcdHJhZGl1czogcmFkaXVzLFxuICAgIFx0XHRzZWdtZW50czogc2VnbWVudHMsXG4gICAgXHRcdHRoZXRhU3RhcnQ6IHRoZXRhU3RhcnQsXG4gICAgXHRcdHRoZXRhTGVuZ3RoOiB0aGV0YUxlbmd0aFxuICAgIFx0fTtcblxuICAgIFx0dGhpcy5mcm9tQnVmZmVyR2VvbWV0cnkoIG5ldyBDaXJjbGVCdWZmZXJHZW9tZXRyeSggcmFkaXVzLCBzZWdtZW50cywgdGhldGFTdGFydCwgdGhldGFMZW5ndGggKSApO1xuXG4gICAgfVxuXG4gICAgQ2lyY2xlR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggR2VvbWV0cnkucHJvdG90eXBlICk7XG4gICAgQ2lyY2xlR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ2lyY2xlR2VvbWV0cnk7XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICAgICAqIGJhc2VkIG9uIGh0dHA6Ly9wYXBlcnZpc2lvbjNkLmdvb2dsZWNvZGUuY29tL3N2bi90cnVuay9hczMvdHJ1bmsvc3JjL29yZy9wYXBlcnZpc2lvbjNkL29iamVjdHMvcHJpbWl0aXZlcy9DdWJlLmFzXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBCb3hHZW9tZXRyeSggd2lkdGgsIGhlaWdodCwgZGVwdGgsIHdpZHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCBkZXB0aFNlZ21lbnRzICkge1xuXG4gICAgXHRHZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cbiAgICBcdHRoaXMudHlwZSA9ICdCb3hHZW9tZXRyeSc7XG5cbiAgICBcdHRoaXMucGFyYW1ldGVycyA9IHtcbiAgICBcdFx0d2lkdGg6IHdpZHRoLFxuICAgIFx0XHRoZWlnaHQ6IGhlaWdodCxcbiAgICBcdFx0ZGVwdGg6IGRlcHRoLFxuICAgIFx0XHR3aWR0aFNlZ21lbnRzOiB3aWR0aFNlZ21lbnRzLFxuICAgIFx0XHRoZWlnaHRTZWdtZW50czogaGVpZ2h0U2VnbWVudHMsXG4gICAgXHRcdGRlcHRoU2VnbWVudHM6IGRlcHRoU2VnbWVudHNcbiAgICBcdH07XG5cbiAgICBcdHRoaXMuZnJvbUJ1ZmZlckdlb21ldHJ5KCBuZXcgQm94QnVmZmVyR2VvbWV0cnkoIHdpZHRoLCBoZWlnaHQsIGRlcHRoLCB3aWR0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgZGVwdGhTZWdtZW50cyApICk7XG4gICAgXHR0aGlzLm1lcmdlVmVydGljZXMoKTtcblxuICAgIH1cblxuICAgIEJveEdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEdlb21ldHJ5LnByb3RvdHlwZSApO1xuICAgIEJveEdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEJveEdlb21ldHJ5O1xuXG5cblxuICAgIHZhciBHZW9tZXRyaWVzID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgXHRXaXJlZnJhbWVHZW9tZXRyeTogV2lyZWZyYW1lR2VvbWV0cnksXG4gICAgXHRQYXJhbWV0cmljR2VvbWV0cnk6IFBhcmFtZXRyaWNHZW9tZXRyeSxcbiAgICBcdFRldHJhaGVkcm9uR2VvbWV0cnk6IFRldHJhaGVkcm9uR2VvbWV0cnksXG4gICAgXHRPY3RhaGVkcm9uR2VvbWV0cnk6IE9jdGFoZWRyb25HZW9tZXRyeSxcbiAgICBcdEljb3NhaGVkcm9uR2VvbWV0cnk6IEljb3NhaGVkcm9uR2VvbWV0cnksXG4gICAgXHREb2RlY2FoZWRyb25HZW9tZXRyeTogRG9kZWNhaGVkcm9uR2VvbWV0cnksXG4gICAgXHRQb2x5aGVkcm9uR2VvbWV0cnk6IFBvbHloZWRyb25HZW9tZXRyeSxcbiAgICBcdFR1YmVHZW9tZXRyeTogVHViZUdlb21ldHJ5LFxuICAgIFx0VG9ydXNLbm90R2VvbWV0cnk6IFRvcnVzS25vdEdlb21ldHJ5LFxuICAgIFx0VG9ydXNLbm90QnVmZmVyR2VvbWV0cnk6IFRvcnVzS25vdEJ1ZmZlckdlb21ldHJ5LFxuICAgIFx0VG9ydXNHZW9tZXRyeTogVG9ydXNHZW9tZXRyeSxcbiAgICBcdFRvcnVzQnVmZmVyR2VvbWV0cnk6IFRvcnVzQnVmZmVyR2VvbWV0cnksXG4gICAgXHRUZXh0R2VvbWV0cnk6IFRleHRHZW9tZXRyeSxcbiAgICBcdFNwaGVyZUJ1ZmZlckdlb21ldHJ5OiBTcGhlcmVCdWZmZXJHZW9tZXRyeSxcbiAgICBcdFNwaGVyZUdlb21ldHJ5OiBTcGhlcmVHZW9tZXRyeSxcbiAgICBcdFJpbmdHZW9tZXRyeTogUmluZ0dlb21ldHJ5LFxuICAgIFx0UmluZ0J1ZmZlckdlb21ldHJ5OiBSaW5nQnVmZmVyR2VvbWV0cnksXG4gICAgXHRQbGFuZUJ1ZmZlckdlb21ldHJ5OiBQbGFuZUJ1ZmZlckdlb21ldHJ5LFxuICAgIFx0UGxhbmVHZW9tZXRyeTogUGxhbmVHZW9tZXRyeSxcbiAgICBcdExhdGhlR2VvbWV0cnk6IExhdGhlR2VvbWV0cnksXG4gICAgXHRMYXRoZUJ1ZmZlckdlb21ldHJ5OiBMYXRoZUJ1ZmZlckdlb21ldHJ5LFxuICAgIFx0U2hhcGVHZW9tZXRyeTogU2hhcGVHZW9tZXRyeSxcbiAgICBcdEV4dHJ1ZGVHZW9tZXRyeTogRXh0cnVkZUdlb21ldHJ5LFxuICAgIFx0RWRnZXNHZW9tZXRyeTogRWRnZXNHZW9tZXRyeSxcbiAgICBcdENvbmVHZW9tZXRyeTogQ29uZUdlb21ldHJ5LFxuICAgIFx0Q29uZUJ1ZmZlckdlb21ldHJ5OiBDb25lQnVmZmVyR2VvbWV0cnksXG4gICAgXHRDeWxpbmRlckdlb21ldHJ5OiBDeWxpbmRlckdlb21ldHJ5LFxuICAgIFx0Q3lsaW5kZXJCdWZmZXJHZW9tZXRyeTogQ3lsaW5kZXJCdWZmZXJHZW9tZXRyeSxcbiAgICBcdENpcmNsZUJ1ZmZlckdlb21ldHJ5OiBDaXJjbGVCdWZmZXJHZW9tZXRyeSxcbiAgICBcdENpcmNsZUdlb21ldHJ5OiBDaXJjbGVHZW9tZXRyeSxcbiAgICBcdEJveEJ1ZmZlckdlb21ldHJ5OiBCb3hCdWZmZXJHZW9tZXRyeSxcbiAgICBcdEJveEdlb21ldHJ5OiBCb3hHZW9tZXRyeVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIFNoYWRvd01hdGVyaWFsKCkge1xuXG4gICAgXHRTaGFkZXJNYXRlcmlhbC5jYWxsKCB0aGlzLCB7XG4gICAgXHRcdHVuaWZvcm1zOiBleHBvcnRzLlVuaWZvcm1zVXRpbHMubWVyZ2UoIFtcbiAgICBcdFx0XHRVbmlmb3Jtc0xpYlsgXCJsaWdodHNcIiBdLFxuICAgIFx0XHRcdHtcbiAgICBcdFx0XHRcdG9wYWNpdHk6IHsgdmFsdWU6IDEuMCB9XG4gICAgXHRcdFx0fVxuICAgIFx0XHRdICksXG4gICAgXHRcdHZlcnRleFNoYWRlcjogU2hhZGVyQ2h1bmtbICdzaGFkb3dfdmVydCcgXSxcbiAgICBcdFx0ZnJhZ21lbnRTaGFkZXI6IFNoYWRlckNodW5rWyAnc2hhZG93X2ZyYWcnIF1cbiAgICBcdH0gKTtcblxuICAgIFx0dGhpcy5saWdodHMgPSB0cnVlO1xuICAgIFx0dGhpcy50cmFuc3BhcmVudCA9IHRydWU7XG5cbiAgICBcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCB0aGlzLCB7XG4gICAgXHRcdG9wYWNpdHk6IHtcbiAgICBcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuICAgIFx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuICAgIFx0XHRcdFx0cmV0dXJuIHRoaXMudW5pZm9ybXMub3BhY2l0eS52YWx1ZTtcbiAgICBcdFx0XHR9LFxuICAgIFx0XHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcbiAgICBcdFx0XHRcdHRoaXMudW5pZm9ybXMub3BhY2l0eS52YWx1ZSA9IHZhbHVlO1xuICAgIFx0XHRcdH1cbiAgICBcdFx0fVxuICAgIFx0fSApO1xuXG4gICAgfVxuXG4gICAgU2hhZG93TWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggU2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlICk7XG4gICAgU2hhZG93TWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU2hhZG93TWF0ZXJpYWw7XG5cbiAgICBTaGFkb3dNYXRlcmlhbC5wcm90b3R5cGUuaXNTaGFkb3dNYXRlcmlhbCA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gUmF3U2hhZGVyTWF0ZXJpYWwoIHBhcmFtZXRlcnMgKSB7XG5cbiAgICBcdFNoYWRlck1hdGVyaWFsLmNhbGwoIHRoaXMsIHBhcmFtZXRlcnMgKTtcblxuICAgIFx0dGhpcy50eXBlID0gJ1Jhd1NoYWRlck1hdGVyaWFsJztcblxuICAgIH1cblxuICAgIFJhd1NoYWRlck1hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFNoYWRlck1hdGVyaWFsLnByb3RvdHlwZSApO1xuICAgIFJhd1NoYWRlck1hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJhd1NoYWRlck1hdGVyaWFsO1xuXG4gICAgUmF3U2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlLmlzUmF3U2hhZGVyTWF0ZXJpYWwgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIE11bHRpTWF0ZXJpYWwoIG1hdGVyaWFscyApIHtcblxuICAgIFx0dGhpcy51dWlkID0gZXhwb3J0cy5NYXRoLmdlbmVyYXRlVVVJRCgpO1xuXG4gICAgXHR0aGlzLnR5cGUgPSAnTXVsdGlNYXRlcmlhbCc7XG5cbiAgICBcdHRoaXMubWF0ZXJpYWxzID0gbWF0ZXJpYWxzIGluc3RhbmNlb2YgQXJyYXkgPyBtYXRlcmlhbHMgOiBbXTtcblxuICAgIFx0dGhpcy52aXNpYmxlID0gdHJ1ZTtcblxuICAgIH1cblxuICAgIE11bHRpTWF0ZXJpYWwucHJvdG90eXBlID0ge1xuXG4gICAgXHRjb25zdHJ1Y3RvcjogTXVsdGlNYXRlcmlhbCxcblxuICAgIFx0aXNNdWx0aU1hdGVyaWFsOiB0cnVlLFxuXG4gICAgXHR0b0pTT046IGZ1bmN0aW9uICggbWV0YSApIHtcblxuICAgIFx0XHR2YXIgb3V0cHV0ID0ge1xuICAgIFx0XHRcdG1ldGFkYXRhOiB7XG4gICAgXHRcdFx0XHR2ZXJzaW9uOiA0LjIsXG4gICAgXHRcdFx0XHR0eXBlOiAnbWF0ZXJpYWwnLFxuICAgIFx0XHRcdFx0Z2VuZXJhdG9yOiAnTWF0ZXJpYWxFeHBvcnRlcidcbiAgICBcdFx0XHR9LFxuICAgIFx0XHRcdHV1aWQ6IHRoaXMudXVpZCxcbiAgICBcdFx0XHR0eXBlOiB0aGlzLnR5cGUsXG4gICAgXHRcdFx0bWF0ZXJpYWxzOiBbXVxuICAgIFx0XHR9O1xuXG4gICAgXHRcdHZhciBtYXRlcmlhbHMgPSB0aGlzLm1hdGVyaWFscztcblxuICAgIFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBtYXRlcmlhbHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgIFx0XHRcdHZhciBtYXRlcmlhbCA9IG1hdGVyaWFsc1sgaSBdLnRvSlNPTiggbWV0YSApO1xuICAgIFx0XHRcdGRlbGV0ZSBtYXRlcmlhbC5tZXRhZGF0YTtcblxuICAgIFx0XHRcdG91dHB1dC5tYXRlcmlhbHMucHVzaCggbWF0ZXJpYWwgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0b3V0cHV0LnZpc2libGUgPSB0aGlzLnZpc2libGU7XG5cbiAgICBcdFx0cmV0dXJuIG91dHB1dDtcblxuICAgIFx0fSxcblxuICAgIFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR2YXIgbWF0ZXJpYWwgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpO1xuXG4gICAgXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMubWF0ZXJpYWxzLmxlbmd0aDsgaSArKyApIHtcblxuICAgIFx0XHRcdG1hdGVyaWFsLm1hdGVyaWFscy5wdXNoKCB0aGlzLm1hdGVyaWFsc1sgaSBdLmNsb25lKCkgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0bWF0ZXJpYWwudmlzaWJsZSA9IHRoaXMudmlzaWJsZTtcblxuICAgIFx0XHRyZXR1cm4gbWF0ZXJpYWw7XG5cbiAgICBcdH1cblxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAgICAgKlxuICAgICAqIHBhcmFtZXRlcnMgPSB7XG4gICAgICogIGNvbG9yOiA8aGV4PixcbiAgICAgKiAgcm91Z2huZXNzOiA8ZmxvYXQ+LFxuICAgICAqICBtZXRhbG5lc3M6IDxmbG9hdD4sXG4gICAgICogIG9wYWNpdHk6IDxmbG9hdD4sXG4gICAgICpcbiAgICAgKiAgbWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICAgICAqXG4gICAgICogIGxpZ2h0TWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICAgICAqICBsaWdodE1hcEludGVuc2l0eTogPGZsb2F0PlxuICAgICAqXG4gICAgICogIGFvTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICAgICAqICBhb01hcEludGVuc2l0eTogPGZsb2F0PlxuICAgICAqXG4gICAgICogIGVtaXNzaXZlOiA8aGV4PixcbiAgICAgKiAgZW1pc3NpdmVJbnRlbnNpdHk6IDxmbG9hdD5cbiAgICAgKiAgZW1pc3NpdmVNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gICAgICpcbiAgICAgKiAgYnVtcE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAgICAgKiAgYnVtcFNjYWxlOiA8ZmxvYXQ+LFxuICAgICAqXG4gICAgICogIG5vcm1hbE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAgICAgKiAgbm9ybWFsU2NhbGU6IDxWZWN0b3IyPixcbiAgICAgKlxuICAgICAqICBkaXNwbGFjZW1lbnRNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gICAgICogIGRpc3BsYWNlbWVudFNjYWxlOiA8ZmxvYXQ+LFxuICAgICAqICBkaXNwbGFjZW1lbnRCaWFzOiA8ZmxvYXQ+LFxuICAgICAqXG4gICAgICogIHJvdWdobmVzc01hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAgICAgKlxuICAgICAqICBtZXRhbG5lc3NNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gICAgICpcbiAgICAgKiAgYWxwaGFNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gICAgICpcbiAgICAgKiAgZW52TWFwOiBuZXcgVEhSRUUuQ3ViZVRleHR1cmUoIFtwb3N4LCBuZWd4LCBwb3N5LCBuZWd5LCBwb3N6LCBuZWd6XSApLFxuICAgICAqICBlbnZNYXBJbnRlbnNpdHk6IDxmbG9hdD5cbiAgICAgKlxuICAgICAqICByZWZyYWN0aW9uUmF0aW86IDxmbG9hdD4sXG4gICAgICpcbiAgICAgKiAgd2lyZWZyYW1lOiA8Ym9vbGVhbj4sXG4gICAgICogIHdpcmVmcmFtZUxpbmV3aWR0aDogPGZsb2F0PixcbiAgICAgKlxuICAgICAqICBza2lubmluZzogPGJvb2w+LFxuICAgICAqICBtb3JwaFRhcmdldHM6IDxib29sPixcbiAgICAgKiAgbW9ycGhOb3JtYWxzOiA8Ym9vbD5cbiAgICAgKiB9XG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBNZXNoU3RhbmRhcmRNYXRlcmlhbCggcGFyYW1ldGVycyApIHtcblxuICAgIFx0TWF0ZXJpYWwuY2FsbCggdGhpcyApO1xuXG4gICAgXHR0aGlzLmRlZmluZXMgPSB7ICdTVEFOREFSRCc6ICcnIH07XG5cbiAgICBcdHRoaXMudHlwZSA9ICdNZXNoU3RhbmRhcmRNYXRlcmlhbCc7XG5cbiAgICBcdHRoaXMuY29sb3IgPSBuZXcgQ29sb3IoIDB4ZmZmZmZmICk7IC8vIGRpZmZ1c2VcbiAgICBcdHRoaXMucm91Z2huZXNzID0gMC41O1xuICAgIFx0dGhpcy5tZXRhbG5lc3MgPSAwLjU7XG5cbiAgICBcdHRoaXMubWFwID0gbnVsbDtcblxuICAgIFx0dGhpcy5saWdodE1hcCA9IG51bGw7XG4gICAgXHR0aGlzLmxpZ2h0TWFwSW50ZW5zaXR5ID0gMS4wO1xuXG4gICAgXHR0aGlzLmFvTWFwID0gbnVsbDtcbiAgICBcdHRoaXMuYW9NYXBJbnRlbnNpdHkgPSAxLjA7XG5cbiAgICBcdHRoaXMuZW1pc3NpdmUgPSBuZXcgQ29sb3IoIDB4MDAwMDAwICk7XG4gICAgXHR0aGlzLmVtaXNzaXZlSW50ZW5zaXR5ID0gMS4wO1xuICAgIFx0dGhpcy5lbWlzc2l2ZU1hcCA9IG51bGw7XG5cbiAgICBcdHRoaXMuYnVtcE1hcCA9IG51bGw7XG4gICAgXHR0aGlzLmJ1bXBTY2FsZSA9IDE7XG5cbiAgICBcdHRoaXMubm9ybWFsTWFwID0gbnVsbDtcbiAgICBcdHRoaXMubm9ybWFsU2NhbGUgPSBuZXcgVmVjdG9yMiggMSwgMSApO1xuXG4gICAgXHR0aGlzLmRpc3BsYWNlbWVudE1hcCA9IG51bGw7XG4gICAgXHR0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gMTtcbiAgICBcdHRoaXMuZGlzcGxhY2VtZW50QmlhcyA9IDA7XG5cbiAgICBcdHRoaXMucm91Z2huZXNzTWFwID0gbnVsbDtcblxuICAgIFx0dGhpcy5tZXRhbG5lc3NNYXAgPSBudWxsO1xuXG4gICAgXHR0aGlzLmFscGhhTWFwID0gbnVsbDtcblxuICAgIFx0dGhpcy5lbnZNYXAgPSBudWxsO1xuICAgIFx0dGhpcy5lbnZNYXBJbnRlbnNpdHkgPSAxLjA7XG5cbiAgICBcdHRoaXMucmVmcmFjdGlvblJhdGlvID0gMC45ODtcblxuICAgIFx0dGhpcy53aXJlZnJhbWUgPSBmYWxzZTtcbiAgICBcdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMTtcbiAgICBcdHRoaXMud2lyZWZyYW1lTGluZWNhcCA9ICdyb3VuZCc7XG4gICAgXHR0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gJ3JvdW5kJztcblxuICAgIFx0dGhpcy5za2lubmluZyA9IGZhbHNlO1xuICAgIFx0dGhpcy5tb3JwaFRhcmdldHMgPSBmYWxzZTtcbiAgICBcdHRoaXMubW9ycGhOb3JtYWxzID0gZmFsc2U7XG5cbiAgICBcdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XG5cbiAgICB9XG5cbiAgICBNZXNoU3RhbmRhcmRNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBNYXRlcmlhbC5wcm90b3R5cGUgKTtcbiAgICBNZXNoU3RhbmRhcmRNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNZXNoU3RhbmRhcmRNYXRlcmlhbDtcblxuICAgIE1lc2hTdGFuZGFyZE1hdGVyaWFsLnByb3RvdHlwZS5pc01lc2hTdGFuZGFyZE1hdGVyaWFsID0gdHJ1ZTtcblxuICAgIE1lc2hTdGFuZGFyZE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cbiAgICBcdE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG4gICAgXHR0aGlzLmRlZmluZXMgPSB7ICdTVEFOREFSRCc6ICcnIH07XG5cbiAgICBcdHRoaXMuY29sb3IuY29weSggc291cmNlLmNvbG9yICk7XG4gICAgXHR0aGlzLnJvdWdobmVzcyA9IHNvdXJjZS5yb3VnaG5lc3M7XG4gICAgXHR0aGlzLm1ldGFsbmVzcyA9IHNvdXJjZS5tZXRhbG5lc3M7XG5cbiAgICBcdHRoaXMubWFwID0gc291cmNlLm1hcDtcblxuICAgIFx0dGhpcy5saWdodE1hcCA9IHNvdXJjZS5saWdodE1hcDtcbiAgICBcdHRoaXMubGlnaHRNYXBJbnRlbnNpdHkgPSBzb3VyY2UubGlnaHRNYXBJbnRlbnNpdHk7XG5cbiAgICBcdHRoaXMuYW9NYXAgPSBzb3VyY2UuYW9NYXA7XG4gICAgXHR0aGlzLmFvTWFwSW50ZW5zaXR5ID0gc291cmNlLmFvTWFwSW50ZW5zaXR5O1xuXG4gICAgXHR0aGlzLmVtaXNzaXZlLmNvcHkoIHNvdXJjZS5lbWlzc2l2ZSApO1xuICAgIFx0dGhpcy5lbWlzc2l2ZU1hcCA9IHNvdXJjZS5lbWlzc2l2ZU1hcDtcbiAgICBcdHRoaXMuZW1pc3NpdmVJbnRlbnNpdHkgPSBzb3VyY2UuZW1pc3NpdmVJbnRlbnNpdHk7XG5cbiAgICBcdHRoaXMuYnVtcE1hcCA9IHNvdXJjZS5idW1wTWFwO1xuICAgIFx0dGhpcy5idW1wU2NhbGUgPSBzb3VyY2UuYnVtcFNjYWxlO1xuXG4gICAgXHR0aGlzLm5vcm1hbE1hcCA9IHNvdXJjZS5ub3JtYWxNYXA7XG4gICAgXHR0aGlzLm5vcm1hbFNjYWxlLmNvcHkoIHNvdXJjZS5ub3JtYWxTY2FsZSApO1xuXG4gICAgXHR0aGlzLmRpc3BsYWNlbWVudE1hcCA9IHNvdXJjZS5kaXNwbGFjZW1lbnRNYXA7XG4gICAgXHR0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gc291cmNlLmRpc3BsYWNlbWVudFNjYWxlO1xuICAgIFx0dGhpcy5kaXNwbGFjZW1lbnRCaWFzID0gc291cmNlLmRpc3BsYWNlbWVudEJpYXM7XG5cbiAgICBcdHRoaXMucm91Z2huZXNzTWFwID0gc291cmNlLnJvdWdobmVzc01hcDtcblxuICAgIFx0dGhpcy5tZXRhbG5lc3NNYXAgPSBzb3VyY2UubWV0YWxuZXNzTWFwO1xuXG4gICAgXHR0aGlzLmFscGhhTWFwID0gc291cmNlLmFscGhhTWFwO1xuXG4gICAgXHR0aGlzLmVudk1hcCA9IHNvdXJjZS5lbnZNYXA7XG4gICAgXHR0aGlzLmVudk1hcEludGVuc2l0eSA9IHNvdXJjZS5lbnZNYXBJbnRlbnNpdHk7XG5cbiAgICBcdHRoaXMucmVmcmFjdGlvblJhdGlvID0gc291cmNlLnJlZnJhY3Rpb25SYXRpbztcblxuICAgIFx0dGhpcy53aXJlZnJhbWUgPSBzb3VyY2Uud2lyZWZyYW1lO1xuICAgIFx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSBzb3VyY2Uud2lyZWZyYW1lTGluZXdpZHRoO1xuICAgIFx0dGhpcy53aXJlZnJhbWVMaW5lY2FwID0gc291cmNlLndpcmVmcmFtZUxpbmVjYXA7XG4gICAgXHR0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gc291cmNlLndpcmVmcmFtZUxpbmVqb2luO1xuXG4gICAgXHR0aGlzLnNraW5uaW5nID0gc291cmNlLnNraW5uaW5nO1xuICAgIFx0dGhpcy5tb3JwaFRhcmdldHMgPSBzb3VyY2UubW9ycGhUYXJnZXRzO1xuICAgIFx0dGhpcy5tb3JwaE5vcm1hbHMgPSBzb3VyY2UubW9ycGhOb3JtYWxzO1xuXG4gICAgXHRyZXR1cm4gdGhpcztcblxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAgICAgKlxuICAgICAqIHBhcmFtZXRlcnMgPSB7XG4gICAgICogIHJlZmxlY3Rpdml0eTogPGZsb2F0PlxuICAgICAqIH1cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIE1lc2hQaHlzaWNhbE1hdGVyaWFsKCBwYXJhbWV0ZXJzICkge1xuXG4gICAgXHRNZXNoU3RhbmRhcmRNYXRlcmlhbC5jYWxsKCB0aGlzICk7XG5cbiAgICBcdHRoaXMuZGVmaW5lcyA9IHsgJ1BIWVNJQ0FMJzogJycgfTtcblxuICAgIFx0dGhpcy50eXBlID0gJ01lc2hQaHlzaWNhbE1hdGVyaWFsJztcblxuICAgIFx0dGhpcy5yZWZsZWN0aXZpdHkgPSAwLjU7IC8vIG1hcHMgdG8gRjAgPSAwLjA0XG5cbiAgICBcdHRoaXMuY2xlYXJDb2F0ID0gMC4wO1xuICAgIFx0dGhpcy5jbGVhckNvYXRSb3VnaG5lc3MgPSAwLjA7XG5cbiAgICBcdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XG5cbiAgICB9XG5cbiAgICBNZXNoUGh5c2ljYWxNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBNZXNoU3RhbmRhcmRNYXRlcmlhbC5wcm90b3R5cGUgKTtcbiAgICBNZXNoUGh5c2ljYWxNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNZXNoUGh5c2ljYWxNYXRlcmlhbDtcblxuICAgIE1lc2hQaHlzaWNhbE1hdGVyaWFsLnByb3RvdHlwZS5pc01lc2hQaHlzaWNhbE1hdGVyaWFsID0gdHJ1ZTtcblxuICAgIE1lc2hQaHlzaWNhbE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cbiAgICBcdE1lc2hTdGFuZGFyZE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG4gICAgXHR0aGlzLmRlZmluZXMgPSB7ICdQSFlTSUNBTCc6ICcnIH07XG5cbiAgICBcdHRoaXMucmVmbGVjdGl2aXR5ID0gc291cmNlLnJlZmxlY3Rpdml0eTtcblxuICAgIFx0dGhpcy5jbGVhckNvYXQgPSBzb3VyY2UuY2xlYXJDb2F0O1xuICAgIFx0dGhpcy5jbGVhckNvYXRSb3VnaG5lc3MgPSBzb3VyY2UuY2xlYXJDb2F0Um91Z2huZXNzO1xuXG4gICAgXHRyZXR1cm4gdGhpcztcblxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICAgICAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gICAgICpcbiAgICAgKiBwYXJhbWV0ZXJzID0ge1xuICAgICAqICBjb2xvcjogPGhleD4sXG4gICAgICogIHNwZWN1bGFyOiA8aGV4PixcbiAgICAgKiAgc2hpbmluZXNzOiA8ZmxvYXQ+LFxuICAgICAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxuICAgICAqXG4gICAgICogIG1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAgICAgKlxuICAgICAqICBsaWdodE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAgICAgKiAgbGlnaHRNYXBJbnRlbnNpdHk6IDxmbG9hdD5cbiAgICAgKlxuICAgICAqICBhb01hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAgICAgKiAgYW9NYXBJbnRlbnNpdHk6IDxmbG9hdD5cbiAgICAgKlxuICAgICAqICBlbWlzc2l2ZTogPGhleD4sXG4gICAgICogIGVtaXNzaXZlSW50ZW5zaXR5OiA8ZmxvYXQ+XG4gICAgICogIGVtaXNzaXZlTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICAgICAqXG4gICAgICogIGJ1bXBNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gICAgICogIGJ1bXBTY2FsZTogPGZsb2F0PixcbiAgICAgKlxuICAgICAqICBub3JtYWxNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gICAgICogIG5vcm1hbFNjYWxlOiA8VmVjdG9yMj4sXG4gICAgICpcbiAgICAgKiAgZGlzcGxhY2VtZW50TWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICAgICAqICBkaXNwbGFjZW1lbnRTY2FsZTogPGZsb2F0PixcbiAgICAgKiAgZGlzcGxhY2VtZW50QmlhczogPGZsb2F0PixcbiAgICAgKlxuICAgICAqICBzcGVjdWxhck1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAgICAgKlxuICAgICAqICBhbHBoYU1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAgICAgKlxuICAgICAqICBlbnZNYXA6IG5ldyBUSFJFRS5UZXh0dXJlQ3ViZSggW3Bvc3gsIG5lZ3gsIHBvc3ksIG5lZ3ksIHBvc3osIG5lZ3pdICksXG4gICAgICogIGNvbWJpbmU6IFRIUkVFLk11bHRpcGx5LFxuICAgICAqICByZWZsZWN0aXZpdHk6IDxmbG9hdD4sXG4gICAgICogIHJlZnJhY3Rpb25SYXRpbzogPGZsb2F0PixcbiAgICAgKlxuICAgICAqICB3aXJlZnJhbWU6IDxib29sZWFuPixcbiAgICAgKiAgd2lyZWZyYW1lTGluZXdpZHRoOiA8ZmxvYXQ+LFxuICAgICAqXG4gICAgICogIHNraW5uaW5nOiA8Ym9vbD4sXG4gICAgICogIG1vcnBoVGFyZ2V0czogPGJvb2w+LFxuICAgICAqICBtb3JwaE5vcm1hbHM6IDxib29sPlxuICAgICAqIH1cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIE1lc2hQaG9uZ01hdGVyaWFsKCBwYXJhbWV0ZXJzICkge1xuXG4gICAgXHRNYXRlcmlhbC5jYWxsKCB0aGlzICk7XG5cbiAgICBcdHRoaXMudHlwZSA9ICdNZXNoUGhvbmdNYXRlcmlhbCc7XG5cbiAgICBcdHRoaXMuY29sb3IgPSBuZXcgQ29sb3IoIDB4ZmZmZmZmICk7IC8vIGRpZmZ1c2VcbiAgICBcdHRoaXMuc3BlY3VsYXIgPSBuZXcgQ29sb3IoIDB4MTExMTExICk7XG4gICAgXHR0aGlzLnNoaW5pbmVzcyA9IDMwO1xuXG4gICAgXHR0aGlzLm1hcCA9IG51bGw7XG5cbiAgICBcdHRoaXMubGlnaHRNYXAgPSBudWxsO1xuICAgIFx0dGhpcy5saWdodE1hcEludGVuc2l0eSA9IDEuMDtcblxuICAgIFx0dGhpcy5hb01hcCA9IG51bGw7XG4gICAgXHR0aGlzLmFvTWFwSW50ZW5zaXR5ID0gMS4wO1xuXG4gICAgXHR0aGlzLmVtaXNzaXZlID0gbmV3IENvbG9yKCAweDAwMDAwMCApO1xuICAgIFx0dGhpcy5lbWlzc2l2ZUludGVuc2l0eSA9IDEuMDtcbiAgICBcdHRoaXMuZW1pc3NpdmVNYXAgPSBudWxsO1xuXG4gICAgXHR0aGlzLmJ1bXBNYXAgPSBudWxsO1xuICAgIFx0dGhpcy5idW1wU2NhbGUgPSAxO1xuXG4gICAgXHR0aGlzLm5vcm1hbE1hcCA9IG51bGw7XG4gICAgXHR0aGlzLm5vcm1hbFNjYWxlID0gbmV3IFZlY3RvcjIoIDEsIDEgKTtcblxuICAgIFx0dGhpcy5kaXNwbGFjZW1lbnRNYXAgPSBudWxsO1xuICAgIFx0dGhpcy5kaXNwbGFjZW1lbnRTY2FsZSA9IDE7XG4gICAgXHR0aGlzLmRpc3BsYWNlbWVudEJpYXMgPSAwO1xuXG4gICAgXHR0aGlzLnNwZWN1bGFyTWFwID0gbnVsbDtcblxuICAgIFx0dGhpcy5hbHBoYU1hcCA9IG51bGw7XG5cbiAgICBcdHRoaXMuZW52TWFwID0gbnVsbDtcbiAgICBcdHRoaXMuY29tYmluZSA9IE11bHRpcGx5T3BlcmF0aW9uO1xuICAgIFx0dGhpcy5yZWZsZWN0aXZpdHkgPSAxO1xuICAgIFx0dGhpcy5yZWZyYWN0aW9uUmF0aW8gPSAwLjk4O1xuXG4gICAgXHR0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xuICAgIFx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSAxO1xuICAgIFx0dGhpcy53aXJlZnJhbWVMaW5lY2FwID0gJ3JvdW5kJztcbiAgICBcdHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSAncm91bmQnO1xuXG4gICAgXHR0aGlzLnNraW5uaW5nID0gZmFsc2U7XG4gICAgXHR0aGlzLm1vcnBoVGFyZ2V0cyA9IGZhbHNlO1xuICAgIFx0dGhpcy5tb3JwaE5vcm1hbHMgPSBmYWxzZTtcblxuICAgIFx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcblxuICAgIH1cblxuICAgIE1lc2hQaG9uZ01hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE1hdGVyaWFsLnByb3RvdHlwZSApO1xuICAgIE1lc2hQaG9uZ01hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1lc2hQaG9uZ01hdGVyaWFsO1xuXG4gICAgTWVzaFBob25nTWF0ZXJpYWwucHJvdG90eXBlLmlzTWVzaFBob25nTWF0ZXJpYWwgPSB0cnVlO1xuXG4gICAgTWVzaFBob25nTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuICAgIFx0TWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XG5cbiAgICBcdHRoaXMuY29sb3IuY29weSggc291cmNlLmNvbG9yICk7XG4gICAgXHR0aGlzLnNwZWN1bGFyLmNvcHkoIHNvdXJjZS5zcGVjdWxhciApO1xuICAgIFx0dGhpcy5zaGluaW5lc3MgPSBzb3VyY2Uuc2hpbmluZXNzO1xuXG4gICAgXHR0aGlzLm1hcCA9IHNvdXJjZS5tYXA7XG5cbiAgICBcdHRoaXMubGlnaHRNYXAgPSBzb3VyY2UubGlnaHRNYXA7XG4gICAgXHR0aGlzLmxpZ2h0TWFwSW50ZW5zaXR5ID0gc291cmNlLmxpZ2h0TWFwSW50ZW5zaXR5O1xuXG4gICAgXHR0aGlzLmFvTWFwID0gc291cmNlLmFvTWFwO1xuICAgIFx0dGhpcy5hb01hcEludGVuc2l0eSA9IHNvdXJjZS5hb01hcEludGVuc2l0eTtcblxuICAgIFx0dGhpcy5lbWlzc2l2ZS5jb3B5KCBzb3VyY2UuZW1pc3NpdmUgKTtcbiAgICBcdHRoaXMuZW1pc3NpdmVNYXAgPSBzb3VyY2UuZW1pc3NpdmVNYXA7XG4gICAgXHR0aGlzLmVtaXNzaXZlSW50ZW5zaXR5ID0gc291cmNlLmVtaXNzaXZlSW50ZW5zaXR5O1xuXG4gICAgXHR0aGlzLmJ1bXBNYXAgPSBzb3VyY2UuYnVtcE1hcDtcbiAgICBcdHRoaXMuYnVtcFNjYWxlID0gc291cmNlLmJ1bXBTY2FsZTtcblxuICAgIFx0dGhpcy5ub3JtYWxNYXAgPSBzb3VyY2Uubm9ybWFsTWFwO1xuICAgIFx0dGhpcy5ub3JtYWxTY2FsZS5jb3B5KCBzb3VyY2Uubm9ybWFsU2NhbGUgKTtcblxuICAgIFx0dGhpcy5kaXNwbGFjZW1lbnRNYXAgPSBzb3VyY2UuZGlzcGxhY2VtZW50TWFwO1xuICAgIFx0dGhpcy5kaXNwbGFjZW1lbnRTY2FsZSA9IHNvdXJjZS5kaXNwbGFjZW1lbnRTY2FsZTtcbiAgICBcdHRoaXMuZGlzcGxhY2VtZW50QmlhcyA9IHNvdXJjZS5kaXNwbGFjZW1lbnRCaWFzO1xuXG4gICAgXHR0aGlzLnNwZWN1bGFyTWFwID0gc291cmNlLnNwZWN1bGFyTWFwO1xuXG4gICAgXHR0aGlzLmFscGhhTWFwID0gc291cmNlLmFscGhhTWFwO1xuXG4gICAgXHR0aGlzLmVudk1hcCA9IHNvdXJjZS5lbnZNYXA7XG4gICAgXHR0aGlzLmNvbWJpbmUgPSBzb3VyY2UuY29tYmluZTtcbiAgICBcdHRoaXMucmVmbGVjdGl2aXR5ID0gc291cmNlLnJlZmxlY3Rpdml0eTtcbiAgICBcdHRoaXMucmVmcmFjdGlvblJhdGlvID0gc291cmNlLnJlZnJhY3Rpb25SYXRpbztcblxuICAgIFx0dGhpcy53aXJlZnJhbWUgPSBzb3VyY2Uud2lyZWZyYW1lO1xuICAgIFx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSBzb3VyY2Uud2lyZWZyYW1lTGluZXdpZHRoO1xuICAgIFx0dGhpcy53aXJlZnJhbWVMaW5lY2FwID0gc291cmNlLndpcmVmcmFtZUxpbmVjYXA7XG4gICAgXHR0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gc291cmNlLndpcmVmcmFtZUxpbmVqb2luO1xuXG4gICAgXHR0aGlzLnNraW5uaW5nID0gc291cmNlLnNraW5uaW5nO1xuICAgIFx0dGhpcy5tb3JwaFRhcmdldHMgPSBzb3VyY2UubW9ycGhUYXJnZXRzO1xuICAgIFx0dGhpcy5tb3JwaE5vcm1hbHMgPSBzb3VyY2UubW9ycGhOb3JtYWxzO1xuXG4gICAgXHRyZXR1cm4gdGhpcztcblxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICAgICAqXG4gICAgICogcGFyYW1ldGVycyA9IHtcbiAgICAgKiAgb3BhY2l0eTogPGZsb2F0PixcbiAgICAgKlxuICAgICAqICB3aXJlZnJhbWU6IDxib29sZWFuPixcbiAgICAgKiAgd2lyZWZyYW1lTGluZXdpZHRoOiA8ZmxvYXQ+XG4gICAgICogfVxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gTWVzaE5vcm1hbE1hdGVyaWFsKCBwYXJhbWV0ZXJzICkge1xuXG4gICAgXHRNYXRlcmlhbC5jYWxsKCB0aGlzLCBwYXJhbWV0ZXJzICk7XG5cbiAgICBcdHRoaXMudHlwZSA9ICdNZXNoTm9ybWFsTWF0ZXJpYWwnO1xuXG4gICAgXHR0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xuICAgIFx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSAxO1xuXG4gICAgXHR0aGlzLmZvZyA9IGZhbHNlO1xuICAgIFx0dGhpcy5saWdodHMgPSBmYWxzZTtcbiAgICBcdHRoaXMubW9ycGhUYXJnZXRzID0gZmFsc2U7XG5cbiAgICBcdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XG5cbiAgICB9XG5cbiAgICBNZXNoTm9ybWFsTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTWF0ZXJpYWwucHJvdG90eXBlICk7XG4gICAgTWVzaE5vcm1hbE1hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1lc2hOb3JtYWxNYXRlcmlhbDtcblxuICAgIE1lc2hOb3JtYWxNYXRlcmlhbC5wcm90b3R5cGUuaXNNZXNoTm9ybWFsTWF0ZXJpYWwgPSB0cnVlO1xuXG4gICAgTWVzaE5vcm1hbE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cbiAgICBcdE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG4gICAgXHR0aGlzLndpcmVmcmFtZSA9IHNvdXJjZS53aXJlZnJhbWU7XG4gICAgXHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IHNvdXJjZS53aXJlZnJhbWVMaW5ld2lkdGg7XG5cbiAgICBcdHJldHVybiB0aGlzO1xuXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gICAgICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAgICAgKlxuICAgICAqIHBhcmFtZXRlcnMgPSB7XG4gICAgICogIGNvbG9yOiA8aGV4PixcbiAgICAgKiAgb3BhY2l0eTogPGZsb2F0PixcbiAgICAgKlxuICAgICAqICBtYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gICAgICpcbiAgICAgKiAgbGlnaHRNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gICAgICogIGxpZ2h0TWFwSW50ZW5zaXR5OiA8ZmxvYXQ+XG4gICAgICpcbiAgICAgKiAgYW9NYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gICAgICogIGFvTWFwSW50ZW5zaXR5OiA8ZmxvYXQ+XG4gICAgICpcbiAgICAgKiAgZW1pc3NpdmU6IDxoZXg+LFxuICAgICAqICBlbWlzc2l2ZUludGVuc2l0eTogPGZsb2F0PlxuICAgICAqICBlbWlzc2l2ZU1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAgICAgKlxuICAgICAqICBzcGVjdWxhck1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAgICAgKlxuICAgICAqICBhbHBoYU1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAgICAgKlxuICAgICAqICBlbnZNYXA6IG5ldyBUSFJFRS5UZXh0dXJlQ3ViZSggW3Bvc3gsIG5lZ3gsIHBvc3ksIG5lZ3ksIHBvc3osIG5lZ3pdICksXG4gICAgICogIGNvbWJpbmU6IFRIUkVFLk11bHRpcGx5LFxuICAgICAqICByZWZsZWN0aXZpdHk6IDxmbG9hdD4sXG4gICAgICogIHJlZnJhY3Rpb25SYXRpbzogPGZsb2F0PixcbiAgICAgKlxuICAgICAqICB3aXJlZnJhbWU6IDxib29sZWFuPixcbiAgICAgKiAgd2lyZWZyYW1lTGluZXdpZHRoOiA8ZmxvYXQ+LFxuICAgICAqXG4gICAgICogIHNraW5uaW5nOiA8Ym9vbD4sXG4gICAgICogIG1vcnBoVGFyZ2V0czogPGJvb2w+LFxuICAgICAqICBtb3JwaE5vcm1hbHM6IDxib29sPlxuICAgICAqIH1cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIE1lc2hMYW1iZXJ0TWF0ZXJpYWwoIHBhcmFtZXRlcnMgKSB7XG5cbiAgICBcdE1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcblxuICAgIFx0dGhpcy50eXBlID0gJ01lc2hMYW1iZXJ0TWF0ZXJpYWwnO1xuXG4gICAgXHR0aGlzLmNvbG9yID0gbmV3IENvbG9yKCAweGZmZmZmZiApOyAvLyBkaWZmdXNlXG5cbiAgICBcdHRoaXMubWFwID0gbnVsbDtcblxuICAgIFx0dGhpcy5saWdodE1hcCA9IG51bGw7XG4gICAgXHR0aGlzLmxpZ2h0TWFwSW50ZW5zaXR5ID0gMS4wO1xuXG4gICAgXHR0aGlzLmFvTWFwID0gbnVsbDtcbiAgICBcdHRoaXMuYW9NYXBJbnRlbnNpdHkgPSAxLjA7XG5cbiAgICBcdHRoaXMuZW1pc3NpdmUgPSBuZXcgQ29sb3IoIDB4MDAwMDAwICk7XG4gICAgXHR0aGlzLmVtaXNzaXZlSW50ZW5zaXR5ID0gMS4wO1xuICAgIFx0dGhpcy5lbWlzc2l2ZU1hcCA9IG51bGw7XG5cbiAgICBcdHRoaXMuc3BlY3VsYXJNYXAgPSBudWxsO1xuXG4gICAgXHR0aGlzLmFscGhhTWFwID0gbnVsbDtcblxuICAgIFx0dGhpcy5lbnZNYXAgPSBudWxsO1xuICAgIFx0dGhpcy5jb21iaW5lID0gTXVsdGlwbHlPcGVyYXRpb247XG4gICAgXHR0aGlzLnJlZmxlY3Rpdml0eSA9IDE7XG4gICAgXHR0aGlzLnJlZnJhY3Rpb25SYXRpbyA9IDAuOTg7XG5cbiAgICBcdHRoaXMud2lyZWZyYW1lID0gZmFsc2U7XG4gICAgXHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XG4gICAgXHR0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSAncm91bmQnO1xuICAgIFx0dGhpcy53aXJlZnJhbWVMaW5lam9pbiA9ICdyb3VuZCc7XG5cbiAgICBcdHRoaXMuc2tpbm5pbmcgPSBmYWxzZTtcbiAgICBcdHRoaXMubW9ycGhUYXJnZXRzID0gZmFsc2U7XG4gICAgXHR0aGlzLm1vcnBoTm9ybWFscyA9IGZhbHNlO1xuXG4gICAgXHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xuXG4gICAgfVxuXG4gICAgTWVzaExhbWJlcnRNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBNYXRlcmlhbC5wcm90b3R5cGUgKTtcbiAgICBNZXNoTGFtYmVydE1hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1lc2hMYW1iZXJ0TWF0ZXJpYWw7XG5cbiAgICBNZXNoTGFtYmVydE1hdGVyaWFsLnByb3RvdHlwZS5pc01lc2hMYW1iZXJ0TWF0ZXJpYWwgPSB0cnVlO1xuXG4gICAgTWVzaExhbWJlcnRNYXRlcmlhbC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xuXG4gICAgXHRNYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuICAgIFx0dGhpcy5jb2xvci5jb3B5KCBzb3VyY2UuY29sb3IgKTtcblxuICAgIFx0dGhpcy5tYXAgPSBzb3VyY2UubWFwO1xuXG4gICAgXHR0aGlzLmxpZ2h0TWFwID0gc291cmNlLmxpZ2h0TWFwO1xuICAgIFx0dGhpcy5saWdodE1hcEludGVuc2l0eSA9IHNvdXJjZS5saWdodE1hcEludGVuc2l0eTtcblxuICAgIFx0dGhpcy5hb01hcCA9IHNvdXJjZS5hb01hcDtcbiAgICBcdHRoaXMuYW9NYXBJbnRlbnNpdHkgPSBzb3VyY2UuYW9NYXBJbnRlbnNpdHk7XG5cbiAgICBcdHRoaXMuZW1pc3NpdmUuY29weSggc291cmNlLmVtaXNzaXZlICk7XG4gICAgXHR0aGlzLmVtaXNzaXZlTWFwID0gc291cmNlLmVtaXNzaXZlTWFwO1xuICAgIFx0dGhpcy5lbWlzc2l2ZUludGVuc2l0eSA9IHNvdXJjZS5lbWlzc2l2ZUludGVuc2l0eTtcblxuICAgIFx0dGhpcy5zcGVjdWxhck1hcCA9IHNvdXJjZS5zcGVjdWxhck1hcDtcblxuICAgIFx0dGhpcy5hbHBoYU1hcCA9IHNvdXJjZS5hbHBoYU1hcDtcblxuICAgIFx0dGhpcy5lbnZNYXAgPSBzb3VyY2UuZW52TWFwO1xuICAgIFx0dGhpcy5jb21iaW5lID0gc291cmNlLmNvbWJpbmU7XG4gICAgXHR0aGlzLnJlZmxlY3Rpdml0eSA9IHNvdXJjZS5yZWZsZWN0aXZpdHk7XG4gICAgXHR0aGlzLnJlZnJhY3Rpb25SYXRpbyA9IHNvdXJjZS5yZWZyYWN0aW9uUmF0aW87XG5cbiAgICBcdHRoaXMud2lyZWZyYW1lID0gc291cmNlLndpcmVmcmFtZTtcbiAgICBcdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gc291cmNlLndpcmVmcmFtZUxpbmV3aWR0aDtcbiAgICBcdHRoaXMud2lyZWZyYW1lTGluZWNhcCA9IHNvdXJjZS53aXJlZnJhbWVMaW5lY2FwO1xuICAgIFx0dGhpcy53aXJlZnJhbWVMaW5lam9pbiA9IHNvdXJjZS53aXJlZnJhbWVMaW5lam9pbjtcblxuICAgIFx0dGhpcy5za2lubmluZyA9IHNvdXJjZS5za2lubmluZztcbiAgICBcdHRoaXMubW9ycGhUYXJnZXRzID0gc291cmNlLm1vcnBoVGFyZ2V0cztcbiAgICBcdHRoaXMubW9ycGhOb3JtYWxzID0gc291cmNlLm1vcnBoTm9ybWFscztcblxuICAgIFx0cmV0dXJuIHRoaXM7XG5cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAgICAgKlxuICAgICAqIHBhcmFtZXRlcnMgPSB7XG4gICAgICogIGNvbG9yOiA8aGV4PixcbiAgICAgKiAgb3BhY2l0eTogPGZsb2F0PixcbiAgICAgKlxuICAgICAqICBsaW5ld2lkdGg6IDxmbG9hdD4sXG4gICAgICpcbiAgICAgKiAgc2NhbGU6IDxmbG9hdD4sXG4gICAgICogIGRhc2hTaXplOiA8ZmxvYXQ+LFxuICAgICAqICBnYXBTaXplOiA8ZmxvYXQ+XG4gICAgICogfVxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gTGluZURhc2hlZE1hdGVyaWFsKCBwYXJhbWV0ZXJzICkge1xuXG4gICAgXHRNYXRlcmlhbC5jYWxsKCB0aGlzICk7XG5cbiAgICBcdHRoaXMudHlwZSA9ICdMaW5lRGFzaGVkTWF0ZXJpYWwnO1xuXG4gICAgXHR0aGlzLmNvbG9yID0gbmV3IENvbG9yKCAweGZmZmZmZiApO1xuXG4gICAgXHR0aGlzLmxpbmV3aWR0aCA9IDE7XG5cbiAgICBcdHRoaXMuc2NhbGUgPSAxO1xuICAgIFx0dGhpcy5kYXNoU2l6ZSA9IDM7XG4gICAgXHR0aGlzLmdhcFNpemUgPSAxO1xuXG4gICAgXHR0aGlzLmxpZ2h0cyA9IGZhbHNlO1xuXG4gICAgXHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xuXG4gICAgfVxuXG4gICAgTGluZURhc2hlZE1hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE1hdGVyaWFsLnByb3RvdHlwZSApO1xuICAgIExpbmVEYXNoZWRNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMaW5lRGFzaGVkTWF0ZXJpYWw7XG5cbiAgICBMaW5lRGFzaGVkTWF0ZXJpYWwucHJvdG90eXBlLmlzTGluZURhc2hlZE1hdGVyaWFsID0gdHJ1ZTtcblxuICAgIExpbmVEYXNoZWRNYXRlcmlhbC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xuXG4gICAgXHRNYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuICAgIFx0dGhpcy5jb2xvci5jb3B5KCBzb3VyY2UuY29sb3IgKTtcblxuICAgIFx0dGhpcy5saW5ld2lkdGggPSBzb3VyY2UubGluZXdpZHRoO1xuXG4gICAgXHR0aGlzLnNjYWxlID0gc291cmNlLnNjYWxlO1xuICAgIFx0dGhpcy5kYXNoU2l6ZSA9IHNvdXJjZS5kYXNoU2l6ZTtcbiAgICBcdHRoaXMuZ2FwU2l6ZSA9IHNvdXJjZS5nYXBTaXplO1xuXG4gICAgXHRyZXR1cm4gdGhpcztcblxuICAgIH07XG5cblxuXG4gICAgdmFyIE1hdGVyaWFscyA9IE9iamVjdC5mcmVlemUoe1xuICAgIFx0U2hhZG93TWF0ZXJpYWw6IFNoYWRvd01hdGVyaWFsLFxuICAgIFx0U3ByaXRlTWF0ZXJpYWw6IFNwcml0ZU1hdGVyaWFsLFxuICAgIFx0UmF3U2hhZGVyTWF0ZXJpYWw6IFJhd1NoYWRlck1hdGVyaWFsLFxuICAgIFx0U2hhZGVyTWF0ZXJpYWw6IFNoYWRlck1hdGVyaWFsLFxuICAgIFx0UG9pbnRzTWF0ZXJpYWw6IFBvaW50c01hdGVyaWFsLFxuICAgIFx0TXVsdGlNYXRlcmlhbDogTXVsdGlNYXRlcmlhbCxcbiAgICBcdE1lc2hQaHlzaWNhbE1hdGVyaWFsOiBNZXNoUGh5c2ljYWxNYXRlcmlhbCxcbiAgICBcdE1lc2hTdGFuZGFyZE1hdGVyaWFsOiBNZXNoU3RhbmRhcmRNYXRlcmlhbCxcbiAgICBcdE1lc2hQaG9uZ01hdGVyaWFsOiBNZXNoUGhvbmdNYXRlcmlhbCxcbiAgICBcdE1lc2hOb3JtYWxNYXRlcmlhbDogTWVzaE5vcm1hbE1hdGVyaWFsLFxuICAgIFx0TWVzaExhbWJlcnRNYXRlcmlhbDogTWVzaExhbWJlcnRNYXRlcmlhbCxcbiAgICBcdE1lc2hEZXB0aE1hdGVyaWFsOiBNZXNoRGVwdGhNYXRlcmlhbCxcbiAgICBcdE1lc2hCYXNpY01hdGVyaWFsOiBNZXNoQmFzaWNNYXRlcmlhbCxcbiAgICBcdExpbmVEYXNoZWRNYXRlcmlhbDogTGluZURhc2hlZE1hdGVyaWFsLFxuICAgIFx0TGluZUJhc2ljTWF0ZXJpYWw6IExpbmVCYXNpY01hdGVyaWFsLFxuICAgIFx0TWF0ZXJpYWw6IE1hdGVyaWFsXG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICAgICAqL1xuXG4gICAgZXhwb3J0cy5DYWNoZSA9IHtcblxuICAgIFx0ZW5hYmxlZDogZmFsc2UsXG5cbiAgICBcdGZpbGVzOiB7fSxcblxuICAgIFx0YWRkOiBmdW5jdGlvbiAoIGtleSwgZmlsZSApIHtcblxuICAgIFx0XHRpZiAoIHRoaXMuZW5hYmxlZCA9PT0gZmFsc2UgKSByZXR1cm47XG5cbiAgICBcdFx0Ly8gY29uc29sZS5sb2coICdUSFJFRS5DYWNoZScsICdBZGRpbmcga2V5OicsIGtleSApO1xuXG4gICAgXHRcdHRoaXMuZmlsZXNbIGtleSBdID0gZmlsZTtcblxuICAgIFx0fSxcblxuICAgIFx0Z2V0OiBmdW5jdGlvbiAoIGtleSApIHtcblxuICAgIFx0XHRpZiAoIHRoaXMuZW5hYmxlZCA9PT0gZmFsc2UgKSByZXR1cm47XG5cbiAgICBcdFx0Ly8gY29uc29sZS5sb2coICdUSFJFRS5DYWNoZScsICdDaGVja2luZyBrZXk6Jywga2V5ICk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMuZmlsZXNbIGtleSBdO1xuXG4gICAgXHR9LFxuXG4gICAgXHRyZW1vdmU6IGZ1bmN0aW9uICgga2V5ICkge1xuXG4gICAgXHRcdGRlbGV0ZSB0aGlzLmZpbGVzWyBrZXkgXTtcblxuICAgIFx0fSxcblxuICAgIFx0Y2xlYXI6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR0aGlzLmZpbGVzID0ge307XG5cbiAgICBcdH1cblxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gTG9hZGluZ01hbmFnZXIoIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcblxuICAgIFx0dmFyIHNjb3BlID0gdGhpcztcblxuICAgIFx0dmFyIGlzTG9hZGluZyA9IGZhbHNlLCBpdGVtc0xvYWRlZCA9IDAsIGl0ZW1zVG90YWwgPSAwO1xuXG4gICAgXHR0aGlzLm9uU3RhcnQgPSB1bmRlZmluZWQ7XG4gICAgXHR0aGlzLm9uTG9hZCA9IG9uTG9hZDtcbiAgICBcdHRoaXMub25Qcm9ncmVzcyA9IG9uUHJvZ3Jlc3M7XG4gICAgXHR0aGlzLm9uRXJyb3IgPSBvbkVycm9yO1xuXG4gICAgXHR0aGlzLml0ZW1TdGFydCA9IGZ1bmN0aW9uICggdXJsICkge1xuXG4gICAgXHRcdGl0ZW1zVG90YWwgKys7XG5cbiAgICBcdFx0aWYgKCBpc0xvYWRpbmcgPT09IGZhbHNlICkge1xuXG4gICAgXHRcdFx0aWYgKCBzY29wZS5vblN0YXJ0ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRcdHNjb3BlLm9uU3RhcnQoIHVybCwgaXRlbXNMb2FkZWQsIGl0ZW1zVG90YWwgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdFx0aXNMb2FkaW5nID0gdHJ1ZTtcblxuICAgIFx0fTtcblxuICAgIFx0dGhpcy5pdGVtRW5kID0gZnVuY3Rpb24gKCB1cmwgKSB7XG5cbiAgICBcdFx0aXRlbXNMb2FkZWQgKys7XG5cbiAgICBcdFx0aWYgKCBzY29wZS5vblByb2dyZXNzICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRzY29wZS5vblByb2dyZXNzKCB1cmwsIGl0ZW1zTG9hZGVkLCBpdGVtc1RvdGFsICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGlmICggaXRlbXNMb2FkZWQgPT09IGl0ZW1zVG90YWwgKSB7XG5cbiAgICBcdFx0XHRpc0xvYWRpbmcgPSBmYWxzZTtcblxuICAgIFx0XHRcdGlmICggc2NvcGUub25Mb2FkICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRcdHNjb3BlLm9uTG9hZCgpO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0fTtcblxuICAgIFx0dGhpcy5pdGVtRXJyb3IgPSBmdW5jdGlvbiAoIHVybCApIHtcblxuICAgIFx0XHRpZiAoIHNjb3BlLm9uRXJyb3IgIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdHNjb3BlLm9uRXJyb3IoIHVybCApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0fTtcblxuICAgIH1cblxuICAgIGV4cG9ydHMuRGVmYXVsdExvYWRpbmdNYW5hZ2VyID0gbmV3IExvYWRpbmdNYW5hZ2VyKCk7XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gWEhSTG9hZGVyKCBtYW5hZ2VyICkge1xuXG4gICAgXHR0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IGV4cG9ydHMuRGVmYXVsdExvYWRpbmdNYW5hZ2VyO1xuXG4gICAgfVxuXG4gICAgT2JqZWN0LmFzc2lnbiggWEhSTG9hZGVyLnByb3RvdHlwZSwge1xuXG4gICAgXHRsb2FkOiBmdW5jdGlvbiAoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG4gICAgXHRcdGlmICggdGhpcy5wYXRoICE9PSB1bmRlZmluZWQgKSB1cmwgPSB0aGlzLnBhdGggKyB1cmw7XG5cbiAgICBcdFx0dmFyIHNjb3BlID0gdGhpcztcblxuICAgIFx0XHR2YXIgY2FjaGVkID0gZXhwb3J0cy5DYWNoZS5nZXQoIHVybCApO1xuXG4gICAgXHRcdGlmICggY2FjaGVkICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRzY29wZS5tYW5hZ2VyLml0ZW1TdGFydCggdXJsICk7XG5cbiAgICBcdFx0XHRzZXRUaW1lb3V0KCBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0XHRcdGlmICggb25Mb2FkICkgb25Mb2FkKCBjYWNoZWQgKTtcblxuICAgIFx0XHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRW5kKCB1cmwgKTtcblxuICAgIFx0XHRcdH0sIDAgKTtcblxuICAgIFx0XHRcdHJldHVybiBjYWNoZWQ7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgXHRcdHJlcXVlc3Qub3BlbiggJ0dFVCcsIHVybCwgdHJ1ZSApO1xuXG4gICAgXHRcdHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lciggJ2xvYWQnLCBmdW5jdGlvbiAoIGV2ZW50ICkge1xuXG4gICAgXHRcdFx0dmFyIHJlc3BvbnNlID0gZXZlbnQudGFyZ2V0LnJlc3BvbnNlO1xuXG4gICAgXHRcdFx0ZXhwb3J0cy5DYWNoZS5hZGQoIHVybCwgcmVzcG9uc2UgKTtcblxuICAgIFx0XHRcdGlmICggdGhpcy5zdGF0dXMgPT09IDIwMCApIHtcblxuICAgIFx0XHRcdFx0aWYgKCBvbkxvYWQgKSBvbkxvYWQoIHJlc3BvbnNlICk7XG5cbiAgICBcdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVuZCggdXJsICk7XG5cbiAgICBcdFx0XHR9IGVsc2UgaWYgKCB0aGlzLnN0YXR1cyA9PT0gMCApIHtcblxuICAgIFx0XHRcdFx0Ly8gU29tZSBicm93c2VycyByZXR1cm4gSFRUUCBTdGF0dXMgMCB3aGVuIHVzaW5nIG5vbi1odHRwIHByb3RvY29sXG4gICAgXHRcdFx0XHQvLyBlLmcuICdmaWxlOi8vJyBvciAnZGF0YTovLycuIEhhbmRsZSBhcyBzdWNjZXNzLlxuXG4gICAgXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5YSFJMb2FkZXI6IEhUVFAgU3RhdHVzIDAgcmVjZWl2ZWQuJyApO1xuXG4gICAgXHRcdFx0XHRpZiAoIG9uTG9hZCApIG9uTG9hZCggcmVzcG9uc2UgKTtcblxuICAgIFx0XHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRW5kKCB1cmwgKTtcblxuICAgIFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdGlmICggb25FcnJvciApIG9uRXJyb3IoIGV2ZW50ICk7XG5cbiAgICBcdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVycm9yKCB1cmwgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9LCBmYWxzZSApO1xuXG4gICAgXHRcdGlmICggb25Qcm9ncmVzcyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0cmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCAncHJvZ3Jlc3MnLCBmdW5jdGlvbiAoIGV2ZW50ICkge1xuXG4gICAgXHRcdFx0XHRvblByb2dyZXNzKCBldmVudCApO1xuXG4gICAgXHRcdFx0fSwgZmFsc2UgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCAnZXJyb3InLCBmdW5jdGlvbiAoIGV2ZW50ICkge1xuXG4gICAgXHRcdFx0aWYgKCBvbkVycm9yICkgb25FcnJvciggZXZlbnQgKTtcblxuICAgIFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVycm9yKCB1cmwgKTtcblxuICAgIFx0XHR9LCBmYWxzZSApO1xuXG4gICAgXHRcdGlmICggdGhpcy5yZXNwb25zZVR5cGUgIT09IHVuZGVmaW5lZCApIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gdGhpcy5yZXNwb25zZVR5cGU7XG4gICAgXHRcdGlmICggdGhpcy53aXRoQ3JlZGVudGlhbHMgIT09IHVuZGVmaW5lZCApIHJlcXVlc3Qud2l0aENyZWRlbnRpYWxzID0gdGhpcy53aXRoQ3JlZGVudGlhbHM7XG5cbiAgICBcdFx0aWYgKCByZXF1ZXN0Lm92ZXJyaWRlTWltZVR5cGUgKSByZXF1ZXN0Lm92ZXJyaWRlTWltZVR5cGUoICd0ZXh0L3BsYWluJyApO1xuXG4gICAgXHRcdHJlcXVlc3Quc2VuZCggbnVsbCApO1xuXG4gICAgXHRcdHNjb3BlLm1hbmFnZXIuaXRlbVN0YXJ0KCB1cmwgKTtcblxuICAgIFx0XHRyZXR1cm4gcmVxdWVzdDtcblxuICAgIFx0fSxcblxuICAgIFx0c2V0UGF0aDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuICAgIFx0XHR0aGlzLnBhdGggPSB2YWx1ZTtcbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldFJlc3BvbnNlVHlwZTogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuICAgIFx0XHR0aGlzLnJlc3BvbnNlVHlwZSA9IHZhbHVlO1xuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0c2V0V2l0aENyZWRlbnRpYWxzOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG4gICAgXHRcdHRoaXMud2l0aENyZWRlbnRpYWxzID0gdmFsdWU7XG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9XG5cbiAgICB9ICk7XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICAgICAqXG4gICAgICogQWJzdHJhY3QgQmFzZSBjbGFzcyB0byBibG9jayBiYXNlZCB0ZXh0dXJlcyBsb2FkZXIgKGRkcywgcHZyLCAuLi4pXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBDb21wcmVzc2VkVGV4dHVyZUxvYWRlciggbWFuYWdlciApIHtcblxuICAgIFx0dGhpcy5tYW5hZ2VyID0gKCBtYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IG1hbmFnZXIgOiBleHBvcnRzLkRlZmF1bHRMb2FkaW5nTWFuYWdlcjtcblxuICAgIFx0Ly8gb3ZlcnJpZGUgaW4gc3ViIGNsYXNzZXNcbiAgICBcdHRoaXMuX3BhcnNlciA9IG51bGw7XG5cbiAgICB9XG5cbiAgICBPYmplY3QuYXNzaWduKCBDb21wcmVzc2VkVGV4dHVyZUxvYWRlci5wcm90b3R5cGUsIHtcblxuICAgIFx0bG9hZDogZnVuY3Rpb24gKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcblxuICAgIFx0XHR2YXIgc2NvcGUgPSB0aGlzO1xuXG4gICAgXHRcdHZhciBpbWFnZXMgPSBbXTtcblxuICAgIFx0XHR2YXIgdGV4dHVyZSA9IG5ldyBDb21wcmVzc2VkVGV4dHVyZSgpO1xuICAgIFx0XHR0ZXh0dXJlLmltYWdlID0gaW1hZ2VzO1xuXG4gICAgXHRcdHZhciBsb2FkZXIgPSBuZXcgWEhSTG9hZGVyKCB0aGlzLm1hbmFnZXIgKTtcbiAgICBcdFx0bG9hZGVyLnNldFBhdGgoIHRoaXMucGF0aCApO1xuICAgIFx0XHRsb2FkZXIuc2V0UmVzcG9uc2VUeXBlKCAnYXJyYXlidWZmZXInICk7XG5cbiAgICBcdFx0ZnVuY3Rpb24gbG9hZFRleHR1cmUoIGkgKSB7XG5cbiAgICBcdFx0XHRsb2FkZXIubG9hZCggdXJsWyBpIF0sIGZ1bmN0aW9uICggYnVmZmVyICkge1xuXG4gICAgXHRcdFx0XHR2YXIgdGV4RGF0YXMgPSBzY29wZS5fcGFyc2VyKCBidWZmZXIsIHRydWUgKTtcblxuICAgIFx0XHRcdFx0aW1hZ2VzWyBpIF0gPSB7XG4gICAgXHRcdFx0XHRcdHdpZHRoOiB0ZXhEYXRhcy53aWR0aCxcbiAgICBcdFx0XHRcdFx0aGVpZ2h0OiB0ZXhEYXRhcy5oZWlnaHQsXG4gICAgXHRcdFx0XHRcdGZvcm1hdDogdGV4RGF0YXMuZm9ybWF0LFxuICAgIFx0XHRcdFx0XHRtaXBtYXBzOiB0ZXhEYXRhcy5taXBtYXBzXG4gICAgXHRcdFx0XHR9O1xuXG4gICAgXHRcdFx0XHRsb2FkZWQgKz0gMTtcblxuICAgIFx0XHRcdFx0aWYgKCBsb2FkZWQgPT09IDYgKSB7XG5cbiAgICBcdFx0XHRcdFx0aWYgKCB0ZXhEYXRhcy5taXBtYXBDb3VudCA9PT0gMSApXG4gICAgXHRcdFx0XHRcdFx0dGV4dHVyZS5taW5GaWx0ZXIgPSBMaW5lYXJGaWx0ZXI7XG5cbiAgICBcdFx0XHRcdFx0dGV4dHVyZS5mb3JtYXQgPSB0ZXhEYXRhcy5mb3JtYXQ7XG4gICAgXHRcdFx0XHRcdHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgXHRcdFx0XHRcdGlmICggb25Mb2FkICkgb25Mb2FkKCB0ZXh0dXJlICk7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0aWYgKCBBcnJheS5pc0FycmF5KCB1cmwgKSApIHtcblxuICAgIFx0XHRcdHZhciBsb2FkZWQgPSAwO1xuXG4gICAgXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHVybC5sZW5ndGg7IGkgPCBpbDsgKysgaSApIHtcblxuICAgIFx0XHRcdFx0bG9hZFRleHR1cmUoIGkgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0Ly8gY29tcHJlc3NlZCBjdWJlbWFwIHRleHR1cmUgc3RvcmVkIGluIGEgc2luZ2xlIEREUyBmaWxlXG5cbiAgICBcdFx0XHRsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIGJ1ZmZlciApIHtcblxuICAgIFx0XHRcdFx0dmFyIHRleERhdGFzID0gc2NvcGUuX3BhcnNlciggYnVmZmVyLCB0cnVlICk7XG5cbiAgICBcdFx0XHRcdGlmICggdGV4RGF0YXMuaXNDdWJlbWFwICkge1xuXG4gICAgXHRcdFx0XHRcdHZhciBmYWNlcyA9IHRleERhdGFzLm1pcG1hcHMubGVuZ3RoIC8gdGV4RGF0YXMubWlwbWFwQ291bnQ7XG5cbiAgICBcdFx0XHRcdFx0Zm9yICggdmFyIGYgPSAwOyBmIDwgZmFjZXM7IGYgKysgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHRpbWFnZXNbIGYgXSA9IHsgbWlwbWFwcyA6IFtdIH07XG5cbiAgICBcdFx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0ZXhEYXRhcy5taXBtYXBDb3VudDsgaSArKyApIHtcblxuICAgIFx0XHRcdFx0XHRcdFx0aW1hZ2VzWyBmIF0ubWlwbWFwcy5wdXNoKCB0ZXhEYXRhcy5taXBtYXBzWyBmICogdGV4RGF0YXMubWlwbWFwQ291bnQgKyBpIF0gKTtcbiAgICBcdFx0XHRcdFx0XHRcdGltYWdlc1sgZiBdLmZvcm1hdCA9IHRleERhdGFzLmZvcm1hdDtcbiAgICBcdFx0XHRcdFx0XHRcdGltYWdlc1sgZiBdLndpZHRoID0gdGV4RGF0YXMud2lkdGg7XG4gICAgXHRcdFx0XHRcdFx0XHRpbWFnZXNbIGYgXS5oZWlnaHQgPSB0ZXhEYXRhcy5oZWlnaHQ7XG5cbiAgICBcdFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHRcdHRleHR1cmUuaW1hZ2Uud2lkdGggPSB0ZXhEYXRhcy53aWR0aDtcbiAgICBcdFx0XHRcdFx0dGV4dHVyZS5pbWFnZS5oZWlnaHQgPSB0ZXhEYXRhcy5oZWlnaHQ7XG4gICAgXHRcdFx0XHRcdHRleHR1cmUubWlwbWFwcyA9IHRleERhdGFzLm1pcG1hcHM7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0aWYgKCB0ZXhEYXRhcy5taXBtYXBDb3VudCA9PT0gMSApIHtcblxuICAgIFx0XHRcdFx0XHR0ZXh0dXJlLm1pbkZpbHRlciA9IExpbmVhckZpbHRlcjtcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHR0ZXh0dXJlLmZvcm1hdCA9IHRleERhdGFzLmZvcm1hdDtcbiAgICBcdFx0XHRcdHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgXHRcdFx0XHRpZiAoIG9uTG9hZCApIG9uTG9hZCggdGV4dHVyZSApO1xuXG4gICAgXHRcdFx0fSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gdGV4dHVyZTtcblxuICAgIFx0fSxcblxuICAgIFx0c2V0UGF0aDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuICAgIFx0XHR0aGlzLnBhdGggPSB2YWx1ZTtcbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH1cblxuICAgIH0gKTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgTmlrb3MgTS4gLyBodHRwczovL2dpdGh1Yi5jb20vZm9vMTIzL1xuICAgICAqXG4gICAgICogQWJzdHJhY3QgQmFzZSBjbGFzcyB0byBsb2FkIGdlbmVyaWMgYmluYXJ5IHRleHR1cmVzIGZvcm1hdHMgKHJnYmUsIGhkciwgLi4uKVxuICAgICAqL1xuXG4gICAgdmFyIERhdGFUZXh0dXJlTG9hZGVyID0gQmluYXJ5VGV4dHVyZUxvYWRlcjtcbiAgICBmdW5jdGlvbiBCaW5hcnlUZXh0dXJlTG9hZGVyKCBtYW5hZ2VyICkge1xuXG4gICAgXHR0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IGV4cG9ydHMuRGVmYXVsdExvYWRpbmdNYW5hZ2VyO1xuXG4gICAgXHQvLyBvdmVycmlkZSBpbiBzdWIgY2xhc3Nlc1xuICAgIFx0dGhpcy5fcGFyc2VyID0gbnVsbDtcblxuICAgIH1cblxuICAgIE9iamVjdC5hc3NpZ24oIEJpbmFyeVRleHR1cmVMb2FkZXIucHJvdG90eXBlLCB7XG5cbiAgICBcdGxvYWQ6IGZ1bmN0aW9uICggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cbiAgICBcdFx0dmFyIHNjb3BlID0gdGhpcztcblxuICAgIFx0XHR2YXIgdGV4dHVyZSA9IG5ldyBEYXRhVGV4dHVyZSgpO1xuXG4gICAgXHRcdHZhciBsb2FkZXIgPSBuZXcgWEhSTG9hZGVyKCB0aGlzLm1hbmFnZXIgKTtcbiAgICBcdFx0bG9hZGVyLnNldFJlc3BvbnNlVHlwZSggJ2FycmF5YnVmZmVyJyApO1xuXG4gICAgXHRcdGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggYnVmZmVyICkge1xuXG4gICAgXHRcdFx0dmFyIHRleERhdGEgPSBzY29wZS5fcGFyc2VyKCBidWZmZXIgKTtcblxuICAgIFx0XHRcdGlmICggISB0ZXhEYXRhICkgcmV0dXJuO1xuXG4gICAgXHRcdFx0aWYgKCB1bmRlZmluZWQgIT09IHRleERhdGEuaW1hZ2UgKSB7XG5cbiAgICBcdFx0XHRcdHRleHR1cmUuaW1hZ2UgPSB0ZXhEYXRhLmltYWdlO1xuXG4gICAgXHRcdFx0fSBlbHNlIGlmICggdW5kZWZpbmVkICE9PSB0ZXhEYXRhLmRhdGEgKSB7XG5cbiAgICBcdFx0XHRcdHRleHR1cmUuaW1hZ2Uud2lkdGggPSB0ZXhEYXRhLndpZHRoO1xuICAgIFx0XHRcdFx0dGV4dHVyZS5pbWFnZS5oZWlnaHQgPSB0ZXhEYXRhLmhlaWdodDtcbiAgICBcdFx0XHRcdHRleHR1cmUuaW1hZ2UuZGF0YSA9IHRleERhdGEuZGF0YTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdHRleHR1cmUud3JhcFMgPSB1bmRlZmluZWQgIT09IHRleERhdGEud3JhcFMgPyB0ZXhEYXRhLndyYXBTIDogQ2xhbXBUb0VkZ2VXcmFwcGluZztcbiAgICBcdFx0XHR0ZXh0dXJlLndyYXBUID0gdW5kZWZpbmVkICE9PSB0ZXhEYXRhLndyYXBUID8gdGV4RGF0YS53cmFwVCA6IENsYW1wVG9FZGdlV3JhcHBpbmc7XG5cbiAgICBcdFx0XHR0ZXh0dXJlLm1hZ0ZpbHRlciA9IHVuZGVmaW5lZCAhPT0gdGV4RGF0YS5tYWdGaWx0ZXIgPyB0ZXhEYXRhLm1hZ0ZpbHRlciA6IExpbmVhckZpbHRlcjtcbiAgICBcdFx0XHR0ZXh0dXJlLm1pbkZpbHRlciA9IHVuZGVmaW5lZCAhPT0gdGV4RGF0YS5taW5GaWx0ZXIgPyB0ZXhEYXRhLm1pbkZpbHRlciA6IExpbmVhck1pcE1hcExpbmVhckZpbHRlcjtcblxuICAgIFx0XHRcdHRleHR1cmUuYW5pc290cm9weSA9IHVuZGVmaW5lZCAhPT0gdGV4RGF0YS5hbmlzb3Ryb3B5ID8gdGV4RGF0YS5hbmlzb3Ryb3B5IDogMTtcblxuICAgIFx0XHRcdGlmICggdW5kZWZpbmVkICE9PSB0ZXhEYXRhLmZvcm1hdCApIHtcblxuICAgIFx0XHRcdFx0dGV4dHVyZS5mb3JtYXQgPSB0ZXhEYXRhLmZvcm1hdDtcblxuICAgIFx0XHRcdH1cbiAgICBcdFx0XHRpZiAoIHVuZGVmaW5lZCAhPT0gdGV4RGF0YS50eXBlICkge1xuXG4gICAgXHRcdFx0XHR0ZXh0dXJlLnR5cGUgPSB0ZXhEYXRhLnR5cGU7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRpZiAoIHVuZGVmaW5lZCAhPT0gdGV4RGF0YS5taXBtYXBzICkge1xuXG4gICAgXHRcdFx0XHR0ZXh0dXJlLm1pcG1hcHMgPSB0ZXhEYXRhLm1pcG1hcHM7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRpZiAoIDEgPT09IHRleERhdGEubWlwbWFwQ291bnQgKSB7XG5cbiAgICBcdFx0XHRcdHRleHR1cmUubWluRmlsdGVyID0gTGluZWFyRmlsdGVyO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0dGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICBcdFx0XHRpZiAoIG9uTG9hZCApIG9uTG9hZCggdGV4dHVyZSwgdGV4RGF0YSApO1xuXG4gICAgXHRcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcblxuXG4gICAgXHRcdHJldHVybiB0ZXh0dXJlO1xuXG4gICAgXHR9XG5cbiAgICB9ICk7XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gSW1hZ2VMb2FkZXIoIG1hbmFnZXIgKSB7XG5cbiAgICBcdHRoaXMubWFuYWdlciA9ICggbWFuYWdlciAhPT0gdW5kZWZpbmVkICkgPyBtYW5hZ2VyIDogZXhwb3J0cy5EZWZhdWx0TG9hZGluZ01hbmFnZXI7XG5cbiAgICB9XG5cbiAgICBPYmplY3QuYXNzaWduKCBJbWFnZUxvYWRlci5wcm90b3R5cGUsIHtcblxuICAgIFx0bG9hZDogZnVuY3Rpb24gKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcblxuICAgIFx0XHR2YXIgc2NvcGUgPSB0aGlzO1xuXG4gICAgXHRcdHZhciBpbWFnZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyggJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnLCAnaW1nJyApO1xuICAgIFx0XHRpbWFnZS5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0XHRpbWFnZS5vbmxvYWQgPSBudWxsO1xuXG4gICAgXHRcdFx0VVJMLnJldm9rZU9iamVjdFVSTCggaW1hZ2Uuc3JjICk7XG5cbiAgICBcdFx0XHRpZiAoIG9uTG9hZCApIG9uTG9hZCggaW1hZ2UgKTtcblxuICAgIFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVuZCggdXJsICk7XG5cbiAgICBcdFx0fTtcblxuICAgIFx0XHRpZiAoIHVybC5pbmRleE9mKCAnZGF0YTonICkgPT09IDAgKSB7XG5cbiAgICBcdFx0XHRpbWFnZS5zcmMgPSB1cmw7XG5cbiAgICBcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdHZhciBsb2FkZXIgPSBuZXcgWEhSTG9hZGVyKCk7XG4gICAgXHRcdFx0bG9hZGVyLnNldFBhdGgoIHRoaXMucGF0aCApO1xuICAgIFx0XHRcdGxvYWRlci5zZXRSZXNwb25zZVR5cGUoICdibG9iJyApO1xuICAgIFx0XHRcdGxvYWRlci5zZXRXaXRoQ3JlZGVudGlhbHMoIHRoaXMud2l0aENyZWRlbnRpYWxzICk7XG4gICAgXHRcdFx0bG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCBibG9iICkge1xuXG4gICAgXHRcdFx0XHRpbWFnZS5zcmMgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKCBibG9iICk7XG5cbiAgICBcdFx0XHR9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHNjb3BlLm1hbmFnZXIuaXRlbVN0YXJ0KCB1cmwgKTtcblxuICAgIFx0XHRyZXR1cm4gaW1hZ2U7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldENyb3NzT3JpZ2luOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG4gICAgXHRcdHRoaXMuY3Jvc3NPcmlnaW4gPSB2YWx1ZTtcbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldFdpdGhDcmVkZW50aWFsczogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuICAgIFx0XHR0aGlzLndpdGhDcmVkZW50aWFscyA9IHZhbHVlO1xuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0c2V0UGF0aDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuICAgIFx0XHR0aGlzLnBhdGggPSB2YWx1ZTtcbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH1cblxuICAgIH0gKTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBDdWJlVGV4dHVyZUxvYWRlciggbWFuYWdlciApIHtcblxuICAgIFx0dGhpcy5tYW5hZ2VyID0gKCBtYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IG1hbmFnZXIgOiBleHBvcnRzLkRlZmF1bHRMb2FkaW5nTWFuYWdlcjtcblxuICAgIH1cblxuICAgIE9iamVjdC5hc3NpZ24oIEN1YmVUZXh0dXJlTG9hZGVyLnByb3RvdHlwZSwge1xuXG4gICAgXHRsb2FkOiBmdW5jdGlvbiAoIHVybHMsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcblxuICAgIFx0XHR2YXIgdGV4dHVyZSA9IG5ldyBDdWJlVGV4dHVyZSgpO1xuXG4gICAgXHRcdHZhciBsb2FkZXIgPSBuZXcgSW1hZ2VMb2FkZXIoIHRoaXMubWFuYWdlciApO1xuICAgIFx0XHRsb2FkZXIuc2V0Q3Jvc3NPcmlnaW4oIHRoaXMuY3Jvc3NPcmlnaW4gKTtcbiAgICBcdFx0bG9hZGVyLnNldFBhdGgoIHRoaXMucGF0aCApO1xuXG4gICAgXHRcdHZhciBsb2FkZWQgPSAwO1xuXG4gICAgXHRcdGZ1bmN0aW9uIGxvYWRUZXh0dXJlKCBpICkge1xuXG4gICAgXHRcdFx0bG9hZGVyLmxvYWQoIHVybHNbIGkgXSwgZnVuY3Rpb24gKCBpbWFnZSApIHtcblxuICAgIFx0XHRcdFx0dGV4dHVyZS5pbWFnZXNbIGkgXSA9IGltYWdlO1xuXG4gICAgXHRcdFx0XHRsb2FkZWQgKys7XG5cbiAgICBcdFx0XHRcdGlmICggbG9hZGVkID09PSA2ICkge1xuXG4gICAgXHRcdFx0XHRcdHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgXHRcdFx0XHRcdGlmICggb25Mb2FkICkgb25Mb2FkKCB0ZXh0dXJlICk7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdH0sIHVuZGVmaW5lZCwgb25FcnJvciApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB1cmxzLmxlbmd0aDsgKysgaSApIHtcblxuICAgIFx0XHRcdGxvYWRUZXh0dXJlKCBpICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiB0ZXh0dXJlO1xuXG4gICAgXHR9LFxuXG4gICAgXHRzZXRDcm9zc09yaWdpbjogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuICAgIFx0XHR0aGlzLmNyb3NzT3JpZ2luID0gdmFsdWU7XG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRzZXRQYXRoOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG4gICAgXHRcdHRoaXMucGF0aCA9IHZhbHVlO1xuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fVxuXG4gICAgfSApO1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIFRleHR1cmVMb2FkZXIoIG1hbmFnZXIgKSB7XG5cbiAgICBcdHRoaXMubWFuYWdlciA9ICggbWFuYWdlciAhPT0gdW5kZWZpbmVkICkgPyBtYW5hZ2VyIDogZXhwb3J0cy5EZWZhdWx0TG9hZGluZ01hbmFnZXI7XG5cbiAgICB9XG5cbiAgICBPYmplY3QuYXNzaWduKCBUZXh0dXJlTG9hZGVyLnByb3RvdHlwZSwge1xuXG4gICAgXHRsb2FkOiBmdW5jdGlvbiAoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG4gICAgXHRcdHZhciB0ZXh0dXJlID0gbmV3IFRleHR1cmUoKTtcblxuICAgIFx0XHR2YXIgbG9hZGVyID0gbmV3IEltYWdlTG9hZGVyKCB0aGlzLm1hbmFnZXIgKTtcbiAgICBcdFx0bG9hZGVyLnNldENyb3NzT3JpZ2luKCB0aGlzLmNyb3NzT3JpZ2luICk7XG4gICAgXHRcdGxvYWRlci5zZXRXaXRoQ3JlZGVudGlhbHMoIHRoaXMud2l0aENyZWRlbnRpYWxzICk7XG4gICAgXHRcdGxvYWRlci5zZXRQYXRoKCB0aGlzLnBhdGggKTtcbiAgICBcdFx0bG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCBpbWFnZSApIHtcblxuICAgIFx0XHRcdC8vIEpQRUdzIGNhbid0IGhhdmUgYW4gYWxwaGEgY2hhbm5lbCwgc28gbWVtb3J5IGNhbiBiZSBzYXZlZCBieSBzdG9yaW5nIHRoZW0gYXMgUkdCLlxuICAgIFx0XHRcdHZhciBpc0pQRUcgPSB1cmwuc2VhcmNoKCAvXFwuKGpwZ3xqcGVnKSQvICkgPiAwIHx8IHVybC5zZWFyY2goIC9eZGF0YVxcOmltYWdlXFwvanBlZy8gKSA9PT0gMDtcblxuICAgIFx0XHRcdHRleHR1cmUuZm9ybWF0ID0gaXNKUEVHID8gUkdCRm9ybWF0IDogUkdCQUZvcm1hdDtcbiAgICBcdFx0XHR0ZXh0dXJlLmltYWdlID0gaW1hZ2U7XG4gICAgXHRcdFx0dGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICBcdFx0XHRpZiAoIG9uTG9hZCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0XHRvbkxvYWQoIHRleHR1cmUgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XG5cbiAgICBcdFx0cmV0dXJuIHRleHR1cmU7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldENyb3NzT3JpZ2luOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG4gICAgXHRcdHRoaXMuY3Jvc3NPcmlnaW4gPSB2YWx1ZTtcbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldFdpdGhDcmVkZW50aWFsczogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuICAgIFx0XHR0aGlzLndpdGhDcmVkZW50aWFscyA9IHZhbHVlO1xuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0c2V0UGF0aDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuICAgIFx0XHR0aGlzLnBhdGggPSB2YWx1ZTtcbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH1cblxuXG5cbiAgICB9ICk7XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICAgICAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBMaWdodCggY29sb3IsIGludGVuc2l0eSApIHtcblxuICAgIFx0T2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG4gICAgXHR0aGlzLnR5cGUgPSAnTGlnaHQnO1xuXG4gICAgXHR0aGlzLmNvbG9yID0gbmV3IENvbG9yKCBjb2xvciApO1xuICAgIFx0dGhpcy5pbnRlbnNpdHkgPSBpbnRlbnNpdHkgIT09IHVuZGVmaW5lZCA/IGludGVuc2l0eSA6IDE7XG5cbiAgICBcdHRoaXMucmVjZWl2ZVNoYWRvdyA9IHVuZGVmaW5lZDtcblxuICAgIH1cblxuICAgIExpZ2h0LnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIE9iamVjdDNELnByb3RvdHlwZSApLCB7XG5cbiAgICBcdGNvbnN0cnVjdG9yOiBMaWdodCxcblxuICAgIFx0aXNMaWdodDogdHJ1ZSxcblxuICAgIFx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cbiAgICBcdFx0T2JqZWN0M0QucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XG5cbiAgICBcdFx0dGhpcy5jb2xvci5jb3B5KCBzb3VyY2UuY29sb3IgKTtcbiAgICBcdFx0dGhpcy5pbnRlbnNpdHkgPSBzb3VyY2UuaW50ZW5zaXR5O1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHR0b0pTT046IGZ1bmN0aW9uICggbWV0YSApIHtcblxuICAgIFx0XHR2YXIgZGF0YSA9IE9iamVjdDNELnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcywgbWV0YSApO1xuXG4gICAgXHRcdGRhdGEub2JqZWN0LmNvbG9yID0gdGhpcy5jb2xvci5nZXRIZXgoKTtcbiAgICBcdFx0ZGF0YS5vYmplY3QuaW50ZW5zaXR5ID0gdGhpcy5pbnRlbnNpdHk7XG5cbiAgICBcdFx0aWYgKCB0aGlzLmdyb3VuZENvbG9yICE9PSB1bmRlZmluZWQgKSBkYXRhLm9iamVjdC5ncm91bmRDb2xvciA9IHRoaXMuZ3JvdW5kQ29sb3IuZ2V0SGV4KCk7XG5cbiAgICBcdFx0aWYgKCB0aGlzLmRpc3RhbmNlICE9PSB1bmRlZmluZWQgKSBkYXRhLm9iamVjdC5kaXN0YW5jZSA9IHRoaXMuZGlzdGFuY2U7XG4gICAgXHRcdGlmICggdGhpcy5hbmdsZSAhPT0gdW5kZWZpbmVkICkgZGF0YS5vYmplY3QuYW5nbGUgPSB0aGlzLmFuZ2xlO1xuICAgIFx0XHRpZiAoIHRoaXMuZGVjYXkgIT09IHVuZGVmaW5lZCApIGRhdGEub2JqZWN0LmRlY2F5ID0gdGhpcy5kZWNheTtcbiAgICBcdFx0aWYgKCB0aGlzLnBlbnVtYnJhICE9PSB1bmRlZmluZWQgKSBkYXRhLm9iamVjdC5wZW51bWJyYSA9IHRoaXMucGVudW1icmE7XG5cbiAgICBcdFx0aWYgKCB0aGlzLnNoYWRvdyAhPT0gdW5kZWZpbmVkICkgZGF0YS5vYmplY3Quc2hhZG93ID0gdGhpcy5zaGFkb3cudG9KU09OKCk7XG5cbiAgICBcdFx0cmV0dXJuIGRhdGE7XG5cbiAgICBcdH1cblxuICAgIH0gKTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBIZW1pc3BoZXJlTGlnaHQoIHNreUNvbG9yLCBncm91bmRDb2xvciwgaW50ZW5zaXR5ICkge1xuXG4gICAgXHRMaWdodC5jYWxsKCB0aGlzLCBza3lDb2xvciwgaW50ZW5zaXR5ICk7XG5cbiAgICBcdHRoaXMudHlwZSA9ICdIZW1pc3BoZXJlTGlnaHQnO1xuXG4gICAgXHR0aGlzLmNhc3RTaGFkb3cgPSB1bmRlZmluZWQ7XG5cbiAgICBcdHRoaXMucG9zaXRpb24uY29weSggT2JqZWN0M0QuRGVmYXVsdFVwICk7XG4gICAgXHR0aGlzLnVwZGF0ZU1hdHJpeCgpO1xuXG4gICAgXHR0aGlzLmdyb3VuZENvbG9yID0gbmV3IENvbG9yKCBncm91bmRDb2xvciApO1xuXG4gICAgfVxuXG4gICAgSGVtaXNwaGVyZUxpZ2h0LnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIExpZ2h0LnByb3RvdHlwZSApLCB7XG5cbiAgICBcdGNvbnN0cnVjdG9yOiBIZW1pc3BoZXJlTGlnaHQsXG5cbiAgICBcdGlzSGVtaXNwaGVyZUxpZ2h0OiB0cnVlLFxuXG4gICAgXHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuICAgIFx0XHRMaWdodC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuICAgIFx0XHR0aGlzLmdyb3VuZENvbG9yLmNvcHkoIHNvdXJjZS5ncm91bmRDb2xvciApO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9XG5cbiAgICB9ICk7XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gTGlnaHRTaGFkb3coIGNhbWVyYSApIHtcblxuICAgIFx0dGhpcy5jYW1lcmEgPSBjYW1lcmE7XG5cbiAgICBcdHRoaXMuYmlhcyA9IDA7XG4gICAgXHR0aGlzLnJhZGl1cyA9IDE7XG5cbiAgICBcdHRoaXMubWFwU2l6ZSA9IG5ldyBWZWN0b3IyKCA1MTIsIDUxMiApO1xuXG4gICAgXHR0aGlzLm1hcCA9IG51bGw7XG4gICAgXHR0aGlzLm1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XG5cbiAgICB9XG5cbiAgICBPYmplY3QuYXNzaWduKCBMaWdodFNoYWRvdy5wcm90b3R5cGUsIHtcblxuICAgIFx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cbiAgICBcdFx0dGhpcy5jYW1lcmEgPSBzb3VyY2UuY2FtZXJhLmNsb25lKCk7XG5cbiAgICBcdFx0dGhpcy5iaWFzID0gc291cmNlLmJpYXM7XG4gICAgXHRcdHRoaXMucmFkaXVzID0gc291cmNlLnJhZGl1cztcblxuICAgIFx0XHR0aGlzLm1hcFNpemUuY29weSggc291cmNlLm1hcFNpemUgKTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdHRvSlNPTjogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHZhciBvYmplY3QgPSB7fTtcblxuICAgIFx0XHRpZiAoIHRoaXMuYmlhcyAhPT0gMCApIG9iamVjdC5iaWFzID0gdGhpcy5iaWFzO1xuICAgIFx0XHRpZiAoIHRoaXMucmFkaXVzICE9PSAxICkgb2JqZWN0LnJhZGl1cyA9IHRoaXMucmFkaXVzO1xuICAgIFx0XHRpZiAoIHRoaXMubWFwU2l6ZS54ICE9PSA1MTIgfHwgdGhpcy5tYXBTaXplLnkgIT09IDUxMiApIG9iamVjdC5tYXBTaXplID0gdGhpcy5tYXBTaXplLnRvQXJyYXkoKTtcblxuICAgIFx0XHRvYmplY3QuY2FtZXJhID0gdGhpcy5jYW1lcmEudG9KU09OKCBmYWxzZSApLm9iamVjdDtcbiAgICBcdFx0ZGVsZXRlIG9iamVjdC5jYW1lcmEubWF0cml4O1xuXG4gICAgXHRcdHJldHVybiBvYmplY3Q7XG5cbiAgICBcdH1cblxuICAgIH0gKTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBTcG90TGlnaHRTaGFkb3coKSB7XG5cbiAgICBcdExpZ2h0U2hhZG93LmNhbGwoIHRoaXMsIG5ldyBQZXJzcGVjdGl2ZUNhbWVyYSggNTAsIDEsIDAuNSwgNTAwICkgKTtcblxuICAgIH1cblxuICAgIFNwb3RMaWdodFNoYWRvdy5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBMaWdodFNoYWRvdy5wcm90b3R5cGUgKSwge1xuXG4gICAgXHRjb25zdHJ1Y3RvcjogU3BvdExpZ2h0U2hhZG93LFxuXG4gICAgXHRpc1Nwb3RMaWdodFNoYWRvdzogdHJ1ZSxcblxuICAgIFx0dXBkYXRlOiBmdW5jdGlvbiAoIGxpZ2h0ICkge1xuXG4gICAgXHRcdHZhciBmb3YgPSBleHBvcnRzLk1hdGguUkFEMkRFRyAqIDIgKiBsaWdodC5hbmdsZTtcbiAgICBcdFx0dmFyIGFzcGVjdCA9IHRoaXMubWFwU2l6ZS53aWR0aCAvIHRoaXMubWFwU2l6ZS5oZWlnaHQ7XG4gICAgXHRcdHZhciBmYXIgPSBsaWdodC5kaXN0YW5jZSB8fCA1MDA7XG5cbiAgICBcdFx0dmFyIGNhbWVyYSA9IHRoaXMuY2FtZXJhO1xuXG4gICAgXHRcdGlmICggZm92ICE9PSBjYW1lcmEuZm92IHx8IGFzcGVjdCAhPT0gY2FtZXJhLmFzcGVjdCB8fCBmYXIgIT09IGNhbWVyYS5mYXIgKSB7XG5cbiAgICBcdFx0XHRjYW1lcmEuZm92ID0gZm92O1xuICAgIFx0XHRcdGNhbWVyYS5hc3BlY3QgPSBhc3BlY3Q7XG4gICAgXHRcdFx0Y2FtZXJhLmZhciA9IGZhcjtcbiAgICBcdFx0XHRjYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xuXG4gICAgXHRcdH1cblxuICAgIFx0fVxuXG4gICAgfSApO1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIFNwb3RMaWdodCggY29sb3IsIGludGVuc2l0eSwgZGlzdGFuY2UsIGFuZ2xlLCBwZW51bWJyYSwgZGVjYXkgKSB7XG5cbiAgICBcdExpZ2h0LmNhbGwoIHRoaXMsIGNvbG9yLCBpbnRlbnNpdHkgKTtcblxuICAgIFx0dGhpcy50eXBlID0gJ1Nwb3RMaWdodCc7XG5cbiAgICBcdHRoaXMucG9zaXRpb24uY29weSggT2JqZWN0M0QuRGVmYXVsdFVwICk7XG4gICAgXHR0aGlzLnVwZGF0ZU1hdHJpeCgpO1xuXG4gICAgXHR0aGlzLnRhcmdldCA9IG5ldyBPYmplY3QzRCgpO1xuXG4gICAgXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsICdwb3dlcicsIHtcbiAgICBcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgXHRcdFx0Ly8gaW50ZW5zaXR5ID0gcG93ZXIgcGVyIHNvbGlkIGFuZ2xlLlxuICAgIFx0XHRcdC8vIHJlZjogZXF1YXRpb24gKDE3KSBmcm9tIGh0dHA6Ly93d3cuZnJvc3RiaXRlLmNvbS93cC1jb250ZW50L3VwbG9hZHMvMjAxNC8xMS9jb3Vyc2Vfbm90ZXNfbW92aW5nX2Zyb3N0Yml0ZV90b19wYnIucGRmXG4gICAgXHRcdFx0cmV0dXJuIHRoaXMuaW50ZW5zaXR5ICogTWF0aC5QSTtcbiAgICBcdFx0fSxcbiAgICBcdFx0c2V0OiBmdW5jdGlvbiAoIHBvd2VyICkge1xuICAgIFx0XHRcdC8vIGludGVuc2l0eSA9IHBvd2VyIHBlciBzb2xpZCBhbmdsZS5cbiAgICBcdFx0XHQvLyByZWY6IGVxdWF0aW9uICgxNykgZnJvbSBodHRwOi8vd3d3LmZyb3N0Yml0ZS5jb20vd3AtY29udGVudC91cGxvYWRzLzIwMTQvMTEvY291cnNlX25vdGVzX21vdmluZ19mcm9zdGJpdGVfdG9fcGJyLnBkZlxuICAgIFx0XHRcdHRoaXMuaW50ZW5zaXR5ID0gcG93ZXIgLyBNYXRoLlBJO1xuICAgIFx0XHR9XG4gICAgXHR9ICk7XG5cbiAgICBcdHRoaXMuZGlzdGFuY2UgPSAoIGRpc3RhbmNlICE9PSB1bmRlZmluZWQgKSA/IGRpc3RhbmNlIDogMDtcbiAgICBcdHRoaXMuYW5nbGUgPSAoIGFuZ2xlICE9PSB1bmRlZmluZWQgKSA/IGFuZ2xlIDogTWF0aC5QSSAvIDM7XG4gICAgXHR0aGlzLnBlbnVtYnJhID0gKCBwZW51bWJyYSAhPT0gdW5kZWZpbmVkICkgPyBwZW51bWJyYSA6IDA7XG4gICAgXHR0aGlzLmRlY2F5ID0gKCBkZWNheSAhPT0gdW5kZWZpbmVkICkgPyBkZWNheSA6IDE7XHQvLyBmb3IgcGh5c2ljYWxseSBjb3JyZWN0IGxpZ2h0cywgc2hvdWxkIGJlIDIuXG5cbiAgICBcdHRoaXMuc2hhZG93ID0gbmV3IFNwb3RMaWdodFNoYWRvdygpO1xuXG4gICAgfVxuXG4gICAgU3BvdExpZ2h0LnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIExpZ2h0LnByb3RvdHlwZSApLCB7XG5cbiAgICBcdGNvbnN0cnVjdG9yOiBTcG90TGlnaHQsXG5cbiAgICBcdGlzU3BvdExpZ2h0OiB0cnVlLFxuXG4gICAgXHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuICAgIFx0XHRMaWdodC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuICAgIFx0XHR0aGlzLmRpc3RhbmNlID0gc291cmNlLmRpc3RhbmNlO1xuICAgIFx0XHR0aGlzLmFuZ2xlID0gc291cmNlLmFuZ2xlO1xuICAgIFx0XHR0aGlzLnBlbnVtYnJhID0gc291cmNlLnBlbnVtYnJhO1xuICAgIFx0XHR0aGlzLmRlY2F5ID0gc291cmNlLmRlY2F5O1xuXG4gICAgXHRcdHRoaXMudGFyZ2V0ID0gc291cmNlLnRhcmdldC5jbG9uZSgpO1xuXG4gICAgXHRcdHRoaXMuc2hhZG93ID0gc291cmNlLnNoYWRvdy5jbG9uZSgpO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9XG5cbiAgICB9ICk7XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICAgICAqL1xuXG5cbiAgICBmdW5jdGlvbiBQb2ludExpZ2h0KCBjb2xvciwgaW50ZW5zaXR5LCBkaXN0YW5jZSwgZGVjYXkgKSB7XG5cbiAgICBcdExpZ2h0LmNhbGwoIHRoaXMsIGNvbG9yLCBpbnRlbnNpdHkgKTtcblxuICAgIFx0dGhpcy50eXBlID0gJ1BvaW50TGlnaHQnO1xuXG4gICAgXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsICdwb3dlcicsIHtcbiAgICBcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgXHRcdFx0Ly8gaW50ZW5zaXR5ID0gcG93ZXIgcGVyIHNvbGlkIGFuZ2xlLlxuICAgIFx0XHRcdC8vIHJlZjogZXF1YXRpb24gKDE1KSBmcm9tIGh0dHA6Ly93d3cuZnJvc3RiaXRlLmNvbS93cC1jb250ZW50L3VwbG9hZHMvMjAxNC8xMS9jb3Vyc2Vfbm90ZXNfbW92aW5nX2Zyb3N0Yml0ZV90b19wYnIucGRmXG4gICAgXHRcdFx0cmV0dXJuIHRoaXMuaW50ZW5zaXR5ICogNCAqIE1hdGguUEk7XG5cbiAgICBcdFx0fSxcbiAgICBcdFx0c2V0OiBmdW5jdGlvbiAoIHBvd2VyICkge1xuICAgIFx0XHRcdC8vIGludGVuc2l0eSA9IHBvd2VyIHBlciBzb2xpZCBhbmdsZS5cbiAgICBcdFx0XHQvLyByZWY6IGVxdWF0aW9uICgxNSkgZnJvbSBodHRwOi8vd3d3LmZyb3N0Yml0ZS5jb20vd3AtY29udGVudC91cGxvYWRzLzIwMTQvMTEvY291cnNlX25vdGVzX21vdmluZ19mcm9zdGJpdGVfdG9fcGJyLnBkZlxuICAgIFx0XHRcdHRoaXMuaW50ZW5zaXR5ID0gcG93ZXIgLyAoIDQgKiBNYXRoLlBJICk7XG4gICAgXHRcdH1cbiAgICBcdH0gKTtcblxuICAgIFx0dGhpcy5kaXN0YW5jZSA9ICggZGlzdGFuY2UgIT09IHVuZGVmaW5lZCApID8gZGlzdGFuY2UgOiAwO1xuICAgIFx0dGhpcy5kZWNheSA9ICggZGVjYXkgIT09IHVuZGVmaW5lZCApID8gZGVjYXkgOiAxO1x0Ly8gZm9yIHBoeXNpY2FsbHkgY29ycmVjdCBsaWdodHMsIHNob3VsZCBiZSAyLlxuXG4gICAgXHR0aGlzLnNoYWRvdyA9IG5ldyBMaWdodFNoYWRvdyggbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKCA5MCwgMSwgMC41LCA1MDAgKSApO1xuXG4gICAgfVxuXG4gICAgUG9pbnRMaWdodC5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBMaWdodC5wcm90b3R5cGUgKSwge1xuXG4gICAgXHRjb25zdHJ1Y3RvcjogUG9pbnRMaWdodCxcblxuICAgIFx0aXNQb2ludExpZ2h0OiB0cnVlLFxuXG4gICAgXHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcblxuICAgIFx0XHRMaWdodC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcblxuICAgIFx0XHR0aGlzLmRpc3RhbmNlID0gc291cmNlLmRpc3RhbmNlO1xuICAgIFx0XHR0aGlzLmRlY2F5ID0gc291cmNlLmRlY2F5O1xuXG4gICAgXHRcdHRoaXMuc2hhZG93ID0gc291cmNlLnNoYWRvdy5jbG9uZSgpO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9XG5cbiAgICB9ICk7XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gRGlyZWN0aW9uYWxMaWdodFNoYWRvdyggbGlnaHQgKSB7XG5cbiAgICBcdExpZ2h0U2hhZG93LmNhbGwoIHRoaXMsIG5ldyBPcnRob2dyYXBoaWNDYW1lcmEoIC0gNSwgNSwgNSwgLSA1LCAwLjUsIDUwMCApICk7XG5cbiAgICB9XG5cbiAgICBEaXJlY3Rpb25hbExpZ2h0U2hhZG93LnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIExpZ2h0U2hhZG93LnByb3RvdHlwZSApLCB7XG5cbiAgICBcdGNvbnN0cnVjdG9yOiBEaXJlY3Rpb25hbExpZ2h0U2hhZG93XG5cbiAgICB9ICk7XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICAgICAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBEaXJlY3Rpb25hbExpZ2h0KCBjb2xvciwgaW50ZW5zaXR5ICkge1xuXG4gICAgXHRMaWdodC5jYWxsKCB0aGlzLCBjb2xvciwgaW50ZW5zaXR5ICk7XG5cbiAgICBcdHRoaXMudHlwZSA9ICdEaXJlY3Rpb25hbExpZ2h0JztcblxuICAgIFx0dGhpcy5wb3NpdGlvbi5jb3B5KCBPYmplY3QzRC5EZWZhdWx0VXAgKTtcbiAgICBcdHRoaXMudXBkYXRlTWF0cml4KCk7XG5cbiAgICBcdHRoaXMudGFyZ2V0ID0gbmV3IE9iamVjdDNEKCk7XG5cbiAgICBcdHRoaXMuc2hhZG93ID0gbmV3IERpcmVjdGlvbmFsTGlnaHRTaGFkb3coKTtcblxuICAgIH1cblxuICAgIERpcmVjdGlvbmFsTGlnaHQucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggTGlnaHQucHJvdG90eXBlICksIHtcblxuICAgIFx0Y29uc3RydWN0b3I6IERpcmVjdGlvbmFsTGlnaHQsXG5cbiAgICBcdGlzRGlyZWN0aW9uYWxMaWdodDogdHJ1ZSxcblxuICAgIFx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cbiAgICBcdFx0TGlnaHQucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XG5cbiAgICBcdFx0dGhpcy50YXJnZXQgPSBzb3VyY2UudGFyZ2V0LmNsb25lKCk7XG5cbiAgICBcdFx0dGhpcy5zaGFkb3cgPSBzb3VyY2Uuc2hhZG93LmNsb25lKCk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH1cblxuICAgIH0gKTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBBbWJpZW50TGlnaHQoIGNvbG9yLCBpbnRlbnNpdHkgKSB7XG5cbiAgICBcdExpZ2h0LmNhbGwoIHRoaXMsIGNvbG9yLCBpbnRlbnNpdHkgKTtcblxuICAgIFx0dGhpcy50eXBlID0gJ0FtYmllbnRMaWdodCc7XG5cbiAgICBcdHRoaXMuY2FzdFNoYWRvdyA9IHVuZGVmaW5lZDtcblxuICAgIH1cblxuICAgIEFtYmllbnRMaWdodC5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBMaWdodC5wcm90b3R5cGUgKSwge1xuXG4gICAgXHRjb25zdHJ1Y3RvcjogQW1iaWVudExpZ2h0LFxuXG4gICAgXHRpc0FtYmllbnRMaWdodDogdHJ1ZSxcblxuICAgIH0gKTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgdHNjaHdcbiAgICAgKiBAYXV0aG9yIEJlbiBIb3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvL1xuICAgICAqIEBhdXRob3IgRGF2aWQgU2Fybm8gLyBodHRwOi8vbGlnaHRoYXVzLnVzL1xuICAgICAqL1xuXG4gICAgZXhwb3J0cy5BbmltYXRpb25VdGlscyA9IHtcblxuICAgIFx0Ly8gc2FtZSBhcyBBcnJheS5wcm90b3R5cGUuc2xpY2UsIGJ1dCBhbHNvIHdvcmtzIG9uIHR5cGVkIGFycmF5c1xuICAgIFx0YXJyYXlTbGljZTogZnVuY3Rpb24oIGFycmF5LCBmcm9tLCB0byApIHtcblxuICAgIFx0XHRpZiAoIGV4cG9ydHMuQW5pbWF0aW9uVXRpbHMuaXNUeXBlZEFycmF5KCBhcnJheSApICkge1xuXG4gICAgXHRcdFx0cmV0dXJuIG5ldyBhcnJheS5jb25zdHJ1Y3RvciggYXJyYXkuc3ViYXJyYXkoIGZyb20sIHRvICkgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIGFycmF5LnNsaWNlKCBmcm9tLCB0byApO1xuXG4gICAgXHR9LFxuXG4gICAgXHQvLyBjb252ZXJ0cyBhbiBhcnJheSB0byBhIHNwZWNpZmljIHR5cGVcbiAgICBcdGNvbnZlcnRBcnJheTogZnVuY3Rpb24oIGFycmF5LCB0eXBlLCBmb3JjZUNsb25lICkge1xuXG4gICAgXHRcdGlmICggISBhcnJheSB8fCAvLyBsZXQgJ3VuZGVmaW5lZCcgYW5kICdudWxsJyBwYXNzXG4gICAgXHRcdFx0XHQhIGZvcmNlQ2xvbmUgJiYgYXJyYXkuY29uc3RydWN0b3IgPT09IHR5cGUgKSByZXR1cm4gYXJyYXk7XG5cbiAgICBcdFx0aWYgKCB0eXBlb2YgdHlwZS5CWVRFU19QRVJfRUxFTUVOVCA9PT0gJ251bWJlcicgKSB7XG5cbiAgICBcdFx0XHRyZXR1cm4gbmV3IHR5cGUoIGFycmF5ICk7IC8vIGNyZWF0ZSB0eXBlZCBhcnJheVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGFycmF5ICk7IC8vIGNyZWF0ZSBBcnJheVxuXG4gICAgXHR9LFxuXG4gICAgXHRpc1R5cGVkQXJyYXk6IGZ1bmN0aW9uKCBvYmplY3QgKSB7XG5cbiAgICBcdFx0cmV0dXJuIEFycmF5QnVmZmVyLmlzVmlldyggb2JqZWN0ICkgJiZcbiAgICBcdFx0XHRcdCEgKCBvYmplY3QgaW5zdGFuY2VvZiBEYXRhVmlldyApO1xuXG4gICAgXHR9LFxuXG4gICAgXHQvLyByZXR1cm5zIGFuIGFycmF5IGJ5IHdoaWNoIHRpbWVzIGFuZCB2YWx1ZXMgY2FuIGJlIHNvcnRlZFxuICAgIFx0Z2V0S2V5ZnJhbWVPcmRlcjogZnVuY3Rpb24oIHRpbWVzICkge1xuXG4gICAgXHRcdGZ1bmN0aW9uIGNvbXBhcmVUaW1lKCBpLCBqICkge1xuXG4gICAgXHRcdFx0cmV0dXJuIHRpbWVzWyBpIF0gLSB0aW1lc1sgaiBdO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHR2YXIgbiA9IHRpbWVzLmxlbmd0aDtcbiAgICBcdFx0dmFyIHJlc3VsdCA9IG5ldyBBcnJheSggbiApO1xuICAgIFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgIT09IG47ICsrIGkgKSByZXN1bHRbIGkgXSA9IGk7XG5cbiAgICBcdFx0cmVzdWx0LnNvcnQoIGNvbXBhcmVUaW1lICk7XG5cbiAgICBcdFx0cmV0dXJuIHJlc3VsdDtcblxuICAgIFx0fSxcblxuICAgIFx0Ly8gdXNlcyB0aGUgYXJyYXkgcHJldmlvdXNseSByZXR1cm5lZCBieSAnZ2V0S2V5ZnJhbWVPcmRlcicgdG8gc29ydCBkYXRhXG4gICAgXHRzb3J0ZWRBcnJheTogZnVuY3Rpb24oIHZhbHVlcywgc3RyaWRlLCBvcmRlciApIHtcblxuICAgIFx0XHR2YXIgblZhbHVlcyA9IHZhbHVlcy5sZW5ndGg7XG4gICAgXHRcdHZhciByZXN1bHQgPSBuZXcgdmFsdWVzLmNvbnN0cnVjdG9yKCBuVmFsdWVzICk7XG5cbiAgICBcdFx0Zm9yICggdmFyIGkgPSAwLCBkc3RPZmZzZXQgPSAwOyBkc3RPZmZzZXQgIT09IG5WYWx1ZXM7ICsrIGkgKSB7XG5cbiAgICBcdFx0XHR2YXIgc3JjT2Zmc2V0ID0gb3JkZXJbIGkgXSAqIHN0cmlkZTtcblxuICAgIFx0XHRcdGZvciAoIHZhciBqID0gMDsgaiAhPT0gc3RyaWRlOyArKyBqICkge1xuXG4gICAgXHRcdFx0XHRyZXN1bHRbIGRzdE9mZnNldCArKyBdID0gdmFsdWVzWyBzcmNPZmZzZXQgKyBqIF07XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiByZXN1bHQ7XG5cbiAgICBcdH0sXG5cbiAgICBcdC8vIGZ1bmN0aW9uIGZvciBwYXJzaW5nIEFPUyBrZXlmcmFtZSBmb3JtYXRzXG4gICAgXHRmbGF0dGVuSlNPTjogZnVuY3Rpb24oIGpzb25LZXlzLCB0aW1lcywgdmFsdWVzLCB2YWx1ZVByb3BlcnR5TmFtZSApIHtcblxuICAgIFx0XHR2YXIgaSA9IDEsIGtleSA9IGpzb25LZXlzWyAwIF07XG5cbiAgICBcdFx0d2hpbGUgKCBrZXkgIT09IHVuZGVmaW5lZCAmJiBrZXlbIHZhbHVlUHJvcGVydHlOYW1lIF0gPT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdGtleSA9IGpzb25LZXlzWyBpICsrIF07XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgKSByZXR1cm47IC8vIG5vIGRhdGFcblxuICAgIFx0XHR2YXIgdmFsdWUgPSBrZXlbIHZhbHVlUHJvcGVydHlOYW1lIF07XG4gICAgXHRcdGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCApIHJldHVybjsgLy8gbm8gZGF0YVxuXG4gICAgXHRcdGlmICggQXJyYXkuaXNBcnJheSggdmFsdWUgKSApIHtcblxuICAgIFx0XHRcdGRvIHtcblxuICAgIFx0XHRcdFx0dmFsdWUgPSBrZXlbIHZhbHVlUHJvcGVydHlOYW1lIF07XG5cbiAgICBcdFx0XHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0XHR0aW1lcy5wdXNoKCBrZXkudGltZSApO1xuICAgIFx0XHRcdFx0XHR2YWx1ZXMucHVzaC5hcHBseSggdmFsdWVzLCB2YWx1ZSApOyAvLyBwdXNoIGFsbCBlbGVtZW50c1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdGtleSA9IGpzb25LZXlzWyBpICsrIF07XG5cbiAgICBcdFx0XHR9IHdoaWxlICgga2V5ICE9PSB1bmRlZmluZWQgKTtcblxuICAgIFx0XHR9IGVsc2UgaWYgKCB2YWx1ZS50b0FycmF5ICE9PSB1bmRlZmluZWQgKSB7XG4gICAgXHRcdFx0Ly8gLi4uYXNzdW1lIFRIUkVFLk1hdGgtaXNoXG5cbiAgICBcdFx0XHRkbyB7XG5cbiAgICBcdFx0XHRcdHZhbHVlID0ga2V5WyB2YWx1ZVByb3BlcnR5TmFtZSBdO1xuXG4gICAgXHRcdFx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRcdFx0dGltZXMucHVzaCgga2V5LnRpbWUgKTtcbiAgICBcdFx0XHRcdFx0dmFsdWUudG9BcnJheSggdmFsdWVzLCB2YWx1ZXMubGVuZ3RoICk7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0a2V5ID0ganNvbktleXNbIGkgKysgXTtcblxuICAgIFx0XHRcdH0gd2hpbGUgKCBrZXkgIT09IHVuZGVmaW5lZCApO1xuXG4gICAgXHRcdH0gZWxzZSB7XG4gICAgXHRcdFx0Ly8gb3RoZXJ3aXNlIHB1c2ggYXMtaXNcblxuICAgIFx0XHRcdGRvIHtcblxuICAgIFx0XHRcdFx0dmFsdWUgPSBrZXlbIHZhbHVlUHJvcGVydHlOYW1lIF07XG5cbiAgICBcdFx0XHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0XHR0aW1lcy5wdXNoKCBrZXkudGltZSApO1xuICAgIFx0XHRcdFx0XHR2YWx1ZXMucHVzaCggdmFsdWUgKTtcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHRrZXkgPSBqc29uS2V5c1sgaSArKyBdO1xuXG4gICAgXHRcdFx0fSB3aGlsZSAoIGtleSAhPT0gdW5kZWZpbmVkICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9XG5cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQWJzdHJhY3QgYmFzZSBjbGFzcyBvZiBpbnRlcnBvbGFudHMgb3ZlciBwYXJhbWV0cmljIHNhbXBsZXMuXG4gICAgICpcbiAgICAgKiBUaGUgcGFyYW1ldGVyIGRvbWFpbiBpcyBvbmUgZGltZW5zaW9uYWwsIHR5cGljYWxseSB0aGUgdGltZSBvciBhIHBhdGhcbiAgICAgKiBhbG9uZyBhIGN1cnZlIGRlZmluZWQgYnkgdGhlIGRhdGEuXG4gICAgICpcbiAgICAgKiBUaGUgc2FtcGxlIHZhbHVlcyBjYW4gaGF2ZSBhbnkgZGltZW5zaW9uYWxpdHkgYW5kIGRlcml2ZWQgY2xhc3NlcyBtYXlcbiAgICAgKiBhcHBseSBzcGVjaWFsIGludGVycHJldGF0aW9ucyB0byB0aGUgZGF0YS5cbiAgICAgKlxuICAgICAqIFRoaXMgY2xhc3MgcHJvdmlkZXMgdGhlIGludGVydmFsIHNlZWsgaW4gYSBUZW1wbGF0ZSBNZXRob2QsIGRlZmVycmluZ1xuICAgICAqIHRoZSBhY3R1YWwgaW50ZXJwb2xhdGlvbiB0byBkZXJpdmVkIGNsYXNzZXMuXG4gICAgICpcbiAgICAgKiBUaW1lIGNvbXBsZXhpdHkgaXMgTygxKSBmb3IgbGluZWFyIGFjY2VzcyBjcm9zc2luZyBhdCBtb3N0IHR3byBwb2ludHNcbiAgICAgKiBhbmQgTyhsb2cgTikgZm9yIHJhbmRvbSBhY2Nlc3MsIHdoZXJlIE4gaXMgdGhlIG51bWJlciBvZiBwb3NpdGlvbnMuXG4gICAgICpcbiAgICAgKiBSZWZlcmVuY2VzOlxuICAgICAqXG4gICAgICogXHRcdGh0dHA6Ly93d3cub29kZXNpZ24uY29tL3RlbXBsYXRlLW1ldGhvZC1wYXR0ZXJuLmh0bWxcbiAgICAgKlxuICAgICAqIEBhdXRob3IgdHNjaHdcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIEludGVycG9sYW50KFxuICAgIFx0XHRwYXJhbWV0ZXJQb3NpdGlvbnMsIHNhbXBsZVZhbHVlcywgc2FtcGxlU2l6ZSwgcmVzdWx0QnVmZmVyICkge1xuXG4gICAgXHR0aGlzLnBhcmFtZXRlclBvc2l0aW9ucyA9IHBhcmFtZXRlclBvc2l0aW9ucztcbiAgICBcdHRoaXMuX2NhY2hlZEluZGV4ID0gMDtcblxuICAgIFx0dGhpcy5yZXN1bHRCdWZmZXIgPSByZXN1bHRCdWZmZXIgIT09IHVuZGVmaW5lZCA/XG4gICAgXHRcdFx0cmVzdWx0QnVmZmVyIDogbmV3IHNhbXBsZVZhbHVlcy5jb25zdHJ1Y3Rvciggc2FtcGxlU2l6ZSApO1xuICAgIFx0dGhpcy5zYW1wbGVWYWx1ZXMgPSBzYW1wbGVWYWx1ZXM7XG4gICAgXHR0aGlzLnZhbHVlU2l6ZSA9IHNhbXBsZVNpemU7XG5cbiAgICB9XG5cbiAgICBJbnRlcnBvbGFudC5wcm90b3R5cGUgPSB7XG5cbiAgICBcdGNvbnN0cnVjdG9yOiBJbnRlcnBvbGFudCxcblxuICAgIFx0ZXZhbHVhdGU6IGZ1bmN0aW9uKCB0ICkge1xuXG4gICAgXHRcdHZhciBwcCA9IHRoaXMucGFyYW1ldGVyUG9zaXRpb25zLFxuICAgIFx0XHRcdGkxID0gdGhpcy5fY2FjaGVkSW5kZXgsXG5cbiAgICBcdFx0XHR0MSA9IHBwWyAgIGkxICAgXSxcbiAgICBcdFx0XHR0MCA9IHBwWyBpMSAtIDEgXTtcblxuICAgIFx0XHR2YWxpZGF0ZV9pbnRlcnZhbDoge1xuXG4gICAgXHRcdFx0c2Vlazoge1xuXG4gICAgXHRcdFx0XHR2YXIgcmlnaHQ7XG5cbiAgICBcdFx0XHRcdGxpbmVhcl9zY2FuOiB7XG4gICAgLy8tIFNlZSBodHRwOi8vanNwZXJmLmNvbS9jb21wYXJpc29uLXRvLXVuZGVmaW5lZC8zXG4gICAgLy8tIHNsb3dlciBjb2RlOlxuICAgIC8vLVxuICAgIC8vLSBcdFx0XHRcdGlmICggdCA+PSB0MSB8fCB0MSA9PT0gdW5kZWZpbmVkICkge1xuICAgIFx0XHRcdFx0XHRmb3J3YXJkX3NjYW46IGlmICggISAoIHQgPCB0MSApICkge1xuXG4gICAgXHRcdFx0XHRcdFx0Zm9yICggdmFyIGdpdmVVcEF0ID0gaTEgKyAyOyA7KSB7XG5cbiAgICBcdFx0XHRcdFx0XHRcdGlmICggdDEgPT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0XHRcdFx0XHRpZiAoIHQgPCB0MCApIGJyZWFrIGZvcndhcmRfc2NhbjtcblxuICAgIFx0XHRcdFx0XHRcdFx0XHQvLyBhZnRlciBlbmRcblxuICAgIFx0XHRcdFx0XHRcdFx0XHRpMSA9IHBwLmxlbmd0aDtcbiAgICBcdFx0XHRcdFx0XHRcdFx0dGhpcy5fY2FjaGVkSW5kZXggPSBpMTtcbiAgICBcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMuYWZ0ZXJFbmRfKCBpMSAtIDEsIHQsIHQwICk7XG5cbiAgICBcdFx0XHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0XHRcdFx0aWYgKCBpMSA9PT0gZ2l2ZVVwQXQgKSBicmVhazsgLy8gdGhpcyBsb29wXG5cbiAgICBcdFx0XHRcdFx0XHRcdHQwID0gdDE7XG4gICAgXHRcdFx0XHRcdFx0XHR0MSA9IHBwWyArKyBpMSBdO1xuXG4gICAgXHRcdFx0XHRcdFx0XHRpZiAoIHQgPCB0MSApIHtcblxuICAgIFx0XHRcdFx0XHRcdFx0XHQvLyB3ZSBoYXZlIGFycml2ZWQgYXQgdGhlIHNvdWdodCBpbnRlcnZhbFxuICAgIFx0XHRcdFx0XHRcdFx0XHRicmVhayBzZWVrO1xuXG4gICAgXHRcdFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdFx0XHQvLyBwcmVwYXJlIGJpbmFyeSBzZWFyY2ggb24gdGhlIHJpZ2h0IHNpZGUgb2YgdGhlIGluZGV4XG4gICAgXHRcdFx0XHRcdFx0cmlnaHQgPSBwcC5sZW5ndGg7XG4gICAgXHRcdFx0XHRcdFx0YnJlYWsgbGluZWFyX3NjYW47XG5cbiAgICBcdFx0XHRcdFx0fVxuXG4gICAgLy8tIHNsb3dlciBjb2RlOlxuICAgIC8vLVx0XHRcdFx0XHRpZiAoIHQgPCB0MCB8fCB0MCA9PT0gdW5kZWZpbmVkICkge1xuICAgIFx0XHRcdFx0XHRpZiAoICEgKCB0ID49IHQwICkgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHQvLyBsb29waW5nP1xuXG4gICAgXHRcdFx0XHRcdFx0dmFyIHQxZ2xvYmFsID0gcHBbIDEgXTtcblxuICAgIFx0XHRcdFx0XHRcdGlmICggdCA8IHQxZ2xvYmFsICkge1xuXG4gICAgXHRcdFx0XHRcdFx0XHRpMSA9IDI7IC8vICsgMSwgdXNpbmcgdGhlIHNjYW4gZm9yIHRoZSBkZXRhaWxzXG4gICAgXHRcdFx0XHRcdFx0XHR0MCA9IHQxZ2xvYmFsO1xuXG4gICAgXHRcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHRcdFx0Ly8gbGluZWFyIHJldmVyc2Ugc2NhblxuXG4gICAgXHRcdFx0XHRcdFx0Zm9yICggdmFyIGdpdmVVcEF0ID0gaTEgLSAyOyA7KSB7XG5cbiAgICBcdFx0XHRcdFx0XHRcdGlmICggdDAgPT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0XHRcdFx0XHQvLyBiZWZvcmUgc3RhcnRcblxuICAgIFx0XHRcdFx0XHRcdFx0XHR0aGlzLl9jYWNoZWRJbmRleCA9IDA7XG4gICAgXHRcdFx0XHRcdFx0XHRcdHJldHVybiB0aGlzLmJlZm9yZVN0YXJ0XyggMCwgdCwgdDEgKTtcblxuICAgIFx0XHRcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHRcdFx0XHRpZiAoIGkxID09PSBnaXZlVXBBdCApIGJyZWFrOyAvLyB0aGlzIGxvb3BcblxuICAgIFx0XHRcdFx0XHRcdFx0dDEgPSB0MDtcbiAgICBcdFx0XHRcdFx0XHRcdHQwID0gcHBbIC0tIGkxIC0gMSBdO1xuXG4gICAgXHRcdFx0XHRcdFx0XHRpZiAoIHQgPj0gdDAgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHRcdFx0Ly8gd2UgaGF2ZSBhcnJpdmVkIGF0IHRoZSBzb3VnaHQgaW50ZXJ2YWxcbiAgICBcdFx0XHRcdFx0XHRcdFx0YnJlYWsgc2VlaztcblxuICAgIFx0XHRcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHRcdFx0Ly8gcHJlcGFyZSBiaW5hcnkgc2VhcmNoIG9uIHRoZSBsZWZ0IHNpZGUgb2YgdGhlIGluZGV4XG4gICAgXHRcdFx0XHRcdFx0cmlnaHQgPSBpMTtcbiAgICBcdFx0XHRcdFx0XHRpMSA9IDA7XG4gICAgXHRcdFx0XHRcdFx0YnJlYWsgbGluZWFyX3NjYW47XG5cbiAgICBcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHRcdC8vIHRoZSBpbnRlcnZhbCBpcyB2YWxpZFxuXG4gICAgXHRcdFx0XHRcdGJyZWFrIHZhbGlkYXRlX2ludGVydmFsO1xuXG4gICAgXHRcdFx0XHR9IC8vIGxpbmVhciBzY2FuXG5cbiAgICBcdFx0XHRcdC8vIGJpbmFyeSBzZWFyY2hcblxuICAgIFx0XHRcdFx0d2hpbGUgKCBpMSA8IHJpZ2h0ICkge1xuXG4gICAgXHRcdFx0XHRcdHZhciBtaWQgPSAoIGkxICsgcmlnaHQgKSA+Pj4gMTtcblxuICAgIFx0XHRcdFx0XHRpZiAoIHQgPCBwcFsgbWlkIF0gKSB7XG5cbiAgICBcdFx0XHRcdFx0XHRyaWdodCA9IG1pZDtcblxuICAgIFx0XHRcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHRcdFx0aTEgPSBtaWQgKyAxO1xuXG4gICAgXHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHR0MSA9IHBwWyAgIGkxICAgXTtcbiAgICBcdFx0XHRcdHQwID0gcHBbIGkxIC0gMSBdO1xuXG4gICAgXHRcdFx0XHQvLyBjaGVjayBib3VuZGFyeSBjYXNlcywgYWdhaW5cblxuICAgIFx0XHRcdFx0aWYgKCB0MCA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0XHRcdHRoaXMuX2NhY2hlZEluZGV4ID0gMDtcbiAgICBcdFx0XHRcdFx0cmV0dXJuIHRoaXMuYmVmb3JlU3RhcnRfKCAwLCB0LCB0MSApO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdGlmICggdDEgPT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0XHRpMSA9IHBwLmxlbmd0aDtcbiAgICBcdFx0XHRcdFx0dGhpcy5fY2FjaGVkSW5kZXggPSBpMTtcbiAgICBcdFx0XHRcdFx0cmV0dXJuIHRoaXMuYWZ0ZXJFbmRfKCBpMSAtIDEsIHQwLCB0ICk7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdH0gLy8gc2Vla1xuXG4gICAgXHRcdFx0dGhpcy5fY2FjaGVkSW5kZXggPSBpMTtcblxuICAgIFx0XHRcdHRoaXMuaW50ZXJ2YWxDaGFuZ2VkXyggaTEsIHQwLCB0MSApO1xuXG4gICAgXHRcdH0gLy8gdmFsaWRhdGVfaW50ZXJ2YWxcblxuICAgIFx0XHRyZXR1cm4gdGhpcy5pbnRlcnBvbGF0ZV8oIGkxLCB0MCwgdCwgdDEgKTtcblxuICAgIFx0fSxcblxuICAgIFx0c2V0dGluZ3M6IG51bGwsIC8vIG9wdGlvbmFsLCBzdWJjbGFzcy1zcGVjaWZpYyBzZXR0aW5ncyBzdHJ1Y3R1cmVcbiAgICBcdC8vIE5vdGU6IFRoZSBpbmRpcmVjdGlvbiBhbGxvd3MgY2VudHJhbCBjb250cm9sIG9mIG1hbnkgaW50ZXJwb2xhbnRzLlxuXG4gICAgXHQvLyAtLS0gUHJvdGVjdGVkIGludGVyZmFjZVxuXG4gICAgXHREZWZhdWx0U2V0dGluZ3NfOiB7fSxcblxuICAgIFx0Z2V0U2V0dGluZ3NfOiBmdW5jdGlvbigpIHtcblxuICAgIFx0XHRyZXR1cm4gdGhpcy5zZXR0aW5ncyB8fCB0aGlzLkRlZmF1bHRTZXR0aW5nc187XG5cbiAgICBcdH0sXG5cbiAgICBcdGNvcHlTYW1wbGVWYWx1ZV86IGZ1bmN0aW9uKCBpbmRleCApIHtcblxuICAgIFx0XHQvLyBjb3BpZXMgYSBzYW1wbGUgdmFsdWUgdG8gdGhlIHJlc3VsdCBidWZmZXJcblxuICAgIFx0XHR2YXIgcmVzdWx0ID0gdGhpcy5yZXN1bHRCdWZmZXIsXG4gICAgXHRcdFx0dmFsdWVzID0gdGhpcy5zYW1wbGVWYWx1ZXMsXG4gICAgXHRcdFx0c3RyaWRlID0gdGhpcy52YWx1ZVNpemUsXG4gICAgXHRcdFx0b2Zmc2V0ID0gaW5kZXggKiBzdHJpZGU7XG5cbiAgICBcdFx0Zm9yICggdmFyIGkgPSAwOyBpICE9PSBzdHJpZGU7ICsrIGkgKSB7XG5cbiAgICBcdFx0XHRyZXN1bHRbIGkgXSA9IHZhbHVlc1sgb2Zmc2V0ICsgaSBdO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gcmVzdWx0O1xuXG4gICAgXHR9LFxuXG4gICAgXHQvLyBUZW1wbGF0ZSBtZXRob2RzIGZvciBkZXJpdmVkIGNsYXNzZXM6XG5cbiAgICBcdGludGVycG9sYXRlXzogZnVuY3Rpb24oIGkxLCB0MCwgdCwgdDEgKSB7XG5cbiAgICBcdFx0dGhyb3cgbmV3IEVycm9yKCBcImNhbGwgdG8gYWJzdHJhY3QgbWV0aG9kXCIgKTtcbiAgICBcdFx0Ly8gaW1wbGVtZW50YXRpb25zIHNoYWxsIHJldHVybiB0aGlzLnJlc3VsdEJ1ZmZlclxuXG4gICAgXHR9LFxuXG4gICAgXHRpbnRlcnZhbENoYW5nZWRfOiBmdW5jdGlvbiggaTEsIHQwLCB0MSApIHtcblxuICAgIFx0XHQvLyBlbXB0eVxuXG4gICAgXHR9XG5cbiAgICB9O1xuXG4gICAgT2JqZWN0LmFzc2lnbiggSW50ZXJwb2xhbnQucHJvdG90eXBlLCB7XG5cbiAgICBcdGJlZm9yZVN0YXJ0XzogLy8oIDAsIHQsIHQwICksIHJldHVybnMgdGhpcy5yZXN1bHRCdWZmZXJcbiAgICBcdFx0SW50ZXJwb2xhbnQucHJvdG90eXBlLmNvcHlTYW1wbGVWYWx1ZV8sXG5cbiAgICBcdGFmdGVyRW5kXzogLy8oIE4tMSwgdE4tMSwgdCApLCByZXR1cm5zIHRoaXMucmVzdWx0QnVmZmVyXG4gICAgXHRcdEludGVycG9sYW50LnByb3RvdHlwZS5jb3B5U2FtcGxlVmFsdWVfXG5cbiAgICB9ICk7XG5cbiAgICAvKipcbiAgICAgKiBGYXN0IGFuZCBzaW1wbGUgY3ViaWMgc3BsaW5lIGludGVycG9sYW50LlxuICAgICAqXG4gICAgICogSXQgd2FzIGRlcml2ZWQgZnJvbSBhIEhlcm1pdGlhbiBjb25zdHJ1Y3Rpb24gc2V0dGluZyB0aGUgZmlyc3QgZGVyaXZhdGl2ZVxuICAgICAqIGF0IGVhY2ggc2FtcGxlIHBvc2l0aW9uIHRvIHRoZSBsaW5lYXIgc2xvcGUgYmV0d2VlbiBuZWlnaGJvcmluZyBwb3NpdGlvbnNcbiAgICAgKiBvdmVyIHRoZWlyIHBhcmFtZXRlciBpbnRlcnZhbC5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgdHNjaHdcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIEN1YmljSW50ZXJwb2xhbnQoXG4gICAgXHRcdHBhcmFtZXRlclBvc2l0aW9ucywgc2FtcGxlVmFsdWVzLCBzYW1wbGVTaXplLCByZXN1bHRCdWZmZXIgKSB7XG5cbiAgICBcdEludGVycG9sYW50LmNhbGwoXG4gICAgXHRcdFx0dGhpcywgcGFyYW1ldGVyUG9zaXRpb25zLCBzYW1wbGVWYWx1ZXMsIHNhbXBsZVNpemUsIHJlc3VsdEJ1ZmZlciApO1xuXG4gICAgXHR0aGlzLl93ZWlnaHRQcmV2ID0gLTA7XG4gICAgXHR0aGlzLl9vZmZzZXRQcmV2ID0gLTA7XG4gICAgXHR0aGlzLl93ZWlnaHROZXh0ID0gLTA7XG4gICAgXHR0aGlzLl9vZmZzZXROZXh0ID0gLTA7XG5cbiAgICB9XG5cbiAgICBDdWJpY0ludGVycG9sYW50LnByb3RvdHlwZSA9XG4gICAgXHRcdE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIEludGVycG9sYW50LnByb3RvdHlwZSApLCB7XG5cbiAgICBcdGNvbnN0cnVjdG9yOiBDdWJpY0ludGVycG9sYW50LFxuXG4gICAgXHREZWZhdWx0U2V0dGluZ3NfOiB7XG5cbiAgICBcdFx0ZW5kaW5nU3RhcnQ6IFx0WmVyb0N1cnZhdHVyZUVuZGluZyxcbiAgICBcdFx0ZW5kaW5nRW5kOlx0XHRaZXJvQ3VydmF0dXJlRW5kaW5nXG5cbiAgICBcdH0sXG5cbiAgICBcdGludGVydmFsQ2hhbmdlZF86IGZ1bmN0aW9uKCBpMSwgdDAsIHQxICkge1xuXG4gICAgXHRcdHZhciBwcCA9IHRoaXMucGFyYW1ldGVyUG9zaXRpb25zLFxuICAgIFx0XHRcdGlQcmV2ID0gaTEgLSAyLFxuICAgIFx0XHRcdGlOZXh0ID0gaTEgKyAxLFxuXG4gICAgXHRcdFx0dFByZXYgPSBwcFsgaVByZXYgXSxcbiAgICBcdFx0XHR0TmV4dCA9IHBwWyBpTmV4dCBdO1xuXG4gICAgXHRcdGlmICggdFByZXYgPT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdHN3aXRjaCAoIHRoaXMuZ2V0U2V0dGluZ3NfKCkuZW5kaW5nU3RhcnQgKSB7XG5cbiAgICBcdFx0XHRcdGNhc2UgWmVyb1Nsb3BlRW5kaW5nOlxuXG4gICAgXHRcdFx0XHRcdC8vIGYnKHQwKSA9IDBcbiAgICBcdFx0XHRcdFx0aVByZXYgPSBpMTtcbiAgICBcdFx0XHRcdFx0dFByZXYgPSAyICogdDAgLSB0MTtcblxuICAgIFx0XHRcdFx0XHRicmVhaztcblxuICAgIFx0XHRcdFx0Y2FzZSBXcmFwQXJvdW5kRW5kaW5nOlxuXG4gICAgXHRcdFx0XHRcdC8vIHVzZSB0aGUgb3RoZXIgZW5kIG9mIHRoZSBjdXJ2ZVxuICAgIFx0XHRcdFx0XHRpUHJldiA9IHBwLmxlbmd0aCAtIDI7XG4gICAgXHRcdFx0XHRcdHRQcmV2ID0gdDAgKyBwcFsgaVByZXYgXSAtIHBwWyBpUHJldiArIDEgXTtcblxuICAgIFx0XHRcdFx0XHRicmVhaztcblxuICAgIFx0XHRcdFx0ZGVmYXVsdDogLy8gWmVyb0N1cnZhdHVyZUVuZGluZ1xuXG4gICAgXHRcdFx0XHRcdC8vIGYnJyh0MCkgPSAwIGEuay5hLiBOYXR1cmFsIFNwbGluZVxuICAgIFx0XHRcdFx0XHRpUHJldiA9IGkxO1xuICAgIFx0XHRcdFx0XHR0UHJldiA9IHQxO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHRpZiAoIHROZXh0ID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRzd2l0Y2ggKCB0aGlzLmdldFNldHRpbmdzXygpLmVuZGluZ0VuZCApIHtcblxuICAgIFx0XHRcdFx0Y2FzZSBaZXJvU2xvcGVFbmRpbmc6XG5cbiAgICBcdFx0XHRcdFx0Ly8gZicodE4pID0gMFxuICAgIFx0XHRcdFx0XHRpTmV4dCA9IGkxO1xuICAgIFx0XHRcdFx0XHR0TmV4dCA9IDIgKiB0MSAtIHQwO1xuXG4gICAgXHRcdFx0XHRcdGJyZWFrO1xuXG4gICAgXHRcdFx0XHRjYXNlIFdyYXBBcm91bmRFbmRpbmc6XG5cbiAgICBcdFx0XHRcdFx0Ly8gdXNlIHRoZSBvdGhlciBlbmQgb2YgdGhlIGN1cnZlXG4gICAgXHRcdFx0XHRcdGlOZXh0ID0gMTtcbiAgICBcdFx0XHRcdFx0dE5leHQgPSB0MSArIHBwWyAxIF0gLSBwcFsgMCBdO1xuXG4gICAgXHRcdFx0XHRcdGJyZWFrO1xuXG4gICAgXHRcdFx0XHRkZWZhdWx0OiAvLyBaZXJvQ3VydmF0dXJlRW5kaW5nXG5cbiAgICBcdFx0XHRcdFx0Ly8gZicnKHROKSA9IDAsIGEuay5hLiBOYXR1cmFsIFNwbGluZVxuICAgIFx0XHRcdFx0XHRpTmV4dCA9IGkxIC0gMTtcbiAgICBcdFx0XHRcdFx0dE5leHQgPSB0MDtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdFx0dmFyIGhhbGZEdCA9ICggdDEgLSB0MCApICogMC41LFxuICAgIFx0XHRcdHN0cmlkZSA9IHRoaXMudmFsdWVTaXplO1xuXG4gICAgXHRcdHRoaXMuX3dlaWdodFByZXYgPSBoYWxmRHQgLyAoIHQwIC0gdFByZXYgKTtcbiAgICBcdFx0dGhpcy5fd2VpZ2h0TmV4dCA9IGhhbGZEdCAvICggdE5leHQgLSB0MSApO1xuICAgIFx0XHR0aGlzLl9vZmZzZXRQcmV2ID0gaVByZXYgKiBzdHJpZGU7XG4gICAgXHRcdHRoaXMuX29mZnNldE5leHQgPSBpTmV4dCAqIHN0cmlkZTtcblxuICAgIFx0fSxcblxuICAgIFx0aW50ZXJwb2xhdGVfOiBmdW5jdGlvbiggaTEsIHQwLCB0LCB0MSApIHtcblxuICAgIFx0XHR2YXIgcmVzdWx0ID0gdGhpcy5yZXN1bHRCdWZmZXIsXG4gICAgXHRcdFx0dmFsdWVzID0gdGhpcy5zYW1wbGVWYWx1ZXMsXG4gICAgXHRcdFx0c3RyaWRlID0gdGhpcy52YWx1ZVNpemUsXG5cbiAgICBcdFx0XHRvMSA9IGkxICogc3RyaWRlLFx0XHRvMCA9IG8xIC0gc3RyaWRlLFxuICAgIFx0XHRcdG9QID0gdGhpcy5fb2Zmc2V0UHJldiwgXHRvTiA9IHRoaXMuX29mZnNldE5leHQsXG4gICAgXHRcdFx0d1AgPSB0aGlzLl93ZWlnaHRQcmV2LFx0d04gPSB0aGlzLl93ZWlnaHROZXh0LFxuXG4gICAgXHRcdFx0cCA9ICggdCAtIHQwICkgLyAoIHQxIC0gdDAgKSxcbiAgICBcdFx0XHRwcCA9IHAgKiBwLFxuICAgIFx0XHRcdHBwcCA9IHBwICogcDtcblxuICAgIFx0XHQvLyBldmFsdWF0ZSBwb2x5bm9taWFsc1xuXG4gICAgXHRcdHZhciBzUCA9ICAgICAtIHdQICAgKiBwcHAgICArICAgICAgICAgMiAqIHdQICAgICogcHAgICAgLSAgICAgICAgICB3UCAgICogcDtcbiAgICBcdFx0dmFyIHMwID0gKCAxICsgd1AgKSAqIHBwcCAgICsgKC0xLjUgLSAyICogd1AgKSAgKiBwcCAgICArICggLTAuNSArIHdQICkgKiBwICAgICArIDE7XG4gICAgXHRcdHZhciBzMSA9ICgtMSAtIHdOICkgKiBwcHAgICArICggMS41ICsgICB3TiAgICkgICogcHAgICAgKyAgICAwLjUgICAgICAgICogcDtcbiAgICBcdFx0dmFyIHNOID0gICAgICAgd04gICAqIHBwcCAgIC0gICAgICAgICAgIHdOICAgICAgKiBwcDtcblxuICAgIFx0XHQvLyBjb21iaW5lIGRhdGEgbGluZWFybHlcblxuICAgIFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgIT09IHN0cmlkZTsgKysgaSApIHtcblxuICAgIFx0XHRcdHJlc3VsdFsgaSBdID1cbiAgICBcdFx0XHRcdFx0c1AgKiB2YWx1ZXNbIG9QICsgaSBdICtcbiAgICBcdFx0XHRcdFx0czAgKiB2YWx1ZXNbIG8wICsgaSBdICtcbiAgICBcdFx0XHRcdFx0czEgKiB2YWx1ZXNbIG8xICsgaSBdICtcbiAgICBcdFx0XHRcdFx0c04gKiB2YWx1ZXNbIG9OICsgaSBdO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gcmVzdWx0O1xuXG4gICAgXHR9XG5cbiAgICB9ICk7XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIHRzY2h3XG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBMaW5lYXJJbnRlcnBvbGFudChcbiAgICBcdFx0cGFyYW1ldGVyUG9zaXRpb25zLCBzYW1wbGVWYWx1ZXMsIHNhbXBsZVNpemUsIHJlc3VsdEJ1ZmZlciApIHtcblxuICAgIFx0SW50ZXJwb2xhbnQuY2FsbChcbiAgICBcdFx0XHR0aGlzLCBwYXJhbWV0ZXJQb3NpdGlvbnMsIHNhbXBsZVZhbHVlcywgc2FtcGxlU2l6ZSwgcmVzdWx0QnVmZmVyICk7XG5cbiAgICB9XG5cbiAgICBMaW5lYXJJbnRlcnBvbGFudC5wcm90b3R5cGUgPVxuICAgIFx0XHRPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBJbnRlcnBvbGFudC5wcm90b3R5cGUgKSwge1xuXG4gICAgXHRjb25zdHJ1Y3RvcjogTGluZWFySW50ZXJwb2xhbnQsXG5cbiAgICBcdGludGVycG9sYXRlXzogZnVuY3Rpb24oIGkxLCB0MCwgdCwgdDEgKSB7XG5cbiAgICBcdFx0dmFyIHJlc3VsdCA9IHRoaXMucmVzdWx0QnVmZmVyLFxuICAgIFx0XHRcdHZhbHVlcyA9IHRoaXMuc2FtcGxlVmFsdWVzLFxuICAgIFx0XHRcdHN0cmlkZSA9IHRoaXMudmFsdWVTaXplLFxuXG4gICAgXHRcdFx0b2Zmc2V0MSA9IGkxICogc3RyaWRlLFxuICAgIFx0XHRcdG9mZnNldDAgPSBvZmZzZXQxIC0gc3RyaWRlLFxuXG4gICAgXHRcdFx0d2VpZ2h0MSA9ICggdCAtIHQwICkgLyAoIHQxIC0gdDAgKSxcbiAgICBcdFx0XHR3ZWlnaHQwID0gMSAtIHdlaWdodDE7XG5cbiAgICBcdFx0Zm9yICggdmFyIGkgPSAwOyBpICE9PSBzdHJpZGU7ICsrIGkgKSB7XG5cbiAgICBcdFx0XHRyZXN1bHRbIGkgXSA9XG4gICAgXHRcdFx0XHRcdHZhbHVlc1sgb2Zmc2V0MCArIGkgXSAqIHdlaWdodDAgK1xuICAgIFx0XHRcdFx0XHR2YWx1ZXNbIG9mZnNldDEgKyBpIF0gKiB3ZWlnaHQxO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gcmVzdWx0O1xuXG4gICAgXHR9XG5cbiAgICB9ICk7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEludGVycG9sYW50IHRoYXQgZXZhbHVhdGVzIHRvIHRoZSBzYW1wbGUgdmFsdWUgYXQgdGhlIHBvc2l0aW9uIHByZWNlZWRpbmdcbiAgICAgKiB0aGUgcGFyYW1ldGVyLlxuICAgICAqXG4gICAgICogQGF1dGhvciB0c2Nod1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gRGlzY3JldGVJbnRlcnBvbGFudChcbiAgICBcdFx0cGFyYW1ldGVyUG9zaXRpb25zLCBzYW1wbGVWYWx1ZXMsIHNhbXBsZVNpemUsIHJlc3VsdEJ1ZmZlciApIHtcblxuICAgIFx0SW50ZXJwb2xhbnQuY2FsbChcbiAgICBcdFx0XHR0aGlzLCBwYXJhbWV0ZXJQb3NpdGlvbnMsIHNhbXBsZVZhbHVlcywgc2FtcGxlU2l6ZSwgcmVzdWx0QnVmZmVyICk7XG5cbiAgICB9XG5cbiAgICBEaXNjcmV0ZUludGVycG9sYW50LnByb3RvdHlwZSA9XG4gICAgXHRcdE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIEludGVycG9sYW50LnByb3RvdHlwZSApLCB7XG5cbiAgICBcdGNvbnN0cnVjdG9yOiBEaXNjcmV0ZUludGVycG9sYW50LFxuXG4gICAgXHRpbnRlcnBvbGF0ZV86IGZ1bmN0aW9uKCBpMSwgdDAsIHQsIHQxICkge1xuXG4gICAgXHRcdHJldHVybiB0aGlzLmNvcHlTYW1wbGVWYWx1ZV8oIGkxIC0gMSApO1xuXG4gICAgXHR9XG5cbiAgICB9ICk7XG5cbiAgICB2YXIgS2V5ZnJhbWVUcmFja1Byb3RvdHlwZTtcblxuICAgIEtleWZyYW1lVHJhY2tQcm90b3R5cGUgPSB7XG5cbiAgICBcdFRpbWVCdWZmZXJUeXBlOiBGbG9hdDMyQXJyYXksXG4gICAgXHRWYWx1ZUJ1ZmZlclR5cGU6IEZsb2F0MzJBcnJheSxcblxuICAgIFx0RGVmYXVsdEludGVycG9sYXRpb246IEludGVycG9sYXRlTGluZWFyLFxuXG4gICAgXHRJbnRlcnBvbGFudEZhY3RvcnlNZXRob2REaXNjcmV0ZTogZnVuY3Rpb24oIHJlc3VsdCApIHtcblxuICAgIFx0XHRyZXR1cm4gbmV3IERpc2NyZXRlSW50ZXJwb2xhbnQoXG4gICAgXHRcdFx0XHR0aGlzLnRpbWVzLCB0aGlzLnZhbHVlcywgdGhpcy5nZXRWYWx1ZVNpemUoKSwgcmVzdWx0ICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdEludGVycG9sYW50RmFjdG9yeU1ldGhvZExpbmVhcjogZnVuY3Rpb24oIHJlc3VsdCApIHtcblxuICAgIFx0XHRyZXR1cm4gbmV3IExpbmVhckludGVycG9sYW50KFxuICAgIFx0XHRcdFx0dGhpcy50aW1lcywgdGhpcy52YWx1ZXMsIHRoaXMuZ2V0VmFsdWVTaXplKCksIHJlc3VsdCApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRJbnRlcnBvbGFudEZhY3RvcnlNZXRob2RTbW9vdGg6IGZ1bmN0aW9uKCByZXN1bHQgKSB7XG5cbiAgICBcdFx0cmV0dXJuIG5ldyBDdWJpY0ludGVycG9sYW50KFxuICAgIFx0XHRcdFx0dGhpcy50aW1lcywgdGhpcy52YWx1ZXMsIHRoaXMuZ2V0VmFsdWVTaXplKCksIHJlc3VsdCApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRzZXRJbnRlcnBvbGF0aW9uOiBmdW5jdGlvbiggaW50ZXJwb2xhdGlvbiApIHtcblxuICAgIFx0XHR2YXIgZmFjdG9yeU1ldGhvZDtcblxuICAgIFx0XHRzd2l0Y2ggKCBpbnRlcnBvbGF0aW9uICkge1xuXG4gICAgXHRcdFx0Y2FzZSBJbnRlcnBvbGF0ZURpc2NyZXRlOlxuXG4gICAgXHRcdFx0XHRmYWN0b3J5TWV0aG9kID0gdGhpcy5JbnRlcnBvbGFudEZhY3RvcnlNZXRob2REaXNjcmV0ZTtcblxuICAgIFx0XHRcdFx0YnJlYWs7XG5cbiAgICBcdFx0XHRjYXNlIEludGVycG9sYXRlTGluZWFyOlxuXG4gICAgXHRcdFx0XHRmYWN0b3J5TWV0aG9kID0gdGhpcy5JbnRlcnBvbGFudEZhY3RvcnlNZXRob2RMaW5lYXI7XG5cbiAgICBcdFx0XHRcdGJyZWFrO1xuXG4gICAgXHRcdFx0Y2FzZSBJbnRlcnBvbGF0ZVNtb290aDpcblxuICAgIFx0XHRcdFx0ZmFjdG9yeU1ldGhvZCA9IHRoaXMuSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kU21vb3RoO1xuXG4gICAgXHRcdFx0XHRicmVhaztcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0aWYgKCBmYWN0b3J5TWV0aG9kID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHR2YXIgbWVzc2FnZSA9IFwidW5zdXBwb3J0ZWQgaW50ZXJwb2xhdGlvbiBmb3IgXCIgK1xuICAgIFx0XHRcdFx0XHR0aGlzLlZhbHVlVHlwZU5hbWUgKyBcIiBrZXlmcmFtZSB0cmFjayBuYW1lZCBcIiArIHRoaXMubmFtZTtcblxuICAgIFx0XHRcdGlmICggdGhpcy5jcmVhdGVJbnRlcnBvbGFudCA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0XHQvLyBmYWxsIGJhY2sgdG8gZGVmYXVsdCwgdW5sZXNzIHRoZSBkZWZhdWx0IGl0c2VsZiBpcyBtZXNzZWQgdXBcbiAgICBcdFx0XHRcdGlmICggaW50ZXJwb2xhdGlvbiAhPT0gdGhpcy5EZWZhdWx0SW50ZXJwb2xhdGlvbiApIHtcblxuICAgIFx0XHRcdFx0XHR0aGlzLnNldEludGVycG9sYXRpb24oIHRoaXMuRGVmYXVsdEludGVycG9sYXRpb24gKTtcblxuICAgIFx0XHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoIG1lc3NhZ2UgKTsgLy8gZmF0YWwsIGluIHRoaXMgY2FzZVxuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRjb25zb2xlLndhcm4oIG1lc3NhZ2UgKTtcbiAgICBcdFx0XHRyZXR1cm47XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHRoaXMuY3JlYXRlSW50ZXJwb2xhbnQgPSBmYWN0b3J5TWV0aG9kO1xuXG4gICAgXHR9LFxuXG4gICAgXHRnZXRJbnRlcnBvbGF0aW9uOiBmdW5jdGlvbigpIHtcblxuICAgIFx0XHRzd2l0Y2ggKCB0aGlzLmNyZWF0ZUludGVycG9sYW50ICkge1xuXG4gICAgXHRcdFx0Y2FzZSB0aGlzLkludGVycG9sYW50RmFjdG9yeU1ldGhvZERpc2NyZXRlOlxuXG4gICAgXHRcdFx0XHRyZXR1cm4gSW50ZXJwb2xhdGVEaXNjcmV0ZTtcblxuICAgIFx0XHRcdGNhc2UgdGhpcy5JbnRlcnBvbGFudEZhY3RvcnlNZXRob2RMaW5lYXI6XG5cbiAgICBcdFx0XHRcdHJldHVybiBJbnRlcnBvbGF0ZUxpbmVhcjtcblxuICAgIFx0XHRcdGNhc2UgdGhpcy5JbnRlcnBvbGFudEZhY3RvcnlNZXRob2RTbW9vdGg6XG5cbiAgICBcdFx0XHRcdHJldHVybiBJbnRlcnBvbGF0ZVNtb290aDtcblxuICAgIFx0XHR9XG5cbiAgICBcdH0sXG5cbiAgICBcdGdldFZhbHVlU2l6ZTogZnVuY3Rpb24oKSB7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMudmFsdWVzLmxlbmd0aCAvIHRoaXMudGltZXMubGVuZ3RoO1xuXG4gICAgXHR9LFxuXG4gICAgXHQvLyBtb3ZlIGFsbCBrZXlmcmFtZXMgZWl0aGVyIGZvcndhcmRzIG9yIGJhY2t3YXJkcyBpbiB0aW1lXG4gICAgXHRzaGlmdDogZnVuY3Rpb24oIHRpbWVPZmZzZXQgKSB7XG5cbiAgICBcdFx0aWYoIHRpbWVPZmZzZXQgIT09IDAuMCApIHtcblxuICAgIFx0XHRcdHZhciB0aW1lcyA9IHRoaXMudGltZXM7XG5cbiAgICBcdFx0XHRmb3IoIHZhciBpID0gMCwgbiA9IHRpbWVzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcblxuICAgIFx0XHRcdFx0dGltZXNbIGkgXSArPSB0aW1lT2Zmc2V0O1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0Ly8gc2NhbGUgYWxsIGtleWZyYW1lIHRpbWVzIGJ5IGEgZmFjdG9yICh1c2VmdWwgZm9yIGZyYW1lIDwtPiBzZWNvbmRzIGNvbnZlcnNpb25zKVxuICAgIFx0c2NhbGU6IGZ1bmN0aW9uKCB0aW1lU2NhbGUgKSB7XG5cbiAgICBcdFx0aWYoIHRpbWVTY2FsZSAhPT0gMS4wICkge1xuXG4gICAgXHRcdFx0dmFyIHRpbWVzID0gdGhpcy50aW1lcztcblxuICAgIFx0XHRcdGZvciggdmFyIGkgPSAwLCBuID0gdGltZXMubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xuXG4gICAgXHRcdFx0XHR0aW1lc1sgaSBdICo9IHRpbWVTY2FsZTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdC8vIHJlbW92ZXMga2V5ZnJhbWVzIGJlZm9yZSBhbmQgYWZ0ZXIgYW5pbWF0aW9uIHdpdGhvdXQgY2hhbmdpbmcgYW55IHZhbHVlcyB3aXRoaW4gdGhlIHJhbmdlIFtzdGFydFRpbWUsIGVuZFRpbWVdLlxuICAgIFx0Ly8gSU1QT1JUQU5UOiBXZSBkbyBub3Qgc2hpZnQgYXJvdW5kIGtleXMgdG8gdGhlIHN0YXJ0IG9mIHRoZSB0cmFjayB0aW1lLCBiZWNhdXNlIGZvciBpbnRlcnBvbGF0ZWQga2V5cyB0aGlzIHdpbGwgY2hhbmdlIHRoZWlyIHZhbHVlc1xuICAgIFx0dHJpbTogZnVuY3Rpb24oIHN0YXJ0VGltZSwgZW5kVGltZSApIHtcblxuICAgIFx0XHR2YXIgdGltZXMgPSB0aGlzLnRpbWVzLFxuICAgIFx0XHRcdG5LZXlzID0gdGltZXMubGVuZ3RoLFxuICAgIFx0XHRcdGZyb20gPSAwLFxuICAgIFx0XHRcdHRvID0gbktleXMgLSAxO1xuXG4gICAgXHRcdHdoaWxlICggZnJvbSAhPT0gbktleXMgJiYgdGltZXNbIGZyb20gXSA8IHN0YXJ0VGltZSApICsrIGZyb207XG4gICAgXHRcdHdoaWxlICggdG8gIT09IC0xICYmIHRpbWVzWyB0byBdID4gZW5kVGltZSApIC0tIHRvO1xuXG4gICAgXHRcdCsrIHRvOyAvLyBpbmNsdXNpdmUgLT4gZXhjbHVzaXZlIGJvdW5kXG5cbiAgICBcdFx0aWYoIGZyb20gIT09IDAgfHwgdG8gIT09IG5LZXlzICkge1xuXG4gICAgXHRcdFx0Ly8gZW1wdHkgdHJhY2tzIGFyZSBmb3JiaWRkZW4sIHNvIGtlZXAgYXQgbGVhc3Qgb25lIGtleWZyYW1lXG4gICAgXHRcdFx0aWYgKCBmcm9tID49IHRvICkgdG8gPSBNYXRoLm1heCggdG8gLCAxICksIGZyb20gPSB0byAtIDE7XG5cbiAgICBcdFx0XHR2YXIgc3RyaWRlID0gdGhpcy5nZXRWYWx1ZVNpemUoKTtcbiAgICBcdFx0XHR0aGlzLnRpbWVzID0gZXhwb3J0cy5BbmltYXRpb25VdGlscy5hcnJheVNsaWNlKCB0aW1lcywgZnJvbSwgdG8gKTtcbiAgICBcdFx0XHR0aGlzLnZhbHVlcyA9IGV4cG9ydHMuQW5pbWF0aW9uVXRpbHMuXG4gICAgXHRcdFx0XHRcdGFycmF5U2xpY2UoIHRoaXMudmFsdWVzLCBmcm9tICogc3RyaWRlLCB0byAqIHN0cmlkZSApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0Ly8gZW5zdXJlIHdlIGRvIG5vdCBnZXQgYSBHYXJiYWdlSW5HYXJiYWdlT3V0IHNpdHVhdGlvbiwgbWFrZSBzdXJlIHRyYWNrcyBhcmUgYXQgbGVhc3QgbWluaW1hbGx5IHZpYWJsZVxuICAgIFx0dmFsaWRhdGU6IGZ1bmN0aW9uKCkge1xuXG4gICAgXHRcdHZhciB2YWxpZCA9IHRydWU7XG5cbiAgICBcdFx0dmFyIHZhbHVlU2l6ZSA9IHRoaXMuZ2V0VmFsdWVTaXplKCk7XG4gICAgXHRcdGlmICggdmFsdWVTaXplIC0gTWF0aC5mbG9vciggdmFsdWVTaXplICkgIT09IDAgKSB7XG5cbiAgICBcdFx0XHRjb25zb2xlLmVycm9yKCBcImludmFsaWQgdmFsdWUgc2l6ZSBpbiB0cmFja1wiLCB0aGlzICk7XG4gICAgXHRcdFx0dmFsaWQgPSBmYWxzZTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0dmFyIHRpbWVzID0gdGhpcy50aW1lcyxcbiAgICBcdFx0XHR2YWx1ZXMgPSB0aGlzLnZhbHVlcyxcblxuICAgIFx0XHRcdG5LZXlzID0gdGltZXMubGVuZ3RoO1xuXG4gICAgXHRcdGlmKCBuS2V5cyA9PT0gMCApIHtcblxuICAgIFx0XHRcdGNvbnNvbGUuZXJyb3IoIFwidHJhY2sgaXMgZW1wdHlcIiwgdGhpcyApO1xuICAgIFx0XHRcdHZhbGlkID0gZmFsc2U7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHZhciBwcmV2VGltZSA9IG51bGw7XG5cbiAgICBcdFx0Zm9yKCB2YXIgaSA9IDA7IGkgIT09IG5LZXlzOyBpICsrICkge1xuXG4gICAgXHRcdFx0dmFyIGN1cnJUaW1lID0gdGltZXNbIGkgXTtcblxuICAgIFx0XHRcdGlmICggdHlwZW9mIGN1cnJUaW1lID09PSAnbnVtYmVyJyAmJiBpc05hTiggY3VyclRpbWUgKSApIHtcblxuICAgIFx0XHRcdFx0Y29uc29sZS5lcnJvciggXCJ0aW1lIGlzIG5vdCBhIHZhbGlkIG51bWJlclwiLCB0aGlzLCBpLCBjdXJyVGltZSApO1xuICAgIFx0XHRcdFx0dmFsaWQgPSBmYWxzZTtcbiAgICBcdFx0XHRcdGJyZWFrO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0aWYoIHByZXZUaW1lICE9PSBudWxsICYmIHByZXZUaW1lID4gY3VyclRpbWUgKSB7XG5cbiAgICBcdFx0XHRcdGNvbnNvbGUuZXJyb3IoIFwib3V0IG9mIG9yZGVyIGtleXNcIiwgdGhpcywgaSwgY3VyclRpbWUsIHByZXZUaW1lICk7XG4gICAgXHRcdFx0XHR2YWxpZCA9IGZhbHNlO1xuICAgIFx0XHRcdFx0YnJlYWs7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRwcmV2VGltZSA9IGN1cnJUaW1lO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRpZiAoIHZhbHVlcyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0aWYgKCBleHBvcnRzLkFuaW1hdGlvblV0aWxzLmlzVHlwZWRBcnJheSggdmFsdWVzICkgKSB7XG5cbiAgICBcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbiA9IHZhbHVlcy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XG5cbiAgICBcdFx0XHRcdFx0dmFyIHZhbHVlID0gdmFsdWVzWyBpIF07XG5cbiAgICBcdFx0XHRcdFx0aWYgKCBpc05hTiggdmFsdWUgKSApIHtcblxuICAgIFx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoIFwidmFsdWUgaXMgbm90IGEgdmFsaWQgbnVtYmVyXCIsIHRoaXMsIGksIHZhbHVlICk7XG4gICAgXHRcdFx0XHRcdFx0dmFsaWQgPSBmYWxzZTtcbiAgICBcdFx0XHRcdFx0XHRicmVhaztcblxuICAgIFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIHZhbGlkO1xuXG4gICAgXHR9LFxuXG4gICAgXHQvLyByZW1vdmVzIGVxdWl2YWxlbnQgc2VxdWVudGlhbCBrZXlzIGFzIGNvbW1vbiBpbiBtb3JwaCB0YXJnZXQgc2VxdWVuY2VzXG4gICAgXHQvLyAoMCwwLDAsMCwxLDEsMSwwLDAsMCwwLDAsMCwwKSAtLT4gKDAsMCwxLDEsMCwwKVxuICAgIFx0b3B0aW1pemU6IGZ1bmN0aW9uKCkge1xuXG4gICAgXHRcdHZhciB0aW1lcyA9IHRoaXMudGltZXMsXG4gICAgXHRcdFx0dmFsdWVzID0gdGhpcy52YWx1ZXMsXG4gICAgXHRcdFx0c3RyaWRlID0gdGhpcy5nZXRWYWx1ZVNpemUoKSxcblxuICAgIFx0XHRcdHNtb290aEludGVycG9sYXRpb24gPSB0aGlzLmdldEludGVycG9sYXRpb24oKSA9PT0gSW50ZXJwb2xhdGVTbW9vdGgsXG5cbiAgICBcdFx0XHR3cml0ZUluZGV4ID0gMSxcbiAgICBcdFx0XHRsYXN0SW5kZXggPSB0aW1lcy5sZW5ndGggLSAxO1xuXG4gICAgXHRcdGZvciggdmFyIGkgPSAxOyBpIDwgbGFzdEluZGV4OyArKyBpICkge1xuXG4gICAgXHRcdFx0dmFyIGtlZXAgPSBmYWxzZTtcblxuICAgIFx0XHRcdHZhciB0aW1lID0gdGltZXNbIGkgXTtcbiAgICBcdFx0XHR2YXIgdGltZU5leHQgPSB0aW1lc1sgaSArIDEgXTtcblxuICAgIFx0XHRcdC8vIHJlbW92ZSBhZGphY2VudCBrZXlmcmFtZXMgc2NoZWR1bGVkIGF0IHRoZSBzYW1lIHRpbWVcblxuICAgIFx0XHRcdGlmICggdGltZSAhPT0gdGltZU5leHQgJiYgKCBpICE9PSAxIHx8IHRpbWUgIT09IHRpbWVbIDAgXSApICkge1xuXG4gICAgXHRcdFx0XHRpZiAoICEgc21vb3RoSW50ZXJwb2xhdGlvbiApIHtcblxuICAgIFx0XHRcdFx0XHQvLyByZW1vdmUgdW5uZWNlc3Nhcnkga2V5ZnJhbWVzIHNhbWUgYXMgdGhlaXIgbmVpZ2hib3JzXG5cbiAgICBcdFx0XHRcdFx0dmFyIG9mZnNldCA9IGkgKiBzdHJpZGUsXG4gICAgXHRcdFx0XHRcdFx0b2Zmc2V0UCA9IG9mZnNldCAtIHN0cmlkZSxcbiAgICBcdFx0XHRcdFx0XHRvZmZzZXROID0gb2Zmc2V0ICsgc3RyaWRlO1xuXG4gICAgXHRcdFx0XHRcdGZvciAoIHZhciBqID0gMDsgaiAhPT0gc3RyaWRlOyArKyBqICkge1xuXG4gICAgXHRcdFx0XHRcdFx0dmFyIHZhbHVlID0gdmFsdWVzWyBvZmZzZXQgKyBqIF07XG5cbiAgICBcdFx0XHRcdFx0XHRpZiAoIHZhbHVlICE9PSB2YWx1ZXNbIG9mZnNldFAgKyBqIF0gfHxcbiAgICBcdFx0XHRcdFx0XHRcdFx0dmFsdWUgIT09IHZhbHVlc1sgb2Zmc2V0TiArIGogXSApIHtcblxuICAgIFx0XHRcdFx0XHRcdFx0a2VlcCA9IHRydWU7XG4gICAgXHRcdFx0XHRcdFx0XHRicmVhaztcblxuICAgIFx0XHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdH0gZWxzZSBrZWVwID0gdHJ1ZTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdC8vIGluLXBsYWNlIGNvbXBhY3Rpb25cblxuICAgIFx0XHRcdGlmICgga2VlcCApIHtcblxuICAgIFx0XHRcdFx0aWYgKCBpICE9PSB3cml0ZUluZGV4ICkge1xuXG4gICAgXHRcdFx0XHRcdHRpbWVzWyB3cml0ZUluZGV4IF0gPSB0aW1lc1sgaSBdO1xuXG4gICAgXHRcdFx0XHRcdHZhciByZWFkT2Zmc2V0ID0gaSAqIHN0cmlkZSxcbiAgICBcdFx0XHRcdFx0XHR3cml0ZU9mZnNldCA9IHdyaXRlSW5kZXggKiBzdHJpZGU7XG5cbiAgICBcdFx0XHRcdFx0Zm9yICggdmFyIGogPSAwOyBqICE9PSBzdHJpZGU7ICsrIGogKVxuXG4gICAgXHRcdFx0XHRcdFx0dmFsdWVzWyB3cml0ZU9mZnNldCArIGogXSA9IHZhbHVlc1sgcmVhZE9mZnNldCArIGogXTtcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHQrKyB3cml0ZUluZGV4O1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHQvLyBmbHVzaCBsYXN0IGtleWZyYW1lIChjb21wYWN0aW9uIGxvb2tzIGFoZWFkKVxuXG4gICAgXHRcdGlmICggbGFzdEluZGV4ID4gMCApIHtcblxuICAgIFx0XHRcdHRpbWVzWyB3cml0ZUluZGV4IF0gPSB0aW1lc1sgbGFzdEluZGV4IF07XG5cbiAgICBcdFx0XHRmb3IgKCB2YXIgcmVhZE9mZnNldCA9IGxhc3RJbmRleCAqIHN0cmlkZSwgd3JpdGVPZmZzZXQgPSB3cml0ZUluZGV4ICogc3RyaWRlLCBqID0gMDsgaiAhPT0gc3RyaWRlOyArKyBqIClcblxuICAgIFx0XHRcdFx0dmFsdWVzWyB3cml0ZU9mZnNldCArIGogXSA9IHZhbHVlc1sgcmVhZE9mZnNldCArIGogXTtcblxuICAgIFx0XHRcdCsrIHdyaXRlSW5kZXg7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGlmICggd3JpdGVJbmRleCAhPT0gdGltZXMubGVuZ3RoICkge1xuXG4gICAgXHRcdFx0dGhpcy50aW1lcyA9IGV4cG9ydHMuQW5pbWF0aW9uVXRpbHMuYXJyYXlTbGljZSggdGltZXMsIDAsIHdyaXRlSW5kZXggKTtcbiAgICBcdFx0XHR0aGlzLnZhbHVlcyA9IGV4cG9ydHMuQW5pbWF0aW9uVXRpbHMuYXJyYXlTbGljZSggdmFsdWVzLCAwLCB3cml0ZUluZGV4ICogc3RyaWRlICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBLZXlmcmFtZVRyYWNrQ29uc3RydWN0b3IoIG5hbWUsIHRpbWVzLCB2YWx1ZXMsIGludGVycG9sYXRpb24gKSB7XG5cbiAgICBcdGlmKCBuYW1lID09PSB1bmRlZmluZWQgKSB0aHJvdyBuZXcgRXJyb3IoIFwidHJhY2sgbmFtZSBpcyB1bmRlZmluZWRcIiApO1xuXG4gICAgXHRpZiggdGltZXMgPT09IHVuZGVmaW5lZCB8fCB0aW1lcy5sZW5ndGggPT09IDAgKSB7XG5cbiAgICBcdFx0dGhyb3cgbmV3IEVycm9yKCBcIm5vIGtleWZyYW1lcyBpbiB0cmFjayBuYW1lZCBcIiArIG5hbWUgKTtcblxuICAgIFx0fVxuXG4gICAgXHR0aGlzLm5hbWUgPSBuYW1lO1xuXG4gICAgXHR0aGlzLnRpbWVzID0gZXhwb3J0cy5BbmltYXRpb25VdGlscy5jb252ZXJ0QXJyYXkoIHRpbWVzLCB0aGlzLlRpbWVCdWZmZXJUeXBlICk7XG4gICAgXHR0aGlzLnZhbHVlcyA9IGV4cG9ydHMuQW5pbWF0aW9uVXRpbHMuY29udmVydEFycmF5KCB2YWx1ZXMsIHRoaXMuVmFsdWVCdWZmZXJUeXBlICk7XG5cbiAgICBcdHRoaXMuc2V0SW50ZXJwb2xhdGlvbiggaW50ZXJwb2xhdGlvbiB8fCB0aGlzLkRlZmF1bHRJbnRlcnBvbGF0aW9uICk7XG5cbiAgICBcdHRoaXMudmFsaWRhdGUoKTtcbiAgICBcdHRoaXMub3B0aW1pemUoKTtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQSBUcmFjayBvZiB2ZWN0b3JlZCBrZXlmcmFtZSB2YWx1ZXMuXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBhdXRob3IgQmVuIEhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW8vXG4gICAgICogQGF1dGhvciBEYXZpZCBTYXJubyAvIGh0dHA6Ly9saWdodGhhdXMudXMvXG4gICAgICogQGF1dGhvciB0c2Nod1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gVmVjdG9yS2V5ZnJhbWVUcmFjayggbmFtZSwgdGltZXMsIHZhbHVlcywgaW50ZXJwb2xhdGlvbiApIHtcblxuICAgIFx0S2V5ZnJhbWVUcmFja0NvbnN0cnVjdG9yLmNhbGwoIHRoaXMsIG5hbWUsIHRpbWVzLCB2YWx1ZXMsIGludGVycG9sYXRpb24gKTtcblxuICAgIH1cblxuICAgIFZlY3RvcktleWZyYW1lVHJhY2sucHJvdG90eXBlID1cbiAgICBcdFx0T2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggS2V5ZnJhbWVUcmFja1Byb3RvdHlwZSApLCB7XG5cbiAgICBcdGNvbnN0cnVjdG9yOiBWZWN0b3JLZXlmcmFtZVRyYWNrLFxuXG4gICAgXHRWYWx1ZVR5cGVOYW1lOiAndmVjdG9yJ1xuXG4gICAgXHQvLyBWYWx1ZUJ1ZmZlclR5cGUgaXMgaW5oZXJpdGVkXG5cbiAgICBcdC8vIERlZmF1bHRJbnRlcnBvbGF0aW9uIGlzIGluaGVyaXRlZFxuXG4gICAgfSApO1xuXG4gICAgLyoqXG4gICAgICogU3BoZXJpY2FsIGxpbmVhciB1bml0IHF1YXRlcm5pb24gaW50ZXJwb2xhbnQuXG4gICAgICpcbiAgICAgKiBAYXV0aG9yIHRzY2h3XG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBRdWF0ZXJuaW9uTGluZWFySW50ZXJwb2xhbnQoXG4gICAgXHRcdHBhcmFtZXRlclBvc2l0aW9ucywgc2FtcGxlVmFsdWVzLCBzYW1wbGVTaXplLCByZXN1bHRCdWZmZXIgKSB7XG5cbiAgICBcdEludGVycG9sYW50LmNhbGwoXG4gICAgXHRcdFx0dGhpcywgcGFyYW1ldGVyUG9zaXRpb25zLCBzYW1wbGVWYWx1ZXMsIHNhbXBsZVNpemUsIHJlc3VsdEJ1ZmZlciApO1xuXG4gICAgfVxuXG4gICAgUXVhdGVybmlvbkxpbmVhckludGVycG9sYW50LnByb3RvdHlwZSA9XG4gICAgXHRcdE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIEludGVycG9sYW50LnByb3RvdHlwZSApLCB7XG5cbiAgICBcdGNvbnN0cnVjdG9yOiBRdWF0ZXJuaW9uTGluZWFySW50ZXJwb2xhbnQsXG5cbiAgICBcdGludGVycG9sYXRlXzogZnVuY3Rpb24oIGkxLCB0MCwgdCwgdDEgKSB7XG5cbiAgICBcdFx0dmFyIHJlc3VsdCA9IHRoaXMucmVzdWx0QnVmZmVyLFxuICAgIFx0XHRcdHZhbHVlcyA9IHRoaXMuc2FtcGxlVmFsdWVzLFxuICAgIFx0XHRcdHN0cmlkZSA9IHRoaXMudmFsdWVTaXplLFxuXG4gICAgXHRcdFx0b2Zmc2V0ID0gaTEgKiBzdHJpZGUsXG5cbiAgICBcdFx0XHRhbHBoYSA9ICggdCAtIHQwICkgLyAoIHQxIC0gdDAgKTtcblxuICAgIFx0XHRmb3IgKCB2YXIgZW5kID0gb2Zmc2V0ICsgc3RyaWRlOyBvZmZzZXQgIT09IGVuZDsgb2Zmc2V0ICs9IDQgKSB7XG5cbiAgICBcdFx0XHRRdWF0ZXJuaW9uLnNsZXJwRmxhdCggcmVzdWx0LCAwLFxuICAgIFx0XHRcdFx0XHR2YWx1ZXMsIG9mZnNldCAtIHN0cmlkZSwgdmFsdWVzLCBvZmZzZXQsIGFscGhhICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiByZXN1bHQ7XG5cbiAgICBcdH1cblxuICAgIH0gKTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQSBUcmFjayBvZiBxdWF0ZXJuaW9uIGtleWZyYW1lIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgQmVuIEhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW8vXG4gICAgICogQGF1dGhvciBEYXZpZCBTYXJubyAvIGh0dHA6Ly9saWdodGhhdXMudXMvXG4gICAgICogQGF1dGhvciB0c2Nod1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gUXVhdGVybmlvbktleWZyYW1lVHJhY2soIG5hbWUsIHRpbWVzLCB2YWx1ZXMsIGludGVycG9sYXRpb24gKSB7XG5cbiAgICBcdEtleWZyYW1lVHJhY2tDb25zdHJ1Y3Rvci5jYWxsKCB0aGlzLCBuYW1lLCB0aW1lcywgdmFsdWVzLCBpbnRlcnBvbGF0aW9uICk7XG5cbiAgICB9XG5cbiAgICBRdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUgPVxuICAgIFx0XHRPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBLZXlmcmFtZVRyYWNrUHJvdG90eXBlICksIHtcblxuICAgIFx0Y29uc3RydWN0b3I6IFF1YXRlcm5pb25LZXlmcmFtZVRyYWNrLFxuXG4gICAgXHRWYWx1ZVR5cGVOYW1lOiAncXVhdGVybmlvbicsXG5cbiAgICBcdC8vIFZhbHVlQnVmZmVyVHlwZSBpcyBpbmhlcml0ZWRcblxuICAgIFx0RGVmYXVsdEludGVycG9sYXRpb246IEludGVycG9sYXRlTGluZWFyLFxuXG4gICAgXHRJbnRlcnBvbGFudEZhY3RvcnlNZXRob2RMaW5lYXI6IGZ1bmN0aW9uKCByZXN1bHQgKSB7XG5cbiAgICBcdFx0cmV0dXJuIG5ldyBRdWF0ZXJuaW9uTGluZWFySW50ZXJwb2xhbnQoXG4gICAgXHRcdFx0XHR0aGlzLnRpbWVzLCB0aGlzLnZhbHVlcywgdGhpcy5nZXRWYWx1ZVNpemUoKSwgcmVzdWx0ICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdEludGVycG9sYW50RmFjdG9yeU1ldGhvZFNtb290aDogdW5kZWZpbmVkIC8vIG5vdCB5ZXQgaW1wbGVtZW50ZWRcblxuICAgIH0gKTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQSBUcmFjayBvZiBudW1lcmljIGtleWZyYW1lIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgQmVuIEhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW8vXG4gICAgICogQGF1dGhvciBEYXZpZCBTYXJubyAvIGh0dHA6Ly9saWdodGhhdXMudXMvXG4gICAgICogQGF1dGhvciB0c2Nod1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gTnVtYmVyS2V5ZnJhbWVUcmFjayggbmFtZSwgdGltZXMsIHZhbHVlcywgaW50ZXJwb2xhdGlvbiApIHtcblxuICAgIFx0S2V5ZnJhbWVUcmFja0NvbnN0cnVjdG9yLmNhbGwoIHRoaXMsIG5hbWUsIHRpbWVzLCB2YWx1ZXMsIGludGVycG9sYXRpb24gKTtcblxuICAgIH1cblxuICAgIE51bWJlcktleWZyYW1lVHJhY2sucHJvdG90eXBlID1cbiAgICBcdFx0T2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggS2V5ZnJhbWVUcmFja1Byb3RvdHlwZSApLCB7XG5cbiAgICBcdGNvbnN0cnVjdG9yOiBOdW1iZXJLZXlmcmFtZVRyYWNrLFxuXG4gICAgXHRWYWx1ZVR5cGVOYW1lOiAnbnVtYmVyJyxcblxuICAgIFx0Ly8gVmFsdWVCdWZmZXJUeXBlIGlzIGluaGVyaXRlZFxuXG4gICAgXHQvLyBEZWZhdWx0SW50ZXJwb2xhdGlvbiBpcyBpbmhlcml0ZWRcblxuICAgIH0gKTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQSBUcmFjayB0aGF0IGludGVycG9sYXRlcyBTdHJpbmdzXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBhdXRob3IgQmVuIEhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW8vXG4gICAgICogQGF1dGhvciBEYXZpZCBTYXJubyAvIGh0dHA6Ly9saWdodGhhdXMudXMvXG4gICAgICogQGF1dGhvciB0c2Nod1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gU3RyaW5nS2V5ZnJhbWVUcmFjayggbmFtZSwgdGltZXMsIHZhbHVlcywgaW50ZXJwb2xhdGlvbiApIHtcblxuICAgIFx0S2V5ZnJhbWVUcmFja0NvbnN0cnVjdG9yLmNhbGwoIHRoaXMsIG5hbWUsIHRpbWVzLCB2YWx1ZXMsIGludGVycG9sYXRpb24gKTtcblxuICAgIH1cblxuICAgIFN0cmluZ0tleWZyYW1lVHJhY2sucHJvdG90eXBlID1cbiAgICBcdFx0T2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggS2V5ZnJhbWVUcmFja1Byb3RvdHlwZSApLCB7XG5cbiAgICBcdGNvbnN0cnVjdG9yOiBTdHJpbmdLZXlmcmFtZVRyYWNrLFxuXG4gICAgXHRWYWx1ZVR5cGVOYW1lOiAnc3RyaW5nJyxcbiAgICBcdFZhbHVlQnVmZmVyVHlwZTogQXJyYXksXG5cbiAgICBcdERlZmF1bHRJbnRlcnBvbGF0aW9uOiBJbnRlcnBvbGF0ZURpc2NyZXRlLFxuXG4gICAgXHRJbnRlcnBvbGFudEZhY3RvcnlNZXRob2RMaW5lYXI6IHVuZGVmaW5lZCxcblxuICAgIFx0SW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kU21vb3RoOiB1bmRlZmluZWRcblxuICAgIH0gKTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQSBUcmFjayBvZiBCb29sZWFuIGtleWZyYW1lIHZhbHVlcy5cbiAgICAgKlxuICAgICAqXG4gICAgICogQGF1dGhvciBCZW4gSG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pby9cbiAgICAgKiBAYXV0aG9yIERhdmlkIFNhcm5vIC8gaHR0cDovL2xpZ2h0aGF1cy51cy9cbiAgICAgKiBAYXV0aG9yIHRzY2h3XG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBCb29sZWFuS2V5ZnJhbWVUcmFjayggbmFtZSwgdGltZXMsIHZhbHVlcyApIHtcblxuICAgIFx0S2V5ZnJhbWVUcmFja0NvbnN0cnVjdG9yLmNhbGwoIHRoaXMsIG5hbWUsIHRpbWVzLCB2YWx1ZXMgKTtcblxuICAgIH1cblxuICAgIEJvb2xlYW5LZXlmcmFtZVRyYWNrLnByb3RvdHlwZSA9XG4gICAgXHRcdE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIEtleWZyYW1lVHJhY2tQcm90b3R5cGUgKSwge1xuXG4gICAgXHRjb25zdHJ1Y3RvcjogQm9vbGVhbktleWZyYW1lVHJhY2ssXG5cbiAgICBcdFZhbHVlVHlwZU5hbWU6ICdib29sJyxcbiAgICBcdFZhbHVlQnVmZmVyVHlwZTogQXJyYXksXG5cbiAgICBcdERlZmF1bHRJbnRlcnBvbGF0aW9uOiBJbnRlcnBvbGF0ZURpc2NyZXRlLFxuXG4gICAgXHRJbnRlcnBvbGFudEZhY3RvcnlNZXRob2RMaW5lYXI6IHVuZGVmaW5lZCxcbiAgICBcdEludGVycG9sYW50RmFjdG9yeU1ldGhvZFNtb290aDogdW5kZWZpbmVkXG5cbiAgICBcdC8vIE5vdGU6IEFjdHVhbGx5IHRoaXMgdHJhY2sgY291bGQgaGF2ZSBhIG9wdGltaXplZCAvIGNvbXByZXNzZWRcbiAgICBcdC8vIHJlcHJlc2VudGF0aW9uIG9mIGEgc2luZ2xlIHZhbHVlIGFuZCBhIGN1c3RvbSBpbnRlcnBvbGFudCB0aGF0XG4gICAgXHQvLyBjb21wdXRlcyBcImZpcnN0VmFsdWUgXiBpc09kZCggaW5kZXggKVwiLlxuXG4gICAgfSApO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBBIFRyYWNrIG9mIGtleWZyYW1lIHZhbHVlcyB0aGF0IHJlcHJlc2VudCBjb2xvci5cbiAgICAgKlxuICAgICAqXG4gICAgICogQGF1dGhvciBCZW4gSG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pby9cbiAgICAgKiBAYXV0aG9yIERhdmlkIFNhcm5vIC8gaHR0cDovL2xpZ2h0aGF1cy51cy9cbiAgICAgKiBAYXV0aG9yIHRzY2h3XG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBDb2xvcktleWZyYW1lVHJhY2soIG5hbWUsIHRpbWVzLCB2YWx1ZXMsIGludGVycG9sYXRpb24gKSB7XG5cbiAgICBcdEtleWZyYW1lVHJhY2tDb25zdHJ1Y3Rvci5jYWxsKCB0aGlzLCBuYW1lLCB0aW1lcywgdmFsdWVzLCBpbnRlcnBvbGF0aW9uICk7XG5cbiAgICB9XG5cbiAgICBDb2xvcktleWZyYW1lVHJhY2sucHJvdG90eXBlID1cbiAgICBcdFx0T2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggS2V5ZnJhbWVUcmFja1Byb3RvdHlwZSApLCB7XG5cbiAgICBcdGNvbnN0cnVjdG9yOiBDb2xvcktleWZyYW1lVHJhY2ssXG5cbiAgICBcdFZhbHVlVHlwZU5hbWU6ICdjb2xvcidcblxuICAgIFx0Ly8gVmFsdWVCdWZmZXJUeXBlIGlzIGluaGVyaXRlZFxuXG4gICAgXHQvLyBEZWZhdWx0SW50ZXJwb2xhdGlvbiBpcyBpbmhlcml0ZWRcblxuXG4gICAgXHQvLyBOb3RlOiBWZXJ5IGJhc2ljIGltcGxlbWVudGF0aW9uIGFuZCBub3RoaW5nIHNwZWNpYWwgeWV0LlxuICAgIFx0Ly8gSG93ZXZlciwgdGhpcyBpcyB0aGUgcGxhY2UgZm9yIGNvbG9yIHNwYWNlIHBhcmFtZXRlcml6YXRpb24uXG5cbiAgICB9ICk7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEEgdGltZWQgc2VxdWVuY2Ugb2Yga2V5ZnJhbWVzIGZvciBhIHNwZWNpZmljIHByb3BlcnR5LlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAYXV0aG9yIEJlbiBIb3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvL1xuICAgICAqIEBhdXRob3IgRGF2aWQgU2Fybm8gLyBodHRwOi8vbGlnaHRoYXVzLnVzL1xuICAgICAqIEBhdXRob3IgdHNjaHdcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIEtleWZyYW1lVHJhY2soIG5hbWUsIHRpbWVzLCB2YWx1ZXMsIGludGVycG9sYXRpb24gKSB7XG5cbiAgICBcdEtleWZyYW1lVHJhY2tDb25zdHJ1Y3Rvci5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cbiAgICB9XG5cbiAgICBLZXlmcmFtZVRyYWNrLnByb3RvdHlwZSA9IEtleWZyYW1lVHJhY2tQcm90b3R5cGU7XG4gICAgS2V5ZnJhbWVUcmFja1Byb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEtleWZyYW1lVHJhY2s7XG5cbiAgICAvLyBTdGF0aWMgbWV0aG9kczpcblxuICAgIE9iamVjdC5hc3NpZ24oIEtleWZyYW1lVHJhY2ssIHtcblxuICAgIFx0Ly8gU2VyaWFsaXphdGlvbiAoaW4gc3RhdGljIGNvbnRleHQsIGJlY2F1c2Ugb2YgY29uc3RydWN0b3IgaW52b2NhdGlvblxuICAgIFx0Ly8gYW5kIGF1dG9tYXRpYyBpbnZvY2F0aW9uIG9mIC50b0pTT04pOlxuXG4gICAgXHRwYXJzZTogZnVuY3Rpb24oIGpzb24gKSB7XG5cbiAgICBcdFx0aWYoIGpzb24udHlwZSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0dGhyb3cgbmV3IEVycm9yKCBcInRyYWNrIHR5cGUgdW5kZWZpbmVkLCBjYW4gbm90IHBhcnNlXCIgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0dmFyIHRyYWNrVHlwZSA9IEtleWZyYW1lVHJhY2suX2dldFRyYWNrVHlwZUZvclZhbHVlVHlwZU5hbWUoIGpzb24udHlwZSApO1xuXG4gICAgXHRcdGlmICgganNvbi50aW1lcyA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0dmFyIHRpbWVzID0gW10sIHZhbHVlcyA9IFtdO1xuXG4gICAgXHRcdFx0ZXhwb3J0cy5BbmltYXRpb25VdGlscy5mbGF0dGVuSlNPTigganNvbi5rZXlzLCB0aW1lcywgdmFsdWVzLCAndmFsdWUnICk7XG5cbiAgICBcdFx0XHRqc29uLnRpbWVzID0gdGltZXM7XG4gICAgXHRcdFx0anNvbi52YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdC8vIGRlcml2ZWQgY2xhc3NlcyBjYW4gZGVmaW5lIGEgc3RhdGljIHBhcnNlIG1ldGhvZFxuICAgIFx0XHRpZiAoIHRyYWNrVHlwZS5wYXJzZSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0cmV0dXJuIHRyYWNrVHlwZS5wYXJzZSgganNvbiApO1xuXG4gICAgXHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHQvLyBieSBkZWZhdWx0LCB3ZSBhc3NzdW1lIGEgY29uc3RydWN0b3IgY29tcGF0aWJsZSB3aXRoIHRoZSBiYXNlXG4gICAgXHRcdFx0cmV0dXJuIG5ldyB0cmFja1R5cGUoXG4gICAgXHRcdFx0XHRcdGpzb24ubmFtZSwganNvbi50aW1lcywganNvbi52YWx1ZXMsIGpzb24uaW50ZXJwb2xhdGlvbiApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0fSxcblxuICAgIFx0dG9KU09OOiBmdW5jdGlvbiggdHJhY2sgKSB7XG5cbiAgICBcdFx0dmFyIHRyYWNrVHlwZSA9IHRyYWNrLmNvbnN0cnVjdG9yO1xuXG4gICAgXHRcdHZhciBqc29uO1xuXG4gICAgXHRcdC8vIGRlcml2ZWQgY2xhc3NlcyBjYW4gZGVmaW5lIGEgc3RhdGljIHRvSlNPTiBtZXRob2RcbiAgICBcdFx0aWYgKCB0cmFja1R5cGUudG9KU09OICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRqc29uID0gdHJhY2tUeXBlLnRvSlNPTiggdHJhY2sgKTtcblxuICAgIFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0Ly8gYnkgZGVmYXVsdCwgd2UgYXNzdW1lIHRoZSBkYXRhIGNhbiBiZSBzZXJpYWxpemVkIGFzLWlzXG4gICAgXHRcdFx0anNvbiA9IHtcblxuICAgIFx0XHRcdFx0J25hbWUnOiB0cmFjay5uYW1lLFxuICAgIFx0XHRcdFx0J3RpbWVzJzogZXhwb3J0cy5BbmltYXRpb25VdGlscy5jb252ZXJ0QXJyYXkoIHRyYWNrLnRpbWVzLCBBcnJheSApLFxuICAgIFx0XHRcdFx0J3ZhbHVlcyc6IGV4cG9ydHMuQW5pbWF0aW9uVXRpbHMuY29udmVydEFycmF5KCB0cmFjay52YWx1ZXMsIEFycmF5IClcblxuICAgIFx0XHRcdH07XG5cbiAgICBcdFx0XHR2YXIgaW50ZXJwb2xhdGlvbiA9IHRyYWNrLmdldEludGVycG9sYXRpb24oKTtcblxuICAgIFx0XHRcdGlmICggaW50ZXJwb2xhdGlvbiAhPT0gdHJhY2suRGVmYXVsdEludGVycG9sYXRpb24gKSB7XG5cbiAgICBcdFx0XHRcdGpzb24uaW50ZXJwb2xhdGlvbiA9IGludGVycG9sYXRpb247XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGpzb24udHlwZSA9IHRyYWNrLlZhbHVlVHlwZU5hbWU7IC8vIG1hbmRhdG9yeVxuXG4gICAgXHRcdHJldHVybiBqc29uO1xuXG4gICAgXHR9LFxuXG4gICAgXHRfZ2V0VHJhY2tUeXBlRm9yVmFsdWVUeXBlTmFtZTogZnVuY3Rpb24oIHR5cGVOYW1lICkge1xuXG4gICAgXHRcdHN3aXRjaCggdHlwZU5hbWUudG9Mb3dlckNhc2UoKSApIHtcblxuICAgIFx0XHRcdGNhc2UgXCJzY2FsYXJcIjpcbiAgICBcdFx0XHRjYXNlIFwiZG91YmxlXCI6XG4gICAgXHRcdFx0Y2FzZSBcImZsb2F0XCI6XG4gICAgXHRcdFx0Y2FzZSBcIm51bWJlclwiOlxuICAgIFx0XHRcdGNhc2UgXCJpbnRlZ2VyXCI6XG5cbiAgICBcdFx0XHRcdHJldHVybiBOdW1iZXJLZXlmcmFtZVRyYWNrO1xuXG4gICAgXHRcdFx0Y2FzZSBcInZlY3RvclwiOlxuICAgIFx0XHRcdGNhc2UgXCJ2ZWN0b3IyXCI6XG4gICAgXHRcdFx0Y2FzZSBcInZlY3RvcjNcIjpcbiAgICBcdFx0XHRjYXNlIFwidmVjdG9yNFwiOlxuXG4gICAgXHRcdFx0XHRyZXR1cm4gVmVjdG9yS2V5ZnJhbWVUcmFjaztcblxuICAgIFx0XHRcdGNhc2UgXCJjb2xvclwiOlxuXG4gICAgXHRcdFx0XHRyZXR1cm4gQ29sb3JLZXlmcmFtZVRyYWNrO1xuXG4gICAgXHRcdFx0Y2FzZSBcInF1YXRlcm5pb25cIjpcblxuICAgIFx0XHRcdFx0cmV0dXJuIFF1YXRlcm5pb25LZXlmcmFtZVRyYWNrO1xuXG4gICAgXHRcdFx0Y2FzZSBcImJvb2xcIjpcbiAgICBcdFx0XHRjYXNlIFwiYm9vbGVhblwiOlxuXG4gICAgXHRcdFx0XHRyZXR1cm4gQm9vbGVhbktleWZyYW1lVHJhY2s7XG5cbiAgICBcdFx0XHRjYXNlIFwic3RyaW5nXCI6XG5cbiAgICBcdFx0XHRcdHJldHVybiBTdHJpbmdLZXlmcmFtZVRyYWNrO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHR0aHJvdyBuZXcgRXJyb3IoIFwiVW5zdXBwb3J0ZWQgdHlwZU5hbWU6IFwiICsgdHlwZU5hbWUgKTtcblxuICAgIFx0fVxuXG4gICAgfSApO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBSZXVzYWJsZSBzZXQgb2YgVHJhY2tzIHRoYXQgcmVwcmVzZW50IGFuIGFuaW1hdGlvbi5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgQmVuIEhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW8vXG4gICAgICogQGF1dGhvciBEYXZpZCBTYXJubyAvIGh0dHA6Ly9saWdodGhhdXMudXMvXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBBbmltYXRpb25DbGlwKCBuYW1lLCBkdXJhdGlvbiwgdHJhY2tzICkge1xuXG4gICAgXHR0aGlzLm5hbWUgPSBuYW1lO1xuICAgIFx0dGhpcy50cmFja3MgPSB0cmFja3M7XG4gICAgXHR0aGlzLmR1cmF0aW9uID0gKCBkdXJhdGlvbiAhPT0gdW5kZWZpbmVkICkgPyBkdXJhdGlvbiA6IC0xO1xuXG4gICAgXHR0aGlzLnV1aWQgPSBleHBvcnRzLk1hdGguZ2VuZXJhdGVVVUlEKCk7XG5cbiAgICBcdC8vIHRoaXMgbWVhbnMgaXQgc2hvdWxkIGZpZ3VyZSBvdXQgaXRzIGR1cmF0aW9uIGJ5IHNjYW5uaW5nIHRoZSB0cmFja3NcbiAgICBcdGlmICggdGhpcy5kdXJhdGlvbiA8IDAgKSB7XG5cbiAgICBcdFx0dGhpcy5yZXNldER1cmF0aW9uKCk7XG5cbiAgICBcdH1cblxuICAgIFx0dGhpcy5vcHRpbWl6ZSgpO1xuXG4gICAgfVxuXG4gICAgQW5pbWF0aW9uQ2xpcC5wcm90b3R5cGUgPSB7XG5cbiAgICBcdGNvbnN0cnVjdG9yOiBBbmltYXRpb25DbGlwLFxuXG4gICAgXHRyZXNldER1cmF0aW9uOiBmdW5jdGlvbigpIHtcblxuICAgIFx0XHR2YXIgdHJhY2tzID0gdGhpcy50cmFja3MsXG4gICAgXHRcdFx0ZHVyYXRpb24gPSAwO1xuXG4gICAgXHRcdGZvciAoIHZhciBpID0gMCwgbiA9IHRyYWNrcy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XG5cbiAgICBcdFx0XHR2YXIgdHJhY2sgPSB0aGlzLnRyYWNrc1sgaSBdO1xuXG4gICAgXHRcdFx0ZHVyYXRpb24gPSBNYXRoLm1heChcbiAgICBcdFx0XHRcdFx0ZHVyYXRpb24sIHRyYWNrLnRpbWVzWyB0cmFjay50aW1lcy5sZW5ndGggLSAxIF0gKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0dGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuXG4gICAgXHR9LFxuXG4gICAgXHR0cmltOiBmdW5jdGlvbigpIHtcblxuICAgIFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLnRyYWNrcy5sZW5ndGg7IGkgKysgKSB7XG5cbiAgICBcdFx0XHR0aGlzLnRyYWNrc1sgaSBdLnRyaW0oIDAsIHRoaXMuZHVyYXRpb24gKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdG9wdGltaXplOiBmdW5jdGlvbigpIHtcblxuICAgIFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLnRyYWNrcy5sZW5ndGg7IGkgKysgKSB7XG5cbiAgICBcdFx0XHR0aGlzLnRyYWNrc1sgaSBdLm9wdGltaXplKCk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9XG5cbiAgICB9O1xuXG4gICAgLy8gU3RhdGljIG1ldGhvZHM6XG5cbiAgICBPYmplY3QuYXNzaWduKCBBbmltYXRpb25DbGlwLCB7XG5cbiAgICBcdHBhcnNlOiBmdW5jdGlvbigganNvbiApIHtcblxuICAgIFx0XHR2YXIgdHJhY2tzID0gW10sXG4gICAgXHRcdFx0anNvblRyYWNrcyA9IGpzb24udHJhY2tzLFxuICAgIFx0XHRcdGZyYW1lVGltZSA9IDEuMCAvICgganNvbi5mcHMgfHwgMS4wICk7XG5cbiAgICBcdFx0Zm9yICggdmFyIGkgPSAwLCBuID0ganNvblRyYWNrcy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XG5cbiAgICBcdFx0XHR0cmFja3MucHVzaCggS2V5ZnJhbWVUcmFjay5wYXJzZSgganNvblRyYWNrc1sgaSBdICkuc2NhbGUoIGZyYW1lVGltZSApICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiBuZXcgQW5pbWF0aW9uQ2xpcCgganNvbi5uYW1lLCBqc29uLmR1cmF0aW9uLCB0cmFja3MgKTtcblxuICAgIFx0fSxcblxuXG4gICAgXHR0b0pTT046IGZ1bmN0aW9uKCBjbGlwICkge1xuXG4gICAgXHRcdHZhciB0cmFja3MgPSBbXSxcbiAgICBcdFx0XHRjbGlwVHJhY2tzID0gY2xpcC50cmFja3M7XG5cbiAgICBcdFx0dmFyIGpzb24gPSB7XG5cbiAgICBcdFx0XHQnbmFtZSc6IGNsaXAubmFtZSxcbiAgICBcdFx0XHQnZHVyYXRpb24nOiBjbGlwLmR1cmF0aW9uLFxuICAgIFx0XHRcdCd0cmFja3MnOiB0cmFja3NcblxuICAgIFx0XHR9O1xuXG4gICAgXHRcdGZvciAoIHZhciBpID0gMCwgbiA9IGNsaXBUcmFja3MubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xuXG4gICAgXHRcdFx0dHJhY2tzLnB1c2goIEtleWZyYW1lVHJhY2sudG9KU09OKCBjbGlwVHJhY2tzWyBpIF0gKSApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4ganNvbjtcblxuICAgIFx0fSxcblxuXG4gICAgXHRDcmVhdGVGcm9tTW9ycGhUYXJnZXRTZXF1ZW5jZTogZnVuY3Rpb24oIG5hbWUsIG1vcnBoVGFyZ2V0U2VxdWVuY2UsIGZwcywgbm9Mb29wICkge1xuXG4gICAgXHRcdHZhciBudW1Nb3JwaFRhcmdldHMgPSBtb3JwaFRhcmdldFNlcXVlbmNlLmxlbmd0aDtcbiAgICBcdFx0dmFyIHRyYWNrcyA9IFtdO1xuXG4gICAgXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IG51bU1vcnBoVGFyZ2V0czsgaSArKyApIHtcblxuICAgIFx0XHRcdHZhciB0aW1lcyA9IFtdO1xuICAgIFx0XHRcdHZhciB2YWx1ZXMgPSBbXTtcblxuICAgIFx0XHRcdHRpbWVzLnB1c2goXG4gICAgXHRcdFx0XHRcdCggaSArIG51bU1vcnBoVGFyZ2V0cyAtIDEgKSAlIG51bU1vcnBoVGFyZ2V0cyxcbiAgICBcdFx0XHRcdFx0aSxcbiAgICBcdFx0XHRcdFx0KCBpICsgMSApICUgbnVtTW9ycGhUYXJnZXRzICk7XG5cbiAgICBcdFx0XHR2YWx1ZXMucHVzaCggMCwgMSwgMCApO1xuXG4gICAgXHRcdFx0dmFyIG9yZGVyID0gZXhwb3J0cy5BbmltYXRpb25VdGlscy5nZXRLZXlmcmFtZU9yZGVyKCB0aW1lcyApO1xuICAgIFx0XHRcdHRpbWVzID0gZXhwb3J0cy5BbmltYXRpb25VdGlscy5zb3J0ZWRBcnJheSggdGltZXMsIDEsIG9yZGVyICk7XG4gICAgXHRcdFx0dmFsdWVzID0gZXhwb3J0cy5BbmltYXRpb25VdGlscy5zb3J0ZWRBcnJheSggdmFsdWVzLCAxLCBvcmRlciApO1xuXG4gICAgXHRcdFx0Ly8gaWYgdGhlcmUgaXMgYSBrZXkgYXQgdGhlIGZpcnN0IGZyYW1lLCBkdXBsaWNhdGUgaXQgYXMgdGhlXG4gICAgXHRcdFx0Ly8gbGFzdCBmcmFtZSBhcyB3ZWxsIGZvciBwZXJmZWN0IGxvb3AuXG4gICAgXHRcdFx0aWYgKCAhIG5vTG9vcCAmJiB0aW1lc1sgMCBdID09PSAwICkge1xuXG4gICAgXHRcdFx0XHR0aW1lcy5wdXNoKCBudW1Nb3JwaFRhcmdldHMgKTtcbiAgICBcdFx0XHRcdHZhbHVlcy5wdXNoKCB2YWx1ZXNbIDAgXSApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0dHJhY2tzLnB1c2goXG4gICAgXHRcdFx0XHRcdG5ldyBOdW1iZXJLZXlmcmFtZVRyYWNrKFxuICAgIFx0XHRcdFx0XHRcdCcubW9ycGhUYXJnZXRJbmZsdWVuY2VzWycgKyBtb3JwaFRhcmdldFNlcXVlbmNlWyBpIF0ubmFtZSArICddJyxcbiAgICBcdFx0XHRcdFx0XHR0aW1lcywgdmFsdWVzXG4gICAgXHRcdFx0XHRcdCkuc2NhbGUoIDEuMCAvIGZwcyApICk7XG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gbmV3IEFuaW1hdGlvbkNsaXAoIG5hbWUsIC0xLCB0cmFja3MgKTtcblxuICAgIFx0fSxcblxuICAgIFx0ZmluZEJ5TmFtZTogZnVuY3Rpb24oIG9iamVjdE9yQ2xpcEFycmF5LCBuYW1lICkge1xuXG4gICAgXHRcdHZhciBjbGlwQXJyYXkgPSBvYmplY3RPckNsaXBBcnJheTtcblxuICAgIFx0XHRpZiAoICEgQXJyYXkuaXNBcnJheSggb2JqZWN0T3JDbGlwQXJyYXkgKSApIHtcblxuICAgIFx0XHRcdHZhciBvID0gb2JqZWN0T3JDbGlwQXJyYXk7XG4gICAgXHRcdFx0Y2xpcEFycmF5ID0gby5nZW9tZXRyeSAmJiBvLmdlb21ldHJ5LmFuaW1hdGlvbnMgfHwgby5hbmltYXRpb25zO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBjbGlwQXJyYXkubGVuZ3RoOyBpICsrICkge1xuXG4gICAgXHRcdFx0aWYgKCBjbGlwQXJyYXlbIGkgXS5uYW1lID09PSBuYW1lICkge1xuXG4gICAgXHRcdFx0XHRyZXR1cm4gY2xpcEFycmF5WyBpIF07XG5cbiAgICBcdFx0XHR9XG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gbnVsbDtcblxuICAgIFx0fSxcblxuICAgIFx0Q3JlYXRlQ2xpcHNGcm9tTW9ycGhUYXJnZXRTZXF1ZW5jZXM6IGZ1bmN0aW9uKCBtb3JwaFRhcmdldHMsIGZwcywgbm9Mb29wICkge1xuXG4gICAgXHRcdHZhciBhbmltYXRpb25Ub01vcnBoVGFyZ2V0cyA9IHt9O1xuXG4gICAgXHRcdC8vIHRlc3RlZCB3aXRoIGh0dHBzOi8vcmVnZXgxMDEuY29tLyBvbiB0cmljayBzZXF1ZW5jZXNcbiAgICBcdFx0Ly8gc3VjaCBmbGFtaW5nb19mbHlBXzAwMywgZmxhbWluZ29fcnVuMV8wMDMsIGNyZGVhdGgwMDU5XG4gICAgXHRcdHZhciBwYXR0ZXJuID0gL14oW1xcdy1dKj8pKFtcXGRdKykkLztcblxuICAgIFx0XHQvLyBzb3J0IG1vcnBoIHRhcmdldCBuYW1lcyBpbnRvIGFuaW1hdGlvbiBncm91cHMgYmFzZWRcbiAgICBcdFx0Ly8gcGF0dGVybnMgbGlrZSBXYWxrXzAwMSwgV2Fsa18wMDIsIFJ1bl8wMDEsIFJ1bl8wMDJcbiAgICBcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IG1vcnBoVGFyZ2V0cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuICAgIFx0XHRcdHZhciBtb3JwaFRhcmdldCA9IG1vcnBoVGFyZ2V0c1sgaSBdO1xuICAgIFx0XHRcdHZhciBwYXJ0cyA9IG1vcnBoVGFyZ2V0Lm5hbWUubWF0Y2goIHBhdHRlcm4gKTtcblxuICAgIFx0XHRcdGlmICggcGFydHMgJiYgcGFydHMubGVuZ3RoID4gMSApIHtcblxuICAgIFx0XHRcdFx0dmFyIG5hbWUgPSBwYXJ0c1sgMSBdO1xuXG4gICAgXHRcdFx0XHR2YXIgYW5pbWF0aW9uTW9ycGhUYXJnZXRzID0gYW5pbWF0aW9uVG9Nb3JwaFRhcmdldHNbIG5hbWUgXTtcbiAgICBcdFx0XHRcdGlmICggISBhbmltYXRpb25Nb3JwaFRhcmdldHMgKSB7XG5cbiAgICBcdFx0XHRcdFx0YW5pbWF0aW9uVG9Nb3JwaFRhcmdldHNbIG5hbWUgXSA9IGFuaW1hdGlvbk1vcnBoVGFyZ2V0cyA9IFtdO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdGFuaW1hdGlvbk1vcnBoVGFyZ2V0cy5wdXNoKCBtb3JwaFRhcmdldCApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHR2YXIgY2xpcHMgPSBbXTtcblxuICAgIFx0XHRmb3IgKCB2YXIgbmFtZSBpbiBhbmltYXRpb25Ub01vcnBoVGFyZ2V0cyApIHtcblxuICAgIFx0XHRcdGNsaXBzLnB1c2goIEFuaW1hdGlvbkNsaXAuQ3JlYXRlRnJvbU1vcnBoVGFyZ2V0U2VxdWVuY2UoIG5hbWUsIGFuaW1hdGlvblRvTW9ycGhUYXJnZXRzWyBuYW1lIF0sIGZwcywgbm9Mb29wICkgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIGNsaXBzO1xuXG4gICAgXHR9LFxuXG4gICAgXHQvLyBwYXJzZSB0aGUgYW5pbWF0aW9uLmhpZXJhcmNoeSBmb3JtYXRcbiAgICBcdHBhcnNlQW5pbWF0aW9uOiBmdW5jdGlvbiggYW5pbWF0aW9uLCBib25lcyApIHtcblxuICAgIFx0XHRpZiAoICEgYW5pbWF0aW9uICkge1xuXG4gICAgXHRcdFx0Y29uc29sZS5lcnJvciggXCIgIG5vIGFuaW1hdGlvbiBpbiBKU09OTG9hZGVyIGRhdGFcIiApO1xuICAgIFx0XHRcdHJldHVybiBudWxsO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHR2YXIgYWRkTm9uZW1wdHlUcmFjayA9IGZ1bmN0aW9uKFxuICAgIFx0XHRcdFx0dHJhY2tUeXBlLCB0cmFja05hbWUsIGFuaW1hdGlvbktleXMsIHByb3BlcnR5TmFtZSwgZGVzdFRyYWNrcyApIHtcblxuICAgIFx0XHRcdC8vIG9ubHkgcmV0dXJuIHRyYWNrIGlmIHRoZXJlIGFyZSBhY3R1YWxseSBrZXlzLlxuICAgIFx0XHRcdGlmICggYW5pbWF0aW9uS2V5cy5sZW5ndGggIT09IDAgKSB7XG5cbiAgICBcdFx0XHRcdHZhciB0aW1lcyA9IFtdO1xuICAgIFx0XHRcdFx0dmFyIHZhbHVlcyA9IFtdO1xuXG4gICAgXHRcdFx0XHRleHBvcnRzLkFuaW1hdGlvblV0aWxzLmZsYXR0ZW5KU09OKFxuICAgIFx0XHRcdFx0XHRcdGFuaW1hdGlvbktleXMsIHRpbWVzLCB2YWx1ZXMsIHByb3BlcnR5TmFtZSApO1xuXG4gICAgXHRcdFx0XHQvLyBlbXB0eSBrZXlzIGFyZSBmaWx0ZXJlZCBvdXQsIHNvIGNoZWNrIGFnYWluXG4gICAgXHRcdFx0XHRpZiAoIHRpbWVzLmxlbmd0aCAhPT0gMCApIHtcblxuICAgIFx0XHRcdFx0XHRkZXN0VHJhY2tzLnB1c2goIG5ldyB0cmFja1R5cGUoIHRyYWNrTmFtZSwgdGltZXMsIHZhbHVlcyApICk7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9O1xuXG4gICAgXHRcdHZhciB0cmFja3MgPSBbXTtcblxuICAgIFx0XHR2YXIgY2xpcE5hbWUgPSBhbmltYXRpb24ubmFtZSB8fCAnZGVmYXVsdCc7XG4gICAgXHRcdC8vIGF1dG9tYXRpYyBsZW5ndGggZGV0ZXJtaW5hdGlvbiBpbiBBbmltYXRpb25DbGlwLlxuICAgIFx0XHR2YXIgZHVyYXRpb24gPSBhbmltYXRpb24ubGVuZ3RoIHx8IC0xO1xuICAgIFx0XHR2YXIgZnBzID0gYW5pbWF0aW9uLmZwcyB8fCAzMDtcblxuICAgIFx0XHR2YXIgaGllcmFyY2h5VHJhY2tzID0gYW5pbWF0aW9uLmhpZXJhcmNoeSB8fCBbXTtcblxuICAgIFx0XHRmb3IgKCB2YXIgaCA9IDA7IGggPCBoaWVyYXJjaHlUcmFja3MubGVuZ3RoOyBoICsrICkge1xuXG4gICAgXHRcdFx0dmFyIGFuaW1hdGlvbktleXMgPSBoaWVyYXJjaHlUcmFja3NbIGggXS5rZXlzO1xuXG4gICAgXHRcdFx0Ly8gc2tpcCBlbXB0eSB0cmFja3NcbiAgICBcdFx0XHRpZiAoICEgYW5pbWF0aW9uS2V5cyB8fCBhbmltYXRpb25LZXlzLmxlbmd0aCA9PT0gMCApIGNvbnRpbnVlO1xuXG4gICAgXHRcdFx0Ly8gcHJvY2VzcyBtb3JwaCB0YXJnZXRzIGluIGEgd2F5IGV4YWN0bHkgY29tcGF0aWJsZVxuICAgIFx0XHRcdC8vIHdpdGggQW5pbWF0aW9uSGFuZGxlci5pbml0KCBhbmltYXRpb24gKVxuICAgIFx0XHRcdGlmICggYW5pbWF0aW9uS2V5c1swXS5tb3JwaFRhcmdldHMgKSB7XG5cbiAgICBcdFx0XHRcdC8vIGZpZ3VyZSBvdXQgYWxsIG1vcnBoIHRhcmdldHMgdXNlZCBpbiB0aGlzIHRyYWNrXG4gICAgXHRcdFx0XHR2YXIgbW9ycGhUYXJnZXROYW1lcyA9IHt9O1xuICAgIFx0XHRcdFx0Zm9yICggdmFyIGsgPSAwOyBrIDwgYW5pbWF0aW9uS2V5cy5sZW5ndGg7IGsgKysgKSB7XG5cbiAgICBcdFx0XHRcdFx0aWYgKCBhbmltYXRpb25LZXlzW2tdLm1vcnBoVGFyZ2V0cyApIHtcblxuICAgIFx0XHRcdFx0XHRcdGZvciAoIHZhciBtID0gMDsgbSA8IGFuaW1hdGlvbktleXNba10ubW9ycGhUYXJnZXRzLmxlbmd0aDsgbSArKyApIHtcblxuICAgIFx0XHRcdFx0XHRcdFx0bW9ycGhUYXJnZXROYW1lc1sgYW5pbWF0aW9uS2V5c1trXS5tb3JwaFRhcmdldHNbbV0gXSA9IC0xO1xuICAgIFx0XHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0Ly8gY3JlYXRlIGEgdHJhY2sgZm9yIGVhY2ggbW9ycGggdGFyZ2V0IHdpdGggYWxsIHplcm9cbiAgICBcdFx0XHRcdC8vIG1vcnBoVGFyZ2V0SW5mbHVlbmNlcyBleGNlcHQgZm9yIHRoZSBrZXlzIGluIHdoaWNoXG4gICAgXHRcdFx0XHQvLyB0aGUgbW9ycGhUYXJnZXQgaXMgbmFtZWQuXG4gICAgXHRcdFx0XHRmb3IgKCB2YXIgbW9ycGhUYXJnZXROYW1lIGluIG1vcnBoVGFyZ2V0TmFtZXMgKSB7XG5cbiAgICBcdFx0XHRcdFx0dmFyIHRpbWVzID0gW107XG4gICAgXHRcdFx0XHRcdHZhciB2YWx1ZXMgPSBbXTtcblxuICAgIFx0XHRcdFx0XHRmb3IgKCB2YXIgbSA9IDA7XG4gICAgXHRcdFx0XHRcdFx0XHRtICE9PSBhbmltYXRpb25LZXlzW2tdLm1vcnBoVGFyZ2V0cy5sZW5ndGg7ICsrIG0gKSB7XG5cbiAgICBcdFx0XHRcdFx0XHR2YXIgYW5pbWF0aW9uS2V5ID0gYW5pbWF0aW9uS2V5c1trXTtcblxuICAgIFx0XHRcdFx0XHRcdHRpbWVzLnB1c2goIGFuaW1hdGlvbktleS50aW1lICk7XG4gICAgXHRcdFx0XHRcdFx0dmFsdWVzLnB1c2goICggYW5pbWF0aW9uS2V5Lm1vcnBoVGFyZ2V0ID09PSBtb3JwaFRhcmdldE5hbWUgKSA/IDEgOiAwICk7XG5cbiAgICBcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHRcdHRyYWNrcy5wdXNoKCBuZXcgTnVtYmVyS2V5ZnJhbWVUcmFjayhcbiAgICBcdFx0XHRcdFx0XHRcdCcubW9ycGhUYXJnZXRJbmZsdWVuY2VbJyArIG1vcnBoVGFyZ2V0TmFtZSArICddJywgdGltZXMsIHZhbHVlcyApICk7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0ZHVyYXRpb24gPSBtb3JwaFRhcmdldE5hbWVzLmxlbmd0aCAqICggZnBzIHx8IDEuMCApO1xuXG4gICAgXHRcdFx0fSBlbHNlIHtcbiAgICBcdFx0XHRcdC8vIC4uLmFzc3VtZSBza2VsZXRhbCBhbmltYXRpb25cblxuICAgIFx0XHRcdFx0dmFyIGJvbmVOYW1lID0gJy5ib25lc1snICsgYm9uZXNbIGggXS5uYW1lICsgJ10nO1xuXG4gICAgXHRcdFx0XHRhZGROb25lbXB0eVRyYWNrKFxuICAgIFx0XHRcdFx0XHRcdFZlY3RvcktleWZyYW1lVHJhY2ssIGJvbmVOYW1lICsgJy5wb3NpdGlvbicsXG4gICAgXHRcdFx0XHRcdFx0YW5pbWF0aW9uS2V5cywgJ3BvcycsIHRyYWNrcyApO1xuXG4gICAgXHRcdFx0XHRhZGROb25lbXB0eVRyYWNrKFxuICAgIFx0XHRcdFx0XHRcdFF1YXRlcm5pb25LZXlmcmFtZVRyYWNrLCBib25lTmFtZSArICcucXVhdGVybmlvbicsXG4gICAgXHRcdFx0XHRcdFx0YW5pbWF0aW9uS2V5cywgJ3JvdCcsIHRyYWNrcyApO1xuXG4gICAgXHRcdFx0XHRhZGROb25lbXB0eVRyYWNrKFxuICAgIFx0XHRcdFx0XHRcdFZlY3RvcktleWZyYW1lVHJhY2ssIGJvbmVOYW1lICsgJy5zY2FsZScsXG4gICAgXHRcdFx0XHRcdFx0YW5pbWF0aW9uS2V5cywgJ3NjbCcsIHRyYWNrcyApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHRpZiAoIHRyYWNrcy5sZW5ndGggPT09IDAgKSB7XG5cbiAgICBcdFx0XHRyZXR1cm4gbnVsbDtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0dmFyIGNsaXAgPSBuZXcgQW5pbWF0aW9uQ2xpcCggY2xpcE5hbWUsIGR1cmF0aW9uLCB0cmFja3MgKTtcblxuICAgIFx0XHRyZXR1cm4gY2xpcDtcblxuICAgIFx0fVxuXG4gICAgfSApO1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIE1hdGVyaWFsTG9hZGVyKCBtYW5hZ2VyICkge1xuXG4gICAgXHR0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IGV4cG9ydHMuRGVmYXVsdExvYWRpbmdNYW5hZ2VyO1xuICAgIFx0dGhpcy50ZXh0dXJlcyA9IHt9O1xuXG4gICAgfVxuXG4gICAgT2JqZWN0LmFzc2lnbiggTWF0ZXJpYWxMb2FkZXIucHJvdG90eXBlLCB7XG5cbiAgICBcdGxvYWQ6IGZ1bmN0aW9uICggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cbiAgICBcdFx0dmFyIHNjb3BlID0gdGhpcztcblxuICAgIFx0XHR2YXIgbG9hZGVyID0gbmV3IFhIUkxvYWRlciggc2NvcGUubWFuYWdlciApO1xuICAgIFx0XHRsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIHRleHQgKSB7XG5cbiAgICBcdFx0XHRvbkxvYWQoIHNjb3BlLnBhcnNlKCBKU09OLnBhcnNlKCB0ZXh0ICkgKSApO1xuXG4gICAgXHRcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcblxuICAgIFx0fSxcblxuICAgIFx0c2V0VGV4dHVyZXM6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cbiAgICBcdFx0dGhpcy50ZXh0dXJlcyA9IHZhbHVlO1xuXG4gICAgXHR9LFxuXG4gICAgXHRwYXJzZTogZnVuY3Rpb24gKCBqc29uICkge1xuXG4gICAgXHRcdHZhciB0ZXh0dXJlcyA9IHRoaXMudGV4dHVyZXM7XG5cbiAgICBcdFx0ZnVuY3Rpb24gZ2V0VGV4dHVyZSggbmFtZSApIHtcblxuICAgIFx0XHRcdGlmICggdGV4dHVyZXNbIG5hbWUgXSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRlcmlhbExvYWRlcjogVW5kZWZpbmVkIHRleHR1cmUnLCBuYW1lICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRyZXR1cm4gdGV4dHVyZXNbIG5hbWUgXTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0dmFyIG1hdGVyaWFsID0gbmV3IE1hdGVyaWFsc1sganNvbi50eXBlIF0oKTtcblxuICAgIFx0XHRpZiAoIGpzb24udXVpZCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwudXVpZCA9IGpzb24udXVpZDtcbiAgICBcdFx0aWYgKCBqc29uLm5hbWUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLm5hbWUgPSBqc29uLm5hbWU7XG4gICAgXHRcdGlmICgganNvbi5jb2xvciAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuY29sb3Iuc2V0SGV4KCBqc29uLmNvbG9yICk7XG4gICAgXHRcdGlmICgganNvbi5yb3VnaG5lc3MgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnJvdWdobmVzcyA9IGpzb24ucm91Z2huZXNzO1xuICAgIFx0XHRpZiAoIGpzb24ubWV0YWxuZXNzICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5tZXRhbG5lc3MgPSBqc29uLm1ldGFsbmVzcztcbiAgICBcdFx0aWYgKCBqc29uLmVtaXNzaXZlICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5lbWlzc2l2ZS5zZXRIZXgoIGpzb24uZW1pc3NpdmUgKTtcbiAgICBcdFx0aWYgKCBqc29uLnNwZWN1bGFyICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zcGVjdWxhci5zZXRIZXgoIGpzb24uc3BlY3VsYXIgKTtcbiAgICBcdFx0aWYgKCBqc29uLnNoaW5pbmVzcyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc2hpbmluZXNzID0ganNvbi5zaGluaW5lc3M7XG4gICAgXHRcdGlmICgganNvbi51bmlmb3JtcyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwudW5pZm9ybXMgPSBqc29uLnVuaWZvcm1zO1xuICAgIFx0XHRpZiAoIGpzb24udmVydGV4U2hhZGVyICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC52ZXJ0ZXhTaGFkZXIgPSBqc29uLnZlcnRleFNoYWRlcjtcbiAgICBcdFx0aWYgKCBqc29uLmZyYWdtZW50U2hhZGVyICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5mcmFnbWVudFNoYWRlciA9IGpzb24uZnJhZ21lbnRTaGFkZXI7XG4gICAgXHRcdGlmICgganNvbi52ZXJ0ZXhDb2xvcnMgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnZlcnRleENvbG9ycyA9IGpzb24udmVydGV4Q29sb3JzO1xuICAgIFx0XHRpZiAoIGpzb24uZm9nICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5mb2cgPSBqc29uLmZvZztcbiAgICBcdFx0aWYgKCBqc29uLnNoYWRpbmcgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnNoYWRpbmcgPSBqc29uLnNoYWRpbmc7XG4gICAgXHRcdGlmICgganNvbi5ibGVuZGluZyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuYmxlbmRpbmcgPSBqc29uLmJsZW5kaW5nO1xuICAgIFx0XHRpZiAoIGpzb24uc2lkZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc2lkZSA9IGpzb24uc2lkZTtcbiAgICBcdFx0aWYgKCBqc29uLm9wYWNpdHkgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLm9wYWNpdHkgPSBqc29uLm9wYWNpdHk7XG4gICAgXHRcdGlmICgganNvbi50cmFuc3BhcmVudCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwudHJhbnNwYXJlbnQgPSBqc29uLnRyYW5zcGFyZW50O1xuICAgIFx0XHRpZiAoIGpzb24uYWxwaGFUZXN0ICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5hbHBoYVRlc3QgPSBqc29uLmFscGhhVGVzdDtcbiAgICBcdFx0aWYgKCBqc29uLmRlcHRoVGVzdCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZGVwdGhUZXN0ID0ganNvbi5kZXB0aFRlc3Q7XG4gICAgXHRcdGlmICgganNvbi5kZXB0aFdyaXRlICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5kZXB0aFdyaXRlID0ganNvbi5kZXB0aFdyaXRlO1xuICAgIFx0XHRpZiAoIGpzb24uY29sb3JXcml0ZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuY29sb3JXcml0ZSA9IGpzb24uY29sb3JXcml0ZTtcbiAgICBcdFx0aWYgKCBqc29uLndpcmVmcmFtZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwud2lyZWZyYW1lID0ganNvbi53aXJlZnJhbWU7XG4gICAgXHRcdGlmICgganNvbi53aXJlZnJhbWVMaW5ld2lkdGggIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLndpcmVmcmFtZUxpbmV3aWR0aCA9IGpzb24ud2lyZWZyYW1lTGluZXdpZHRoO1xuICAgIFx0XHRpZiAoIGpzb24ud2lyZWZyYW1lTGluZWNhcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwud2lyZWZyYW1lTGluZWNhcCA9IGpzb24ud2lyZWZyYW1lTGluZWNhcDtcbiAgICBcdFx0aWYgKCBqc29uLndpcmVmcmFtZUxpbmVqb2luICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC53aXJlZnJhbWVMaW5lam9pbiA9IGpzb24ud2lyZWZyYW1lTGluZWpvaW47XG4gICAgXHRcdGlmICgganNvbi5za2lubmluZyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc2tpbm5pbmcgPSBqc29uLnNraW5uaW5nO1xuICAgIFx0XHRpZiAoIGpzb24ubW9ycGhUYXJnZXRzICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5tb3JwaFRhcmdldHMgPSBqc29uLm1vcnBoVGFyZ2V0cztcblxuICAgIFx0XHQvLyBmb3IgUG9pbnRzTWF0ZXJpYWxcblxuICAgIFx0XHRpZiAoIGpzb24uc2l6ZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc2l6ZSA9IGpzb24uc2l6ZTtcbiAgICBcdFx0aWYgKCBqc29uLnNpemVBdHRlbnVhdGlvbiAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc2l6ZUF0dGVudWF0aW9uID0ganNvbi5zaXplQXR0ZW51YXRpb247XG5cbiAgICBcdFx0Ly8gbWFwc1xuXG4gICAgXHRcdGlmICgganNvbi5tYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLm1hcCA9IGdldFRleHR1cmUoIGpzb24ubWFwICk7XG5cbiAgICBcdFx0aWYgKCBqc29uLmFscGhhTWFwICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRtYXRlcmlhbC5hbHBoYU1hcCA9IGdldFRleHR1cmUoIGpzb24uYWxwaGFNYXAgKTtcbiAgICBcdFx0XHRtYXRlcmlhbC50cmFuc3BhcmVudCA9IHRydWU7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGlmICgganNvbi5idW1wTWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5idW1wTWFwID0gZ2V0VGV4dHVyZSgganNvbi5idW1wTWFwICk7XG4gICAgXHRcdGlmICgganNvbi5idW1wU2NhbGUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmJ1bXBTY2FsZSA9IGpzb24uYnVtcFNjYWxlO1xuXG4gICAgXHRcdGlmICgganNvbi5ub3JtYWxNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLm5vcm1hbE1hcCA9IGdldFRleHR1cmUoIGpzb24ubm9ybWFsTWFwICk7XG4gICAgXHRcdGlmICgganNvbi5ub3JtYWxTY2FsZSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0dmFyIG5vcm1hbFNjYWxlID0ganNvbi5ub3JtYWxTY2FsZTtcblxuICAgIFx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggbm9ybWFsU2NhbGUgKSA9PT0gZmFsc2UgKSB7XG5cbiAgICBcdFx0XHRcdC8vIEJsZW5kZXIgZXhwb3J0ZXIgdXNlZCB0byBleHBvcnQgYSBzY2FsYXIuIFNlZSAjNzQ1OVxuXG4gICAgXHRcdFx0XHRub3JtYWxTY2FsZSA9IFsgbm9ybWFsU2NhbGUsIG5vcm1hbFNjYWxlIF07XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRtYXRlcmlhbC5ub3JtYWxTY2FsZSA9IG5ldyBWZWN0b3IyKCkuZnJvbUFycmF5KCBub3JtYWxTY2FsZSApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRpZiAoIGpzb24uZGlzcGxhY2VtZW50TWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXAgPSBnZXRUZXh0dXJlKCBqc29uLmRpc3BsYWNlbWVudE1hcCApO1xuICAgIFx0XHRpZiAoIGpzb24uZGlzcGxhY2VtZW50U2NhbGUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmRpc3BsYWNlbWVudFNjYWxlID0ganNvbi5kaXNwbGFjZW1lbnRTY2FsZTtcbiAgICBcdFx0aWYgKCBqc29uLmRpc3BsYWNlbWVudEJpYXMgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmRpc3BsYWNlbWVudEJpYXMgPSBqc29uLmRpc3BsYWNlbWVudEJpYXM7XG5cbiAgICBcdFx0aWYgKCBqc29uLnJvdWdobmVzc01hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwucm91Z2huZXNzTWFwID0gZ2V0VGV4dHVyZSgganNvbi5yb3VnaG5lc3NNYXAgKTtcbiAgICBcdFx0aWYgKCBqc29uLm1ldGFsbmVzc01hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwubWV0YWxuZXNzTWFwID0gZ2V0VGV4dHVyZSgganNvbi5tZXRhbG5lc3NNYXAgKTtcblxuICAgIFx0XHRpZiAoIGpzb24uZW1pc3NpdmVNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmVtaXNzaXZlTWFwID0gZ2V0VGV4dHVyZSgganNvbi5lbWlzc2l2ZU1hcCApO1xuICAgIFx0XHRpZiAoIGpzb24uZW1pc3NpdmVJbnRlbnNpdHkgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmVtaXNzaXZlSW50ZW5zaXR5ID0ganNvbi5lbWlzc2l2ZUludGVuc2l0eTtcblxuICAgIFx0XHRpZiAoIGpzb24uc3BlY3VsYXJNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnNwZWN1bGFyTWFwID0gZ2V0VGV4dHVyZSgganNvbi5zcGVjdWxhck1hcCApO1xuXG4gICAgXHRcdGlmICgganNvbi5lbnZNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmVudk1hcCA9IGdldFRleHR1cmUoIGpzb24uZW52TWFwICk7XG5cbiAgICBcdFx0aWYgKCBqc29uLnJlZmxlY3Rpdml0eSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwucmVmbGVjdGl2aXR5ID0ganNvbi5yZWZsZWN0aXZpdHk7XG5cbiAgICBcdFx0aWYgKCBqc29uLmxpZ2h0TWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5saWdodE1hcCA9IGdldFRleHR1cmUoIGpzb24ubGlnaHRNYXAgKTtcbiAgICBcdFx0aWYgKCBqc29uLmxpZ2h0TWFwSW50ZW5zaXR5ICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5saWdodE1hcEludGVuc2l0eSA9IGpzb24ubGlnaHRNYXBJbnRlbnNpdHk7XG5cbiAgICBcdFx0aWYgKCBqc29uLmFvTWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5hb01hcCA9IGdldFRleHR1cmUoIGpzb24uYW9NYXAgKTtcbiAgICBcdFx0aWYgKCBqc29uLmFvTWFwSW50ZW5zaXR5ICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5hb01hcEludGVuc2l0eSA9IGpzb24uYW9NYXBJbnRlbnNpdHk7XG5cbiAgICBcdFx0Ly8gTXVsdGlNYXRlcmlhbFxuXG4gICAgXHRcdGlmICgganNvbi5tYXRlcmlhbHMgIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGpzb24ubWF0ZXJpYWxzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICBcdFx0XHRcdG1hdGVyaWFsLm1hdGVyaWFscy5wdXNoKCB0aGlzLnBhcnNlKCBqc29uLm1hdGVyaWFsc1sgaSBdICkgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIG1hdGVyaWFsO1xuXG4gICAgXHR9XG5cbiAgICB9ICk7XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gQnVmZmVyR2VvbWV0cnlMb2FkZXIoIG1hbmFnZXIgKSB7XG5cbiAgICBcdHRoaXMubWFuYWdlciA9ICggbWFuYWdlciAhPT0gdW5kZWZpbmVkICkgPyBtYW5hZ2VyIDogZXhwb3J0cy5EZWZhdWx0TG9hZGluZ01hbmFnZXI7XG5cbiAgICB9XG5cbiAgICBPYmplY3QuYXNzaWduKCBCdWZmZXJHZW9tZXRyeUxvYWRlci5wcm90b3R5cGUsIHtcblxuICAgIFx0bG9hZDogZnVuY3Rpb24gKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcblxuICAgIFx0XHR2YXIgc2NvcGUgPSB0aGlzO1xuXG4gICAgXHRcdHZhciBsb2FkZXIgPSBuZXcgWEhSTG9hZGVyKCBzY29wZS5tYW5hZ2VyICk7XG4gICAgXHRcdGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggdGV4dCApIHtcblxuICAgIFx0XHRcdG9uTG9hZCggc2NvcGUucGFyc2UoIEpTT04ucGFyc2UoIHRleHQgKSApICk7XG5cbiAgICBcdFx0fSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRwYXJzZTogZnVuY3Rpb24gKCBqc29uICkge1xuXG4gICAgXHRcdHZhciBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuXG4gICAgXHRcdHZhciBpbmRleCA9IGpzb24uZGF0YS5pbmRleDtcblxuICAgIFx0XHR2YXIgVFlQRURfQVJSQVlTID0ge1xuICAgIFx0XHRcdCdJbnQ4QXJyYXknOiBJbnQ4QXJyYXksXG4gICAgXHRcdFx0J1VpbnQ4QXJyYXknOiBVaW50OEFycmF5LFxuICAgIFx0XHRcdCdVaW50OENsYW1wZWRBcnJheSc6IFVpbnQ4Q2xhbXBlZEFycmF5LFxuICAgIFx0XHRcdCdJbnQxNkFycmF5JzogSW50MTZBcnJheSxcbiAgICBcdFx0XHQnVWludDE2QXJyYXknOiBVaW50MTZBcnJheSxcbiAgICBcdFx0XHQnSW50MzJBcnJheSc6IEludDMyQXJyYXksXG4gICAgXHRcdFx0J1VpbnQzMkFycmF5JzogVWludDMyQXJyYXksXG4gICAgXHRcdFx0J0Zsb2F0MzJBcnJheSc6IEZsb2F0MzJBcnJheSxcbiAgICBcdFx0XHQnRmxvYXQ2NEFycmF5JzogRmxvYXQ2NEFycmF5XG4gICAgXHRcdH07XG5cbiAgICBcdFx0aWYgKCBpbmRleCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0dmFyIHR5cGVkQXJyYXkgPSBuZXcgVFlQRURfQVJSQVlTWyBpbmRleC50eXBlIF0oIGluZGV4LmFycmF5ICk7XG4gICAgXHRcdFx0Z2VvbWV0cnkuc2V0SW5kZXgoIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIHR5cGVkQXJyYXksIDEgKSApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHR2YXIgYXR0cmlidXRlcyA9IGpzb24uZGF0YS5hdHRyaWJ1dGVzO1xuXG4gICAgXHRcdGZvciAoIHZhciBrZXkgaW4gYXR0cmlidXRlcyApIHtcblxuICAgIFx0XHRcdHZhciBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzWyBrZXkgXTtcbiAgICBcdFx0XHR2YXIgdHlwZWRBcnJheSA9IG5ldyBUWVBFRF9BUlJBWVNbIGF0dHJpYnV0ZS50eXBlIF0oIGF0dHJpYnV0ZS5hcnJheSApO1xuXG4gICAgXHRcdFx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCBrZXksIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIHR5cGVkQXJyYXksIGF0dHJpYnV0ZS5pdGVtU2l6ZSwgYXR0cmlidXRlLm5vcm1hbGl6ZWQgKSApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHR2YXIgZ3JvdXBzID0ganNvbi5kYXRhLmdyb3VwcyB8fCBqc29uLmRhdGEuZHJhd2NhbGxzIHx8IGpzb24uZGF0YS5vZmZzZXRzO1xuXG4gICAgXHRcdGlmICggZ3JvdXBzICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIG4gPSBncm91cHMubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xuXG4gICAgXHRcdFx0XHR2YXIgZ3JvdXAgPSBncm91cHNbIGkgXTtcblxuICAgIFx0XHRcdFx0Z2VvbWV0cnkuYWRkR3JvdXAoIGdyb3VwLnN0YXJ0LCBncm91cC5jb3VudCwgZ3JvdXAubWF0ZXJpYWxJbmRleCApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHR2YXIgYm91bmRpbmdTcGhlcmUgPSBqc29uLmRhdGEuYm91bmRpbmdTcGhlcmU7XG5cbiAgICBcdFx0aWYgKCBib3VuZGluZ1NwaGVyZSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0dmFyIGNlbnRlciA9IG5ldyBWZWN0b3IzKCk7XG5cbiAgICBcdFx0XHRpZiAoIGJvdW5kaW5nU3BoZXJlLmNlbnRlciAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0XHRjZW50ZXIuZnJvbUFycmF5KCBib3VuZGluZ1NwaGVyZS5jZW50ZXIgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlID0gbmV3IFNwaGVyZSggY2VudGVyLCBib3VuZGluZ1NwaGVyZS5yYWRpdXMgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIGdlb21ldHJ5O1xuXG4gICAgXHR9XG5cbiAgICB9ICk7XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gTG9hZGVyKCkge1xuXG4gICAgXHR0aGlzLm9uTG9hZFN0YXJ0ID0gZnVuY3Rpb24gKCkge307XG4gICAgXHR0aGlzLm9uTG9hZFByb2dyZXNzID0gZnVuY3Rpb24gKCkge307XG4gICAgXHR0aGlzLm9uTG9hZENvbXBsZXRlID0gZnVuY3Rpb24gKCkge307XG5cbiAgICB9XG5cbiAgICBMb2FkZXIucHJvdG90eXBlID0ge1xuXG4gICAgXHRjb25zdHJ1Y3RvcjogTG9hZGVyLFxuXG4gICAgXHRjcm9zc09yaWdpbjogdW5kZWZpbmVkLFxuXG4gICAgXHRleHRyYWN0VXJsQmFzZTogZnVuY3Rpb24gKCB1cmwgKSB7XG5cbiAgICBcdFx0dmFyIHBhcnRzID0gdXJsLnNwbGl0KCAnLycgKTtcblxuICAgIFx0XHRpZiAoIHBhcnRzLmxlbmd0aCA9PT0gMSApIHJldHVybiAnLi8nO1xuXG4gICAgXHRcdHBhcnRzLnBvcCgpO1xuXG4gICAgXHRcdHJldHVybiBwYXJ0cy5qb2luKCAnLycgKSArICcvJztcblxuICAgIFx0fSxcblxuICAgIFx0aW5pdE1hdGVyaWFsczogZnVuY3Rpb24gKCBtYXRlcmlhbHMsIHRleHR1cmVQYXRoLCBjcm9zc09yaWdpbiApIHtcblxuICAgIFx0XHR2YXIgYXJyYXkgPSBbXTtcblxuICAgIFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBtYXRlcmlhbHMubGVuZ3RoOyArKyBpICkge1xuXG4gICAgXHRcdFx0YXJyYXlbIGkgXSA9IHRoaXMuY3JlYXRlTWF0ZXJpYWwoIG1hdGVyaWFsc1sgaSBdLCB0ZXh0dXJlUGF0aCwgY3Jvc3NPcmlnaW4gKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIGFycmF5O1xuXG4gICAgXHR9LFxuXG4gICAgXHRjcmVhdGVNYXRlcmlhbDogKCBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dmFyIGNvbG9yLCB0ZXh0dXJlTG9hZGVyLCBtYXRlcmlhbExvYWRlcjtcblxuICAgIFx0XHRyZXR1cm4gZnVuY3Rpb24gY3JlYXRlTWF0ZXJpYWwoIG0sIHRleHR1cmVQYXRoLCBjcm9zc09yaWdpbiApIHtcblxuICAgIFx0XHRcdGlmICggY29sb3IgPT09IHVuZGVmaW5lZCApIGNvbG9yID0gbmV3IENvbG9yKCk7XG4gICAgXHRcdFx0aWYgKCB0ZXh0dXJlTG9hZGVyID09PSB1bmRlZmluZWQgKSB0ZXh0dXJlTG9hZGVyID0gbmV3IFRleHR1cmVMb2FkZXIoKTtcbiAgICBcdFx0XHRpZiAoIG1hdGVyaWFsTG9hZGVyID09PSB1bmRlZmluZWQgKSBtYXRlcmlhbExvYWRlciA9IG5ldyBNYXRlcmlhbExvYWRlcigpO1xuXG4gICAgXHRcdFx0Ly8gY29udmVydCBmcm9tIG9sZCBtYXRlcmlhbCBmb3JtYXRcblxuICAgIFx0XHRcdHZhciB0ZXh0dXJlcyA9IHt9O1xuXG4gICAgXHRcdFx0ZnVuY3Rpb24gbG9hZFRleHR1cmUoIHBhdGgsIHJlcGVhdCwgb2Zmc2V0LCB3cmFwLCBhbmlzb3Ryb3B5ICkge1xuXG4gICAgXHRcdFx0XHR2YXIgZnVsbFBhdGggPSB0ZXh0dXJlUGF0aCArIHBhdGg7XG4gICAgXHRcdFx0XHR2YXIgbG9hZGVyID0gTG9hZGVyLkhhbmRsZXJzLmdldCggZnVsbFBhdGggKTtcblxuICAgIFx0XHRcdFx0dmFyIHRleHR1cmU7XG5cbiAgICBcdFx0XHRcdGlmICggbG9hZGVyICE9PSBudWxsICkge1xuXG4gICAgXHRcdFx0XHRcdHRleHR1cmUgPSBsb2FkZXIubG9hZCggZnVsbFBhdGggKTtcblxuICAgIFx0XHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0XHR0ZXh0dXJlTG9hZGVyLnNldENyb3NzT3JpZ2luKCBjcm9zc09yaWdpbiApO1xuICAgIFx0XHRcdFx0XHR0ZXh0dXJlID0gdGV4dHVyZUxvYWRlci5sb2FkKCBmdWxsUGF0aCApO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdGlmICggcmVwZWF0ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRcdFx0dGV4dHVyZS5yZXBlYXQuZnJvbUFycmF5KCByZXBlYXQgKTtcblxuICAgIFx0XHRcdFx0XHRpZiAoIHJlcGVhdFsgMCBdICE9PSAxICkgdGV4dHVyZS53cmFwUyA9IFJlcGVhdFdyYXBwaW5nO1xuICAgIFx0XHRcdFx0XHRpZiAoIHJlcGVhdFsgMSBdICE9PSAxICkgdGV4dHVyZS53cmFwVCA9IFJlcGVhdFdyYXBwaW5nO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdGlmICggb2Zmc2V0ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRcdFx0dGV4dHVyZS5vZmZzZXQuZnJvbUFycmF5KCBvZmZzZXQgKTtcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHRpZiAoIHdyYXAgIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0XHRpZiAoIHdyYXBbIDAgXSA9PT0gJ3JlcGVhdCcgKSB0ZXh0dXJlLndyYXBTID0gUmVwZWF0V3JhcHBpbmc7XG4gICAgXHRcdFx0XHRcdGlmICggd3JhcFsgMCBdID09PSAnbWlycm9yJyApIHRleHR1cmUud3JhcFMgPSBNaXJyb3JlZFJlcGVhdFdyYXBwaW5nO1xuXG4gICAgXHRcdFx0XHRcdGlmICggd3JhcFsgMSBdID09PSAncmVwZWF0JyApIHRleHR1cmUud3JhcFQgPSBSZXBlYXRXcmFwcGluZztcbiAgICBcdFx0XHRcdFx0aWYgKCB3cmFwWyAxIF0gPT09ICdtaXJyb3InICkgdGV4dHVyZS53cmFwVCA9IE1pcnJvcmVkUmVwZWF0V3JhcHBpbmc7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0aWYgKCBhbmlzb3Ryb3B5ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRcdFx0dGV4dHVyZS5hbmlzb3Ryb3B5ID0gYW5pc290cm9weTtcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHR2YXIgdXVpZCA9IGV4cG9ydHMuTWF0aC5nZW5lcmF0ZVVVSUQoKTtcblxuICAgIFx0XHRcdFx0dGV4dHVyZXNbIHV1aWQgXSA9IHRleHR1cmU7XG5cbiAgICBcdFx0XHRcdHJldHVybiB1dWlkO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0Ly9cblxuICAgIFx0XHRcdHZhciBqc29uID0ge1xuICAgIFx0XHRcdFx0dXVpZDogZXhwb3J0cy5NYXRoLmdlbmVyYXRlVVVJRCgpLFxuICAgIFx0XHRcdFx0dHlwZTogJ01lc2hMYW1iZXJ0TWF0ZXJpYWwnXG4gICAgXHRcdFx0fTtcblxuICAgIFx0XHRcdGZvciAoIHZhciBuYW1lIGluIG0gKSB7XG5cbiAgICBcdFx0XHRcdHZhciB2YWx1ZSA9IG1bIG5hbWUgXTtcblxuICAgIFx0XHRcdFx0c3dpdGNoICggbmFtZSApIHtcbiAgICBcdFx0XHRcdFx0Y2FzZSAnRGJnQ29sb3InOlxuICAgIFx0XHRcdFx0XHRjYXNlICdEYmdJbmRleCc6XG4gICAgXHRcdFx0XHRcdGNhc2UgJ29wdGljYWxEZW5zaXR5JzpcbiAgICBcdFx0XHRcdFx0Y2FzZSAnaWxsdW1pbmF0aW9uJzpcbiAgICBcdFx0XHRcdFx0XHRicmVhaztcbiAgICBcdFx0XHRcdFx0Y2FzZSAnRGJnTmFtZSc6XG4gICAgXHRcdFx0XHRcdFx0anNvbi5uYW1lID0gdmFsdWU7XG4gICAgXHRcdFx0XHRcdFx0YnJlYWs7XG4gICAgXHRcdFx0XHRcdGNhc2UgJ2JsZW5kaW5nJzpcbiAgICBcdFx0XHRcdFx0XHRqc29uLmJsZW5kaW5nID0gQmxlbmRpbmdNb2RlWyB2YWx1ZSBdO1xuICAgIFx0XHRcdFx0XHRcdGJyZWFrO1xuICAgIFx0XHRcdFx0XHRjYXNlICdjb2xvckFtYmllbnQnOlxuICAgIFx0XHRcdFx0XHRjYXNlICdtYXBBbWJpZW50JzpcbiAgICBcdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Mb2FkZXIuY3JlYXRlTWF0ZXJpYWw6JywgbmFtZSwgJ2lzIG5vIGxvbmdlciBzdXBwb3J0ZWQuJyApO1xuICAgIFx0XHRcdFx0XHRcdGJyZWFrO1xuICAgIFx0XHRcdFx0XHRjYXNlICdjb2xvckRpZmZ1c2UnOlxuICAgIFx0XHRcdFx0XHRcdGpzb24uY29sb3IgPSBjb2xvci5mcm9tQXJyYXkoIHZhbHVlICkuZ2V0SGV4KCk7XG4gICAgXHRcdFx0XHRcdFx0YnJlYWs7XG4gICAgXHRcdFx0XHRcdGNhc2UgJ2NvbG9yU3BlY3VsYXInOlxuICAgIFx0XHRcdFx0XHRcdGpzb24uc3BlY3VsYXIgPSBjb2xvci5mcm9tQXJyYXkoIHZhbHVlICkuZ2V0SGV4KCk7XG4gICAgXHRcdFx0XHRcdFx0YnJlYWs7XG4gICAgXHRcdFx0XHRcdGNhc2UgJ2NvbG9yRW1pc3NpdmUnOlxuICAgIFx0XHRcdFx0XHRcdGpzb24uZW1pc3NpdmUgPSBjb2xvci5mcm9tQXJyYXkoIHZhbHVlICkuZ2V0SGV4KCk7XG4gICAgXHRcdFx0XHRcdFx0YnJlYWs7XG4gICAgXHRcdFx0XHRcdGNhc2UgJ3NwZWN1bGFyQ29lZic6XG4gICAgXHRcdFx0XHRcdFx0anNvbi5zaGluaW5lc3MgPSB2YWx1ZTtcbiAgICBcdFx0XHRcdFx0XHRicmVhaztcbiAgICBcdFx0XHRcdFx0Y2FzZSAnc2hhZGluZyc6XG4gICAgXHRcdFx0XHRcdFx0aWYgKCB2YWx1ZS50b0xvd2VyQ2FzZSgpID09PSAnYmFzaWMnICkganNvbi50eXBlID0gJ01lc2hCYXNpY01hdGVyaWFsJztcbiAgICBcdFx0XHRcdFx0XHRpZiAoIHZhbHVlLnRvTG93ZXJDYXNlKCkgPT09ICdwaG9uZycgKSBqc29uLnR5cGUgPSAnTWVzaFBob25nTWF0ZXJpYWwnO1xuICAgIFx0XHRcdFx0XHRcdGlmICggdmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gJ3N0YW5kYXJkJyApIGpzb24udHlwZSA9ICdNZXNoU3RhbmRhcmRNYXRlcmlhbCc7XG4gICAgXHRcdFx0XHRcdFx0YnJlYWs7XG4gICAgXHRcdFx0XHRcdGNhc2UgJ21hcERpZmZ1c2UnOlxuICAgIFx0XHRcdFx0XHRcdGpzb24ubWFwID0gbG9hZFRleHR1cmUoIHZhbHVlLCBtLm1hcERpZmZ1c2VSZXBlYXQsIG0ubWFwRGlmZnVzZU9mZnNldCwgbS5tYXBEaWZmdXNlV3JhcCwgbS5tYXBEaWZmdXNlQW5pc290cm9weSApO1xuICAgIFx0XHRcdFx0XHRcdGJyZWFrO1xuICAgIFx0XHRcdFx0XHRjYXNlICdtYXBEaWZmdXNlUmVwZWF0JzpcbiAgICBcdFx0XHRcdFx0Y2FzZSAnbWFwRGlmZnVzZU9mZnNldCc6XG4gICAgXHRcdFx0XHRcdGNhc2UgJ21hcERpZmZ1c2VXcmFwJzpcbiAgICBcdFx0XHRcdFx0Y2FzZSAnbWFwRGlmZnVzZUFuaXNvdHJvcHknOlxuICAgIFx0XHRcdFx0XHRcdGJyZWFrO1xuICAgIFx0XHRcdFx0XHRjYXNlICdtYXBFbWlzc2l2ZSc6XG4gICAgXHRcdFx0XHRcdFx0anNvbi5lbWlzc2l2ZU1hcCA9IGxvYWRUZXh0dXJlKCB2YWx1ZSwgbS5tYXBFbWlzc2l2ZVJlcGVhdCwgbS5tYXBFbWlzc2l2ZU9mZnNldCwgbS5tYXBFbWlzc2l2ZVdyYXAsIG0ubWFwRW1pc3NpdmVBbmlzb3Ryb3B5ICk7XG4gICAgXHRcdFx0XHRcdFx0YnJlYWs7XG4gICAgXHRcdFx0XHRcdGNhc2UgJ21hcEVtaXNzaXZlUmVwZWF0JzpcbiAgICBcdFx0XHRcdFx0Y2FzZSAnbWFwRW1pc3NpdmVPZmZzZXQnOlxuICAgIFx0XHRcdFx0XHRjYXNlICdtYXBFbWlzc2l2ZVdyYXAnOlxuICAgIFx0XHRcdFx0XHRjYXNlICdtYXBFbWlzc2l2ZUFuaXNvdHJvcHknOlxuICAgIFx0XHRcdFx0XHRcdGJyZWFrO1xuICAgIFx0XHRcdFx0XHRjYXNlICdtYXBMaWdodCc6XG4gICAgXHRcdFx0XHRcdFx0anNvbi5saWdodE1hcCA9IGxvYWRUZXh0dXJlKCB2YWx1ZSwgbS5tYXBMaWdodFJlcGVhdCwgbS5tYXBMaWdodE9mZnNldCwgbS5tYXBMaWdodFdyYXAsIG0ubWFwTGlnaHRBbmlzb3Ryb3B5ICk7XG4gICAgXHRcdFx0XHRcdFx0YnJlYWs7XG4gICAgXHRcdFx0XHRcdGNhc2UgJ21hcExpZ2h0UmVwZWF0JzpcbiAgICBcdFx0XHRcdFx0Y2FzZSAnbWFwTGlnaHRPZmZzZXQnOlxuICAgIFx0XHRcdFx0XHRjYXNlICdtYXBMaWdodFdyYXAnOlxuICAgIFx0XHRcdFx0XHRjYXNlICdtYXBMaWdodEFuaXNvdHJvcHknOlxuICAgIFx0XHRcdFx0XHRcdGJyZWFrO1xuICAgIFx0XHRcdFx0XHRjYXNlICdtYXBBTyc6XG4gICAgXHRcdFx0XHRcdFx0anNvbi5hb01hcCA9IGxvYWRUZXh0dXJlKCB2YWx1ZSwgbS5tYXBBT1JlcGVhdCwgbS5tYXBBT09mZnNldCwgbS5tYXBBT1dyYXAsIG0ubWFwQU9Bbmlzb3Ryb3B5ICk7XG4gICAgXHRcdFx0XHRcdFx0YnJlYWs7XG4gICAgXHRcdFx0XHRcdGNhc2UgJ21hcEFPUmVwZWF0JzpcbiAgICBcdFx0XHRcdFx0Y2FzZSAnbWFwQU9PZmZzZXQnOlxuICAgIFx0XHRcdFx0XHRjYXNlICdtYXBBT1dyYXAnOlxuICAgIFx0XHRcdFx0XHRjYXNlICdtYXBBT0FuaXNvdHJvcHknOlxuICAgIFx0XHRcdFx0XHRcdGJyZWFrO1xuICAgIFx0XHRcdFx0XHRjYXNlICdtYXBCdW1wJzpcbiAgICBcdFx0XHRcdFx0XHRqc29uLmJ1bXBNYXAgPSBsb2FkVGV4dHVyZSggdmFsdWUsIG0ubWFwQnVtcFJlcGVhdCwgbS5tYXBCdW1wT2Zmc2V0LCBtLm1hcEJ1bXBXcmFwLCBtLm1hcEJ1bXBBbmlzb3Ryb3B5ICk7XG4gICAgXHRcdFx0XHRcdFx0YnJlYWs7XG4gICAgXHRcdFx0XHRcdGNhc2UgJ21hcEJ1bXBTY2FsZSc6XG4gICAgXHRcdFx0XHRcdFx0anNvbi5idW1wU2NhbGUgPSB2YWx1ZTtcbiAgICBcdFx0XHRcdFx0XHRicmVhaztcbiAgICBcdFx0XHRcdFx0Y2FzZSAnbWFwQnVtcFJlcGVhdCc6XG4gICAgXHRcdFx0XHRcdGNhc2UgJ21hcEJ1bXBPZmZzZXQnOlxuICAgIFx0XHRcdFx0XHRjYXNlICdtYXBCdW1wV3JhcCc6XG4gICAgXHRcdFx0XHRcdGNhc2UgJ21hcEJ1bXBBbmlzb3Ryb3B5JzpcbiAgICBcdFx0XHRcdFx0XHRicmVhaztcbiAgICBcdFx0XHRcdFx0Y2FzZSAnbWFwTm9ybWFsJzpcbiAgICBcdFx0XHRcdFx0XHRqc29uLm5vcm1hbE1hcCA9IGxvYWRUZXh0dXJlKCB2YWx1ZSwgbS5tYXBOb3JtYWxSZXBlYXQsIG0ubWFwTm9ybWFsT2Zmc2V0LCBtLm1hcE5vcm1hbFdyYXAsIG0ubWFwTm9ybWFsQW5pc290cm9weSApO1xuICAgIFx0XHRcdFx0XHRcdGJyZWFrO1xuICAgIFx0XHRcdFx0XHRjYXNlICdtYXBOb3JtYWxGYWN0b3InOlxuICAgIFx0XHRcdFx0XHRcdGpzb24ubm9ybWFsU2NhbGUgPSBbIHZhbHVlLCB2YWx1ZSBdO1xuICAgIFx0XHRcdFx0XHRcdGJyZWFrO1xuICAgIFx0XHRcdFx0XHRjYXNlICdtYXBOb3JtYWxSZXBlYXQnOlxuICAgIFx0XHRcdFx0XHRjYXNlICdtYXBOb3JtYWxPZmZzZXQnOlxuICAgIFx0XHRcdFx0XHRjYXNlICdtYXBOb3JtYWxXcmFwJzpcbiAgICBcdFx0XHRcdFx0Y2FzZSAnbWFwTm9ybWFsQW5pc290cm9weSc6XG4gICAgXHRcdFx0XHRcdFx0YnJlYWs7XG4gICAgXHRcdFx0XHRcdGNhc2UgJ21hcFNwZWN1bGFyJzpcbiAgICBcdFx0XHRcdFx0XHRqc29uLnNwZWN1bGFyTWFwID0gbG9hZFRleHR1cmUoIHZhbHVlLCBtLm1hcFNwZWN1bGFyUmVwZWF0LCBtLm1hcFNwZWN1bGFyT2Zmc2V0LCBtLm1hcFNwZWN1bGFyV3JhcCwgbS5tYXBTcGVjdWxhckFuaXNvdHJvcHkgKTtcbiAgICBcdFx0XHRcdFx0XHRicmVhaztcbiAgICBcdFx0XHRcdFx0Y2FzZSAnbWFwU3BlY3VsYXJSZXBlYXQnOlxuICAgIFx0XHRcdFx0XHRjYXNlICdtYXBTcGVjdWxhck9mZnNldCc6XG4gICAgXHRcdFx0XHRcdGNhc2UgJ21hcFNwZWN1bGFyV3JhcCc6XG4gICAgXHRcdFx0XHRcdGNhc2UgJ21hcFNwZWN1bGFyQW5pc290cm9weSc6XG4gICAgXHRcdFx0XHRcdFx0YnJlYWs7XG4gICAgXHRcdFx0XHRcdGNhc2UgJ21hcE1ldGFsbmVzcyc6XG4gICAgXHRcdFx0XHRcdFx0anNvbi5tZXRhbG5lc3NNYXAgPSBsb2FkVGV4dHVyZSggdmFsdWUsIG0ubWFwTWV0YWxuZXNzUmVwZWF0LCBtLm1hcE1ldGFsbmVzc09mZnNldCwgbS5tYXBNZXRhbG5lc3NXcmFwLCBtLm1hcE1ldGFsbmVzc0FuaXNvdHJvcHkgKTtcbiAgICBcdFx0XHRcdFx0XHRicmVhaztcbiAgICBcdFx0XHRcdFx0Y2FzZSAnbWFwTWV0YWxuZXNzUmVwZWF0JzpcbiAgICBcdFx0XHRcdFx0Y2FzZSAnbWFwTWV0YWxuZXNzT2Zmc2V0JzpcbiAgICBcdFx0XHRcdFx0Y2FzZSAnbWFwTWV0YWxuZXNzV3JhcCc6XG4gICAgXHRcdFx0XHRcdGNhc2UgJ21hcE1ldGFsbmVzc0FuaXNvdHJvcHknOlxuICAgIFx0XHRcdFx0XHRcdGJyZWFrO1xuICAgIFx0XHRcdFx0XHRjYXNlICdtYXBSb3VnaG5lc3MnOlxuICAgIFx0XHRcdFx0XHRcdGpzb24ucm91Z2huZXNzTWFwID0gbG9hZFRleHR1cmUoIHZhbHVlLCBtLm1hcFJvdWdobmVzc1JlcGVhdCwgbS5tYXBSb3VnaG5lc3NPZmZzZXQsIG0ubWFwUm91Z2huZXNzV3JhcCwgbS5tYXBSb3VnaG5lc3NBbmlzb3Ryb3B5ICk7XG4gICAgXHRcdFx0XHRcdFx0YnJlYWs7XG4gICAgXHRcdFx0XHRcdGNhc2UgJ21hcFJvdWdobmVzc1JlcGVhdCc6XG4gICAgXHRcdFx0XHRcdGNhc2UgJ21hcFJvdWdobmVzc09mZnNldCc6XG4gICAgXHRcdFx0XHRcdGNhc2UgJ21hcFJvdWdobmVzc1dyYXAnOlxuICAgIFx0XHRcdFx0XHRjYXNlICdtYXBSb3VnaG5lc3NBbmlzb3Ryb3B5JzpcbiAgICBcdFx0XHRcdFx0XHRicmVhaztcbiAgICBcdFx0XHRcdFx0Y2FzZSAnbWFwQWxwaGEnOlxuICAgIFx0XHRcdFx0XHRcdGpzb24uYWxwaGFNYXAgPSBsb2FkVGV4dHVyZSggdmFsdWUsIG0ubWFwQWxwaGFSZXBlYXQsIG0ubWFwQWxwaGFPZmZzZXQsIG0ubWFwQWxwaGFXcmFwLCBtLm1hcEFscGhhQW5pc290cm9weSApO1xuICAgIFx0XHRcdFx0XHRcdGJyZWFrO1xuICAgIFx0XHRcdFx0XHRjYXNlICdtYXBBbHBoYVJlcGVhdCc6XG4gICAgXHRcdFx0XHRcdGNhc2UgJ21hcEFscGhhT2Zmc2V0JzpcbiAgICBcdFx0XHRcdFx0Y2FzZSAnbWFwQWxwaGFXcmFwJzpcbiAgICBcdFx0XHRcdFx0Y2FzZSAnbWFwQWxwaGFBbmlzb3Ryb3B5JzpcbiAgICBcdFx0XHRcdFx0XHRicmVhaztcbiAgICBcdFx0XHRcdFx0Y2FzZSAnZmxpcFNpZGVkJzpcbiAgICBcdFx0XHRcdFx0XHRqc29uLnNpZGUgPSBCYWNrU2lkZTtcbiAgICBcdFx0XHRcdFx0XHRicmVhaztcbiAgICBcdFx0XHRcdFx0Y2FzZSAnZG91YmxlU2lkZWQnOlxuICAgIFx0XHRcdFx0XHRcdGpzb24uc2lkZSA9IERvdWJsZVNpZGU7XG4gICAgXHRcdFx0XHRcdFx0YnJlYWs7XG4gICAgXHRcdFx0XHRcdGNhc2UgJ3RyYW5zcGFyZW5jeSc6XG4gICAgXHRcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTG9hZGVyLmNyZWF0ZU1hdGVyaWFsOiB0cmFuc3BhcmVuY3kgaGFzIGJlZW4gcmVuYW1lZCB0byBvcGFjaXR5JyApO1xuICAgIFx0XHRcdFx0XHRcdGpzb24ub3BhY2l0eSA9IHZhbHVlO1xuICAgIFx0XHRcdFx0XHRcdGJyZWFrO1xuICAgIFx0XHRcdFx0XHRjYXNlICdkZXB0aFRlc3QnOlxuICAgIFx0XHRcdFx0XHRjYXNlICdkZXB0aFdyaXRlJzpcbiAgICBcdFx0XHRcdFx0Y2FzZSAnY29sb3JXcml0ZSc6XG4gICAgXHRcdFx0XHRcdGNhc2UgJ29wYWNpdHknOlxuICAgIFx0XHRcdFx0XHRjYXNlICdyZWZsZWN0aXZpdHknOlxuICAgIFx0XHRcdFx0XHRjYXNlICd0cmFuc3BhcmVudCc6XG4gICAgXHRcdFx0XHRcdGNhc2UgJ3Zpc2libGUnOlxuICAgIFx0XHRcdFx0XHRjYXNlICd3aXJlZnJhbWUnOlxuICAgIFx0XHRcdFx0XHRcdGpzb25bIG5hbWUgXSA9IHZhbHVlO1xuICAgIFx0XHRcdFx0XHRcdGJyZWFrO1xuICAgIFx0XHRcdFx0XHRjYXNlICd2ZXJ0ZXhDb2xvcnMnOlxuICAgIFx0XHRcdFx0XHRcdGlmICggdmFsdWUgPT09IHRydWUgKSBqc29uLnZlcnRleENvbG9ycyA9IFZlcnRleENvbG9ycztcbiAgICBcdFx0XHRcdFx0XHRpZiAoIHZhbHVlID09PSAnZmFjZScgKSBqc29uLnZlcnRleENvbG9ycyA9IEZhY2VDb2xvcnM7XG4gICAgXHRcdFx0XHRcdFx0YnJlYWs7XG4gICAgXHRcdFx0XHRcdGRlZmF1bHQ6XG4gICAgXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkxvYWRlci5jcmVhdGVNYXRlcmlhbDogVW5zdXBwb3J0ZWQnLCBuYW1lLCB2YWx1ZSApO1xuICAgIFx0XHRcdFx0XHRcdGJyZWFrO1xuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0aWYgKCBqc29uLnR5cGUgPT09ICdNZXNoQmFzaWNNYXRlcmlhbCcgKSBkZWxldGUganNvbi5lbWlzc2l2ZTtcbiAgICBcdFx0XHRpZiAoIGpzb24udHlwZSAhPT0gJ01lc2hQaG9uZ01hdGVyaWFsJyApIGRlbGV0ZSBqc29uLnNwZWN1bGFyO1xuXG4gICAgXHRcdFx0aWYgKCBqc29uLm9wYWNpdHkgPCAxICkganNvbi50cmFuc3BhcmVudCA9IHRydWU7XG5cbiAgICBcdFx0XHRtYXRlcmlhbExvYWRlci5zZXRUZXh0dXJlcyggdGV4dHVyZXMgKTtcblxuICAgIFx0XHRcdHJldHVybiBtYXRlcmlhbExvYWRlci5wYXJzZSgganNvbiApO1xuXG4gICAgXHRcdH07XG5cbiAgICBcdH0gKSgpXG5cbiAgICB9O1xuXG4gICAgTG9hZGVyLkhhbmRsZXJzID0ge1xuXG4gICAgXHRoYW5kbGVyczogW10sXG5cbiAgICBcdGFkZDogZnVuY3Rpb24gKCByZWdleCwgbG9hZGVyICkge1xuXG4gICAgXHRcdHRoaXMuaGFuZGxlcnMucHVzaCggcmVnZXgsIGxvYWRlciApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRnZXQ6IGZ1bmN0aW9uICggZmlsZSApIHtcblxuICAgIFx0XHR2YXIgaGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzO1xuXG4gICAgXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGhhbmRsZXJzLmxlbmd0aDsgaSA8IGw7IGkgKz0gMiApIHtcblxuICAgIFx0XHRcdHZhciByZWdleCA9IGhhbmRsZXJzWyBpIF07XG4gICAgXHRcdFx0dmFyIGxvYWRlciAgPSBoYW5kbGVyc1sgaSArIDEgXTtcblxuICAgIFx0XHRcdGlmICggcmVnZXgudGVzdCggZmlsZSApICkge1xuXG4gICAgXHRcdFx0XHRyZXR1cm4gbG9hZGVyO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gbnVsbDtcblxuICAgIFx0fVxuXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gICAgICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIEpTT05Mb2FkZXIoIG1hbmFnZXIgKSB7XG5cbiAgICBcdGlmICggdHlwZW9mIG1hbmFnZXIgPT09ICdib29sZWFuJyApIHtcblxuICAgIFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5KU09OTG9hZGVyOiBzaG93U3RhdHVzIHBhcmFtZXRlciBoYXMgYmVlbiByZW1vdmVkIGZyb20gY29uc3RydWN0b3IuJyApO1xuICAgIFx0XHRtYW5hZ2VyID0gdW5kZWZpbmVkO1xuXG4gICAgXHR9XG5cbiAgICBcdHRoaXMubWFuYWdlciA9ICggbWFuYWdlciAhPT0gdW5kZWZpbmVkICkgPyBtYW5hZ2VyIDogZXhwb3J0cy5EZWZhdWx0TG9hZGluZ01hbmFnZXI7XG5cbiAgICBcdHRoaXMud2l0aENyZWRlbnRpYWxzID0gZmFsc2U7XG5cbiAgICB9XG5cbiAgICBPYmplY3QuYXNzaWduKCBKU09OTG9hZGVyLnByb3RvdHlwZSwge1xuXG4gICAgXHRsb2FkOiBmdW5jdGlvbiggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cbiAgICBcdFx0dmFyIHNjb3BlID0gdGhpcztcblxuICAgIFx0XHR2YXIgdGV4dHVyZVBhdGggPSB0aGlzLnRleHR1cmVQYXRoICYmICggdHlwZW9mIHRoaXMudGV4dHVyZVBhdGggPT09IFwic3RyaW5nXCIgKSA/IHRoaXMudGV4dHVyZVBhdGggOiBMb2FkZXIucHJvdG90eXBlLmV4dHJhY3RVcmxCYXNlKCB1cmwgKTtcblxuICAgIFx0XHR2YXIgbG9hZGVyID0gbmV3IFhIUkxvYWRlciggdGhpcy5tYW5hZ2VyICk7XG4gICAgXHRcdGxvYWRlci5zZXRXaXRoQ3JlZGVudGlhbHMoIHRoaXMud2l0aENyZWRlbnRpYWxzICk7XG4gICAgXHRcdGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggdGV4dCApIHtcblxuICAgIFx0XHRcdHZhciBqc29uID0gSlNPTi5wYXJzZSggdGV4dCApO1xuICAgIFx0XHRcdHZhciBtZXRhZGF0YSA9IGpzb24ubWV0YWRhdGE7XG5cbiAgICBcdFx0XHRpZiAoIG1ldGFkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRcdHZhciB0eXBlID0gbWV0YWRhdGEudHlwZTtcblxuICAgIFx0XHRcdFx0aWYgKCB0eXBlICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRcdFx0aWYgKCB0eXBlLnRvTG93ZXJDYXNlKCkgPT09ICdvYmplY3QnICkge1xuXG4gICAgXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkpTT05Mb2FkZXI6ICcgKyB1cmwgKyAnIHNob3VsZCBiZSBsb2FkZWQgd2l0aCBUSFJFRS5PYmplY3RMb2FkZXIgaW5zdGVhZC4nICk7XG4gICAgXHRcdFx0XHRcdFx0cmV0dXJuO1xuXG4gICAgXHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0XHRpZiAoIHR5cGUudG9Mb3dlckNhc2UoKSA9PT0gJ3NjZW5lJyApIHtcblxuICAgIFx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5KU09OTG9hZGVyOiAnICsgdXJsICsgJyBzaG91bGQgYmUgbG9hZGVkIHdpdGggVEhSRUUuU2NlbmVMb2FkZXIgaW5zdGVhZC4nICk7XG4gICAgXHRcdFx0XHRcdFx0cmV0dXJuO1xuXG4gICAgXHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0dmFyIG9iamVjdCA9IHNjb3BlLnBhcnNlKCBqc29uLCB0ZXh0dXJlUGF0aCApO1xuICAgIFx0XHRcdG9uTG9hZCggb2JqZWN0Lmdlb21ldHJ5LCBvYmplY3QubWF0ZXJpYWxzICk7XG5cbiAgICBcdFx0fSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRzZXRUZXh0dXJlUGF0aDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuICAgIFx0XHR0aGlzLnRleHR1cmVQYXRoID0gdmFsdWU7XG5cbiAgICBcdH0sXG5cbiAgICBcdHBhcnNlOiBmdW5jdGlvbiAoIGpzb24sIHRleHR1cmVQYXRoICkge1xuXG4gICAgXHRcdHZhciBnZW9tZXRyeSA9IG5ldyBHZW9tZXRyeSgpLFxuICAgIFx0XHRzY2FsZSA9ICgganNvbi5zY2FsZSAhPT0gdW5kZWZpbmVkICkgPyAxLjAgLyBqc29uLnNjYWxlIDogMS4wO1xuXG4gICAgXHRcdHBhcnNlTW9kZWwoIHNjYWxlICk7XG5cbiAgICBcdFx0cGFyc2VTa2luKCk7XG4gICAgXHRcdHBhcnNlTW9ycGhpbmcoIHNjYWxlICk7XG4gICAgXHRcdHBhcnNlQW5pbWF0aW9ucygpO1xuXG4gICAgXHRcdGdlb21ldHJ5LmNvbXB1dGVGYWNlTm9ybWFscygpO1xuICAgIFx0XHRnZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcblxuICAgIFx0XHRmdW5jdGlvbiBwYXJzZU1vZGVsKCBzY2FsZSApIHtcblxuICAgIFx0XHRcdGZ1bmN0aW9uIGlzQml0U2V0KCB2YWx1ZSwgcG9zaXRpb24gKSB7XG5cbiAgICBcdFx0XHRcdHJldHVybiB2YWx1ZSAmICggMSA8PCBwb3NpdGlvbiApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0dmFyIGksIGosIGZpLFxuXG4gICAgXHRcdFx0b2Zmc2V0LCB6TGVuZ3RoLFxuXG4gICAgXHRcdGNvbG9ySW5kZXgsIG5vcm1hbEluZGV4LCB1dkluZGV4LCBtYXRlcmlhbEluZGV4LFxuXG4gICAgXHRcdFx0dHlwZSxcbiAgICBcdFx0XHRpc1F1YWQsXG4gICAgXHRcdFx0aGFzTWF0ZXJpYWwsXG4gICAgXHRcdFx0aGFzRmFjZVZlcnRleFV2LFxuICAgIFx0XHRcdGhhc0ZhY2VOb3JtYWwsIGhhc0ZhY2VWZXJ0ZXhOb3JtYWwsXG4gICAgXHRcdFx0aGFzRmFjZUNvbG9yLCBoYXNGYWNlVmVydGV4Q29sb3IsXG5cbiAgICBcdFx0dmVydGV4LCBmYWNlLCBmYWNlQSwgZmFjZUIsIGhleCwgbm9ybWFsLFxuXG4gICAgXHRcdFx0dXZMYXllciwgdXYsIHUsIHYsXG5cbiAgICBcdFx0XHRmYWNlcyA9IGpzb24uZmFjZXMsXG4gICAgXHRcdFx0dmVydGljZXMgPSBqc29uLnZlcnRpY2VzLFxuICAgIFx0XHRcdG5vcm1hbHMgPSBqc29uLm5vcm1hbHMsXG4gICAgXHRcdFx0Y29sb3JzID0ganNvbi5jb2xvcnMsXG5cbiAgICBcdFx0XHRuVXZMYXllcnMgPSAwO1xuXG4gICAgXHRcdFx0aWYgKCBqc29uLnV2cyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0XHQvLyBkaXNyZWdhcmQgZW1wdHkgYXJyYXlzXG5cbiAgICBcdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwganNvbi51dnMubGVuZ3RoOyBpICsrICkge1xuXG4gICAgXHRcdFx0XHRcdGlmICgganNvbi51dnNbIGkgXS5sZW5ndGggKSBuVXZMYXllcnMgKys7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBuVXZMYXllcnM7IGkgKysgKSB7XG5cbiAgICBcdFx0XHRcdFx0Z2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgaSBdID0gW107XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdG9mZnNldCA9IDA7XG4gICAgXHRcdFx0ekxlbmd0aCA9IHZlcnRpY2VzLmxlbmd0aDtcblxuICAgIFx0XHRcdHdoaWxlICggb2Zmc2V0IDwgekxlbmd0aCApIHtcblxuICAgIFx0XHRcdFx0dmVydGV4ID0gbmV3IFZlY3RvcjMoKTtcblxuICAgIFx0XHRcdFx0dmVydGV4LnggPSB2ZXJ0aWNlc1sgb2Zmc2V0ICsrIF0gKiBzY2FsZTtcbiAgICBcdFx0XHRcdHZlcnRleC55ID0gdmVydGljZXNbIG9mZnNldCArKyBdICogc2NhbGU7XG4gICAgXHRcdFx0XHR2ZXJ0ZXgueiA9IHZlcnRpY2VzWyBvZmZzZXQgKysgXSAqIHNjYWxlO1xuXG4gICAgXHRcdFx0XHRnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXggKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdG9mZnNldCA9IDA7XG4gICAgXHRcdFx0ekxlbmd0aCA9IGZhY2VzLmxlbmd0aDtcblxuICAgIFx0XHRcdHdoaWxlICggb2Zmc2V0IDwgekxlbmd0aCApIHtcblxuICAgIFx0XHRcdFx0dHlwZSA9IGZhY2VzWyBvZmZzZXQgKysgXTtcblxuXG4gICAgXHRcdFx0XHRpc1F1YWQgICAgICAgICAgICAgID0gaXNCaXRTZXQoIHR5cGUsIDAgKTtcbiAgICBcdFx0XHRcdGhhc01hdGVyaWFsICAgICAgICAgPSBpc0JpdFNldCggdHlwZSwgMSApO1xuICAgIFx0XHRcdFx0aGFzRmFjZVZlcnRleFV2ICAgICA9IGlzQml0U2V0KCB0eXBlLCAzICk7XG4gICAgXHRcdFx0XHRoYXNGYWNlTm9ybWFsICAgICAgID0gaXNCaXRTZXQoIHR5cGUsIDQgKTtcbiAgICBcdFx0XHRcdGhhc0ZhY2VWZXJ0ZXhOb3JtYWwgPSBpc0JpdFNldCggdHlwZSwgNSApO1xuICAgIFx0XHRcdFx0aGFzRmFjZUNvbG9yXHQgICAgID0gaXNCaXRTZXQoIHR5cGUsIDYgKTtcbiAgICBcdFx0XHRcdGhhc0ZhY2VWZXJ0ZXhDb2xvciAgPSBpc0JpdFNldCggdHlwZSwgNyApO1xuXG4gICAgXHRcdFx0XHQvLyBjb25zb2xlLmxvZyhcInR5cGVcIiwgdHlwZSwgXCJiaXRzXCIsIGlzUXVhZCwgaGFzTWF0ZXJpYWwsIGhhc0ZhY2VWZXJ0ZXhVdiwgaGFzRmFjZU5vcm1hbCwgaGFzRmFjZVZlcnRleE5vcm1hbCwgaGFzRmFjZUNvbG9yLCBoYXNGYWNlVmVydGV4Q29sb3IpO1xuXG4gICAgXHRcdFx0XHRpZiAoIGlzUXVhZCApIHtcblxuICAgIFx0XHRcdFx0XHRmYWNlQSA9IG5ldyBGYWNlMygpO1xuICAgIFx0XHRcdFx0XHRmYWNlQS5hID0gZmFjZXNbIG9mZnNldCBdO1xuICAgIFx0XHRcdFx0XHRmYWNlQS5iID0gZmFjZXNbIG9mZnNldCArIDEgXTtcbiAgICBcdFx0XHRcdFx0ZmFjZUEuYyA9IGZhY2VzWyBvZmZzZXQgKyAzIF07XG5cbiAgICBcdFx0XHRcdFx0ZmFjZUIgPSBuZXcgRmFjZTMoKTtcbiAgICBcdFx0XHRcdFx0ZmFjZUIuYSA9IGZhY2VzWyBvZmZzZXQgKyAxIF07XG4gICAgXHRcdFx0XHRcdGZhY2VCLmIgPSBmYWNlc1sgb2Zmc2V0ICsgMiBdO1xuICAgIFx0XHRcdFx0XHRmYWNlQi5jID0gZmFjZXNbIG9mZnNldCArIDMgXTtcblxuICAgIFx0XHRcdFx0XHRvZmZzZXQgKz0gNDtcblxuICAgIFx0XHRcdFx0XHRpZiAoIGhhc01hdGVyaWFsICkge1xuXG4gICAgXHRcdFx0XHRcdFx0bWF0ZXJpYWxJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXTtcbiAgICBcdFx0XHRcdFx0XHRmYWNlQS5tYXRlcmlhbEluZGV4ID0gbWF0ZXJpYWxJbmRleDtcbiAgICBcdFx0XHRcdFx0XHRmYWNlQi5tYXRlcmlhbEluZGV4ID0gbWF0ZXJpYWxJbmRleDtcblxuICAgIFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdFx0Ly8gdG8gZ2V0IGZhY2UgPD0+IHV2IGluZGV4IGNvcnJlc3BvbmRlbmNlXG5cbiAgICBcdFx0XHRcdFx0ZmkgPSBnZW9tZXRyeS5mYWNlcy5sZW5ndGg7XG5cbiAgICBcdFx0XHRcdFx0aWYgKCBoYXNGYWNlVmVydGV4VXYgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IG5VdkxheWVyczsgaSArKyApIHtcblxuICAgIFx0XHRcdFx0XHRcdFx0dXZMYXllciA9IGpzb24udXZzWyBpIF07XG5cbiAgICBcdFx0XHRcdFx0XHRcdGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIGkgXVsgZmkgXSA9IFtdO1xuICAgIFx0XHRcdFx0XHRcdFx0Z2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgaSBdWyBmaSArIDEgXSA9IFtdO1xuXG4gICAgXHRcdFx0XHRcdFx0XHRmb3IgKCBqID0gMDsgaiA8IDQ7IGogKysgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHRcdFx0dXZJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXTtcblxuICAgIFx0XHRcdFx0XHRcdFx0XHR1ID0gdXZMYXllclsgdXZJbmRleCAqIDIgXTtcbiAgICBcdFx0XHRcdFx0XHRcdFx0diA9IHV2TGF5ZXJbIHV2SW5kZXggKiAyICsgMSBdO1xuXG4gICAgXHRcdFx0XHRcdFx0XHRcdHV2ID0gbmV3IFZlY3RvcjIoIHUsIHYgKTtcblxuICAgIFx0XHRcdFx0XHRcdFx0XHRpZiAoIGogIT09IDIgKSBnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyBpIF1bIGZpIF0ucHVzaCggdXYgKTtcbiAgICBcdFx0XHRcdFx0XHRcdFx0aWYgKCBqICE9PSAwICkgZ2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgaSBdWyBmaSArIDEgXS5wdXNoKCB1diApO1xuXG4gICAgXHRcdFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHRcdGlmICggaGFzRmFjZU5vcm1hbCApIHtcblxuICAgIFx0XHRcdFx0XHRcdG5vcm1hbEluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdICogMztcblxuICAgIFx0XHRcdFx0XHRcdGZhY2VBLm5vcm1hbC5zZXQoXG4gICAgXHRcdFx0XHRcdFx0XHRub3JtYWxzWyBub3JtYWxJbmRleCArKyBdLFxuICAgIFx0XHRcdFx0XHRcdFx0bm9ybWFsc1sgbm9ybWFsSW5kZXggKysgXSxcbiAgICBcdFx0XHRcdFx0XHRcdG5vcm1hbHNbIG5vcm1hbEluZGV4IF1cbiAgICBcdFx0XHRcdFx0XHQpO1xuXG4gICAgXHRcdFx0XHRcdFx0ZmFjZUIubm9ybWFsLmNvcHkoIGZhY2VBLm5vcm1hbCApO1xuXG4gICAgXHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0XHRpZiAoIGhhc0ZhY2VWZXJ0ZXhOb3JtYWwgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IDQ7IGkgKysgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHRcdG5vcm1hbEluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdICogMztcblxuICAgIFx0XHRcdFx0XHRcdFx0bm9ybWFsID0gbmV3IFZlY3RvcjMoXG4gICAgXHRcdFx0XHRcdFx0XHRcdG5vcm1hbHNbIG5vcm1hbEluZGV4ICsrIF0sXG4gICAgXHRcdFx0XHRcdFx0XHRcdG5vcm1hbHNbIG5vcm1hbEluZGV4ICsrIF0sXG4gICAgXHRcdFx0XHRcdFx0XHRcdG5vcm1hbHNbIG5vcm1hbEluZGV4IF1cbiAgICBcdFx0XHRcdFx0XHRcdCk7XG5cblxuICAgIFx0XHRcdFx0XHRcdFx0aWYgKCBpICE9PSAyICkgZmFjZUEudmVydGV4Tm9ybWFscy5wdXNoKCBub3JtYWwgKTtcbiAgICBcdFx0XHRcdFx0XHRcdGlmICggaSAhPT0gMCApIGZhY2VCLnZlcnRleE5vcm1hbHMucHVzaCggbm9ybWFsICk7XG5cbiAgICBcdFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdFx0fVxuXG5cbiAgICBcdFx0XHRcdFx0aWYgKCBoYXNGYWNlQ29sb3IgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHRjb2xvckluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdO1xuICAgIFx0XHRcdFx0XHRcdGhleCA9IGNvbG9yc1sgY29sb3JJbmRleCBdO1xuXG4gICAgXHRcdFx0XHRcdFx0ZmFjZUEuY29sb3Iuc2V0SGV4KCBoZXggKTtcbiAgICBcdFx0XHRcdFx0XHRmYWNlQi5jb2xvci5zZXRIZXgoIGhleCApO1xuXG4gICAgXHRcdFx0XHRcdH1cblxuXG4gICAgXHRcdFx0XHRcdGlmICggaGFzRmFjZVZlcnRleENvbG9yICkge1xuXG4gICAgXHRcdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCA0OyBpICsrICkge1xuXG4gICAgXHRcdFx0XHRcdFx0XHRjb2xvckluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdO1xuICAgIFx0XHRcdFx0XHRcdFx0aGV4ID0gY29sb3JzWyBjb2xvckluZGV4IF07XG5cbiAgICBcdFx0XHRcdFx0XHRcdGlmICggaSAhPT0gMiApIGZhY2VBLnZlcnRleENvbG9ycy5wdXNoKCBuZXcgQ29sb3IoIGhleCApICk7XG4gICAgXHRcdFx0XHRcdFx0XHRpZiAoIGkgIT09IDAgKSBmYWNlQi52ZXJ0ZXhDb2xvcnMucHVzaCggbmV3IENvbG9yKCBoZXggKSApO1xuXG4gICAgXHRcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0XHRnZW9tZXRyeS5mYWNlcy5wdXNoKCBmYWNlQSApO1xuICAgIFx0XHRcdFx0XHRnZW9tZXRyeS5mYWNlcy5wdXNoKCBmYWNlQiApO1xuXG4gICAgXHRcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHRcdGZhY2UgPSBuZXcgRmFjZTMoKTtcbiAgICBcdFx0XHRcdFx0ZmFjZS5hID0gZmFjZXNbIG9mZnNldCArKyBdO1xuICAgIFx0XHRcdFx0XHRmYWNlLmIgPSBmYWNlc1sgb2Zmc2V0ICsrIF07XG4gICAgXHRcdFx0XHRcdGZhY2UuYyA9IGZhY2VzWyBvZmZzZXQgKysgXTtcblxuICAgIFx0XHRcdFx0XHRpZiAoIGhhc01hdGVyaWFsICkge1xuXG4gICAgXHRcdFx0XHRcdFx0bWF0ZXJpYWxJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXTtcbiAgICBcdFx0XHRcdFx0XHRmYWNlLm1hdGVyaWFsSW5kZXggPSBtYXRlcmlhbEluZGV4O1xuXG4gICAgXHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0XHQvLyB0byBnZXQgZmFjZSA8PT4gdXYgaW5kZXggY29ycmVzcG9uZGVuY2VcblxuICAgIFx0XHRcdFx0XHRmaSA9IGdlb21ldHJ5LmZhY2VzLmxlbmd0aDtcblxuICAgIFx0XHRcdFx0XHRpZiAoIGhhc0ZhY2VWZXJ0ZXhVdiApIHtcblxuICAgIFx0XHRcdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgblV2TGF5ZXJzOyBpICsrICkge1xuXG4gICAgXHRcdFx0XHRcdFx0XHR1dkxheWVyID0ganNvbi51dnNbIGkgXTtcblxuICAgIFx0XHRcdFx0XHRcdFx0Z2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgaSBdWyBmaSBdID0gW107XG5cbiAgICBcdFx0XHRcdFx0XHRcdGZvciAoIGogPSAwOyBqIDwgMzsgaiArKyApIHtcblxuICAgIFx0XHRcdFx0XHRcdFx0XHR1dkluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdO1xuXG4gICAgXHRcdFx0XHRcdFx0XHRcdHUgPSB1dkxheWVyWyB1dkluZGV4ICogMiBdO1xuICAgIFx0XHRcdFx0XHRcdFx0XHR2ID0gdXZMYXllclsgdXZJbmRleCAqIDIgKyAxIF07XG5cbiAgICBcdFx0XHRcdFx0XHRcdFx0dXYgPSBuZXcgVmVjdG9yMiggdSwgdiApO1xuXG4gICAgXHRcdFx0XHRcdFx0XHRcdGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIGkgXVsgZmkgXS5wdXNoKCB1diApO1xuXG4gICAgXHRcdFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHRcdGlmICggaGFzRmFjZU5vcm1hbCApIHtcblxuICAgIFx0XHRcdFx0XHRcdG5vcm1hbEluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdICogMztcblxuICAgIFx0XHRcdFx0XHRcdGZhY2Uubm9ybWFsLnNldChcbiAgICBcdFx0XHRcdFx0XHRcdG5vcm1hbHNbIG5vcm1hbEluZGV4ICsrIF0sXG4gICAgXHRcdFx0XHRcdFx0XHRub3JtYWxzWyBub3JtYWxJbmRleCArKyBdLFxuICAgIFx0XHRcdFx0XHRcdFx0bm9ybWFsc1sgbm9ybWFsSW5kZXggXVxuICAgIFx0XHRcdFx0XHRcdCk7XG5cbiAgICBcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHRcdGlmICggaGFzRmFjZVZlcnRleE5vcm1hbCApIHtcblxuICAgIFx0XHRcdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgMzsgaSArKyApIHtcblxuICAgIFx0XHRcdFx0XHRcdFx0bm9ybWFsSW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF0gKiAzO1xuXG4gICAgXHRcdFx0XHRcdFx0XHRub3JtYWwgPSBuZXcgVmVjdG9yMyhcbiAgICBcdFx0XHRcdFx0XHRcdFx0bm9ybWFsc1sgbm9ybWFsSW5kZXggKysgXSxcbiAgICBcdFx0XHRcdFx0XHRcdFx0bm9ybWFsc1sgbm9ybWFsSW5kZXggKysgXSxcbiAgICBcdFx0XHRcdFx0XHRcdFx0bm9ybWFsc1sgbm9ybWFsSW5kZXggXVxuICAgIFx0XHRcdFx0XHRcdFx0KTtcblxuICAgIFx0XHRcdFx0XHRcdFx0ZmFjZS52ZXJ0ZXhOb3JtYWxzLnB1c2goIG5vcm1hbCApO1xuXG4gICAgXHRcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHRcdH1cblxuXG4gICAgXHRcdFx0XHRcdGlmICggaGFzRmFjZUNvbG9yICkge1xuXG4gICAgXHRcdFx0XHRcdFx0Y29sb3JJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXTtcbiAgICBcdFx0XHRcdFx0XHRmYWNlLmNvbG9yLnNldEhleCggY29sb3JzWyBjb2xvckluZGV4IF0gKTtcblxuICAgIFx0XHRcdFx0XHR9XG5cblxuICAgIFx0XHRcdFx0XHRpZiAoIGhhc0ZhY2VWZXJ0ZXhDb2xvciApIHtcblxuICAgIFx0XHRcdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgMzsgaSArKyApIHtcblxuICAgIFx0XHRcdFx0XHRcdFx0Y29sb3JJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXTtcbiAgICBcdFx0XHRcdFx0XHRcdGZhY2UudmVydGV4Q29sb3JzLnB1c2goIG5ldyBDb2xvciggY29sb3JzWyBjb2xvckluZGV4IF0gKSApO1xuXG4gICAgXHRcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0XHRnZW9tZXRyeS5mYWNlcy5wdXNoKCBmYWNlICk7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdFx0ZnVuY3Rpb24gcGFyc2VTa2luKCkge1xuXG4gICAgXHRcdFx0dmFyIGluZmx1ZW5jZXNQZXJWZXJ0ZXggPSAoIGpzb24uaW5mbHVlbmNlc1BlclZlcnRleCAhPT0gdW5kZWZpbmVkICkgPyBqc29uLmluZmx1ZW5jZXNQZXJWZXJ0ZXggOiAyO1xuXG4gICAgXHRcdFx0aWYgKCBqc29uLnNraW5XZWlnaHRzICkge1xuXG4gICAgXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBqc29uLnNraW5XZWlnaHRzLmxlbmd0aDsgaSA8IGw7IGkgKz0gaW5mbHVlbmNlc1BlclZlcnRleCApIHtcblxuICAgIFx0XHRcdFx0XHR2YXIgeCA9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb24uc2tpbldlaWdodHNbIGkgXTtcbiAgICBcdFx0XHRcdFx0dmFyIHkgPSAoIGluZmx1ZW5jZXNQZXJWZXJ0ZXggPiAxICkgPyBqc29uLnNraW5XZWlnaHRzWyBpICsgMSBdIDogMDtcbiAgICBcdFx0XHRcdFx0dmFyIHogPSAoIGluZmx1ZW5jZXNQZXJWZXJ0ZXggPiAyICkgPyBqc29uLnNraW5XZWlnaHRzWyBpICsgMiBdIDogMDtcbiAgICBcdFx0XHRcdFx0dmFyIHcgPSAoIGluZmx1ZW5jZXNQZXJWZXJ0ZXggPiAzICkgPyBqc29uLnNraW5XZWlnaHRzWyBpICsgMyBdIDogMDtcblxuICAgIFx0XHRcdFx0XHRnZW9tZXRyeS5za2luV2VpZ2h0cy5wdXNoKCBuZXcgVmVjdG9yNCggeCwgeSwgeiwgdyApICk7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdGlmICgganNvbi5za2luSW5kaWNlcyApIHtcblxuICAgIFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0ganNvbi5za2luSW5kaWNlcy5sZW5ndGg7IGkgPCBsOyBpICs9IGluZmx1ZW5jZXNQZXJWZXJ0ZXggKSB7XG5cbiAgICBcdFx0XHRcdFx0dmFyIGEgPSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29uLnNraW5JbmRpY2VzWyBpIF07XG4gICAgXHRcdFx0XHRcdHZhciBiID0gKCBpbmZsdWVuY2VzUGVyVmVydGV4ID4gMSApID8ganNvbi5za2luSW5kaWNlc1sgaSArIDEgXSA6IDA7XG4gICAgXHRcdFx0XHRcdHZhciBjID0gKCBpbmZsdWVuY2VzUGVyVmVydGV4ID4gMiApID8ganNvbi5za2luSW5kaWNlc1sgaSArIDIgXSA6IDA7XG4gICAgXHRcdFx0XHRcdHZhciBkID0gKCBpbmZsdWVuY2VzUGVyVmVydGV4ID4gMyApID8ganNvbi5za2luSW5kaWNlc1sgaSArIDMgXSA6IDA7XG5cbiAgICBcdFx0XHRcdFx0Z2VvbWV0cnkuc2tpbkluZGljZXMucHVzaCggbmV3IFZlY3RvcjQoIGEsIGIsIGMsIGQgKSApO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRnZW9tZXRyeS5ib25lcyA9IGpzb24uYm9uZXM7XG5cbiAgICBcdFx0XHRpZiAoIGdlb21ldHJ5LmJvbmVzICYmIGdlb21ldHJ5LmJvbmVzLmxlbmd0aCA+IDAgJiYgKCBnZW9tZXRyeS5za2luV2VpZ2h0cy5sZW5ndGggIT09IGdlb21ldHJ5LnNraW5JbmRpY2VzLmxlbmd0aCB8fCBnZW9tZXRyeS5za2luSW5kaWNlcy5sZW5ndGggIT09IGdlb21ldHJ5LnZlcnRpY2VzLmxlbmd0aCApICkge1xuXG4gICAgXHRcdFx0XHRjb25zb2xlLndhcm4oICdXaGVuIHNraW5uaW5nLCBudW1iZXIgb2YgdmVydGljZXMgKCcgKyBnZW9tZXRyeS52ZXJ0aWNlcy5sZW5ndGggKyAnKSwgc2tpbkluZGljZXMgKCcgK1xuICAgIFx0XHRcdFx0XHRnZW9tZXRyeS5za2luSW5kaWNlcy5sZW5ndGggKyAnKSwgYW5kIHNraW5XZWlnaHRzICgnICsgZ2VvbWV0cnkuc2tpbldlaWdodHMubGVuZ3RoICsgJykgc2hvdWxkIG1hdGNoLicgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdFx0ZnVuY3Rpb24gcGFyc2VNb3JwaGluZyggc2NhbGUgKSB7XG5cbiAgICBcdFx0XHRpZiAoIGpzb24ubW9ycGhUYXJnZXRzICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGpzb24ubW9ycGhUYXJnZXRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICBcdFx0XHRcdFx0Z2VvbWV0cnkubW9ycGhUYXJnZXRzWyBpIF0gPSB7fTtcbiAgICBcdFx0XHRcdFx0Z2VvbWV0cnkubW9ycGhUYXJnZXRzWyBpIF0ubmFtZSA9IGpzb24ubW9ycGhUYXJnZXRzWyBpIF0ubmFtZTtcbiAgICBcdFx0XHRcdFx0Z2VvbWV0cnkubW9ycGhUYXJnZXRzWyBpIF0udmVydGljZXMgPSBbXTtcblxuICAgIFx0XHRcdFx0XHR2YXIgZHN0VmVydGljZXMgPSBnZW9tZXRyeS5tb3JwaFRhcmdldHNbIGkgXS52ZXJ0aWNlcztcbiAgICBcdFx0XHRcdFx0dmFyIHNyY1ZlcnRpY2VzID0ganNvbi5tb3JwaFRhcmdldHNbIGkgXS52ZXJ0aWNlcztcblxuICAgIFx0XHRcdFx0XHRmb3IgKCB2YXIgdiA9IDAsIHZsID0gc3JjVmVydGljZXMubGVuZ3RoOyB2IDwgdmw7IHYgKz0gMyApIHtcblxuICAgIFx0XHRcdFx0XHRcdHZhciB2ZXJ0ZXggPSBuZXcgVmVjdG9yMygpO1xuICAgIFx0XHRcdFx0XHRcdHZlcnRleC54ID0gc3JjVmVydGljZXNbIHYgXSAqIHNjYWxlO1xuICAgIFx0XHRcdFx0XHRcdHZlcnRleC55ID0gc3JjVmVydGljZXNbIHYgKyAxIF0gKiBzY2FsZTtcbiAgICBcdFx0XHRcdFx0XHR2ZXJ0ZXgueiA9IHNyY1ZlcnRpY2VzWyB2ICsgMiBdICogc2NhbGU7XG5cbiAgICBcdFx0XHRcdFx0XHRkc3RWZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXggKTtcblxuICAgIFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdGlmICgganNvbi5tb3JwaENvbG9ycyAhPT0gdW5kZWZpbmVkICYmIGpzb24ubW9ycGhDb2xvcnMubGVuZ3RoID4gMCApIHtcblxuICAgIFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuSlNPTkxvYWRlcjogXCJtb3JwaENvbG9yc1wiIG5vIGxvbmdlciBzdXBwb3J0ZWQuIFVzaW5nIHRoZW0gYXMgZmFjZSBjb2xvcnMuJyApO1xuXG4gICAgXHRcdFx0XHR2YXIgZmFjZXMgPSBnZW9tZXRyeS5mYWNlcztcbiAgICBcdFx0XHRcdHZhciBtb3JwaENvbG9ycyA9IGpzb24ubW9ycGhDb2xvcnNbIDAgXS5jb2xvcnM7XG5cbiAgICBcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGZhY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICBcdFx0XHRcdFx0ZmFjZXNbIGkgXS5jb2xvci5mcm9tQXJyYXkoIG1vcnBoQ29sb3JzLCBpICogMyApO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGZ1bmN0aW9uIHBhcnNlQW5pbWF0aW9ucygpIHtcblxuICAgIFx0XHRcdHZhciBvdXRwdXRBbmltYXRpb25zID0gW107XG5cbiAgICBcdFx0XHQvLyBwYXJzZSBvbGQgc3R5bGUgQm9uZS9IaWVyYXJjaHkgYW5pbWF0aW9uc1xuICAgIFx0XHRcdHZhciBhbmltYXRpb25zID0gW107XG5cbiAgICBcdFx0XHRpZiAoIGpzb24uYW5pbWF0aW9uICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRcdGFuaW1hdGlvbnMucHVzaCgganNvbi5hbmltYXRpb24gKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdGlmICgganNvbi5hbmltYXRpb25zICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRcdGlmICgganNvbi5hbmltYXRpb25zLmxlbmd0aCApIHtcblxuICAgIFx0XHRcdFx0XHRhbmltYXRpb25zID0gYW5pbWF0aW9ucy5jb25jYXQoIGpzb24uYW5pbWF0aW9ucyApO1xuXG4gICAgXHRcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHRcdGFuaW1hdGlvbnMucHVzaCgganNvbi5hbmltYXRpb25zICk7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGFuaW1hdGlvbnMubGVuZ3RoOyBpICsrICkge1xuXG4gICAgXHRcdFx0XHR2YXIgY2xpcCA9IEFuaW1hdGlvbkNsaXAucGFyc2VBbmltYXRpb24oIGFuaW1hdGlvbnNbIGkgXSwgZ2VvbWV0cnkuYm9uZXMgKTtcbiAgICBcdFx0XHRcdGlmICggY2xpcCApIG91dHB1dEFuaW1hdGlvbnMucHVzaCggY2xpcCApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0Ly8gcGFyc2UgaW1wbGljaXQgbW9ycGggYW5pbWF0aW9uc1xuICAgIFx0XHRcdGlmICggZ2VvbWV0cnkubW9ycGhUYXJnZXRzICkge1xuXG4gICAgXHRcdFx0XHQvLyBUT0RPOiBGaWd1cmUgb3V0IHdoYXQgYW4gYXBwcm9wcmFpdGUgRlBTIGlzIGZvciBtb3JwaCB0YXJnZXQgYW5pbWF0aW9ucyAtLSBkZWZhdWx0aW5nIHRvIDEwLCBidXQgcmVhbGx5IGl0IGlzIGNvbXBsZXRlbHkgYXJiaXRyYXJ5LlxuICAgIFx0XHRcdFx0dmFyIG1vcnBoQW5pbWF0aW9uQ2xpcHMgPSBBbmltYXRpb25DbGlwLkNyZWF0ZUNsaXBzRnJvbU1vcnBoVGFyZ2V0U2VxdWVuY2VzKCBnZW9tZXRyeS5tb3JwaFRhcmdldHMsIDEwICk7XG4gICAgXHRcdFx0XHRvdXRwdXRBbmltYXRpb25zID0gb3V0cHV0QW5pbWF0aW9ucy5jb25jYXQoIG1vcnBoQW5pbWF0aW9uQ2xpcHMgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdGlmICggb3V0cHV0QW5pbWF0aW9ucy5sZW5ndGggPiAwICkgZ2VvbWV0cnkuYW5pbWF0aW9ucyA9IG91dHB1dEFuaW1hdGlvbnM7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGlmICgganNvbi5tYXRlcmlhbHMgPT09IHVuZGVmaW5lZCB8fCBqc29uLm1hdGVyaWFscy5sZW5ndGggPT09IDAgKSB7XG5cbiAgICBcdFx0XHRyZXR1cm4geyBnZW9tZXRyeTogZ2VvbWV0cnkgfTtcblxuICAgIFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0dmFyIG1hdGVyaWFscyA9IExvYWRlci5wcm90b3R5cGUuaW5pdE1hdGVyaWFscygganNvbi5tYXRlcmlhbHMsIHRleHR1cmVQYXRoLCB0aGlzLmNyb3NzT3JpZ2luICk7XG5cbiAgICBcdFx0XHRyZXR1cm4geyBnZW9tZXRyeTogZ2VvbWV0cnksIG1hdGVyaWFsczogbWF0ZXJpYWxzIH07XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9XG5cbiAgICB9ICk7XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gT2JqZWN0TG9hZGVyICggbWFuYWdlciApIHtcblxuICAgIFx0dGhpcy5tYW5hZ2VyID0gKCBtYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IG1hbmFnZXIgOiBleHBvcnRzLkRlZmF1bHRMb2FkaW5nTWFuYWdlcjtcbiAgICBcdHRoaXMudGV4dHVyZVBhdGggPSAnJztcblxuICAgIH1cblxuICAgIE9iamVjdC5hc3NpZ24oIE9iamVjdExvYWRlci5wcm90b3R5cGUsIHtcblxuICAgIFx0bG9hZDogZnVuY3Rpb24gKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcblxuICAgIFx0XHRpZiAoIHRoaXMudGV4dHVyZVBhdGggPT09ICcnICkge1xuXG4gICAgXHRcdFx0dGhpcy50ZXh0dXJlUGF0aCA9IHVybC5zdWJzdHJpbmcoIDAsIHVybC5sYXN0SW5kZXhPZiggJy8nICkgKyAxICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHZhciBzY29wZSA9IHRoaXM7XG5cbiAgICBcdFx0dmFyIGxvYWRlciA9IG5ldyBYSFJMb2FkZXIoIHNjb3BlLm1hbmFnZXIgKTtcbiAgICBcdFx0bG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCB0ZXh0ICkge1xuXG4gICAgXHRcdFx0c2NvcGUucGFyc2UoIEpTT04ucGFyc2UoIHRleHQgKSwgb25Mb2FkICk7XG5cbiAgICBcdFx0fSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRzZXRUZXh0dXJlUGF0aDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuICAgIFx0XHR0aGlzLnRleHR1cmVQYXRoID0gdmFsdWU7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldENyb3NzT3JpZ2luOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG4gICAgXHRcdHRoaXMuY3Jvc3NPcmlnaW4gPSB2YWx1ZTtcblxuICAgIFx0fSxcblxuICAgIFx0cGFyc2U6IGZ1bmN0aW9uICgganNvbiwgb25Mb2FkICkge1xuXG4gICAgXHRcdHZhciBnZW9tZXRyaWVzID0gdGhpcy5wYXJzZUdlb21ldHJpZXMoIGpzb24uZ2VvbWV0cmllcyApO1xuXG4gICAgXHRcdHZhciBpbWFnZXMgPSB0aGlzLnBhcnNlSW1hZ2VzKCBqc29uLmltYWdlcywgZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdFx0aWYgKCBvbkxvYWQgIT09IHVuZGVmaW5lZCApIG9uTG9hZCggb2JqZWN0ICk7XG5cbiAgICBcdFx0fSApO1xuXG4gICAgXHRcdHZhciB0ZXh0dXJlcyAgPSB0aGlzLnBhcnNlVGV4dHVyZXMoIGpzb24udGV4dHVyZXMsIGltYWdlcyApO1xuICAgIFx0XHR2YXIgbWF0ZXJpYWxzID0gdGhpcy5wYXJzZU1hdGVyaWFscygganNvbi5tYXRlcmlhbHMsIHRleHR1cmVzICk7XG5cbiAgICBcdFx0dmFyIG9iamVjdCA9IHRoaXMucGFyc2VPYmplY3QoIGpzb24ub2JqZWN0LCBnZW9tZXRyaWVzLCBtYXRlcmlhbHMgKTtcblxuICAgIFx0XHRpZiAoIGpzb24uYW5pbWF0aW9ucyApIHtcblxuICAgIFx0XHRcdG9iamVjdC5hbmltYXRpb25zID0gdGhpcy5wYXJzZUFuaW1hdGlvbnMoIGpzb24uYW5pbWF0aW9ucyApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRpZiAoIGpzb24uaW1hZ2VzID09PSB1bmRlZmluZWQgfHwganNvbi5pbWFnZXMubGVuZ3RoID09PSAwICkge1xuXG4gICAgXHRcdFx0aWYgKCBvbkxvYWQgIT09IHVuZGVmaW5lZCApIG9uTG9hZCggb2JqZWN0ICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiBvYmplY3Q7XG5cbiAgICBcdH0sXG5cbiAgICBcdHBhcnNlR2VvbWV0cmllczogZnVuY3Rpb24gKCBqc29uICkge1xuXG4gICAgXHRcdHZhciBnZW9tZXRyaWVzID0ge307XG5cbiAgICBcdFx0aWYgKCBqc29uICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHR2YXIgZ2VvbWV0cnlMb2FkZXIgPSBuZXcgSlNPTkxvYWRlcigpO1xuICAgIFx0XHRcdHZhciBidWZmZXJHZW9tZXRyeUxvYWRlciA9IG5ldyBCdWZmZXJHZW9tZXRyeUxvYWRlcigpO1xuXG4gICAgXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0ganNvbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgXHRcdFx0XHR2YXIgZ2VvbWV0cnk7XG4gICAgXHRcdFx0XHR2YXIgZGF0YSA9IGpzb25bIGkgXTtcblxuICAgIFx0XHRcdFx0c3dpdGNoICggZGF0YS50eXBlICkge1xuXG4gICAgXHRcdFx0XHRcdGNhc2UgJ1BsYW5lR2VvbWV0cnknOlxuICAgIFx0XHRcdFx0XHRjYXNlICdQbGFuZUJ1ZmZlckdlb21ldHJ5JzpcblxuICAgIFx0XHRcdFx0XHRcdGdlb21ldHJ5ID0gbmV3IEdlb21ldHJpZXNbIGRhdGEudHlwZSBdKFxuICAgIFx0XHRcdFx0XHRcdFx0ZGF0YS53aWR0aCxcbiAgICBcdFx0XHRcdFx0XHRcdGRhdGEuaGVpZ2h0LFxuICAgIFx0XHRcdFx0XHRcdFx0ZGF0YS53aWR0aFNlZ21lbnRzLFxuICAgIFx0XHRcdFx0XHRcdFx0ZGF0YS5oZWlnaHRTZWdtZW50c1xuICAgIFx0XHRcdFx0XHRcdCk7XG5cbiAgICBcdFx0XHRcdFx0XHRicmVhaztcblxuICAgIFx0XHRcdFx0XHRjYXNlICdCb3hHZW9tZXRyeSc6XG4gICAgXHRcdFx0XHRcdGNhc2UgJ0JveEJ1ZmZlckdlb21ldHJ5JzpcbiAgICBcdFx0XHRcdFx0Y2FzZSAnQ3ViZUdlb21ldHJ5JzogLy8gYmFja3dhcmRzIGNvbXBhdGlibGVcblxuICAgIFx0XHRcdFx0XHRcdGdlb21ldHJ5ID0gbmV3IEdlb21ldHJpZXNbIGRhdGEudHlwZSBdKFxuICAgIFx0XHRcdFx0XHRcdFx0ZGF0YS53aWR0aCxcbiAgICBcdFx0XHRcdFx0XHRcdGRhdGEuaGVpZ2h0LFxuICAgIFx0XHRcdFx0XHRcdFx0ZGF0YS5kZXB0aCxcbiAgICBcdFx0XHRcdFx0XHRcdGRhdGEud2lkdGhTZWdtZW50cyxcbiAgICBcdFx0XHRcdFx0XHRcdGRhdGEuaGVpZ2h0U2VnbWVudHMsXG4gICAgXHRcdFx0XHRcdFx0XHRkYXRhLmRlcHRoU2VnbWVudHNcbiAgICBcdFx0XHRcdFx0XHQpO1xuXG4gICAgXHRcdFx0XHRcdFx0YnJlYWs7XG5cbiAgICBcdFx0XHRcdFx0Y2FzZSAnQ2lyY2xlR2VvbWV0cnknOlxuICAgIFx0XHRcdFx0XHRjYXNlICdDaXJjbGVCdWZmZXJHZW9tZXRyeSc6XG5cbiAgICBcdFx0XHRcdFx0XHRnZW9tZXRyeSA9IG5ldyBHZW9tZXRyaWVzWyBkYXRhLnR5cGUgXShcbiAgICBcdFx0XHRcdFx0XHRcdGRhdGEucmFkaXVzLFxuICAgIFx0XHRcdFx0XHRcdFx0ZGF0YS5zZWdtZW50cyxcbiAgICBcdFx0XHRcdFx0XHRcdGRhdGEudGhldGFTdGFydCxcbiAgICBcdFx0XHRcdFx0XHRcdGRhdGEudGhldGFMZW5ndGhcbiAgICBcdFx0XHRcdFx0XHQpO1xuXG4gICAgXHRcdFx0XHRcdFx0YnJlYWs7XG5cbiAgICBcdFx0XHRcdFx0Y2FzZSAnQ3lsaW5kZXJHZW9tZXRyeSc6XG4gICAgXHRcdFx0XHRcdGNhc2UgJ0N5bGluZGVyQnVmZmVyR2VvbWV0cnknOlxuXG4gICAgXHRcdFx0XHRcdFx0Z2VvbWV0cnkgPSBuZXcgR2VvbWV0cmllc1sgZGF0YS50eXBlIF0oXG4gICAgXHRcdFx0XHRcdFx0XHRkYXRhLnJhZGl1c1RvcCxcbiAgICBcdFx0XHRcdFx0XHRcdGRhdGEucmFkaXVzQm90dG9tLFxuICAgIFx0XHRcdFx0XHRcdFx0ZGF0YS5oZWlnaHQsXG4gICAgXHRcdFx0XHRcdFx0XHRkYXRhLnJhZGlhbFNlZ21lbnRzLFxuICAgIFx0XHRcdFx0XHRcdFx0ZGF0YS5oZWlnaHRTZWdtZW50cyxcbiAgICBcdFx0XHRcdFx0XHRcdGRhdGEub3BlbkVuZGVkLFxuICAgIFx0XHRcdFx0XHRcdFx0ZGF0YS50aGV0YVN0YXJ0LFxuICAgIFx0XHRcdFx0XHRcdFx0ZGF0YS50aGV0YUxlbmd0aFxuICAgIFx0XHRcdFx0XHRcdCk7XG5cbiAgICBcdFx0XHRcdFx0XHRicmVhaztcblxuICAgIFx0XHRcdFx0XHRjYXNlICdDb25lR2VvbWV0cnknOlxuICAgIFx0XHRcdFx0XHRjYXNlICdDb25lQnVmZmVyR2VvbWV0cnknOlxuXG4gICAgXHRcdFx0XHRcdFx0Z2VvbWV0cnkgPSBuZXcgR2VvbWV0cmllc1sgZGF0YS50eXBlIF0oXG4gICAgXHRcdFx0XHRcdFx0XHRkYXRhLnJhZGl1cyxcbiAgICBcdFx0XHRcdFx0XHRcdGRhdGEuaGVpZ2h0LFxuICAgIFx0XHRcdFx0XHRcdFx0ZGF0YS5yYWRpYWxTZWdtZW50cyxcbiAgICBcdFx0XHRcdFx0XHRcdGRhdGEuaGVpZ2h0U2VnbWVudHMsXG4gICAgXHRcdFx0XHRcdFx0XHRkYXRhLm9wZW5FbmRlZCxcbiAgICBcdFx0XHRcdFx0XHRcdGRhdGEudGhldGFTdGFydCxcbiAgICBcdFx0XHRcdFx0XHRcdGRhdGEudGhldGFMZW5ndGhcbiAgICBcdFx0XHRcdFx0XHQpO1xuXG4gICAgXHRcdFx0XHRcdFx0YnJlYWs7XG5cbiAgICBcdFx0XHRcdFx0Y2FzZSAnU3BoZXJlR2VvbWV0cnknOlxuICAgIFx0XHRcdFx0XHRjYXNlICdTcGhlcmVCdWZmZXJHZW9tZXRyeSc6XG5cbiAgICBcdFx0XHRcdFx0XHRnZW9tZXRyeSA9IG5ldyBHZW9tZXRyaWVzWyBkYXRhLnR5cGUgXShcbiAgICBcdFx0XHRcdFx0XHRcdGRhdGEucmFkaXVzLFxuICAgIFx0XHRcdFx0XHRcdFx0ZGF0YS53aWR0aFNlZ21lbnRzLFxuICAgIFx0XHRcdFx0XHRcdFx0ZGF0YS5oZWlnaHRTZWdtZW50cyxcbiAgICBcdFx0XHRcdFx0XHRcdGRhdGEucGhpU3RhcnQsXG4gICAgXHRcdFx0XHRcdFx0XHRkYXRhLnBoaUxlbmd0aCxcbiAgICBcdFx0XHRcdFx0XHRcdGRhdGEudGhldGFTdGFydCxcbiAgICBcdFx0XHRcdFx0XHRcdGRhdGEudGhldGFMZW5ndGhcbiAgICBcdFx0XHRcdFx0XHQpO1xuXG4gICAgXHRcdFx0XHRcdFx0YnJlYWs7XG5cbiAgICBcdFx0XHRcdFx0Y2FzZSAnRG9kZWNhaGVkcm9uR2VvbWV0cnknOlxuICAgIFx0XHRcdFx0XHRjYXNlICdJY29zYWhlZHJvbkdlb21ldHJ5JzpcbiAgICBcdFx0XHRcdFx0Y2FzZSAnT2N0YWhlZHJvbkdlb21ldHJ5JzpcbiAgICBcdFx0XHRcdFx0Y2FzZSAnVGV0cmFoZWRyb25HZW9tZXRyeSc6XG5cbiAgICBcdFx0XHRcdFx0XHRnZW9tZXRyeSA9IG5ldyBHZW9tZXRyaWVzWyBkYXRhLnR5cGUgXShcbiAgICBcdFx0XHRcdFx0XHRcdGRhdGEucmFkaXVzLFxuICAgIFx0XHRcdFx0XHRcdFx0ZGF0YS5kZXRhaWxcbiAgICBcdFx0XHRcdFx0XHQpO1xuXG4gICAgXHRcdFx0XHRcdFx0YnJlYWs7XG5cbiAgICBcdFx0XHRcdFx0Y2FzZSAnUmluZ0dlb21ldHJ5JzpcbiAgICBcdFx0XHRcdFx0Y2FzZSAnUmluZ0J1ZmZlckdlb21ldHJ5JzpcblxuICAgIFx0XHRcdFx0XHRcdGdlb21ldHJ5ID0gbmV3IEdlb21ldHJpZXNbIGRhdGEudHlwZSBdKFxuICAgIFx0XHRcdFx0XHRcdFx0ZGF0YS5pbm5lclJhZGl1cyxcbiAgICBcdFx0XHRcdFx0XHRcdGRhdGEub3V0ZXJSYWRpdXMsXG4gICAgXHRcdFx0XHRcdFx0XHRkYXRhLnRoZXRhU2VnbWVudHMsXG4gICAgXHRcdFx0XHRcdFx0XHRkYXRhLnBoaVNlZ21lbnRzLFxuICAgIFx0XHRcdFx0XHRcdFx0ZGF0YS50aGV0YVN0YXJ0LFxuICAgIFx0XHRcdFx0XHRcdFx0ZGF0YS50aGV0YUxlbmd0aFxuICAgIFx0XHRcdFx0XHRcdCk7XG5cbiAgICBcdFx0XHRcdFx0XHRicmVhaztcblxuICAgIFx0XHRcdFx0XHRjYXNlICdUb3J1c0dlb21ldHJ5JzpcbiAgICBcdFx0XHRcdFx0Y2FzZSAnVG9ydXNCdWZmZXJHZW9tZXRyeSc6XG5cbiAgICBcdFx0XHRcdFx0XHRnZW9tZXRyeSA9IG5ldyBHZW9tZXRyaWVzWyBkYXRhLnR5cGUgXShcbiAgICBcdFx0XHRcdFx0XHRcdGRhdGEucmFkaXVzLFxuICAgIFx0XHRcdFx0XHRcdFx0ZGF0YS50dWJlLFxuICAgIFx0XHRcdFx0XHRcdFx0ZGF0YS5yYWRpYWxTZWdtZW50cyxcbiAgICBcdFx0XHRcdFx0XHRcdGRhdGEudHVidWxhclNlZ21lbnRzLFxuICAgIFx0XHRcdFx0XHRcdFx0ZGF0YS5hcmNcbiAgICBcdFx0XHRcdFx0XHQpO1xuXG4gICAgXHRcdFx0XHRcdFx0YnJlYWs7XG5cbiAgICBcdFx0XHRcdFx0Y2FzZSAnVG9ydXNLbm90R2VvbWV0cnknOlxuICAgIFx0XHRcdFx0XHRjYXNlICdUb3J1c0tub3RCdWZmZXJHZW9tZXRyeSc6XG5cbiAgICBcdFx0XHRcdFx0XHRnZW9tZXRyeSA9IG5ldyBHZW9tZXRyaWVzWyBkYXRhLnR5cGUgXShcbiAgICBcdFx0XHRcdFx0XHRcdGRhdGEucmFkaXVzLFxuICAgIFx0XHRcdFx0XHRcdFx0ZGF0YS50dWJlLFxuICAgIFx0XHRcdFx0XHRcdFx0ZGF0YS50dWJ1bGFyU2VnbWVudHMsXG4gICAgXHRcdFx0XHRcdFx0XHRkYXRhLnJhZGlhbFNlZ21lbnRzLFxuICAgIFx0XHRcdFx0XHRcdFx0ZGF0YS5wLFxuICAgIFx0XHRcdFx0XHRcdFx0ZGF0YS5xXG4gICAgXHRcdFx0XHRcdFx0KTtcblxuICAgIFx0XHRcdFx0XHRcdGJyZWFrO1xuXG4gICAgXHRcdFx0XHRcdGNhc2UgJ0xhdGhlR2VvbWV0cnknOlxuICAgIFx0XHRcdFx0XHRjYXNlICdMYXRoZUJ1ZmZlckdlb21ldHJ5JzpcblxuICAgIFx0XHRcdFx0XHRcdGdlb21ldHJ5ID0gbmV3IEdlb21ldHJpZXNbIGRhdGEudHlwZSBdKFxuICAgIFx0XHRcdFx0XHRcdFx0ZGF0YS5wb2ludHMsXG4gICAgXHRcdFx0XHRcdFx0XHRkYXRhLnNlZ21lbnRzLFxuICAgIFx0XHRcdFx0XHRcdFx0ZGF0YS5waGlTdGFydCxcbiAgICBcdFx0XHRcdFx0XHRcdGRhdGEucGhpTGVuZ3RoXG4gICAgXHRcdFx0XHRcdFx0KTtcblxuICAgIFx0XHRcdFx0XHRcdGJyZWFrO1xuXG4gICAgXHRcdFx0XHRcdGNhc2UgJ0J1ZmZlckdlb21ldHJ5JzpcblxuICAgIFx0XHRcdFx0XHRcdGdlb21ldHJ5ID0gYnVmZmVyR2VvbWV0cnlMb2FkZXIucGFyc2UoIGRhdGEgKTtcblxuICAgIFx0XHRcdFx0XHRcdGJyZWFrO1xuXG4gICAgXHRcdFx0XHRcdGNhc2UgJ0dlb21ldHJ5JzpcblxuICAgIFx0XHRcdFx0XHRcdGdlb21ldHJ5ID0gZ2VvbWV0cnlMb2FkZXIucGFyc2UoIGRhdGEuZGF0YSwgdGhpcy50ZXh0dXJlUGF0aCApLmdlb21ldHJ5O1xuXG4gICAgXHRcdFx0XHRcdFx0YnJlYWs7XG5cbiAgICBcdFx0XHRcdFx0ZGVmYXVsdDpcblxuICAgIFx0XHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdExvYWRlcjogVW5zdXBwb3J0ZWQgZ2VvbWV0cnkgdHlwZSBcIicgKyBkYXRhLnR5cGUgKyAnXCInICk7XG5cbiAgICBcdFx0XHRcdFx0XHRjb250aW51ZTtcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHRnZW9tZXRyeS51dWlkID0gZGF0YS51dWlkO1xuXG4gICAgXHRcdFx0XHRpZiAoIGRhdGEubmFtZSAhPT0gdW5kZWZpbmVkICkgZ2VvbWV0cnkubmFtZSA9IGRhdGEubmFtZTtcblxuICAgIFx0XHRcdFx0Z2VvbWV0cmllc1sgZGF0YS51dWlkIF0gPSBnZW9tZXRyeTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIGdlb21ldHJpZXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdHBhcnNlTWF0ZXJpYWxzOiBmdW5jdGlvbiAoIGpzb24sIHRleHR1cmVzICkge1xuXG4gICAgXHRcdHZhciBtYXRlcmlhbHMgPSB7fTtcblxuICAgIFx0XHRpZiAoIGpzb24gIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdHZhciBsb2FkZXIgPSBuZXcgTWF0ZXJpYWxMb2FkZXIoKTtcbiAgICBcdFx0XHRsb2FkZXIuc2V0VGV4dHVyZXMoIHRleHR1cmVzICk7XG5cbiAgICBcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBqc29uLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICBcdFx0XHRcdHZhciBtYXRlcmlhbCA9IGxvYWRlci5wYXJzZSgganNvblsgaSBdICk7XG4gICAgXHRcdFx0XHRtYXRlcmlhbHNbIG1hdGVyaWFsLnV1aWQgXSA9IG1hdGVyaWFsO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gbWF0ZXJpYWxzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRwYXJzZUFuaW1hdGlvbnM6IGZ1bmN0aW9uICgganNvbiApIHtcblxuICAgIFx0XHR2YXIgYW5pbWF0aW9ucyA9IFtdO1xuXG4gICAgXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGpzb24ubGVuZ3RoOyBpICsrICkge1xuXG4gICAgXHRcdFx0dmFyIGNsaXAgPSBBbmltYXRpb25DbGlwLnBhcnNlKCBqc29uWyBpIF0gKTtcblxuICAgIFx0XHRcdGFuaW1hdGlvbnMucHVzaCggY2xpcCApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gYW5pbWF0aW9ucztcblxuICAgIFx0fSxcblxuICAgIFx0cGFyc2VJbWFnZXM6IGZ1bmN0aW9uICgganNvbiwgb25Mb2FkICkge1xuXG4gICAgXHRcdHZhciBzY29wZSA9IHRoaXM7XG4gICAgXHRcdHZhciBpbWFnZXMgPSB7fTtcblxuICAgIFx0XHRmdW5jdGlvbiBsb2FkSW1hZ2UoIHVybCApIHtcblxuICAgIFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbVN0YXJ0KCB1cmwgKTtcblxuICAgIFx0XHRcdHJldHVybiBsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0XHRcdHNjb3BlLm1hbmFnZXIuaXRlbUVuZCggdXJsICk7XG5cbiAgICBcdFx0XHR9LCB1bmRlZmluZWQsIGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHRcdFx0c2NvcGUubWFuYWdlci5pdGVtRXJyb3IoIHVybCApO1xuXG4gICAgXHRcdFx0fSApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRpZiAoIGpzb24gIT09IHVuZGVmaW5lZCAmJiBqc29uLmxlbmd0aCA+IDAgKSB7XG5cbiAgICBcdFx0XHR2YXIgbWFuYWdlciA9IG5ldyBMb2FkaW5nTWFuYWdlciggb25Mb2FkICk7XG5cbiAgICBcdFx0XHR2YXIgbG9hZGVyID0gbmV3IEltYWdlTG9hZGVyKCBtYW5hZ2VyICk7XG4gICAgXHRcdFx0bG9hZGVyLnNldENyb3NzT3JpZ2luKCB0aGlzLmNyb3NzT3JpZ2luICk7XG5cbiAgICBcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBqc29uLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICBcdFx0XHRcdHZhciBpbWFnZSA9IGpzb25bIGkgXTtcbiAgICBcdFx0XHRcdHZhciBwYXRoID0gL14oXFwvXFwvKXwoW2Etel0rOihcXC9cXC8pPykvaS50ZXN0KCBpbWFnZS51cmwgKSA/IGltYWdlLnVybCA6IHNjb3BlLnRleHR1cmVQYXRoICsgaW1hZ2UudXJsO1xuXG4gICAgXHRcdFx0XHRpbWFnZXNbIGltYWdlLnV1aWQgXSA9IGxvYWRJbWFnZSggcGF0aCApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gaW1hZ2VzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRwYXJzZVRleHR1cmVzOiBmdW5jdGlvbiAoIGpzb24sIGltYWdlcyApIHtcblxuICAgIFx0XHRmdW5jdGlvbiBwYXJzZUNvbnN0YW50KCB2YWx1ZSwgdHlwZSApIHtcblxuICAgIFx0XHRcdGlmICggdHlwZW9mKCB2YWx1ZSApID09PSAnbnVtYmVyJyApIHJldHVybiB2YWx1ZTtcblxuICAgIFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdExvYWRlci5wYXJzZVRleHR1cmU6IENvbnN0YW50IHNob3VsZCBiZSBpbiBudW1lcmljIGZvcm0uJywgdmFsdWUgKTtcblxuICAgIFx0XHRcdHJldHVybiB0eXBlWyB2YWx1ZSBdO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHR2YXIgdGV4dHVyZXMgPSB7fTtcblxuICAgIFx0XHRpZiAoIGpzb24gIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGpzb24ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgIFx0XHRcdFx0dmFyIGRhdGEgPSBqc29uWyBpIF07XG5cbiAgICBcdFx0XHRcdGlmICggZGF0YS5pbWFnZSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdExvYWRlcjogTm8gXCJpbWFnZVwiIHNwZWNpZmllZCBmb3InLCBkYXRhLnV1aWQgKTtcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHRpZiAoIGltYWdlc1sgZGF0YS5pbWFnZSBdID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0TG9hZGVyOiBVbmRlZmluZWQgaW1hZ2UnLCBkYXRhLmltYWdlICk7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0dmFyIHRleHR1cmUgPSBuZXcgVGV4dHVyZSggaW1hZ2VzWyBkYXRhLmltYWdlIF0gKTtcbiAgICBcdFx0XHRcdHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgXHRcdFx0XHR0ZXh0dXJlLnV1aWQgPSBkYXRhLnV1aWQ7XG5cbiAgICBcdFx0XHRcdGlmICggZGF0YS5uYW1lICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLm5hbWUgPSBkYXRhLm5hbWU7XG5cbiAgICBcdFx0XHRcdGlmICggZGF0YS5tYXBwaW5nICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLm1hcHBpbmcgPSBwYXJzZUNvbnN0YW50KCBkYXRhLm1hcHBpbmcsIFRleHR1cmVNYXBwaW5nICk7XG5cbiAgICBcdFx0XHRcdGlmICggZGF0YS5vZmZzZXQgIT09IHVuZGVmaW5lZCApIHRleHR1cmUub2Zmc2V0LmZyb21BcnJheSggZGF0YS5vZmZzZXQgKTtcbiAgICBcdFx0XHRcdGlmICggZGF0YS5yZXBlYXQgIT09IHVuZGVmaW5lZCApIHRleHR1cmUucmVwZWF0LmZyb21BcnJheSggZGF0YS5yZXBlYXQgKTtcbiAgICBcdFx0XHRcdGlmICggZGF0YS53cmFwICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRcdFx0dGV4dHVyZS53cmFwUyA9IHBhcnNlQ29uc3RhbnQoIGRhdGEud3JhcFsgMCBdLCBUZXh0dXJlV3JhcHBpbmcgKTtcbiAgICBcdFx0XHRcdFx0dGV4dHVyZS53cmFwVCA9IHBhcnNlQ29uc3RhbnQoIGRhdGEud3JhcFsgMSBdLCBUZXh0dXJlV3JhcHBpbmcgKTtcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHRpZiAoIGRhdGEubWluRmlsdGVyICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLm1pbkZpbHRlciA9IHBhcnNlQ29uc3RhbnQoIGRhdGEubWluRmlsdGVyLCBUZXh0dXJlRmlsdGVyICk7XG4gICAgXHRcdFx0XHRpZiAoIGRhdGEubWFnRmlsdGVyICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLm1hZ0ZpbHRlciA9IHBhcnNlQ29uc3RhbnQoIGRhdGEubWFnRmlsdGVyLCBUZXh0dXJlRmlsdGVyICk7XG4gICAgXHRcdFx0XHRpZiAoIGRhdGEuYW5pc290cm9weSAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS5hbmlzb3Ryb3B5ID0gZGF0YS5hbmlzb3Ryb3B5O1xuXG4gICAgXHRcdFx0XHRpZiAoIGRhdGEuZmxpcFkgIT09IHVuZGVmaW5lZCApIHRleHR1cmUuZmxpcFkgPSBkYXRhLmZsaXBZO1xuXG4gICAgXHRcdFx0XHR0ZXh0dXJlc1sgZGF0YS51dWlkIF0gPSB0ZXh0dXJlO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gdGV4dHVyZXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdHBhcnNlT2JqZWN0OiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dmFyIG1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XG5cbiAgICBcdFx0cmV0dXJuIGZ1bmN0aW9uIHBhcnNlT2JqZWN0KCBkYXRhLCBnZW9tZXRyaWVzLCBtYXRlcmlhbHMgKSB7XG5cbiAgICBcdFx0XHR2YXIgb2JqZWN0O1xuXG4gICAgXHRcdFx0ZnVuY3Rpb24gZ2V0R2VvbWV0cnkoIG5hbWUgKSB7XG5cbiAgICBcdFx0XHRcdGlmICggZ2VvbWV0cmllc1sgbmFtZSBdID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0TG9hZGVyOiBVbmRlZmluZWQgZ2VvbWV0cnknLCBuYW1lICk7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0cmV0dXJuIGdlb21ldHJpZXNbIG5hbWUgXTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdGZ1bmN0aW9uIGdldE1hdGVyaWFsKCBuYW1lICkge1xuXG4gICAgXHRcdFx0XHRpZiAoIG5hbWUgPT09IHVuZGVmaW5lZCApIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgICBcdFx0XHRcdGlmICggbWF0ZXJpYWxzWyBuYW1lIF0gPT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3RMb2FkZXI6IFVuZGVmaW5lZCBtYXRlcmlhbCcsIG5hbWUgKTtcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHRyZXR1cm4gbWF0ZXJpYWxzWyBuYW1lIF07XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRzd2l0Y2ggKCBkYXRhLnR5cGUgKSB7XG5cbiAgICBcdFx0XHRcdGNhc2UgJ1NjZW5lJzpcblxuICAgIFx0XHRcdFx0XHRvYmplY3QgPSBuZXcgU2NlbmUoKTtcblxuICAgIFx0XHRcdFx0XHRpZiAoIGRhdGEuYmFja2dyb3VuZCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0XHRcdFx0aWYgKCBOdW1iZXIuaXNJbnRlZ2VyKCBkYXRhLmJhY2tncm91bmQgKSApIHtcblxuICAgIFx0XHRcdFx0XHRcdFx0b2JqZWN0LmJhY2tncm91bmQgPSBuZXcgQ29sb3IoIGRhdGEuYmFja2dyb3VuZCApO1xuXG4gICAgXHRcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0XHRpZiAoIGRhdGEuZm9nICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHRpZiAoIGRhdGEuZm9nLnR5cGUgPT09ICdGb2cnICkge1xuXG4gICAgXHRcdFx0XHRcdFx0XHRvYmplY3QuZm9nID0gbmV3IEZvZyggZGF0YS5mb2cuY29sb3IsIGRhdGEuZm9nLm5lYXIsIGRhdGEuZm9nLmZhciApO1xuXG4gICAgXHRcdFx0XHRcdFx0fSBlbHNlIGlmICggZGF0YS5mb2cudHlwZSA9PT0gJ0ZvZ0V4cDInICkge1xuXG4gICAgXHRcdFx0XHRcdFx0XHRvYmplY3QuZm9nID0gbmV3IEZvZ0V4cDIoIGRhdGEuZm9nLmNvbG9yLCBkYXRhLmZvZy5kZW5zaXR5ICk7XG5cbiAgICBcdFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHRcdGJyZWFrO1xuXG4gICAgXHRcdFx0XHRjYXNlICdQZXJzcGVjdGl2ZUNhbWVyYSc6XG5cbiAgICBcdFx0XHRcdFx0b2JqZWN0ID0gbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKCBkYXRhLmZvdiwgZGF0YS5hc3BlY3QsIGRhdGEubmVhciwgZGF0YS5mYXIgKTtcblxuICAgIFx0XHRcdFx0XHRpZiAoIGRhdGEuZm9jdXMgIT09IHVuZGVmaW5lZCApIG9iamVjdC5mb2N1cyA9IGRhdGEuZm9jdXM7XG4gICAgXHRcdFx0XHRcdGlmICggZGF0YS56b29tICE9PSB1bmRlZmluZWQgKSBvYmplY3Quem9vbSA9IGRhdGEuem9vbTtcbiAgICBcdFx0XHRcdFx0aWYgKCBkYXRhLmZpbG1HYXVnZSAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LmZpbG1HYXVnZSA9IGRhdGEuZmlsbUdhdWdlO1xuICAgIFx0XHRcdFx0XHRpZiAoIGRhdGEuZmlsbU9mZnNldCAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LmZpbG1PZmZzZXQgPSBkYXRhLmZpbG1PZmZzZXQ7XG4gICAgXHRcdFx0XHRcdGlmICggZGF0YS52aWV3ICE9PSB1bmRlZmluZWQgKSBvYmplY3QudmlldyA9IE9iamVjdC5hc3NpZ24oIHt9LCBkYXRhLnZpZXcgKTtcblxuICAgIFx0XHRcdFx0XHRicmVhaztcblxuICAgIFx0XHRcdFx0Y2FzZSAnT3J0aG9ncmFwaGljQ2FtZXJhJzpcblxuICAgIFx0XHRcdFx0XHRvYmplY3QgPSBuZXcgT3J0aG9ncmFwaGljQ2FtZXJhKCBkYXRhLmxlZnQsIGRhdGEucmlnaHQsIGRhdGEudG9wLCBkYXRhLmJvdHRvbSwgZGF0YS5uZWFyLCBkYXRhLmZhciApO1xuXG4gICAgXHRcdFx0XHRcdGJyZWFrO1xuXG4gICAgXHRcdFx0XHRjYXNlICdBbWJpZW50TGlnaHQnOlxuXG4gICAgXHRcdFx0XHRcdG9iamVjdCA9IG5ldyBBbWJpZW50TGlnaHQoIGRhdGEuY29sb3IsIGRhdGEuaW50ZW5zaXR5ICk7XG5cbiAgICBcdFx0XHRcdFx0YnJlYWs7XG5cbiAgICBcdFx0XHRcdGNhc2UgJ0RpcmVjdGlvbmFsTGlnaHQnOlxuXG4gICAgXHRcdFx0XHRcdG9iamVjdCA9IG5ldyBEaXJlY3Rpb25hbExpZ2h0KCBkYXRhLmNvbG9yLCBkYXRhLmludGVuc2l0eSApO1xuXG4gICAgXHRcdFx0XHRcdGJyZWFrO1xuXG4gICAgXHRcdFx0XHRjYXNlICdQb2ludExpZ2h0JzpcblxuICAgIFx0XHRcdFx0XHRvYmplY3QgPSBuZXcgUG9pbnRMaWdodCggZGF0YS5jb2xvciwgZGF0YS5pbnRlbnNpdHksIGRhdGEuZGlzdGFuY2UsIGRhdGEuZGVjYXkgKTtcblxuICAgIFx0XHRcdFx0XHRicmVhaztcblxuICAgIFx0XHRcdFx0Y2FzZSAnU3BvdExpZ2h0JzpcblxuICAgIFx0XHRcdFx0XHRvYmplY3QgPSBuZXcgU3BvdExpZ2h0KCBkYXRhLmNvbG9yLCBkYXRhLmludGVuc2l0eSwgZGF0YS5kaXN0YW5jZSwgZGF0YS5hbmdsZSwgZGF0YS5wZW51bWJyYSwgZGF0YS5kZWNheSApO1xuXG4gICAgXHRcdFx0XHRcdGJyZWFrO1xuXG4gICAgXHRcdFx0XHRjYXNlICdIZW1pc3BoZXJlTGlnaHQnOlxuXG4gICAgXHRcdFx0XHRcdG9iamVjdCA9IG5ldyBIZW1pc3BoZXJlTGlnaHQoIGRhdGEuY29sb3IsIGRhdGEuZ3JvdW5kQ29sb3IsIGRhdGEuaW50ZW5zaXR5ICk7XG5cbiAgICBcdFx0XHRcdFx0YnJlYWs7XG5cbiAgICBcdFx0XHRcdGNhc2UgJ01lc2gnOlxuXG4gICAgXHRcdFx0XHRcdHZhciBnZW9tZXRyeSA9IGdldEdlb21ldHJ5KCBkYXRhLmdlb21ldHJ5ICk7XG4gICAgXHRcdFx0XHRcdHZhciBtYXRlcmlhbCA9IGdldE1hdGVyaWFsKCBkYXRhLm1hdGVyaWFsICk7XG5cbiAgICBcdFx0XHRcdFx0aWYgKCBnZW9tZXRyeS5ib25lcyAmJiBnZW9tZXRyeS5ib25lcy5sZW5ndGggPiAwICkge1xuXG4gICAgXHRcdFx0XHRcdFx0b2JqZWN0ID0gbmV3IFNraW5uZWRNZXNoKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblxuICAgIFx0XHRcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHRcdFx0b2JqZWN0ID0gbmV3IE1lc2goIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG4gICAgXHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0XHRicmVhaztcblxuICAgIFx0XHRcdFx0Y2FzZSAnTE9EJzpcblxuICAgIFx0XHRcdFx0XHRvYmplY3QgPSBuZXcgTE9EKCk7XG5cbiAgICBcdFx0XHRcdFx0YnJlYWs7XG5cbiAgICBcdFx0XHRcdGNhc2UgJ0xpbmUnOlxuXG4gICAgXHRcdFx0XHRcdG9iamVjdCA9IG5ldyBMaW5lKCBnZXRHZW9tZXRyeSggZGF0YS5nZW9tZXRyeSApLCBnZXRNYXRlcmlhbCggZGF0YS5tYXRlcmlhbCApLCBkYXRhLm1vZGUgKTtcblxuICAgIFx0XHRcdFx0XHRicmVhaztcblxuICAgIFx0XHRcdFx0Y2FzZSAnTGluZVNlZ21lbnRzJzpcblxuICAgIFx0XHRcdFx0XHRvYmplY3QgPSBuZXcgTGluZVNlZ21lbnRzKCBnZXRHZW9tZXRyeSggZGF0YS5nZW9tZXRyeSApLCBnZXRNYXRlcmlhbCggZGF0YS5tYXRlcmlhbCApICk7XG5cbiAgICBcdFx0XHRcdFx0YnJlYWs7XG5cbiAgICBcdFx0XHRcdGNhc2UgJ1BvaW50Q2xvdWQnOlxuICAgIFx0XHRcdFx0Y2FzZSAnUG9pbnRzJzpcblxuICAgIFx0XHRcdFx0XHRvYmplY3QgPSBuZXcgUG9pbnRzKCBnZXRHZW9tZXRyeSggZGF0YS5nZW9tZXRyeSApLCBnZXRNYXRlcmlhbCggZGF0YS5tYXRlcmlhbCApICk7XG5cbiAgICBcdFx0XHRcdFx0YnJlYWs7XG5cbiAgICBcdFx0XHRcdGNhc2UgJ1Nwcml0ZSc6XG5cbiAgICBcdFx0XHRcdFx0b2JqZWN0ID0gbmV3IFNwcml0ZSggZ2V0TWF0ZXJpYWwoIGRhdGEubWF0ZXJpYWwgKSApO1xuXG4gICAgXHRcdFx0XHRcdGJyZWFrO1xuXG4gICAgXHRcdFx0XHRjYXNlICdHcm91cCc6XG5cbiAgICBcdFx0XHRcdFx0b2JqZWN0ID0gbmV3IEdyb3VwKCk7XG5cbiAgICBcdFx0XHRcdFx0YnJlYWs7XG5cbiAgICBcdFx0XHRcdGRlZmF1bHQ6XG5cbiAgICBcdFx0XHRcdFx0b2JqZWN0ID0gbmV3IE9iamVjdDNEKCk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRvYmplY3QudXVpZCA9IGRhdGEudXVpZDtcblxuICAgIFx0XHRcdGlmICggZGF0YS5uYW1lICE9PSB1bmRlZmluZWQgKSBvYmplY3QubmFtZSA9IGRhdGEubmFtZTtcbiAgICBcdFx0XHRpZiAoIGRhdGEubWF0cml4ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRcdG1hdHJpeC5mcm9tQXJyYXkoIGRhdGEubWF0cml4ICk7XG4gICAgXHRcdFx0XHRtYXRyaXguZGVjb21wb3NlKCBvYmplY3QucG9zaXRpb24sIG9iamVjdC5xdWF0ZXJuaW9uLCBvYmplY3Quc2NhbGUgKTtcblxuICAgIFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdGlmICggZGF0YS5wb3NpdGlvbiAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LnBvc2l0aW9uLmZyb21BcnJheSggZGF0YS5wb3NpdGlvbiApO1xuICAgIFx0XHRcdFx0aWYgKCBkYXRhLnJvdGF0aW9uICE9PSB1bmRlZmluZWQgKSBvYmplY3Qucm90YXRpb24uZnJvbUFycmF5KCBkYXRhLnJvdGF0aW9uICk7XG4gICAgXHRcdFx0XHRpZiAoIGRhdGEucXVhdGVybmlvbiAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LnF1YXRlcm5pb24uZnJvbUFycmF5KCBkYXRhLnF1YXRlcm5pb24gKTtcbiAgICBcdFx0XHRcdGlmICggZGF0YS5zY2FsZSAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LnNjYWxlLmZyb21BcnJheSggZGF0YS5zY2FsZSApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0aWYgKCBkYXRhLmNhc3RTaGFkb3cgIT09IHVuZGVmaW5lZCApIG9iamVjdC5jYXN0U2hhZG93ID0gZGF0YS5jYXN0U2hhZG93O1xuICAgIFx0XHRcdGlmICggZGF0YS5yZWNlaXZlU2hhZG93ICE9PSB1bmRlZmluZWQgKSBvYmplY3QucmVjZWl2ZVNoYWRvdyA9IGRhdGEucmVjZWl2ZVNoYWRvdztcblxuICAgIFx0XHRcdGlmICggZGF0YS5zaGFkb3cgKSB7XG5cbiAgICBcdFx0XHRcdGlmICggZGF0YS5zaGFkb3cuYmlhcyAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LnNoYWRvdy5iaWFzID0gZGF0YS5zaGFkb3cuYmlhcztcbiAgICBcdFx0XHRcdGlmICggZGF0YS5zaGFkb3cucmFkaXVzICE9PSB1bmRlZmluZWQgKSBvYmplY3Quc2hhZG93LnJhZGl1cyA9IGRhdGEuc2hhZG93LnJhZGl1cztcbiAgICBcdFx0XHRcdGlmICggZGF0YS5zaGFkb3cubWFwU2l6ZSAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LnNoYWRvdy5tYXBTaXplLmZyb21BcnJheSggZGF0YS5zaGFkb3cubWFwU2l6ZSApO1xuICAgIFx0XHRcdFx0aWYgKCBkYXRhLnNoYWRvdy5jYW1lcmEgIT09IHVuZGVmaW5lZCApIG9iamVjdC5zaGFkb3cuY2FtZXJhID0gdGhpcy5wYXJzZU9iamVjdCggZGF0YS5zaGFkb3cuY2FtZXJhICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRpZiAoIGRhdGEudmlzaWJsZSAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LnZpc2libGUgPSBkYXRhLnZpc2libGU7XG4gICAgXHRcdFx0aWYgKCBkYXRhLnVzZXJEYXRhICE9PSB1bmRlZmluZWQgKSBvYmplY3QudXNlckRhdGEgPSBkYXRhLnVzZXJEYXRhO1xuXG4gICAgXHRcdFx0aWYgKCBkYXRhLmNoaWxkcmVuICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRcdGZvciAoIHZhciBjaGlsZCBpbiBkYXRhLmNoaWxkcmVuICkge1xuXG4gICAgXHRcdFx0XHRcdG9iamVjdC5hZGQoIHRoaXMucGFyc2VPYmplY3QoIGRhdGEuY2hpbGRyZW5bIGNoaWxkIF0sIGdlb21ldHJpZXMsIG1hdGVyaWFscyApICk7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdGlmICggZGF0YS50eXBlID09PSAnTE9EJyApIHtcblxuICAgIFx0XHRcdFx0dmFyIGxldmVscyA9IGRhdGEubGV2ZWxzO1xuXG4gICAgXHRcdFx0XHRmb3IgKCB2YXIgbCA9IDA7IGwgPCBsZXZlbHMubGVuZ3RoOyBsICsrICkge1xuXG4gICAgXHRcdFx0XHRcdHZhciBsZXZlbCA9IGxldmVsc1sgbCBdO1xuICAgIFx0XHRcdFx0XHR2YXIgY2hpbGQgPSBvYmplY3QuZ2V0T2JqZWN0QnlQcm9wZXJ0eSggJ3V1aWQnLCBsZXZlbC5vYmplY3QgKTtcblxuICAgIFx0XHRcdFx0XHRpZiAoIGNoaWxkICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHRvYmplY3QuYWRkTGV2ZWwoIGNoaWxkLCBsZXZlbC5kaXN0YW5jZSApO1xuXG4gICAgXHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0cmV0dXJuIG9iamVjdDtcblxuICAgIFx0XHR9O1xuXG4gICAgXHR9KClcblxuICAgIH0gKTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcbiAgICAgKiBFeHRlbnNpYmxlIGN1cnZlIG9iamVjdFxuICAgICAqXG4gICAgICogU29tZSBjb21tb24gb2YgQ3VydmUgbWV0aG9kc1xuICAgICAqIC5nZXRQb2ludCh0KSwgZ2V0VGFuZ2VudCh0KVxuICAgICAqIC5nZXRQb2ludEF0KHUpLCBnZXRUYW5nZW50QXQodSlcbiAgICAgKiAuZ2V0UG9pbnRzKCksIC5nZXRTcGFjZWRQb2ludHMoKVxuICAgICAqIC5nZXRMZW5ndGgoKVxuICAgICAqIC51cGRhdGVBcmNMZW5ndGhzKClcbiAgICAgKlxuICAgICAqIFRoaXMgZm9sbG93aW5nIGNsYXNzZXMgc3ViY2xhc3NlcyBUSFJFRS5DdXJ2ZTpcbiAgICAgKlxuICAgICAqIC0tIDJkIGNsYXNzZXMgLS1cbiAgICAgKiBUSFJFRS5MaW5lQ3VydmVcbiAgICAgKiBUSFJFRS5RdWFkcmF0aWNCZXppZXJDdXJ2ZVxuICAgICAqIFRIUkVFLkN1YmljQmV6aWVyQ3VydmVcbiAgICAgKiBUSFJFRS5TcGxpbmVDdXJ2ZVxuICAgICAqIFRIUkVFLkFyY0N1cnZlXG4gICAgICogVEhSRUUuRWxsaXBzZUN1cnZlXG4gICAgICpcbiAgICAgKiAtLSAzZCBjbGFzc2VzIC0tXG4gICAgICogVEhSRUUuTGluZUN1cnZlM1xuICAgICAqIFRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlM1xuICAgICAqIFRIUkVFLkN1YmljQmV6aWVyQ3VydmUzXG4gICAgICogVEhSRUUuU3BsaW5lQ3VydmUzXG4gICAgICpcbiAgICAgKiBBIHNlcmllcyBvZiBjdXJ2ZXMgY2FuIGJlIHJlcHJlc2VudGVkIGFzIGEgVEhSRUUuQ3VydmVQYXRoXG4gICAgICpcbiAgICAgKiovXG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgKlx0QWJzdHJhY3QgQ3VydmUgYmFzZSBjbGFzc1xuICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgIGZ1bmN0aW9uIEN1cnZlKCkge31cblxuICAgIEN1cnZlLnByb3RvdHlwZSA9IHtcblxuICAgIFx0Y29uc3RydWN0b3I6IEN1cnZlLFxuXG4gICAgXHQvLyBWaXJ0dWFsIGJhc2UgY2xhc3MgbWV0aG9kIHRvIG92ZXJ3cml0ZSBhbmQgaW1wbGVtZW50IGluIHN1YmNsYXNzZXNcbiAgICBcdC8vXHQtIHQgWzAgLi4gMV1cblxuICAgIFx0Z2V0UG9pbnQ6IGZ1bmN0aW9uICggdCApIHtcblxuICAgIFx0XHRjb25zb2xlLndhcm4oIFwiVEhSRUUuQ3VydmU6IFdhcm5pbmcsIGdldFBvaW50KCkgbm90IGltcGxlbWVudGVkIVwiICk7XG4gICAgXHRcdHJldHVybiBudWxsO1xuXG4gICAgXHR9LFxuXG4gICAgXHQvLyBHZXQgcG9pbnQgYXQgcmVsYXRpdmUgcG9zaXRpb24gaW4gY3VydmUgYWNjb3JkaW5nIHRvIGFyYyBsZW5ndGhcbiAgICBcdC8vIC0gdSBbMCAuLiAxXVxuXG4gICAgXHRnZXRQb2ludEF0OiBmdW5jdGlvbiAoIHUgKSB7XG5cbiAgICBcdFx0dmFyIHQgPSB0aGlzLmdldFV0b1RtYXBwaW5nKCB1ICk7XG4gICAgXHRcdHJldHVybiB0aGlzLmdldFBvaW50KCB0ICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdC8vIEdldCBzZXF1ZW5jZSBvZiBwb2ludHMgdXNpbmcgZ2V0UG9pbnQoIHQgKVxuXG4gICAgXHRnZXRQb2ludHM6IGZ1bmN0aW9uICggZGl2aXNpb25zICkge1xuXG4gICAgXHRcdGlmICggISBkaXZpc2lvbnMgKSBkaXZpc2lvbnMgPSA1O1xuXG4gICAgXHRcdHZhciBwb2ludHMgPSBbXTtcblxuICAgIFx0XHRmb3IgKCB2YXIgZCA9IDA7IGQgPD0gZGl2aXNpb25zOyBkICsrICkge1xuXG4gICAgXHRcdFx0cG9pbnRzLnB1c2goIHRoaXMuZ2V0UG9pbnQoIGQgLyBkaXZpc2lvbnMgKSApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gcG9pbnRzO1xuXG4gICAgXHR9LFxuXG4gICAgXHQvLyBHZXQgc2VxdWVuY2Ugb2YgcG9pbnRzIHVzaW5nIGdldFBvaW50QXQoIHUgKVxuXG4gICAgXHRnZXRTcGFjZWRQb2ludHM6IGZ1bmN0aW9uICggZGl2aXNpb25zICkge1xuXG4gICAgXHRcdGlmICggISBkaXZpc2lvbnMgKSBkaXZpc2lvbnMgPSA1O1xuXG4gICAgXHRcdHZhciBwb2ludHMgPSBbXTtcblxuICAgIFx0XHRmb3IgKCB2YXIgZCA9IDA7IGQgPD0gZGl2aXNpb25zOyBkICsrICkge1xuXG4gICAgXHRcdFx0cG9pbnRzLnB1c2goIHRoaXMuZ2V0UG9pbnRBdCggZCAvIGRpdmlzaW9ucyApICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiBwb2ludHM7XG5cbiAgICBcdH0sXG5cbiAgICBcdC8vIEdldCB0b3RhbCBjdXJ2ZSBhcmMgbGVuZ3RoXG5cbiAgICBcdGdldExlbmd0aDogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHZhciBsZW5ndGhzID0gdGhpcy5nZXRMZW5ndGhzKCk7XG4gICAgXHRcdHJldHVybiBsZW5ndGhzWyBsZW5ndGhzLmxlbmd0aCAtIDEgXTtcblxuICAgIFx0fSxcblxuICAgIFx0Ly8gR2V0IGxpc3Qgb2YgY3VtdWxhdGl2ZSBzZWdtZW50IGxlbmd0aHNcblxuICAgIFx0Z2V0TGVuZ3RoczogZnVuY3Rpb24gKCBkaXZpc2lvbnMgKSB7XG5cbiAgICBcdFx0aWYgKCAhIGRpdmlzaW9ucyApIGRpdmlzaW9ucyA9ICggdGhpcy5fX2FyY0xlbmd0aERpdmlzaW9ucyApID8gKCB0aGlzLl9fYXJjTGVuZ3RoRGl2aXNpb25zICkgOiAyMDA7XG5cbiAgICBcdFx0aWYgKCB0aGlzLmNhY2hlQXJjTGVuZ3Roc1xuICAgIFx0XHRcdCYmICggdGhpcy5jYWNoZUFyY0xlbmd0aHMubGVuZ3RoID09PSBkaXZpc2lvbnMgKyAxIClcbiAgICBcdFx0XHQmJiAhIHRoaXMubmVlZHNVcGRhdGUgKSB7XG5cbiAgICBcdFx0XHQvL2NvbnNvbGUubG9nKCBcImNhY2hlZFwiLCB0aGlzLmNhY2hlQXJjTGVuZ3RocyApO1xuICAgIFx0XHRcdHJldHVybiB0aGlzLmNhY2hlQXJjTGVuZ3RocztcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0dGhpcy5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXG4gICAgXHRcdHZhciBjYWNoZSA9IFtdO1xuICAgIFx0XHR2YXIgY3VycmVudCwgbGFzdCA9IHRoaXMuZ2V0UG9pbnQoIDAgKTtcbiAgICBcdFx0dmFyIHAsIHN1bSA9IDA7XG5cbiAgICBcdFx0Y2FjaGUucHVzaCggMCApO1xuXG4gICAgXHRcdGZvciAoIHAgPSAxOyBwIDw9IGRpdmlzaW9uczsgcCArKyApIHtcblxuICAgIFx0XHRcdGN1cnJlbnQgPSB0aGlzLmdldFBvaW50ICggcCAvIGRpdmlzaW9ucyApO1xuICAgIFx0XHRcdHN1bSArPSBjdXJyZW50LmRpc3RhbmNlVG8oIGxhc3QgKTtcbiAgICBcdFx0XHRjYWNoZS5wdXNoKCBzdW0gKTtcbiAgICBcdFx0XHRsYXN0ID0gY3VycmVudDtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0dGhpcy5jYWNoZUFyY0xlbmd0aHMgPSBjYWNoZTtcblxuICAgIFx0XHRyZXR1cm4gY2FjaGU7IC8vIHsgc3VtczogY2FjaGUsIHN1bTpzdW0gfTsgU3VtIGlzIGluIHRoZSBsYXN0IGVsZW1lbnQuXG5cbiAgICBcdH0sXG5cbiAgICBcdHVwZGF0ZUFyY0xlbmd0aHM6IGZ1bmN0aW9uKCkge1xuXG4gICAgXHRcdHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIFx0XHR0aGlzLmdldExlbmd0aHMoKTtcblxuICAgIFx0fSxcblxuICAgIFx0Ly8gR2l2ZW4gdSAoIDAgLi4gMSApLCBnZXQgYSB0IHRvIGZpbmQgcC4gVGhpcyBnaXZlcyB5b3UgcG9pbnRzIHdoaWNoIGFyZSBlcXVpZGlzdGFudFxuXG4gICAgXHRnZXRVdG9UbWFwcGluZzogZnVuY3Rpb24gKCB1LCBkaXN0YW5jZSApIHtcblxuICAgIFx0XHR2YXIgYXJjTGVuZ3RocyA9IHRoaXMuZ2V0TGVuZ3RocygpO1xuXG4gICAgXHRcdHZhciBpID0gMCwgaWwgPSBhcmNMZW5ndGhzLmxlbmd0aDtcblxuICAgIFx0XHR2YXIgdGFyZ2V0QXJjTGVuZ3RoOyAvLyBUaGUgdGFyZ2V0ZWQgdSBkaXN0YW5jZSB2YWx1ZSB0byBnZXRcblxuICAgIFx0XHRpZiAoIGRpc3RhbmNlICkge1xuXG4gICAgXHRcdFx0dGFyZ2V0QXJjTGVuZ3RoID0gZGlzdGFuY2U7XG5cbiAgICBcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdHRhcmdldEFyY0xlbmd0aCA9IHUgKiBhcmNMZW5ndGhzWyBpbCAtIDEgXTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0Ly92YXIgdGltZSA9IERhdGUubm93KCk7XG5cbiAgICBcdFx0Ly8gYmluYXJ5IHNlYXJjaCBmb3IgdGhlIGluZGV4IHdpdGggbGFyZ2VzdCB2YWx1ZSBzbWFsbGVyIHRoYW4gdGFyZ2V0IHUgZGlzdGFuY2VcblxuICAgIFx0XHR2YXIgbG93ID0gMCwgaGlnaCA9IGlsIC0gMSwgY29tcGFyaXNvbjtcblxuICAgIFx0XHR3aGlsZSAoIGxvdyA8PSBoaWdoICkge1xuXG4gICAgXHRcdFx0aSA9IE1hdGguZmxvb3IoIGxvdyArICggaGlnaCAtIGxvdyApIC8gMiApOyAvLyBsZXNzIGxpa2VseSB0byBvdmVyZmxvdywgdGhvdWdoIHByb2JhYmx5IG5vdCBpc3N1ZSBoZXJlLCBKUyBkb2Vzbid0IHJlYWxseSBoYXZlIGludGVnZXJzLCBhbGwgbnVtYmVycyBhcmUgZmxvYXRzXG5cbiAgICBcdFx0XHRjb21wYXJpc29uID0gYXJjTGVuZ3Roc1sgaSBdIC0gdGFyZ2V0QXJjTGVuZ3RoO1xuXG4gICAgXHRcdFx0aWYgKCBjb21wYXJpc29uIDwgMCApIHtcblxuICAgIFx0XHRcdFx0bG93ID0gaSArIDE7XG5cbiAgICBcdFx0XHR9IGVsc2UgaWYgKCBjb21wYXJpc29uID4gMCApIHtcblxuICAgIFx0XHRcdFx0aGlnaCA9IGkgLSAxO1xuXG4gICAgXHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0aGlnaCA9IGk7XG4gICAgXHRcdFx0XHRicmVhaztcblxuICAgIFx0XHRcdFx0Ly8gRE9ORVxuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHRpID0gaGlnaDtcblxuICAgIFx0XHQvL2NvbnNvbGUubG9nKCdiJyAsIGksIGxvdywgaGlnaCwgRGF0ZS5ub3coKS0gdGltZSk7XG5cbiAgICBcdFx0aWYgKCBhcmNMZW5ndGhzWyBpIF0gPT09IHRhcmdldEFyY0xlbmd0aCApIHtcblxuICAgIFx0XHRcdHZhciB0ID0gaSAvICggaWwgLSAxICk7XG4gICAgXHRcdFx0cmV0dXJuIHQ7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdC8vIHdlIGNvdWxkIGdldCBmaW5lciBncmFpbiBhdCBsZW5ndGhzLCBvciB1c2Ugc2ltcGxlIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gcG9pbnRzXG5cbiAgICBcdFx0dmFyIGxlbmd0aEJlZm9yZSA9IGFyY0xlbmd0aHNbIGkgXTtcbiAgICBcdFx0dmFyIGxlbmd0aEFmdGVyID0gYXJjTGVuZ3Roc1sgaSArIDEgXTtcblxuICAgIFx0XHR2YXIgc2VnbWVudExlbmd0aCA9IGxlbmd0aEFmdGVyIC0gbGVuZ3RoQmVmb3JlO1xuXG4gICAgXHRcdC8vIGRldGVybWluZSB3aGVyZSB3ZSBhcmUgYmV0d2VlbiB0aGUgJ2JlZm9yZScgYW5kICdhZnRlcicgcG9pbnRzXG5cbiAgICBcdFx0dmFyIHNlZ21lbnRGcmFjdGlvbiA9ICggdGFyZ2V0QXJjTGVuZ3RoIC0gbGVuZ3RoQmVmb3JlICkgLyBzZWdtZW50TGVuZ3RoO1xuXG4gICAgXHRcdC8vIGFkZCB0aGF0IGZyYWN0aW9uYWwgYW1vdW50IHRvIHRcblxuICAgIFx0XHR2YXIgdCA9ICggaSArIHNlZ21lbnRGcmFjdGlvbiApIC8gKCBpbCAtIDEgKTtcblxuICAgIFx0XHRyZXR1cm4gdDtcblxuICAgIFx0fSxcblxuICAgIFx0Ly8gUmV0dXJucyBhIHVuaXQgdmVjdG9yIHRhbmdlbnQgYXQgdFxuICAgIFx0Ly8gSW4gY2FzZSBhbnkgc3ViIGN1cnZlIGRvZXMgbm90IGltcGxlbWVudCBpdHMgdGFuZ2VudCBkZXJpdmF0aW9uLFxuICAgIFx0Ly8gMiBwb2ludHMgYSBzbWFsbCBkZWx0YSBhcGFydCB3aWxsIGJlIHVzZWQgdG8gZmluZCBpdHMgZ3JhZGllbnRcbiAgICBcdC8vIHdoaWNoIHNlZW1zIHRvIGdpdmUgYSByZWFzb25hYmxlIGFwcHJveGltYXRpb25cblxuICAgIFx0Z2V0VGFuZ2VudDogZnVuY3Rpb24oIHQgKSB7XG5cbiAgICBcdFx0dmFyIGRlbHRhID0gMC4wMDAxO1xuICAgIFx0XHR2YXIgdDEgPSB0IC0gZGVsdGE7XG4gICAgXHRcdHZhciB0MiA9IHQgKyBkZWx0YTtcblxuICAgIFx0XHQvLyBDYXBwaW5nIGluIGNhc2Ugb2YgZGFuZ2VyXG5cbiAgICBcdFx0aWYgKCB0MSA8IDAgKSB0MSA9IDA7XG4gICAgXHRcdGlmICggdDIgPiAxICkgdDIgPSAxO1xuXG4gICAgXHRcdHZhciBwdDEgPSB0aGlzLmdldFBvaW50KCB0MSApO1xuICAgIFx0XHR2YXIgcHQyID0gdGhpcy5nZXRQb2ludCggdDIgKTtcblxuICAgIFx0XHR2YXIgdmVjID0gcHQyLmNsb25lKCkuc3ViKCBwdDEgKTtcbiAgICBcdFx0cmV0dXJuIHZlYy5ub3JtYWxpemUoKTtcblxuICAgIFx0fSxcblxuICAgIFx0Z2V0VGFuZ2VudEF0OiBmdW5jdGlvbiAoIHUgKSB7XG5cbiAgICBcdFx0dmFyIHQgPSB0aGlzLmdldFV0b1RtYXBwaW5nKCB1ICk7XG4gICAgXHRcdHJldHVybiB0aGlzLmdldFRhbmdlbnQoIHQgKTtcblxuICAgIFx0fVxuXG4gICAgfTtcblxuICAgIC8vIFRPRE86IFRyYW5zZm9ybWF0aW9uIGZvciBDdXJ2ZXM/XG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgKlx0M0QgQ3VydmVzXG4gICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgLy8gQSBGYWN0b3J5IG1ldGhvZCBmb3IgY3JlYXRpbmcgbmV3IGN1cnZlIHN1YmNsYXNzZXNcblxuICAgIEN1cnZlLmNyZWF0ZSA9IGZ1bmN0aW9uICggY29uc3RydWN0b3IsIGdldFBvaW50RnVuYyApIHtcblxuICAgIFx0Y29uc3RydWN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQ3VydmUucHJvdG90eXBlICk7XG4gICAgXHRjb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjb25zdHJ1Y3RvcjtcbiAgICBcdGNvbnN0cnVjdG9yLnByb3RvdHlwZS5nZXRQb2ludCA9IGdldFBvaW50RnVuYztcblxuICAgIFx0cmV0dXJuIGNvbnN0cnVjdG9yO1xuXG4gICAgfTtcblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAqXHRMaW5lXG4gICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgZnVuY3Rpb24gTGluZUN1cnZlKCB2MSwgdjIgKSB7XG5cbiAgICBcdHRoaXMudjEgPSB2MTtcbiAgICBcdHRoaXMudjIgPSB2MjtcblxuICAgIH1cblxuICAgIExpbmVDdXJ2ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBDdXJ2ZS5wcm90b3R5cGUgKTtcbiAgICBMaW5lQ3VydmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTGluZUN1cnZlO1xuXG4gICAgTGluZUN1cnZlLnByb3RvdHlwZS5pc0xpbmVDdXJ2ZSA9IHRydWU7XG5cbiAgICBMaW5lQ3VydmUucHJvdG90eXBlLmdldFBvaW50ID0gZnVuY3Rpb24gKCB0ICkge1xuXG4gICAgXHRpZiAoIHQgPT09IDEgKSB7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMudjIuY2xvbmUoKTtcblxuICAgIFx0fVxuXG4gICAgXHR2YXIgcG9pbnQgPSB0aGlzLnYyLmNsb25lKCkuc3ViKCB0aGlzLnYxICk7XG4gICAgXHRwb2ludC5tdWx0aXBseVNjYWxhciggdCApLmFkZCggdGhpcy52MSApO1xuXG4gICAgXHRyZXR1cm4gcG9pbnQ7XG5cbiAgICB9O1xuXG4gICAgLy8gTGluZSBjdXJ2ZSBpcyBsaW5lYXIsIHNvIHdlIGNhbiBvdmVyd3JpdGUgZGVmYXVsdCBnZXRQb2ludEF0XG5cbiAgICBMaW5lQ3VydmUucHJvdG90eXBlLmdldFBvaW50QXQgPSBmdW5jdGlvbiAoIHUgKSB7XG5cbiAgICBcdHJldHVybiB0aGlzLmdldFBvaW50KCB1ICk7XG5cbiAgICB9O1xuXG4gICAgTGluZUN1cnZlLnByb3RvdHlwZS5nZXRUYW5nZW50ID0gZnVuY3Rpb24oIHQgKSB7XG5cbiAgICBcdHZhciB0YW5nZW50ID0gdGhpcy52Mi5jbG9uZSgpLnN1YiggdGhpcy52MSApO1xuXG4gICAgXHRyZXR1cm4gdGFuZ2VudC5ub3JtYWxpemUoKTtcblxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXG4gICAgICpcbiAgICAgKiovXG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgKlx0Q3VydmVkIFBhdGggLSBhIGN1cnZlIHBhdGggaXMgc2ltcGx5IGEgYXJyYXkgb2YgY29ubmVjdGVkXG4gICAgICogIGN1cnZlcywgYnV0IHJldGFpbnMgdGhlIGFwaSBvZiBhIGN1cnZlXG4gICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgZnVuY3Rpb24gQ3VydmVQYXRoKCkge1xuXG4gICAgXHR0aGlzLmN1cnZlcyA9IFtdO1xuXG4gICAgXHR0aGlzLmF1dG9DbG9zZSA9IGZhbHNlOyAvLyBBdXRvbWF0aWNhbGx5IGNsb3NlcyB0aGUgcGF0aFxuXG4gICAgfVxuXG4gICAgQ3VydmVQYXRoLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIEN1cnZlLnByb3RvdHlwZSApLCB7XG5cbiAgICBcdGNvbnN0cnVjdG9yOiBDdXJ2ZVBhdGgsXG5cbiAgICBcdGFkZDogZnVuY3Rpb24gKCBjdXJ2ZSApIHtcblxuICAgIFx0XHR0aGlzLmN1cnZlcy5wdXNoKCBjdXJ2ZSApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRjbG9zZVBhdGg6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHQvLyBBZGQgYSBsaW5lIGN1cnZlIGlmIHN0YXJ0IGFuZCBlbmQgb2YgbGluZXMgYXJlIG5vdCBjb25uZWN0ZWRcbiAgICBcdFx0dmFyIHN0YXJ0UG9pbnQgPSB0aGlzLmN1cnZlc1sgMCBdLmdldFBvaW50KCAwICk7XG4gICAgXHRcdHZhciBlbmRQb2ludCA9IHRoaXMuY3VydmVzWyB0aGlzLmN1cnZlcy5sZW5ndGggLSAxIF0uZ2V0UG9pbnQoIDEgKTtcblxuICAgIFx0XHRpZiAoICEgc3RhcnRQb2ludC5lcXVhbHMoIGVuZFBvaW50ICkgKSB7XG5cbiAgICBcdFx0XHR0aGlzLmN1cnZlcy5wdXNoKCBuZXcgTGluZUN1cnZlKCBlbmRQb2ludCwgc3RhcnRQb2ludCApICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9LFxuXG4gICAgXHQvLyBUbyBnZXQgYWNjdXJhdGUgcG9pbnQgd2l0aCByZWZlcmVuY2UgdG9cbiAgICBcdC8vIGVudGlyZSBwYXRoIGRpc3RhbmNlIGF0IHRpbWUgdCxcbiAgICBcdC8vIGZvbGxvd2luZyBoYXMgdG8gYmUgZG9uZTpcblxuICAgIFx0Ly8gMS4gTGVuZ3RoIG9mIGVhY2ggc3ViIHBhdGggaGF2ZSB0byBiZSBrbm93blxuICAgIFx0Ly8gMi4gTG9jYXRlIGFuZCBpZGVudGlmeSB0eXBlIG9mIGN1cnZlXG4gICAgXHQvLyAzLiBHZXQgdCBmb3IgdGhlIGN1cnZlXG4gICAgXHQvLyA0LiBSZXR1cm4gY3VydmUuZ2V0UG9pbnRBdCh0JylcblxuICAgIFx0Z2V0UG9pbnQ6IGZ1bmN0aW9uICggdCApIHtcblxuICAgIFx0XHR2YXIgZCA9IHQgKiB0aGlzLmdldExlbmd0aCgpO1xuICAgIFx0XHR2YXIgY3VydmVMZW5ndGhzID0gdGhpcy5nZXRDdXJ2ZUxlbmd0aHMoKTtcbiAgICBcdFx0dmFyIGkgPSAwO1xuXG4gICAgXHRcdC8vIFRvIHRoaW5rIGFib3V0IGJvdW5kYXJpZXMgcG9pbnRzLlxuXG4gICAgXHRcdHdoaWxlICggaSA8IGN1cnZlTGVuZ3Rocy5sZW5ndGggKSB7XG5cbiAgICBcdFx0XHRpZiAoIGN1cnZlTGVuZ3Roc1sgaSBdID49IGQgKSB7XG5cbiAgICBcdFx0XHRcdHZhciBkaWZmID0gY3VydmVMZW5ndGhzWyBpIF0gLSBkO1xuICAgIFx0XHRcdFx0dmFyIGN1cnZlID0gdGhpcy5jdXJ2ZXNbIGkgXTtcblxuICAgIFx0XHRcdFx0dmFyIHNlZ21lbnRMZW5ndGggPSBjdXJ2ZS5nZXRMZW5ndGgoKTtcbiAgICBcdFx0XHRcdHZhciB1ID0gc2VnbWVudExlbmd0aCA9PT0gMCA/IDAgOiAxIC0gZGlmZiAvIHNlZ21lbnRMZW5ndGg7XG5cbiAgICBcdFx0XHRcdHJldHVybiBjdXJ2ZS5nZXRQb2ludEF0KCB1ICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRpICsrO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gbnVsbDtcblxuICAgIFx0XHQvLyBsb29wIHdoZXJlIHN1bSAhPSAwLCBzdW0gPiBkICwgc3VtKzEgPGRcblxuICAgIFx0fSxcblxuICAgIFx0Ly8gV2UgY2Fubm90IHVzZSB0aGUgZGVmYXVsdCBUSFJFRS5DdXJ2ZSBnZXRQb2ludCgpIHdpdGggZ2V0TGVuZ3RoKCkgYmVjYXVzZSBpblxuICAgIFx0Ly8gVEhSRUUuQ3VydmUsIGdldExlbmd0aCgpIGRlcGVuZHMgb24gZ2V0UG9pbnQoKSBidXQgaW4gVEhSRUUuQ3VydmVQYXRoXG4gICAgXHQvLyBnZXRQb2ludCgpIGRlcGVuZHMgb24gZ2V0TGVuZ3RoXG5cbiAgICBcdGdldExlbmd0aDogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHZhciBsZW5zID0gdGhpcy5nZXRDdXJ2ZUxlbmd0aHMoKTtcbiAgICBcdFx0cmV0dXJuIGxlbnNbIGxlbnMubGVuZ3RoIC0gMSBdO1xuXG4gICAgXHR9LFxuXG4gICAgXHQvLyBjYWNoZUxlbmd0aHMgbXVzdCBiZSByZWNhbGN1bGF0ZWQuXG4gICAgXHR1cGRhdGVBcmNMZW5ndGhzOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgXHRcdHRoaXMuY2FjaGVMZW5ndGhzID0gbnVsbDtcbiAgICBcdFx0dGhpcy5nZXRMZW5ndGhzKCk7XG5cbiAgICBcdH0sXG5cbiAgICBcdC8vIENvbXB1dGUgbGVuZ3RocyBhbmQgY2FjaGUgdGhlbVxuICAgIFx0Ly8gV2UgY2Fubm90IG92ZXJ3cml0ZSBnZXRMZW5ndGhzKCkgYmVjYXVzZSBVdG9UIG1hcHBpbmcgdXNlcyBpdC5cblxuICAgIFx0Z2V0Q3VydmVMZW5ndGhzOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0Ly8gV2UgdXNlIGNhY2hlIHZhbHVlcyBpZiBjdXJ2ZXMgYW5kIGNhY2hlIGFycmF5IGFyZSBzYW1lIGxlbmd0aFxuXG4gICAgXHRcdGlmICggdGhpcy5jYWNoZUxlbmd0aHMgJiYgdGhpcy5jYWNoZUxlbmd0aHMubGVuZ3RoID09PSB0aGlzLmN1cnZlcy5sZW5ndGggKSB7XG5cbiAgICBcdFx0XHRyZXR1cm4gdGhpcy5jYWNoZUxlbmd0aHM7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdC8vIEdldCBsZW5ndGggb2Ygc3ViLWN1cnZlXG4gICAgXHRcdC8vIFB1c2ggc3VtcyBpbnRvIGNhY2hlZCBhcnJheVxuXG4gICAgXHRcdHZhciBsZW5ndGhzID0gW10sIHN1bXMgPSAwO1xuXG4gICAgXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMuY3VydmVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICBcdFx0XHRzdW1zICs9IHRoaXMuY3VydmVzWyBpIF0uZ2V0TGVuZ3RoKCk7XG4gICAgXHRcdFx0bGVuZ3Rocy5wdXNoKCBzdW1zICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHRoaXMuY2FjaGVMZW5ndGhzID0gbGVuZ3RocztcblxuICAgIFx0XHRyZXR1cm4gbGVuZ3RocztcblxuICAgIFx0fSxcblxuICAgIFx0Z2V0U3BhY2VkUG9pbnRzOiBmdW5jdGlvbiAoIGRpdmlzaW9ucyApIHtcblxuICAgIFx0XHRpZiAoICEgZGl2aXNpb25zICkgZGl2aXNpb25zID0gNDA7XG5cbiAgICBcdFx0dmFyIHBvaW50cyA9IFtdO1xuXG4gICAgXHRcdGZvciAoIHZhciBpID0gMDsgaSA8PSBkaXZpc2lvbnM7IGkgKysgKSB7XG5cbiAgICBcdFx0XHRwb2ludHMucHVzaCggdGhpcy5nZXRQb2ludCggaSAvIGRpdmlzaW9ucyApICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGlmICggdGhpcy5hdXRvQ2xvc2UgKSB7XG5cbiAgICBcdFx0XHRwb2ludHMucHVzaCggcG9pbnRzWyAwIF0gKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIHBvaW50cztcblxuICAgIFx0fSxcblxuICAgIFx0Z2V0UG9pbnRzOiBmdW5jdGlvbiAoIGRpdmlzaW9ucyApIHtcblxuICAgIFx0XHRkaXZpc2lvbnMgPSBkaXZpc2lvbnMgfHwgMTI7XG5cbiAgICBcdFx0dmFyIHBvaW50cyA9IFtdLCBsYXN0O1xuXG4gICAgXHRcdGZvciAoIHZhciBpID0gMCwgY3VydmVzID0gdGhpcy5jdXJ2ZXM7IGkgPCBjdXJ2ZXMubGVuZ3RoOyBpICsrICkge1xuXG4gICAgXHRcdFx0dmFyIGN1cnZlID0gY3VydmVzWyBpIF07XG4gICAgXHRcdFx0dmFyIHJlc29sdXRpb24gPSAoY3VydmUgJiYgY3VydmUuaXNFbGxpcHNlQ3VydmUpID8gZGl2aXNpb25zICogMlxuICAgIFx0XHRcdFx0OiAoY3VydmUgJiYgY3VydmUuaXNMaW5lQ3VydmUpID8gMVxuICAgIFx0XHRcdFx0OiAoY3VydmUgJiYgY3VydmUuaXNTcGxpbmVDdXJ2ZSkgPyBkaXZpc2lvbnMgKiBjdXJ2ZS5wb2ludHMubGVuZ3RoXG4gICAgXHRcdFx0XHQ6IGRpdmlzaW9ucztcblxuICAgIFx0XHRcdHZhciBwdHMgPSBjdXJ2ZS5nZXRQb2ludHMoIHJlc29sdXRpb24gKTtcblxuICAgIFx0XHRcdGZvciAoIHZhciBqID0gMDsgaiA8IHB0cy5sZW5ndGg7IGorKyApIHtcblxuICAgIFx0XHRcdFx0dmFyIHBvaW50ID0gcHRzWyBqIF07XG5cbiAgICBcdFx0XHRcdGlmICggbGFzdCAmJiBsYXN0LmVxdWFscyggcG9pbnQgKSApIGNvbnRpbnVlOyAvLyBlbnN1cmVzIG5vIGNvbnNlY3V0aXZlIHBvaW50cyBhcmUgZHVwbGljYXRlc1xuXG4gICAgXHRcdFx0XHRwb2ludHMucHVzaCggcG9pbnQgKTtcbiAgICBcdFx0XHRcdGxhc3QgPSBwb2ludDtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdFx0aWYgKCB0aGlzLmF1dG9DbG9zZSAmJiBwb2ludHMubGVuZ3RoID4gMSAmJiAhcG9pbnRzWyBwb2ludHMubGVuZ3RoIC0gMSBdLmVxdWFscyggcG9pbnRzWyAwIF0gKSApIHtcblxuICAgIFx0XHRcdHBvaW50cy5wdXNoKCBwb2ludHNbIDAgXSApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gcG9pbnRzO1xuXG4gICAgXHR9LFxuXG4gICAgXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICBcdCAqXHRDcmVhdGUgR2VvbWV0cmllcyBIZWxwZXJzXG4gICAgXHQgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICBcdC8vLyBHZW5lcmF0ZSBnZW9tZXRyeSBmcm9tIHBhdGggcG9pbnRzIChmb3IgTGluZSBvciBQb2ludHMgb2JqZWN0cylcblxuICAgIFx0Y3JlYXRlUG9pbnRzR2VvbWV0cnk6IGZ1bmN0aW9uICggZGl2aXNpb25zICkge1xuXG4gICAgXHRcdHZhciBwdHMgPSB0aGlzLmdldFBvaW50cyggZGl2aXNpb25zICk7XG4gICAgXHRcdHJldHVybiB0aGlzLmNyZWF0ZUdlb21ldHJ5KCBwdHMgKTtcblxuICAgIFx0fSxcblxuICAgIFx0Ly8gR2VuZXJhdGUgZ2VvbWV0cnkgZnJvbSBlcXVpZGlzdGFudCBzYW1wbGluZyBhbG9uZyB0aGUgcGF0aFxuXG4gICAgXHRjcmVhdGVTcGFjZWRQb2ludHNHZW9tZXRyeTogZnVuY3Rpb24gKCBkaXZpc2lvbnMgKSB7XG5cbiAgICBcdFx0dmFyIHB0cyA9IHRoaXMuZ2V0U3BhY2VkUG9pbnRzKCBkaXZpc2lvbnMgKTtcbiAgICBcdFx0cmV0dXJuIHRoaXMuY3JlYXRlR2VvbWV0cnkoIHB0cyApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRjcmVhdGVHZW9tZXRyeTogZnVuY3Rpb24gKCBwb2ludHMgKSB7XG5cbiAgICBcdFx0dmFyIGdlb21ldHJ5ID0gbmV3IEdlb21ldHJ5KCk7XG5cbiAgICBcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICBcdFx0XHR2YXIgcG9pbnQgPSBwb2ludHNbIGkgXTtcbiAgICBcdFx0XHRnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKCBuZXcgVmVjdG9yMyggcG9pbnQueCwgcG9pbnQueSwgcG9pbnQueiB8fCAwICkgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIGdlb21ldHJ5O1xuXG4gICAgXHR9XG5cbiAgICB9ICk7XG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgKlx0RWxsaXBzZSBjdXJ2ZVxuICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgIGZ1bmN0aW9uIEVsbGlwc2VDdXJ2ZSggYVgsIGFZLCB4UmFkaXVzLCB5UmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlLCBhUm90YXRpb24gKSB7XG5cbiAgICBcdHRoaXMuYVggPSBhWDtcbiAgICBcdHRoaXMuYVkgPSBhWTtcblxuICAgIFx0dGhpcy54UmFkaXVzID0geFJhZGl1cztcbiAgICBcdHRoaXMueVJhZGl1cyA9IHlSYWRpdXM7XG5cbiAgICBcdHRoaXMuYVN0YXJ0QW5nbGUgPSBhU3RhcnRBbmdsZTtcbiAgICBcdHRoaXMuYUVuZEFuZ2xlID0gYUVuZEFuZ2xlO1xuXG4gICAgXHR0aGlzLmFDbG9ja3dpc2UgPSBhQ2xvY2t3aXNlO1xuXG4gICAgXHR0aGlzLmFSb3RhdGlvbiA9IGFSb3RhdGlvbiB8fCAwO1xuXG4gICAgfVxuXG4gICAgRWxsaXBzZUN1cnZlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEN1cnZlLnByb3RvdHlwZSApO1xuICAgIEVsbGlwc2VDdXJ2ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBFbGxpcHNlQ3VydmU7XG5cbiAgICBFbGxpcHNlQ3VydmUucHJvdG90eXBlLmlzRWxsaXBzZUN1cnZlID0gdHJ1ZTtcblxuICAgIEVsbGlwc2VDdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbiggdCApIHtcblxuICAgIFx0dmFyIHR3b1BpID0gTWF0aC5QSSAqIDI7XG4gICAgXHR2YXIgZGVsdGFBbmdsZSA9IHRoaXMuYUVuZEFuZ2xlIC0gdGhpcy5hU3RhcnRBbmdsZTtcbiAgICBcdHZhciBzYW1lUG9pbnRzID0gTWF0aC5hYnMoIGRlbHRhQW5nbGUgKSA8IE51bWJlci5FUFNJTE9OO1xuXG4gICAgXHQvLyBlbnN1cmVzIHRoYXQgZGVsdGFBbmdsZSBpcyAwIC4uIDIgUElcbiAgICBcdHdoaWxlICggZGVsdGFBbmdsZSA8IDAgKSBkZWx0YUFuZ2xlICs9IHR3b1BpO1xuICAgIFx0d2hpbGUgKCBkZWx0YUFuZ2xlID4gdHdvUGkgKSBkZWx0YUFuZ2xlIC09IHR3b1BpO1xuXG4gICAgXHRpZiAoIGRlbHRhQW5nbGUgPCBOdW1iZXIuRVBTSUxPTiApIHtcblxuICAgIFx0XHRpZiAoIHNhbWVQb2ludHMgKSB7XG5cbiAgICBcdFx0XHRkZWx0YUFuZ2xlID0gMDtcblxuICAgIFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0ZGVsdGFBbmdsZSA9IHR3b1BpO1xuXG4gICAgXHRcdH1cblxuICAgIFx0fVxuXG4gICAgXHRpZiAoIHRoaXMuYUNsb2Nrd2lzZSA9PT0gdHJ1ZSAmJiAhIHNhbWVQb2ludHMgKSB7XG5cbiAgICBcdFx0aWYgKCBkZWx0YUFuZ2xlID09PSB0d29QaSApIHtcblxuICAgIFx0XHRcdGRlbHRhQW5nbGUgPSAtIHR3b1BpO1xuXG4gICAgXHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRkZWx0YUFuZ2xlID0gZGVsdGFBbmdsZSAtIHR3b1BpO1xuXG4gICAgXHRcdH1cblxuICAgIFx0fVxuXG4gICAgXHR2YXIgYW5nbGUgPSB0aGlzLmFTdGFydEFuZ2xlICsgdCAqIGRlbHRhQW5nbGU7XG4gICAgXHR2YXIgeCA9IHRoaXMuYVggKyB0aGlzLnhSYWRpdXMgKiBNYXRoLmNvcyggYW5nbGUgKTtcbiAgICBcdHZhciB5ID0gdGhpcy5hWSArIHRoaXMueVJhZGl1cyAqIE1hdGguc2luKCBhbmdsZSApO1xuXG4gICAgXHRpZiAoIHRoaXMuYVJvdGF0aW9uICE9PSAwICkge1xuXG4gICAgXHRcdHZhciBjb3MgPSBNYXRoLmNvcyggdGhpcy5hUm90YXRpb24gKTtcbiAgICBcdFx0dmFyIHNpbiA9IE1hdGguc2luKCB0aGlzLmFSb3RhdGlvbiApO1xuXG4gICAgXHRcdHZhciB0eCA9IHggLSB0aGlzLmFYO1xuICAgIFx0XHR2YXIgdHkgPSB5IC0gdGhpcy5hWTtcblxuICAgIFx0XHQvLyBSb3RhdGUgdGhlIHBvaW50IGFib3V0IHRoZSBjZW50ZXIgb2YgdGhlIGVsbGlwc2UuXG4gICAgXHRcdHggPSB0eCAqIGNvcyAtIHR5ICogc2luICsgdGhpcy5hWDtcbiAgICBcdFx0eSA9IHR4ICogc2luICsgdHkgKiBjb3MgKyB0aGlzLmFZO1xuXG4gICAgXHR9XG5cbiAgICBcdHJldHVybiBuZXcgVmVjdG9yMiggeCwgeSApO1xuXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcbiAgICAgKi9cblxuICAgIGV4cG9ydHMuQ3VydmVVdGlscyA9IHtcblxuICAgIFx0dGFuZ2VudFF1YWRyYXRpY0JlemllcjogZnVuY3Rpb24gKCB0LCBwMCwgcDEsIHAyICkge1xuXG4gICAgXHRcdHJldHVybiAyICogKCAxIC0gdCApICogKCBwMSAtIHAwICkgKyAyICogdCAqICggcDIgLSBwMSApO1xuXG4gICAgXHR9LFxuXG4gICAgXHQvLyBQdWF5IEJpbmcsIHRoYW5rcyBmb3IgaGVscGluZyB3aXRoIHRoaXMgZGVyaXZhdGl2ZSFcblxuICAgIFx0dGFuZ2VudEN1YmljQmV6aWVyOiBmdW5jdGlvbiAoIHQsIHAwLCBwMSwgcDIsIHAzICkge1xuXG4gICAgXHRcdHJldHVybiAtIDMgKiBwMCAqICggMSAtIHQgKSAqICggMSAtIHQgKSAgK1xuICAgIFx0XHRcdDMgKiBwMSAqICggMSAtIHQgKSAqICggMSAtIHQgKSAtIDYgKiB0ICogcDEgKiAoIDEgLSB0ICkgK1xuICAgIFx0XHRcdDYgKiB0ICogIHAyICogKCAxIC0gdCApIC0gMyAqIHQgKiB0ICogcDIgK1xuICAgIFx0XHRcdDMgKiB0ICogdCAqIHAzO1xuXG4gICAgXHR9LFxuXG4gICAgXHR0YW5nZW50U3BsaW5lOiBmdW5jdGlvbiAoIHQsIHAwLCBwMSwgcDIsIHAzICkge1xuXG4gICAgXHRcdC8vIFRvIGNoZWNrIGlmIG15IGZvcm11bGFzIGFyZSBjb3JyZWN0XG5cbiAgICBcdFx0dmFyIGgwMCA9IDYgKiB0ICogdCAtIDYgKiB0OyBcdC8vIGRlcml2ZWQgZnJvbSAydF4zIOKIkiAzdF4yICsgMVxuICAgIFx0XHR2YXIgaDEwID0gMyAqIHQgKiB0IC0gNCAqIHQgKyAxOyAvLyB0XjMg4oiSIDJ0XjIgKyB0XG4gICAgXHRcdHZhciBoMDEgPSAtIDYgKiB0ICogdCArIDYgKiB0OyBcdC8vIOKIkiAydDMgKyAzdDJcbiAgICBcdFx0dmFyIGgxMSA9IDMgKiB0ICogdCAtIDIgKiB0O1x0Ly8gdDMg4oiSIHQyXG5cbiAgICBcdFx0cmV0dXJuIGgwMCArIGgxMCArIGgwMSArIGgxMTtcblxuICAgIFx0fSxcblxuICAgIFx0Ly8gQ2F0bXVsbC1Sb21cblxuICAgIFx0aW50ZXJwb2xhdGU6IGZ1bmN0aW9uKCBwMCwgcDEsIHAyLCBwMywgdCApIHtcblxuICAgIFx0XHR2YXIgdjAgPSAoIHAyIC0gcDAgKSAqIDAuNTtcbiAgICBcdFx0dmFyIHYxID0gKCBwMyAtIHAxICkgKiAwLjU7XG4gICAgXHRcdHZhciB0MiA9IHQgKiB0O1xuICAgIFx0XHR2YXIgdDMgPSB0ICogdDI7XG4gICAgXHRcdHJldHVybiAoIDIgKiBwMSAtIDIgKiBwMiArIHYwICsgdjEgKSAqIHQzICsgKCAtIDMgKiBwMSArIDMgKiBwMiAtIDIgKiB2MCAtIHYxICkgKiB0MiArIHYwICogdCArIHAxO1xuXG4gICAgXHR9XG5cbiAgICB9O1xuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICpcdFNwbGluZSBjdXJ2ZVxuICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgIGZ1bmN0aW9uIFNwbGluZUN1cnZlKCBwb2ludHMgLyogYXJyYXkgb2YgVmVjdG9yMiAqLyApIHtcblxuICAgIFx0dGhpcy5wb2ludHMgPSAoIHBvaW50cyA9PT0gdW5kZWZpbmVkICkgPyBbXSA6IHBvaW50cztcblxuICAgIH1cblxuICAgIFNwbGluZUN1cnZlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEN1cnZlLnByb3RvdHlwZSApO1xuICAgIFNwbGluZUN1cnZlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNwbGluZUN1cnZlO1xuXG4gICAgU3BsaW5lQ3VydmUucHJvdG90eXBlLmlzU3BsaW5lQ3VydmUgPSB0cnVlO1xuXG4gICAgU3BsaW5lQ3VydmUucHJvdG90eXBlLmdldFBvaW50ID0gZnVuY3Rpb24gKCB0ICkge1xuXG4gICAgXHR2YXIgcG9pbnRzID0gdGhpcy5wb2ludHM7XG4gICAgXHR2YXIgcG9pbnQgPSAoIHBvaW50cy5sZW5ndGggLSAxICkgKiB0O1xuXG4gICAgXHR2YXIgaW50UG9pbnQgPSBNYXRoLmZsb29yKCBwb2ludCApO1xuICAgIFx0dmFyIHdlaWdodCA9IHBvaW50IC0gaW50UG9pbnQ7XG5cbiAgICBcdHZhciBwb2ludDAgPSBwb2ludHNbIGludFBvaW50ID09PSAwID8gaW50UG9pbnQgOiBpbnRQb2ludCAtIDEgXTtcbiAgICBcdHZhciBwb2ludDEgPSBwb2ludHNbIGludFBvaW50IF07XG4gICAgXHR2YXIgcG9pbnQyID0gcG9pbnRzWyBpbnRQb2ludCA+IHBvaW50cy5sZW5ndGggLSAyID8gcG9pbnRzLmxlbmd0aCAtIDEgOiBpbnRQb2ludCArIDEgXTtcbiAgICBcdHZhciBwb2ludDMgPSBwb2ludHNbIGludFBvaW50ID4gcG9pbnRzLmxlbmd0aCAtIDMgPyBwb2ludHMubGVuZ3RoIC0gMSA6IGludFBvaW50ICsgMiBdO1xuXG4gICAgXHR2YXIgaW50ZXJwb2xhdGUgPSBleHBvcnRzLkN1cnZlVXRpbHMuaW50ZXJwb2xhdGU7XG5cbiAgICBcdHJldHVybiBuZXcgVmVjdG9yMihcbiAgICBcdFx0aW50ZXJwb2xhdGUoIHBvaW50MC54LCBwb2ludDEueCwgcG9pbnQyLngsIHBvaW50My54LCB3ZWlnaHQgKSxcbiAgICBcdFx0aW50ZXJwb2xhdGUoIHBvaW50MC55LCBwb2ludDEueSwgcG9pbnQyLnksIHBvaW50My55LCB3ZWlnaHQgKVxuICAgIFx0KTtcblxuICAgIH07XG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgKlx0Q3ViaWMgQmV6aWVyIGN1cnZlXG4gICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgZnVuY3Rpb24gQ3ViaWNCZXppZXJDdXJ2ZSggdjAsIHYxLCB2MiwgdjMgKSB7XG5cbiAgICBcdHRoaXMudjAgPSB2MDtcbiAgICBcdHRoaXMudjEgPSB2MTtcbiAgICBcdHRoaXMudjIgPSB2MjtcbiAgICBcdHRoaXMudjMgPSB2MztcblxuICAgIH1cblxuICAgIEN1YmljQmV6aWVyQ3VydmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQ3VydmUucHJvdG90eXBlICk7XG4gICAgQ3ViaWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDdWJpY0JlemllckN1cnZlO1xuXG4gICAgQ3ViaWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbiAoIHQgKSB7XG5cbiAgICBcdHZhciBiMyA9IGV4cG9ydHMuU2hhcGVVdGlscy5iMztcblxuICAgIFx0cmV0dXJuIG5ldyBWZWN0b3IyKFxuICAgIFx0XHRiMyggdCwgdGhpcy52MC54LCB0aGlzLnYxLngsIHRoaXMudjIueCwgdGhpcy52My54ICksXG4gICAgXHRcdGIzKCB0LCB0aGlzLnYwLnksIHRoaXMudjEueSwgdGhpcy52Mi55LCB0aGlzLnYzLnkgKVxuICAgIFx0KTtcblxuICAgIH07XG5cbiAgICBDdWJpY0JlemllckN1cnZlLnByb3RvdHlwZS5nZXRUYW5nZW50ID0gZnVuY3Rpb24oIHQgKSB7XG5cbiAgICBcdHZhciB0YW5nZW50Q3ViaWNCZXppZXIgPSBleHBvcnRzLkN1cnZlVXRpbHMudGFuZ2VudEN1YmljQmV6aWVyO1xuXG4gICAgXHRyZXR1cm4gbmV3IFZlY3RvcjIoXG4gICAgXHRcdHRhbmdlbnRDdWJpY0JlemllciggdCwgdGhpcy52MC54LCB0aGlzLnYxLngsIHRoaXMudjIueCwgdGhpcy52My54ICksXG4gICAgXHRcdHRhbmdlbnRDdWJpY0JlemllciggdCwgdGhpcy52MC55LCB0aGlzLnYxLnksIHRoaXMudjIueSwgdGhpcy52My55IClcbiAgICBcdCkubm9ybWFsaXplKCk7XG5cbiAgICB9O1xuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICpcdFF1YWRyYXRpYyBCZXppZXIgY3VydmVcbiAgICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblxuICAgIGZ1bmN0aW9uIFF1YWRyYXRpY0JlemllckN1cnZlKCB2MCwgdjEsIHYyICkge1xuXG4gICAgXHR0aGlzLnYwID0gdjA7XG4gICAgXHR0aGlzLnYxID0gdjE7XG4gICAgXHR0aGlzLnYyID0gdjI7XG5cbiAgICB9XG5cbiAgICBRdWFkcmF0aWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBDdXJ2ZS5wcm90b3R5cGUgKTtcbiAgICBRdWFkcmF0aWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBRdWFkcmF0aWNCZXppZXJDdXJ2ZTtcblxuXG4gICAgUXVhZHJhdGljQmV6aWVyQ3VydmUucHJvdG90eXBlLmdldFBvaW50ID0gZnVuY3Rpb24gKCB0ICkge1xuXG4gICAgXHR2YXIgYjIgPSBleHBvcnRzLlNoYXBlVXRpbHMuYjI7XG5cbiAgICBcdHJldHVybiBuZXcgVmVjdG9yMihcbiAgICBcdFx0YjIoIHQsIHRoaXMudjAueCwgdGhpcy52MS54LCB0aGlzLnYyLnggKSxcbiAgICBcdFx0YjIoIHQsIHRoaXMudjAueSwgdGhpcy52MS55LCB0aGlzLnYyLnkgKVxuICAgIFx0KTtcblxuICAgIH07XG5cblxuICAgIFF1YWRyYXRpY0JlemllckN1cnZlLnByb3RvdHlwZS5nZXRUYW5nZW50ID0gZnVuY3Rpb24oIHQgKSB7XG5cbiAgICBcdHZhciB0YW5nZW50UXVhZHJhdGljQmV6aWVyID0gZXhwb3J0cy5DdXJ2ZVV0aWxzLnRhbmdlbnRRdWFkcmF0aWNCZXppZXI7XG5cbiAgICBcdHJldHVybiBuZXcgVmVjdG9yMihcbiAgICBcdFx0dGFuZ2VudFF1YWRyYXRpY0JlemllciggdCwgdGhpcy52MC54LCB0aGlzLnYxLngsIHRoaXMudjIueCApLFxuICAgIFx0XHR0YW5nZW50UXVhZHJhdGljQmV6aWVyKCB0LCB0aGlzLnYwLnksIHRoaXMudjEueSwgdGhpcy52Mi55IClcbiAgICBcdCkubm9ybWFsaXplKCk7XG5cbiAgICB9O1xuXG4gICAgdmFyIFBhdGhQcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBDdXJ2ZVBhdGgucHJvdG90eXBlICksIHtcblxuICAgIFx0ZnJvbVBvaW50czogZnVuY3Rpb24gKCB2ZWN0b3JzICkge1xuXG4gICAgXHRcdHRoaXMubW92ZVRvKCB2ZWN0b3JzWyAwIF0ueCwgdmVjdG9yc1sgMCBdLnkgKTtcblxuICAgIFx0XHRmb3IgKCB2YXIgaSA9IDEsIGwgPSB2ZWN0b3JzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICBcdFx0XHR0aGlzLmxpbmVUbyggdmVjdG9yc1sgaSBdLngsIHZlY3RvcnNbIGkgXS55ICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9LFxuXG4gICAgXHRtb3ZlVG86IGZ1bmN0aW9uICggeCwgeSApIHtcblxuICAgIFx0XHR0aGlzLmN1cnJlbnRQb2ludC5zZXQoIHgsIHkgKTsgLy8gVE9ETyBjb25zaWRlciByZWZlcmVuY2luZyB2ZWN0b3JzIGluc3RlYWQgb2YgY29weWluZz9cblxuICAgIFx0fSxcblxuICAgIFx0bGluZVRvOiBmdW5jdGlvbiAoIHgsIHkgKSB7XG5cbiAgICBcdFx0dmFyIGN1cnZlID0gbmV3IExpbmVDdXJ2ZSggdGhpcy5jdXJyZW50UG9pbnQuY2xvbmUoKSwgbmV3IFZlY3RvcjIoIHgsIHkgKSApO1xuICAgIFx0XHR0aGlzLmN1cnZlcy5wdXNoKCBjdXJ2ZSApO1xuXG4gICAgXHRcdHRoaXMuY3VycmVudFBvaW50LnNldCggeCwgeSApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRxdWFkcmF0aWNDdXJ2ZVRvOiBmdW5jdGlvbiAoIGFDUHgsIGFDUHksIGFYLCBhWSApIHtcblxuICAgIFx0XHR2YXIgY3VydmUgPSBuZXcgUXVhZHJhdGljQmV6aWVyQ3VydmUoXG4gICAgXHRcdFx0dGhpcy5jdXJyZW50UG9pbnQuY2xvbmUoKSxcbiAgICBcdFx0XHRuZXcgVmVjdG9yMiggYUNQeCwgYUNQeSApLFxuICAgIFx0XHRcdG5ldyBWZWN0b3IyKCBhWCwgYVkgKVxuICAgIFx0XHQpO1xuXG4gICAgXHRcdHRoaXMuY3VydmVzLnB1c2goIGN1cnZlICk7XG5cbiAgICBcdFx0dGhpcy5jdXJyZW50UG9pbnQuc2V0KCBhWCwgYVkgKTtcblxuICAgIFx0fSxcblxuICAgIFx0YmV6aWVyQ3VydmVUbzogZnVuY3Rpb24gKCBhQ1AxeCwgYUNQMXksIGFDUDJ4LCBhQ1AyeSwgYVgsIGFZICkge1xuXG4gICAgXHRcdHZhciBjdXJ2ZSA9IG5ldyBDdWJpY0JlemllckN1cnZlKFxuICAgIFx0XHRcdHRoaXMuY3VycmVudFBvaW50LmNsb25lKCksXG4gICAgXHRcdFx0bmV3IFZlY3RvcjIoIGFDUDF4LCBhQ1AxeSApLFxuICAgIFx0XHRcdG5ldyBWZWN0b3IyKCBhQ1AyeCwgYUNQMnkgKSxcbiAgICBcdFx0XHRuZXcgVmVjdG9yMiggYVgsIGFZIClcbiAgICBcdFx0KTtcblxuICAgIFx0XHR0aGlzLmN1cnZlcy5wdXNoKCBjdXJ2ZSApO1xuXG4gICAgXHRcdHRoaXMuY3VycmVudFBvaW50LnNldCggYVgsIGFZICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNwbGluZVRocnU6IGZ1bmN0aW9uICggcHRzIC8qQXJyYXkgb2YgVmVjdG9yKi8gKSB7XG5cbiAgICBcdFx0dmFyIG5wdHMgPSBbIHRoaXMuY3VycmVudFBvaW50LmNsb25lKCkgXS5jb25jYXQoIHB0cyApO1xuXG4gICAgXHRcdHZhciBjdXJ2ZSA9IG5ldyBTcGxpbmVDdXJ2ZSggbnB0cyApO1xuICAgIFx0XHR0aGlzLmN1cnZlcy5wdXNoKCBjdXJ2ZSApO1xuXG4gICAgXHRcdHRoaXMuY3VycmVudFBvaW50LmNvcHkoIHB0c1sgcHRzLmxlbmd0aCAtIDEgXSApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRhcmM6IGZ1bmN0aW9uICggYVgsIGFZLCBhUmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlICkge1xuXG4gICAgXHRcdHZhciB4MCA9IHRoaXMuY3VycmVudFBvaW50Lng7XG4gICAgXHRcdHZhciB5MCA9IHRoaXMuY3VycmVudFBvaW50Lnk7XG5cbiAgICBcdFx0dGhpcy5hYnNhcmMoIGFYICsgeDAsIGFZICsgeTAsIGFSYWRpdXMsXG4gICAgXHRcdFx0YVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRhYnNhcmM6IGZ1bmN0aW9uICggYVgsIGFZLCBhUmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlICkge1xuXG4gICAgXHRcdHRoaXMuYWJzZWxsaXBzZSggYVgsIGFZLCBhUmFkaXVzLCBhUmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGVsbGlwc2U6IGZ1bmN0aW9uICggYVgsIGFZLCB4UmFkaXVzLCB5UmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlLCBhUm90YXRpb24gKSB7XG5cbiAgICBcdFx0dmFyIHgwID0gdGhpcy5jdXJyZW50UG9pbnQueDtcbiAgICBcdFx0dmFyIHkwID0gdGhpcy5jdXJyZW50UG9pbnQueTtcblxuICAgIFx0XHR0aGlzLmFic2VsbGlwc2UoIGFYICsgeDAsIGFZICsgeTAsIHhSYWRpdXMsIHlSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UsIGFSb3RhdGlvbiApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRhYnNlbGxpcHNlOiBmdW5jdGlvbiAoIGFYLCBhWSwgeFJhZGl1cywgeVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSwgYVJvdGF0aW9uICkge1xuXG4gICAgXHRcdHZhciBjdXJ2ZSA9IG5ldyBFbGxpcHNlQ3VydmUoIGFYLCBhWSwgeFJhZGl1cywgeVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSwgYVJvdGF0aW9uICk7XG5cbiAgICBcdFx0aWYgKCB0aGlzLmN1cnZlcy5sZW5ndGggPiAwICkge1xuXG4gICAgXHRcdFx0Ly8gaWYgYSBwcmV2aW91cyBjdXJ2ZSBpcyBwcmVzZW50LCBhdHRlbXB0IHRvIGpvaW5cbiAgICBcdFx0XHR2YXIgZmlyc3RQb2ludCA9IGN1cnZlLmdldFBvaW50KCAwICk7XG5cbiAgICBcdFx0XHRpZiAoICEgZmlyc3RQb2ludC5lcXVhbHMoIHRoaXMuY3VycmVudFBvaW50ICkgKSB7XG5cbiAgICBcdFx0XHRcdHRoaXMubGluZVRvKCBmaXJzdFBvaW50LngsIGZpcnN0UG9pbnQueSApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHR0aGlzLmN1cnZlcy5wdXNoKCBjdXJ2ZSApO1xuXG4gICAgXHRcdHZhciBsYXN0UG9pbnQgPSBjdXJ2ZS5nZXRQb2ludCggMSApO1xuICAgIFx0XHR0aGlzLmN1cnJlbnRQb2ludC5jb3B5KCBsYXN0UG9pbnQgKTtcblxuICAgIFx0fVxuXG4gICAgfSApO1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xuICAgICAqIERlZmluZXMgYSAyZCBzaGFwZSBwbGFuZSB1c2luZyBwYXRocy5cbiAgICAgKiovXG5cbiAgICAvLyBTVEVQIDEgQ3JlYXRlIGEgcGF0aC5cbiAgICAvLyBTVEVQIDIgVHVybiBwYXRoIGludG8gc2hhcGUuXG4gICAgLy8gU1RFUCAzIEV4dHJ1ZGVHZW9tZXRyeSB0YWtlcyBpbiBTaGFwZS9TaGFwZXNcbiAgICAvLyBTVEVQIDNhIC0gRXh0cmFjdCBwb2ludHMgZnJvbSBlYWNoIHNoYXBlLCB0dXJuIHRvIHZlcnRpY2VzXG4gICAgLy8gU1RFUCAzYiAtIFRyaWFuZ3VsYXRlIGVhY2ggc2hhcGUsIGFkZCBmYWNlcy5cblxuICAgIGZ1bmN0aW9uIFNoYXBlKCkge1xuXG4gICAgXHRQYXRoLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblxuICAgIFx0dGhpcy5ob2xlcyA9IFtdO1xuXG4gICAgfVxuXG4gICAgU2hhcGUucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggUGF0aFByb3RvdHlwZSApLCB7XG5cbiAgICBcdGNvbnN0cnVjdG9yOiBTaGFwZSxcblxuICAgIFx0Z2V0UG9pbnRzSG9sZXM6IGZ1bmN0aW9uICggZGl2aXNpb25zICkge1xuXG4gICAgXHRcdHZhciBob2xlc1B0cyA9IFtdO1xuXG4gICAgXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMuaG9sZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgIFx0XHRcdGhvbGVzUHRzWyBpIF0gPSB0aGlzLmhvbGVzWyBpIF0uZ2V0UG9pbnRzKCBkaXZpc2lvbnMgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIGhvbGVzUHRzO1xuXG4gICAgXHR9LFxuXG4gICAgXHQvLyBHZXQgcG9pbnRzIG9mIHNoYXBlIGFuZCBob2xlcyAoa2V5cG9pbnRzIGJhc2VkIG9uIHNlZ21lbnRzIHBhcmFtZXRlcilcblxuICAgIFx0ZXh0cmFjdEFsbFBvaW50czogZnVuY3Rpb24gKCBkaXZpc2lvbnMgKSB7XG5cbiAgICBcdFx0cmV0dXJuIHtcblxuICAgIFx0XHRcdHNoYXBlOiB0aGlzLmdldFBvaW50cyggZGl2aXNpb25zICksXG4gICAgXHRcdFx0aG9sZXM6IHRoaXMuZ2V0UG9pbnRzSG9sZXMoIGRpdmlzaW9ucyApXG5cbiAgICBcdFx0fTtcblxuICAgIFx0fSxcblxuICAgIFx0ZXh0cmFjdFBvaW50czogZnVuY3Rpb24gKCBkaXZpc2lvbnMgKSB7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMuZXh0cmFjdEFsbFBvaW50cyggZGl2aXNpb25zICk7XG5cbiAgICBcdH1cblxuICAgIH0gKTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcbiAgICAgKiBDcmVhdGVzIGZyZWUgZm9ybSAyZCBwYXRoIHVzaW5nIHNlcmllcyBvZiBwb2ludHMsIGxpbmVzIG9yIGN1cnZlcy5cbiAgICAgKlxuICAgICAqKi9cblxuICAgIGZ1bmN0aW9uIFBhdGgoIHBvaW50cyApIHtcblxuICAgIFx0Q3VydmVQYXRoLmNhbGwoIHRoaXMgKTtcbiAgICBcdHRoaXMuY3VycmVudFBvaW50ID0gbmV3IFZlY3RvcjIoKTtcblxuICAgIFx0aWYgKCBwb2ludHMgKSB7XG5cbiAgICBcdFx0dGhpcy5mcm9tUG9pbnRzKCBwb2ludHMgKTtcblxuICAgIFx0fVxuXG4gICAgfVxuXG4gICAgUGF0aC5wcm90b3R5cGUgPSBQYXRoUHJvdG90eXBlO1xuICAgIFBhdGhQcm90b3R5cGUuY29uc3RydWN0b3IgPSBQYXRoO1xuXG5cbiAgICAvLyBtaW5pbWFsIGNsYXNzIGZvciBwcm94aW5nIGZ1bmN0aW9ucyB0byBQYXRoLiBSZXBsYWNlcyBvbGQgXCJleHRyYWN0U3VicGF0aHMoKVwiXG4gICAgZnVuY3Rpb24gU2hhcGVQYXRoKCkge1xuICAgIFx0dGhpcy5zdWJQYXRocyA9IFtdO1xuICAgIFx0dGhpcy5jdXJyZW50UGF0aCA9IG51bGw7XG4gICAgfVxuXG4gICAgU2hhcGVQYXRoLnByb3RvdHlwZSA9IHtcbiAgICBcdG1vdmVUbzogZnVuY3Rpb24gKCB4LCB5ICkge1xuICAgIFx0XHR0aGlzLmN1cnJlbnRQYXRoID0gbmV3IFBhdGgoKTtcbiAgICBcdFx0dGhpcy5zdWJQYXRocy5wdXNoKHRoaXMuY3VycmVudFBhdGgpO1xuICAgIFx0XHR0aGlzLmN1cnJlbnRQYXRoLm1vdmVUbyggeCwgeSApO1xuICAgIFx0fSxcbiAgICBcdGxpbmVUbzogZnVuY3Rpb24gKCB4LCB5ICkge1xuICAgIFx0XHR0aGlzLmN1cnJlbnRQYXRoLmxpbmVUbyggeCwgeSApO1xuICAgIFx0fSxcbiAgICBcdHF1YWRyYXRpY0N1cnZlVG86IGZ1bmN0aW9uICggYUNQeCwgYUNQeSwgYVgsIGFZICkge1xuICAgIFx0XHR0aGlzLmN1cnJlbnRQYXRoLnF1YWRyYXRpY0N1cnZlVG8oIGFDUHgsIGFDUHksIGFYLCBhWSApO1xuICAgIFx0fSxcbiAgICBcdGJlemllckN1cnZlVG86IGZ1bmN0aW9uICggYUNQMXgsIGFDUDF5LCBhQ1AyeCwgYUNQMnksIGFYLCBhWSApIHtcbiAgICBcdFx0dGhpcy5jdXJyZW50UGF0aC5iZXppZXJDdXJ2ZVRvKCBhQ1AxeCwgYUNQMXksIGFDUDJ4LCBhQ1AyeSwgYVgsIGFZICk7XG4gICAgXHR9LFxuICAgIFx0c3BsaW5lVGhydTogZnVuY3Rpb24gKCBwdHMgKSB7XG4gICAgXHRcdHRoaXMuY3VycmVudFBhdGguc3BsaW5lVGhydSggcHRzICk7XG4gICAgXHR9LFxuXG4gICAgXHR0b1NoYXBlczogZnVuY3Rpb24gKCBpc0NDVywgbm9Ib2xlcyApIHtcblxuICAgIFx0XHRmdW5jdGlvbiB0b1NoYXBlc05vSG9sZXMoIGluU3VicGF0aHMgKSB7XG5cbiAgICBcdFx0XHR2YXIgc2hhcGVzID0gW107XG5cbiAgICBcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBpblN1YnBhdGhzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICBcdFx0XHRcdHZhciB0bXBQYXRoID0gaW5TdWJwYXRoc1sgaSBdO1xuXG4gICAgXHRcdFx0XHR2YXIgdG1wU2hhcGUgPSBuZXcgU2hhcGUoKTtcbiAgICBcdFx0XHRcdHRtcFNoYXBlLmN1cnZlcyA9IHRtcFBhdGguY3VydmVzO1xuXG4gICAgXHRcdFx0XHRzaGFwZXMucHVzaCggdG1wU2hhcGUgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdHJldHVybiBzaGFwZXM7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGZ1bmN0aW9uIGlzUG9pbnRJbnNpZGVQb2x5Z29uKCBpblB0LCBpblBvbHlnb24gKSB7XG5cbiAgICBcdFx0XHR2YXIgcG9seUxlbiA9IGluUG9seWdvbi5sZW5ndGg7XG5cbiAgICBcdFx0XHQvLyBpblB0IG9uIHBvbHlnb24gY29udG91ciA9PiBpbW1lZGlhdGUgc3VjY2VzcyAgICBvclxuICAgIFx0XHRcdC8vIHRvZ2dsaW5nIG9mIGluc2lkZS9vdXRzaWRlIGF0IGV2ZXJ5IHNpbmdsZSEgaW50ZXJzZWN0aW9uIHBvaW50IG9mIGFuIGVkZ2VcbiAgICBcdFx0XHQvLyAgd2l0aCB0aGUgaG9yaXpvbnRhbCBsaW5lIHRocm91Z2ggaW5QdCwgbGVmdCBvZiBpblB0XG4gICAgXHRcdFx0Ly8gIG5vdCBjb3VudGluZyBsb3dlclkgZW5kcG9pbnRzIG9mIGVkZ2VzIGFuZCB3aG9sZSBlZGdlcyBvbiB0aGF0IGxpbmVcbiAgICBcdFx0XHR2YXIgaW5zaWRlID0gZmFsc2U7XG4gICAgXHRcdFx0Zm9yICggdmFyIHAgPSBwb2x5TGVuIC0gMSwgcSA9IDA7IHEgPCBwb2x5TGVuOyBwID0gcSArKyApIHtcblxuICAgIFx0XHRcdFx0dmFyIGVkZ2VMb3dQdCAgPSBpblBvbHlnb25bIHAgXTtcbiAgICBcdFx0XHRcdHZhciBlZGdlSGlnaFB0ID0gaW5Qb2x5Z29uWyBxIF07XG5cbiAgICBcdFx0XHRcdHZhciBlZGdlRHggPSBlZGdlSGlnaFB0LnggLSBlZGdlTG93UHQueDtcbiAgICBcdFx0XHRcdHZhciBlZGdlRHkgPSBlZGdlSGlnaFB0LnkgLSBlZGdlTG93UHQueTtcblxuICAgIFx0XHRcdFx0aWYgKCBNYXRoLmFicyggZWRnZUR5ICkgPiBOdW1iZXIuRVBTSUxPTiApIHtcblxuICAgIFx0XHRcdFx0XHQvLyBub3QgcGFyYWxsZWxcbiAgICBcdFx0XHRcdFx0aWYgKCBlZGdlRHkgPCAwICkge1xuXG4gICAgXHRcdFx0XHRcdFx0ZWRnZUxvd1B0ICA9IGluUG9seWdvblsgcSBdOyBlZGdlRHggPSAtIGVkZ2VEeDtcbiAgICBcdFx0XHRcdFx0XHRlZGdlSGlnaFB0ID0gaW5Qb2x5Z29uWyBwIF07IGVkZ2VEeSA9IC0gZWRnZUR5O1xuXG4gICAgXHRcdFx0XHRcdH1cbiAgICBcdFx0XHRcdFx0aWYgKCAoIGluUHQueSA8IGVkZ2VMb3dQdC55ICkgfHwgKCBpblB0LnkgPiBlZGdlSGlnaFB0LnkgKSApIFx0XHRjb250aW51ZTtcblxuICAgIFx0XHRcdFx0XHRpZiAoIGluUHQueSA9PT0gZWRnZUxvd1B0LnkgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHRpZiAoIGluUHQueCA9PT0gZWRnZUxvd1B0LnggKVx0XHRyZXR1cm5cdHRydWU7XHRcdC8vIGluUHQgaXMgb24gY29udG91ciA/XG4gICAgXHRcdFx0XHRcdFx0Ly8gY29udGludWU7XHRcdFx0XHQvLyBubyBpbnRlcnNlY3Rpb24gb3IgZWRnZUxvd1B0ID0+IGRvZXNuJ3QgY291bnQgISEhXG5cbiAgICBcdFx0XHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0XHRcdHZhciBwZXJwRWRnZSA9IGVkZ2VEeSAqICggaW5QdC54IC0gZWRnZUxvd1B0LnggKSAtIGVkZ2VEeCAqICggaW5QdC55IC0gZWRnZUxvd1B0LnkgKTtcbiAgICBcdFx0XHRcdFx0XHRpZiAoIHBlcnBFZGdlID09PSAwIClcdFx0XHRcdHJldHVyblx0dHJ1ZTtcdFx0Ly8gaW5QdCBpcyBvbiBjb250b3VyID9cbiAgICBcdFx0XHRcdFx0XHRpZiAoIHBlcnBFZGdlIDwgMCApIFx0XHRcdFx0Y29udGludWU7XG4gICAgXHRcdFx0XHRcdFx0aW5zaWRlID0gISBpbnNpZGU7XHRcdC8vIHRydWUgaW50ZXJzZWN0aW9uIGxlZnQgb2YgaW5QdFxuXG4gICAgXHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0XHQvLyBwYXJhbGxlbCBvciBjb2xsaW5lYXJcbiAgICBcdFx0XHRcdFx0aWYgKCBpblB0LnkgIT09IGVkZ2VMb3dQdC55ICkgXHRcdGNvbnRpbnVlO1x0XHRcdC8vIHBhcmFsbGVsXG4gICAgXHRcdFx0XHRcdC8vIGVkZ2UgbGllcyBvbiB0aGUgc2FtZSBob3Jpem9udGFsIGxpbmUgYXMgaW5QdFxuICAgIFx0XHRcdFx0XHRpZiAoICggKCBlZGdlSGlnaFB0LnggPD0gaW5QdC54ICkgJiYgKCBpblB0LnggPD0gZWRnZUxvd1B0LnggKSApIHx8XG4gICAgXHRcdFx0XHRcdFx0ICggKCBlZGdlTG93UHQueCA8PSBpblB0LnggKSAmJiAoIGluUHQueCA8PSBlZGdlSGlnaFB0LnggKSApIClcdFx0cmV0dXJuXHR0cnVlO1x0Ly8gaW5QdDogUG9pbnQgb24gY29udG91ciAhXG4gICAgXHRcdFx0XHRcdC8vIGNvbnRpbnVlO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRyZXR1cm5cdGluc2lkZTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0dmFyIGlzQ2xvY2tXaXNlID0gZXhwb3J0cy5TaGFwZVV0aWxzLmlzQ2xvY2tXaXNlO1xuXG4gICAgXHRcdHZhciBzdWJQYXRocyA9IHRoaXMuc3ViUGF0aHM7XG4gICAgXHRcdGlmICggc3ViUGF0aHMubGVuZ3RoID09PSAwICkgcmV0dXJuIFtdO1xuXG4gICAgXHRcdGlmICggbm9Ib2xlcyA9PT0gdHJ1ZSApXHRyZXR1cm5cdHRvU2hhcGVzTm9Ib2xlcyggc3ViUGF0aHMgKTtcblxuXG4gICAgXHRcdHZhciBzb2xpZCwgdG1wUGF0aCwgdG1wU2hhcGUsIHNoYXBlcyA9IFtdO1xuXG4gICAgXHRcdGlmICggc3ViUGF0aHMubGVuZ3RoID09PSAxICkge1xuXG4gICAgXHRcdFx0dG1wUGF0aCA9IHN1YlBhdGhzWyAwIF07XG4gICAgXHRcdFx0dG1wU2hhcGUgPSBuZXcgU2hhcGUoKTtcbiAgICBcdFx0XHR0bXBTaGFwZS5jdXJ2ZXMgPSB0bXBQYXRoLmN1cnZlcztcbiAgICBcdFx0XHRzaGFwZXMucHVzaCggdG1wU2hhcGUgKTtcbiAgICBcdFx0XHRyZXR1cm4gc2hhcGVzO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHR2YXIgaG9sZXNGaXJzdCA9ICEgaXNDbG9ja1dpc2UoIHN1YlBhdGhzWyAwIF0uZ2V0UG9pbnRzKCkgKTtcbiAgICBcdFx0aG9sZXNGaXJzdCA9IGlzQ0NXID8gISBob2xlc0ZpcnN0IDogaG9sZXNGaXJzdDtcblxuICAgIFx0XHQvLyBjb25zb2xlLmxvZyhcIkhvbGVzIGZpcnN0XCIsIGhvbGVzRmlyc3QpO1xuXG4gICAgXHRcdHZhciBiZXR0ZXJTaGFwZUhvbGVzID0gW107XG4gICAgXHRcdHZhciBuZXdTaGFwZXMgPSBbXTtcbiAgICBcdFx0dmFyIG5ld1NoYXBlSG9sZXMgPSBbXTtcbiAgICBcdFx0dmFyIG1haW5JZHggPSAwO1xuICAgIFx0XHR2YXIgdG1wUG9pbnRzO1xuXG4gICAgXHRcdG5ld1NoYXBlc1sgbWFpbklkeCBdID0gdW5kZWZpbmVkO1xuICAgIFx0XHRuZXdTaGFwZUhvbGVzWyBtYWluSWR4IF0gPSBbXTtcblxuICAgIFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBzdWJQYXRocy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgXHRcdFx0dG1wUGF0aCA9IHN1YlBhdGhzWyBpIF07XG4gICAgXHRcdFx0dG1wUG9pbnRzID0gdG1wUGF0aC5nZXRQb2ludHMoKTtcbiAgICBcdFx0XHRzb2xpZCA9IGlzQ2xvY2tXaXNlKCB0bXBQb2ludHMgKTtcbiAgICBcdFx0XHRzb2xpZCA9IGlzQ0NXID8gISBzb2xpZCA6IHNvbGlkO1xuXG4gICAgXHRcdFx0aWYgKCBzb2xpZCApIHtcblxuICAgIFx0XHRcdFx0aWYgKCAoICEgaG9sZXNGaXJzdCApICYmICggbmV3U2hhcGVzWyBtYWluSWR4IF0gKSApXHRtYWluSWR4ICsrO1xuXG4gICAgXHRcdFx0XHRuZXdTaGFwZXNbIG1haW5JZHggXSA9IHsgczogbmV3IFNoYXBlKCksIHA6IHRtcFBvaW50cyB9O1xuICAgIFx0XHRcdFx0bmV3U2hhcGVzWyBtYWluSWR4IF0ucy5jdXJ2ZXMgPSB0bXBQYXRoLmN1cnZlcztcblxuICAgIFx0XHRcdFx0aWYgKCBob2xlc0ZpcnN0IClcdG1haW5JZHggKys7XG4gICAgXHRcdFx0XHRuZXdTaGFwZUhvbGVzWyBtYWluSWR4IF0gPSBbXTtcblxuICAgIFx0XHRcdFx0Ly9jb25zb2xlLmxvZygnY3cnLCBpKTtcblxuICAgIFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdG5ld1NoYXBlSG9sZXNbIG1haW5JZHggXS5wdXNoKCB7IGg6IHRtcFBhdGgsIHA6IHRtcFBvaW50c1sgMCBdIH0gKTtcblxuICAgIFx0XHRcdFx0Ly9jb25zb2xlLmxvZygnY2N3JywgaSk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdC8vIG9ubHkgSG9sZXM/IC0+IHByb2JhYmx5IGFsbCBTaGFwZXMgd2l0aCB3cm9uZyBvcmllbnRhdGlvblxuICAgIFx0XHRpZiAoICEgbmV3U2hhcGVzWyAwIF0gKVx0cmV0dXJuXHR0b1NoYXBlc05vSG9sZXMoIHN1YlBhdGhzICk7XG5cblxuICAgIFx0XHRpZiAoIG5ld1NoYXBlcy5sZW5ndGggPiAxICkge1xuXG4gICAgXHRcdFx0dmFyIGFtYmlndW91cyA9IGZhbHNlO1xuICAgIFx0XHRcdHZhciB0b0NoYW5nZSA9IFtdO1xuXG4gICAgXHRcdFx0Zm9yICggdmFyIHNJZHggPSAwLCBzTGVuID0gbmV3U2hhcGVzLmxlbmd0aDsgc0lkeCA8IHNMZW47IHNJZHggKysgKSB7XG5cbiAgICBcdFx0XHRcdGJldHRlclNoYXBlSG9sZXNbIHNJZHggXSA9IFtdO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0Zm9yICggdmFyIHNJZHggPSAwLCBzTGVuID0gbmV3U2hhcGVzLmxlbmd0aDsgc0lkeCA8IHNMZW47IHNJZHggKysgKSB7XG5cbiAgICBcdFx0XHRcdHZhciBzaG8gPSBuZXdTaGFwZUhvbGVzWyBzSWR4IF07XG5cbiAgICBcdFx0XHRcdGZvciAoIHZhciBoSWR4ID0gMDsgaElkeCA8IHNoby5sZW5ndGg7IGhJZHggKysgKSB7XG5cbiAgICBcdFx0XHRcdFx0dmFyIGhvID0gc2hvWyBoSWR4IF07XG4gICAgXHRcdFx0XHRcdHZhciBob2xlX3VuYXNzaWduZWQgPSB0cnVlO1xuXG4gICAgXHRcdFx0XHRcdGZvciAoIHZhciBzMklkeCA9IDA7IHMySWR4IDwgbmV3U2hhcGVzLmxlbmd0aDsgczJJZHggKysgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHRpZiAoIGlzUG9pbnRJbnNpZGVQb2x5Z29uKCBoby5wLCBuZXdTaGFwZXNbIHMySWR4IF0ucCApICkge1xuXG4gICAgXHRcdFx0XHRcdFx0XHRpZiAoIHNJZHggIT09IHMySWR4IClcdHRvQ2hhbmdlLnB1c2goIHsgZnJvbXM6IHNJZHgsIHRvczogczJJZHgsIGhvbGU6IGhJZHggfSApO1xuICAgIFx0XHRcdFx0XHRcdFx0aWYgKCBob2xlX3VuYXNzaWduZWQgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHRcdFx0aG9sZV91bmFzc2lnbmVkID0gZmFsc2U7XG4gICAgXHRcdFx0XHRcdFx0XHRcdGJldHRlclNoYXBlSG9sZXNbIHMySWR4IF0ucHVzaCggaG8gKTtcblxuICAgIFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0XHRcdFx0XHRhbWJpZ3VvdXMgPSB0cnVlO1xuXG4gICAgXHRcdFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdFx0fVxuICAgIFx0XHRcdFx0XHRpZiAoIGhvbGVfdW5hc3NpZ25lZCApIHtcblxuICAgIFx0XHRcdFx0XHRcdGJldHRlclNoYXBlSG9sZXNbIHNJZHggXS5wdXNoKCBobyApO1xuXG4gICAgXHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0fVxuICAgIFx0XHRcdC8vIGNvbnNvbGUubG9nKFwiYW1iaWd1b3VzOiBcIiwgYW1iaWd1b3VzKTtcbiAgICBcdFx0XHRpZiAoIHRvQ2hhbmdlLmxlbmd0aCA+IDAgKSB7XG5cbiAgICBcdFx0XHRcdC8vIGNvbnNvbGUubG9nKFwidG8gY2hhbmdlOiBcIiwgdG9DaGFuZ2UpO1xuICAgIFx0XHRcdFx0aWYgKCAhIGFtYmlndW91cyApXHRuZXdTaGFwZUhvbGVzID0gYmV0dGVyU2hhcGVIb2xlcztcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdFx0dmFyIHRtcEhvbGVzO1xuXG4gICAgXHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBuZXdTaGFwZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICBcdFx0XHR0bXBTaGFwZSA9IG5ld1NoYXBlc1sgaSBdLnM7XG4gICAgXHRcdFx0c2hhcGVzLnB1c2goIHRtcFNoYXBlICk7XG4gICAgXHRcdFx0dG1wSG9sZXMgPSBuZXdTaGFwZUhvbGVzWyBpIF07XG5cbiAgICBcdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gdG1wSG9sZXMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XG5cbiAgICBcdFx0XHRcdHRtcFNoYXBlLmhvbGVzLnB1c2goIHRtcEhvbGVzWyBqIF0uaCApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHQvL2NvbnNvbGUubG9nKFwic2hhcGVcIiwgc2hhcGVzKTtcblxuICAgIFx0XHRyZXR1cm4gc2hhcGVzO1xuXG4gICAgXHR9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xuICAgICAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBGb250KCBkYXRhICkge1xuXG4gICAgXHR0aGlzLmRhdGEgPSBkYXRhO1xuXG4gICAgfVxuXG4gICAgT2JqZWN0LmFzc2lnbiggRm9udC5wcm90b3R5cGUsIHtcblxuICAgIFx0aXNGb250OiB0cnVlLFxuXG4gICAgXHRnZW5lcmF0ZVNoYXBlczogZnVuY3Rpb24gKCB0ZXh0LCBzaXplLCBkaXZpc2lvbnMgKSB7XG5cbiAgICBcdFx0ZnVuY3Rpb24gY3JlYXRlUGF0aHMoIHRleHQgKSB7XG5cbiAgICBcdFx0XHR2YXIgY2hhcnMgPSBTdHJpbmcoIHRleHQgKS5zcGxpdCggJycgKTtcbiAgICBcdFx0XHR2YXIgc2NhbGUgPSBzaXplIC8gZGF0YS5yZXNvbHV0aW9uO1xuICAgIFx0XHRcdHZhciBvZmZzZXQgPSAwO1xuXG4gICAgXHRcdFx0dmFyIHBhdGhzID0gW107XG5cbiAgICBcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBjaGFycy5sZW5ndGg7IGkgKysgKSB7XG5cbiAgICBcdFx0XHRcdHZhciByZXQgPSBjcmVhdGVQYXRoKCBjaGFyc1sgaSBdLCBzY2FsZSwgb2Zmc2V0ICk7XG4gICAgXHRcdFx0XHRvZmZzZXQgKz0gcmV0Lm9mZnNldDtcblxuICAgIFx0XHRcdFx0cGF0aHMucHVzaCggcmV0LnBhdGggKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdHJldHVybiBwYXRocztcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0ZnVuY3Rpb24gY3JlYXRlUGF0aCggYywgc2NhbGUsIG9mZnNldCApIHtcblxuICAgIFx0XHRcdHZhciBnbHlwaCA9IGRhdGEuZ2x5cGhzWyBjIF0gfHwgZGF0YS5nbHlwaHNbICc/JyBdO1xuXG4gICAgXHRcdFx0aWYgKCAhIGdseXBoICkgcmV0dXJuO1xuXG4gICAgXHRcdFx0dmFyIHBhdGggPSBuZXcgU2hhcGVQYXRoKCk7XG5cbiAgICBcdFx0XHR2YXIgcHRzID0gW10sIGIyID0gZXhwb3J0cy5TaGFwZVV0aWxzLmIyLCBiMyA9IGV4cG9ydHMuU2hhcGVVdGlscy5iMztcbiAgICBcdFx0XHR2YXIgeCwgeSwgY3B4LCBjcHksIGNweDAsIGNweTAsIGNweDEsIGNweTEsIGNweDIsIGNweTIsIGxhc3RlO1xuXG4gICAgXHRcdFx0aWYgKCBnbHlwaC5vICkge1xuXG4gICAgXHRcdFx0XHR2YXIgb3V0bGluZSA9IGdseXBoLl9jYWNoZWRPdXRsaW5lIHx8ICggZ2x5cGguX2NhY2hlZE91dGxpbmUgPSBnbHlwaC5vLnNwbGl0KCAnICcgKSApO1xuXG4gICAgXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBvdXRsaW5lLmxlbmd0aDsgaSA8IGw7ICkge1xuXG4gICAgXHRcdFx0XHRcdHZhciBhY3Rpb24gPSBvdXRsaW5lWyBpICsrIF07XG5cbiAgICBcdFx0XHRcdFx0c3dpdGNoICggYWN0aW9uICkge1xuXG4gICAgXHRcdFx0XHRcdFx0Y2FzZSAnbSc6IC8vIG1vdmVUb1xuXG4gICAgXHRcdFx0XHRcdFx0XHR4ID0gb3V0bGluZVsgaSArKyBdICogc2NhbGUgKyBvZmZzZXQ7XG4gICAgXHRcdFx0XHRcdFx0XHR5ID0gb3V0bGluZVsgaSArKyBdICogc2NhbGU7XG5cbiAgICBcdFx0XHRcdFx0XHRcdHBhdGgubW92ZVRvKCB4LCB5ICk7XG5cbiAgICBcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG4gICAgXHRcdFx0XHRcdFx0Y2FzZSAnbCc6IC8vIGxpbmVUb1xuXG4gICAgXHRcdFx0XHRcdFx0XHR4ID0gb3V0bGluZVsgaSArKyBdICogc2NhbGUgKyBvZmZzZXQ7XG4gICAgXHRcdFx0XHRcdFx0XHR5ID0gb3V0bGluZVsgaSArKyBdICogc2NhbGU7XG5cbiAgICBcdFx0XHRcdFx0XHRcdHBhdGgubGluZVRvKCB4LCB5ICk7XG5cbiAgICBcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG4gICAgXHRcdFx0XHRcdFx0Y2FzZSAncSc6IC8vIHF1YWRyYXRpY0N1cnZlVG9cblxuICAgIFx0XHRcdFx0XHRcdFx0Y3B4ICA9IG91dGxpbmVbIGkgKysgXSAqIHNjYWxlICsgb2Zmc2V0O1xuICAgIFx0XHRcdFx0XHRcdFx0Y3B5ICA9IG91dGxpbmVbIGkgKysgXSAqIHNjYWxlO1xuICAgIFx0XHRcdFx0XHRcdFx0Y3B4MSA9IG91dGxpbmVbIGkgKysgXSAqIHNjYWxlICsgb2Zmc2V0O1xuICAgIFx0XHRcdFx0XHRcdFx0Y3B5MSA9IG91dGxpbmVbIGkgKysgXSAqIHNjYWxlO1xuXG4gICAgXHRcdFx0XHRcdFx0XHRwYXRoLnF1YWRyYXRpY0N1cnZlVG8oIGNweDEsIGNweTEsIGNweCwgY3B5ICk7XG5cbiAgICBcdFx0XHRcdFx0XHRcdGxhc3RlID0gcHRzWyBwdHMubGVuZ3RoIC0gMSBdO1xuXG4gICAgXHRcdFx0XHRcdFx0XHRpZiAoIGxhc3RlICkge1xuXG4gICAgXHRcdFx0XHRcdFx0XHRcdGNweDAgPSBsYXN0ZS54O1xuICAgIFx0XHRcdFx0XHRcdFx0XHRjcHkwID0gbGFzdGUueTtcblxuICAgIFx0XHRcdFx0XHRcdFx0XHRmb3IgKCB2YXIgaTIgPSAxOyBpMiA8PSBkaXZpc2lvbnM7IGkyICsrICkge1xuXG4gICAgXHRcdFx0XHRcdFx0XHRcdFx0dmFyIHQgPSBpMiAvIGRpdmlzaW9ucztcbiAgICBcdFx0XHRcdFx0XHRcdFx0XHRiMiggdCwgY3B4MCwgY3B4MSwgY3B4ICk7XG4gICAgXHRcdFx0XHRcdFx0XHRcdFx0YjIoIHQsIGNweTAsIGNweTEsIGNweSApO1xuXG4gICAgXHRcdFx0XHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHRcdFx0XHRicmVhaztcblxuICAgIFx0XHRcdFx0XHRcdGNhc2UgJ2InOiAvLyBiZXppZXJDdXJ2ZVRvXG5cbiAgICBcdFx0XHRcdFx0XHRcdGNweCAgPSBvdXRsaW5lWyBpICsrIF0gKiBzY2FsZSArIG9mZnNldDtcbiAgICBcdFx0XHRcdFx0XHRcdGNweSAgPSBvdXRsaW5lWyBpICsrIF0gKiBzY2FsZTtcbiAgICBcdFx0XHRcdFx0XHRcdGNweDEgPSBvdXRsaW5lWyBpICsrIF0gKiBzY2FsZSArIG9mZnNldDtcbiAgICBcdFx0XHRcdFx0XHRcdGNweTEgPSBvdXRsaW5lWyBpICsrIF0gKiBzY2FsZTtcbiAgICBcdFx0XHRcdFx0XHRcdGNweDIgPSBvdXRsaW5lWyBpICsrIF0gKiBzY2FsZSArIG9mZnNldDtcbiAgICBcdFx0XHRcdFx0XHRcdGNweTIgPSBvdXRsaW5lWyBpICsrIF0gKiBzY2FsZTtcblxuICAgIFx0XHRcdFx0XHRcdFx0cGF0aC5iZXppZXJDdXJ2ZVRvKCBjcHgxLCBjcHkxLCBjcHgyLCBjcHkyLCBjcHgsIGNweSApO1xuXG4gICAgXHRcdFx0XHRcdFx0XHRsYXN0ZSA9IHB0c1sgcHRzLmxlbmd0aCAtIDEgXTtcblxuICAgIFx0XHRcdFx0XHRcdFx0aWYgKCBsYXN0ZSApIHtcblxuICAgIFx0XHRcdFx0XHRcdFx0XHRjcHgwID0gbGFzdGUueDtcbiAgICBcdFx0XHRcdFx0XHRcdFx0Y3B5MCA9IGxhc3RlLnk7XG5cbiAgICBcdFx0XHRcdFx0XHRcdFx0Zm9yICggdmFyIGkyID0gMTsgaTIgPD0gZGl2aXNpb25zOyBpMiArKyApIHtcblxuICAgIFx0XHRcdFx0XHRcdFx0XHRcdHZhciB0ID0gaTIgLyBkaXZpc2lvbnM7XG4gICAgXHRcdFx0XHRcdFx0XHRcdFx0YjMoIHQsIGNweDAsIGNweDEsIGNweDIsIGNweCApO1xuICAgIFx0XHRcdFx0XHRcdFx0XHRcdGIzKCB0LCBjcHkwLCBjcHkxLCBjcHkyLCBjcHkgKTtcblxuICAgIFx0XHRcdFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cbiAgICBcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRyZXR1cm4geyBvZmZzZXQ6IGdseXBoLmhhICogc2NhbGUsIHBhdGg6IHBhdGggfTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0Ly9cblxuICAgIFx0XHRpZiAoIHNpemUgPT09IHVuZGVmaW5lZCApIHNpemUgPSAxMDA7XG4gICAgXHRcdGlmICggZGl2aXNpb25zID09PSB1bmRlZmluZWQgKSBkaXZpc2lvbnMgPSA0O1xuXG4gICAgXHRcdHZhciBkYXRhID0gdGhpcy5kYXRhO1xuXG4gICAgXHRcdHZhciBwYXRocyA9IGNyZWF0ZVBhdGhzKCB0ZXh0ICk7XG4gICAgXHRcdHZhciBzaGFwZXMgPSBbXTtcblxuICAgIFx0XHRmb3IgKCB2YXIgcCA9IDAsIHBsID0gcGF0aHMubGVuZ3RoOyBwIDwgcGw7IHAgKysgKSB7XG5cbiAgICBcdFx0XHRBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseSggc2hhcGVzLCBwYXRoc1sgcCBdLnRvU2hhcGVzKCkgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIHNoYXBlcztcblxuICAgIFx0fVxuXG4gICAgfSApO1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIEZvbnRMb2FkZXIoIG1hbmFnZXIgKSB7XG5cbiAgICBcdHRoaXMubWFuYWdlciA9ICggbWFuYWdlciAhPT0gdW5kZWZpbmVkICkgPyBtYW5hZ2VyIDogZXhwb3J0cy5EZWZhdWx0TG9hZGluZ01hbmFnZXI7XG5cbiAgICB9XG5cbiAgICBPYmplY3QuYXNzaWduKCBGb250TG9hZGVyLnByb3RvdHlwZSwge1xuXG4gICAgXHRsb2FkOiBmdW5jdGlvbiAoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG4gICAgXHRcdHZhciBzY29wZSA9IHRoaXM7XG5cbiAgICBcdFx0dmFyIGxvYWRlciA9IG5ldyBYSFJMb2FkZXIoIHRoaXMubWFuYWdlciApO1xuICAgIFx0XHRsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIHRleHQgKSB7XG5cbiAgICBcdFx0XHR2YXIganNvbjtcblxuICAgIFx0XHRcdHRyeSB7XG5cbiAgICBcdFx0XHRcdGpzb24gPSBKU09OLnBhcnNlKCB0ZXh0ICk7XG5cbiAgICBcdFx0XHR9IGNhdGNoICggZSApIHtcblxuICAgIFx0XHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuRm9udExvYWRlcjogdHlwZWZhY2UuanMgc3VwcG9ydCBpcyBiZWluZyBkZXByZWNhdGVkLiBVc2UgdHlwZWZhY2UuanNvbiBpbnN0ZWFkLicgKTtcbiAgICBcdFx0XHRcdGpzb24gPSBKU09OLnBhcnNlKCB0ZXh0LnN1YnN0cmluZyggNjUsIHRleHQubGVuZ3RoIC0gMiApICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHR2YXIgZm9udCA9IHNjb3BlLnBhcnNlKCBqc29uICk7XG5cbiAgICBcdFx0XHRpZiAoIG9uTG9hZCApIG9uTG9hZCggZm9udCApO1xuXG4gICAgXHRcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcblxuICAgIFx0fSxcblxuICAgIFx0cGFyc2U6IGZ1bmN0aW9uICgganNvbiApIHtcblxuICAgIFx0XHRyZXR1cm4gbmV3IEZvbnQoIGpzb24gKTtcblxuICAgIFx0fVxuXG4gICAgfSApO1xuXG4gICAgdmFyIGNvbnRleHQ7XG5cbiAgICBmdW5jdGlvbiBnZXRBdWRpb0NvbnRleHQoKSB7XG5cbiAgICBcdGlmICggY29udGV4dCA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdGNvbnRleHQgPSBuZXcgKCB3aW5kb3cuQXVkaW9Db250ZXh0IHx8IHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHQgKSgpO1xuXG4gICAgXHR9XG5cbiAgICBcdHJldHVybiBjb250ZXh0O1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBSZWVjZSBBYXJvbiBMZWNyaXZhaW4gLyBodHRwOi8vcmVlY2Vub3Rlcy5jb20vXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBBdWRpb0xvYWRlciggbWFuYWdlciApIHtcblxuICAgIFx0dGhpcy5tYW5hZ2VyID0gKCBtYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IG1hbmFnZXIgOiBleHBvcnRzLkRlZmF1bHRMb2FkaW5nTWFuYWdlcjtcblxuICAgIH1cblxuICAgIE9iamVjdC5hc3NpZ24oIEF1ZGlvTG9hZGVyLnByb3RvdHlwZSwge1xuXG4gICAgXHRsb2FkOiBmdW5jdGlvbiAoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG4gICAgXHRcdHZhciBsb2FkZXIgPSBuZXcgWEhSTG9hZGVyKCB0aGlzLm1hbmFnZXIgKTtcbiAgICBcdFx0bG9hZGVyLnNldFJlc3BvbnNlVHlwZSggJ2FycmF5YnVmZmVyJyApO1xuICAgIFx0XHRsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIGJ1ZmZlciApIHtcblxuICAgIFx0XHRcdHZhciBjb250ZXh0ID0gZ2V0QXVkaW9Db250ZXh0KCk7XG5cbiAgICBcdFx0XHRjb250ZXh0LmRlY29kZUF1ZGlvRGF0YSggYnVmZmVyLCBmdW5jdGlvbiAoIGF1ZGlvQnVmZmVyICkge1xuXG4gICAgXHRcdFx0XHRvbkxvYWQoIGF1ZGlvQnVmZmVyICk7XG5cbiAgICBcdFx0XHR9ICk7XG5cbiAgICBcdFx0fSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xuXG4gICAgXHR9XG5cbiAgICB9ICk7XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gU3RlcmVvQ2FtZXJhKCkge1xuXG4gICAgXHR0aGlzLnR5cGUgPSAnU3RlcmVvQ2FtZXJhJztcblxuICAgIFx0dGhpcy5hc3BlY3QgPSAxO1xuXG4gICAgXHR0aGlzLmV5ZVNlcCA9IDAuMDY0O1xuXG4gICAgXHR0aGlzLmNhbWVyYUwgPSBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoKTtcbiAgICBcdHRoaXMuY2FtZXJhTC5sYXllcnMuZW5hYmxlKCAxICk7XG4gICAgXHR0aGlzLmNhbWVyYUwubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXG4gICAgXHR0aGlzLmNhbWVyYVIgPSBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoKTtcbiAgICBcdHRoaXMuY2FtZXJhUi5sYXllcnMuZW5hYmxlKCAyICk7XG4gICAgXHR0aGlzLmNhbWVyYVIubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXG4gICAgfVxuXG4gICAgT2JqZWN0LmFzc2lnbiggU3RlcmVvQ2FtZXJhLnByb3RvdHlwZSwge1xuXG4gICAgXHR1cGRhdGU6ICggZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHZhciBpbnN0YW5jZSwgZm9jdXMsIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIsIHpvb207XG5cbiAgICBcdFx0dmFyIGV5ZVJpZ2h0ID0gbmV3IE1hdHJpeDQoKTtcbiAgICBcdFx0dmFyIGV5ZUxlZnQgPSBuZXcgTWF0cml4NCgpO1xuXG4gICAgXHRcdHJldHVybiBmdW5jdGlvbiB1cGRhdGUoIGNhbWVyYSApIHtcblxuICAgIFx0XHRcdHZhciBuZWVkc1VwZGF0ZSA9IGluc3RhbmNlICE9PSB0aGlzIHx8IGZvY3VzICE9PSBjYW1lcmEuZm9jdXMgfHwgZm92ICE9PSBjYW1lcmEuZm92IHx8XG4gICAgXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0YXNwZWN0ICE9PSBjYW1lcmEuYXNwZWN0ICogdGhpcy5hc3BlY3QgfHwgbmVhciAhPT0gY2FtZXJhLm5lYXIgfHxcbiAgICBcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRmYXIgIT09IGNhbWVyYS5mYXIgfHwgem9vbSAhPT0gY2FtZXJhLnpvb207XG5cbiAgICBcdFx0XHRpZiAoIG5lZWRzVXBkYXRlICkge1xuXG4gICAgXHRcdFx0XHRpbnN0YW5jZSA9IHRoaXM7XG4gICAgXHRcdFx0XHRmb2N1cyA9IGNhbWVyYS5mb2N1cztcbiAgICBcdFx0XHRcdGZvdiA9IGNhbWVyYS5mb3Y7XG4gICAgXHRcdFx0XHRhc3BlY3QgPSBjYW1lcmEuYXNwZWN0ICogdGhpcy5hc3BlY3Q7XG4gICAgXHRcdFx0XHRuZWFyID0gY2FtZXJhLm5lYXI7XG4gICAgXHRcdFx0XHRmYXIgPSBjYW1lcmEuZmFyO1xuICAgIFx0XHRcdFx0em9vbSA9IGNhbWVyYS56b29tO1xuXG4gICAgXHRcdFx0XHQvLyBPZmYtYXhpcyBzdGVyZW9zY29waWMgZWZmZWN0IGJhc2VkIG9uXG4gICAgXHRcdFx0XHQvLyBodHRwOi8vcGF1bGJvdXJrZS5uZXQvc3RlcmVvZ3JhcGhpY3Mvc3RlcmVvcmVuZGVyL1xuXG4gICAgXHRcdFx0XHR2YXIgcHJvamVjdGlvbk1hdHJpeCA9IGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4LmNsb25lKCk7XG4gICAgXHRcdFx0XHR2YXIgZXllU2VwID0gdGhpcy5leWVTZXAgLyAyO1xuICAgIFx0XHRcdFx0dmFyIGV5ZVNlcE9uUHJvamVjdGlvbiA9IGV5ZVNlcCAqIG5lYXIgLyBmb2N1cztcbiAgICBcdFx0XHRcdHZhciB5bWF4ID0gKCBuZWFyICogTWF0aC50YW4oIGV4cG9ydHMuTWF0aC5ERUcyUkFEICogZm92ICogMC41ICkgKSAvIHpvb207XG4gICAgXHRcdFx0XHR2YXIgeG1pbiwgeG1heDtcblxuICAgIFx0XHRcdFx0Ly8gdHJhbnNsYXRlIHhPZmZzZXRcblxuICAgIFx0XHRcdFx0ZXllTGVmdC5lbGVtZW50c1sgMTIgXSA9IC0gZXllU2VwO1xuICAgIFx0XHRcdFx0ZXllUmlnaHQuZWxlbWVudHNbIDEyIF0gPSBleWVTZXA7XG5cbiAgICBcdFx0XHRcdC8vIGZvciBsZWZ0IGV5ZVxuXG4gICAgXHRcdFx0XHR4bWluID0gLSB5bWF4ICogYXNwZWN0ICsgZXllU2VwT25Qcm9qZWN0aW9uO1xuICAgIFx0XHRcdFx0eG1heCA9IHltYXggKiBhc3BlY3QgKyBleWVTZXBPblByb2plY3Rpb247XG5cbiAgICBcdFx0XHRcdHByb2plY3Rpb25NYXRyaXguZWxlbWVudHNbIDAgXSA9IDIgKiBuZWFyIC8gKCB4bWF4IC0geG1pbiApO1xuICAgIFx0XHRcdFx0cHJvamVjdGlvbk1hdHJpeC5lbGVtZW50c1sgOCBdID0gKCB4bWF4ICsgeG1pbiApIC8gKCB4bWF4IC0geG1pbiApO1xuXG4gICAgXHRcdFx0XHR0aGlzLmNhbWVyYUwucHJvamVjdGlvbk1hdHJpeC5jb3B5KCBwcm9qZWN0aW9uTWF0cml4ICk7XG5cbiAgICBcdFx0XHRcdC8vIGZvciByaWdodCBleWVcblxuICAgIFx0XHRcdFx0eG1pbiA9IC0geW1heCAqIGFzcGVjdCAtIGV5ZVNlcE9uUHJvamVjdGlvbjtcbiAgICBcdFx0XHRcdHhtYXggPSB5bWF4ICogYXNwZWN0IC0gZXllU2VwT25Qcm9qZWN0aW9uO1xuXG4gICAgXHRcdFx0XHRwcm9qZWN0aW9uTWF0cml4LmVsZW1lbnRzWyAwIF0gPSAyICogbmVhciAvICggeG1heCAtIHhtaW4gKTtcbiAgICBcdFx0XHRcdHByb2plY3Rpb25NYXRyaXguZWxlbWVudHNbIDggXSA9ICggeG1heCArIHhtaW4gKSAvICggeG1heCAtIHhtaW4gKTtcblxuICAgIFx0XHRcdFx0dGhpcy5jYW1lcmFSLnByb2plY3Rpb25NYXRyaXguY29weSggcHJvamVjdGlvbk1hdHJpeCApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0dGhpcy5jYW1lcmFMLm1hdHJpeFdvcmxkLmNvcHkoIGNhbWVyYS5tYXRyaXhXb3JsZCApLm11bHRpcGx5KCBleWVMZWZ0ICk7XG4gICAgXHRcdFx0dGhpcy5jYW1lcmFSLm1hdHJpeFdvcmxkLmNvcHkoIGNhbWVyYS5tYXRyaXhXb3JsZCApLm11bHRpcGx5KCBleWVSaWdodCApO1xuXG4gICAgXHRcdH07XG5cbiAgICBcdH0gKSgpXG5cbiAgICB9ICk7XG5cbiAgICAvKipcbiAgICAgKiBDYW1lcmEgZm9yIHJlbmRlcmluZyBjdWJlIG1hcHNcbiAgICAgKlx0LSByZW5kZXJzIHNjZW5lIGludG8gYXhpcy1hbGlnbmVkIGN1YmVcbiAgICAgKlxuICAgICAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBDdWJlQ2FtZXJhKCBuZWFyLCBmYXIsIGN1YmVSZXNvbHV0aW9uICkge1xuXG4gICAgXHRPYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cbiAgICBcdHRoaXMudHlwZSA9ICdDdWJlQ2FtZXJhJztcblxuICAgIFx0dmFyIGZvdiA9IDkwLCBhc3BlY3QgPSAxO1xuXG4gICAgXHR2YXIgY2FtZXJhUFggPSBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIgKTtcbiAgICBcdGNhbWVyYVBYLnVwLnNldCggMCwgLSAxLCAwICk7XG4gICAgXHRjYW1lcmFQWC5sb29rQXQoIG5ldyBWZWN0b3IzKCAxLCAwLCAwICkgKTtcbiAgICBcdHRoaXMuYWRkKCBjYW1lcmFQWCApO1xuXG4gICAgXHR2YXIgY2FtZXJhTlggPSBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIgKTtcbiAgICBcdGNhbWVyYU5YLnVwLnNldCggMCwgLSAxLCAwICk7XG4gICAgXHRjYW1lcmFOWC5sb29rQXQoIG5ldyBWZWN0b3IzKCAtIDEsIDAsIDAgKSApO1xuICAgIFx0dGhpcy5hZGQoIGNhbWVyYU5YICk7XG5cbiAgICBcdHZhciBjYW1lcmFQWSA9IG5ldyBQZXJzcGVjdGl2ZUNhbWVyYSggZm92LCBhc3BlY3QsIG5lYXIsIGZhciApO1xuICAgIFx0Y2FtZXJhUFkudXAuc2V0KCAwLCAwLCAxICk7XG4gICAgXHRjYW1lcmFQWS5sb29rQXQoIG5ldyBWZWN0b3IzKCAwLCAxLCAwICkgKTtcbiAgICBcdHRoaXMuYWRkKCBjYW1lcmFQWSApO1xuXG4gICAgXHR2YXIgY2FtZXJhTlkgPSBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIgKTtcbiAgICBcdGNhbWVyYU5ZLnVwLnNldCggMCwgMCwgLSAxICk7XG4gICAgXHRjYW1lcmFOWS5sb29rQXQoIG5ldyBWZWN0b3IzKCAwLCAtIDEsIDAgKSApO1xuICAgIFx0dGhpcy5hZGQoIGNhbWVyYU5ZICk7XG5cbiAgICBcdHZhciBjYW1lcmFQWiA9IG5ldyBQZXJzcGVjdGl2ZUNhbWVyYSggZm92LCBhc3BlY3QsIG5lYXIsIGZhciApO1xuICAgIFx0Y2FtZXJhUFoudXAuc2V0KCAwLCAtIDEsIDAgKTtcbiAgICBcdGNhbWVyYVBaLmxvb2tBdCggbmV3IFZlY3RvcjMoIDAsIDAsIDEgKSApO1xuICAgIFx0dGhpcy5hZGQoIGNhbWVyYVBaICk7XG5cbiAgICBcdHZhciBjYW1lcmFOWiA9IG5ldyBQZXJzcGVjdGl2ZUNhbWVyYSggZm92LCBhc3BlY3QsIG5lYXIsIGZhciApO1xuICAgIFx0Y2FtZXJhTloudXAuc2V0KCAwLCAtIDEsIDAgKTtcbiAgICBcdGNhbWVyYU5aLmxvb2tBdCggbmV3IFZlY3RvcjMoIDAsIDAsIC0gMSApICk7XG4gICAgXHR0aGlzLmFkZCggY2FtZXJhTlogKTtcblxuICAgIFx0dmFyIG9wdGlvbnMgPSB7IGZvcm1hdDogUkdCRm9ybWF0LCBtYWdGaWx0ZXI6IExpbmVhckZpbHRlciwgbWluRmlsdGVyOiBMaW5lYXJGaWx0ZXIgfTtcblxuICAgIFx0dGhpcy5yZW5kZXJUYXJnZXQgPSBuZXcgV2ViR0xSZW5kZXJUYXJnZXRDdWJlKCBjdWJlUmVzb2x1dGlvbiwgY3ViZVJlc29sdXRpb24sIG9wdGlvbnMgKTtcblxuICAgIFx0dGhpcy51cGRhdGVDdWJlTWFwID0gZnVuY3Rpb24gKCByZW5kZXJlciwgc2NlbmUgKSB7XG5cbiAgICBcdFx0aWYgKCB0aGlzLnBhcmVudCA9PT0gbnVsbCApIHRoaXMudXBkYXRlTWF0cml4V29ybGQoKTtcblxuICAgIFx0XHR2YXIgcmVuZGVyVGFyZ2V0ID0gdGhpcy5yZW5kZXJUYXJnZXQ7XG4gICAgXHRcdHZhciBnZW5lcmF0ZU1pcG1hcHMgPSByZW5kZXJUYXJnZXQudGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHM7XG5cbiAgICBcdFx0cmVuZGVyVGFyZ2V0LnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XG5cbiAgICBcdFx0cmVuZGVyVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlID0gMDtcbiAgICBcdFx0cmVuZGVyZXIucmVuZGVyKCBzY2VuZSwgY2FtZXJhUFgsIHJlbmRlclRhcmdldCApO1xuXG4gICAgXHRcdHJlbmRlclRhcmdldC5hY3RpdmVDdWJlRmFjZSA9IDE7XG4gICAgXHRcdHJlbmRlcmVyLnJlbmRlciggc2NlbmUsIGNhbWVyYU5YLCByZW5kZXJUYXJnZXQgKTtcblxuICAgIFx0XHRyZW5kZXJUYXJnZXQuYWN0aXZlQ3ViZUZhY2UgPSAyO1xuICAgIFx0XHRyZW5kZXJlci5yZW5kZXIoIHNjZW5lLCBjYW1lcmFQWSwgcmVuZGVyVGFyZ2V0ICk7XG5cbiAgICBcdFx0cmVuZGVyVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlID0gMztcbiAgICBcdFx0cmVuZGVyZXIucmVuZGVyKCBzY2VuZSwgY2FtZXJhTlksIHJlbmRlclRhcmdldCApO1xuXG4gICAgXHRcdHJlbmRlclRhcmdldC5hY3RpdmVDdWJlRmFjZSA9IDQ7XG4gICAgXHRcdHJlbmRlcmVyLnJlbmRlciggc2NlbmUsIGNhbWVyYVBaLCByZW5kZXJUYXJnZXQgKTtcblxuICAgIFx0XHRyZW5kZXJUYXJnZXQudGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSBnZW5lcmF0ZU1pcG1hcHM7XG5cbiAgICBcdFx0cmVuZGVyVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlID0gNTtcbiAgICBcdFx0cmVuZGVyZXIucmVuZGVyKCBzY2VuZSwgY2FtZXJhTlosIHJlbmRlclRhcmdldCApO1xuXG4gICAgXHRcdHJlbmRlcmVyLnNldFJlbmRlclRhcmdldCggbnVsbCApO1xuXG4gICAgXHR9O1xuXG4gICAgfVxuXG4gICAgQ3ViZUNhbWVyYS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBPYmplY3QzRC5wcm90b3R5cGUgKTtcbiAgICBDdWJlQ2FtZXJhLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEN1YmVDYW1lcmE7XG5cbiAgICBmdW5jdGlvbiBBdWRpb0xpc3RlbmVyKCkge1xuXG4gICAgXHRPYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cbiAgICBcdHRoaXMudHlwZSA9ICdBdWRpb0xpc3RlbmVyJztcblxuICAgIFx0dGhpcy5jb250ZXh0ID0gZ2V0QXVkaW9Db250ZXh0KCk7XG5cbiAgICBcdHRoaXMuZ2FpbiA9IHRoaXMuY29udGV4dC5jcmVhdGVHYWluKCk7XG4gICAgXHR0aGlzLmdhaW4uY29ubmVjdCggdGhpcy5jb250ZXh0LmRlc3RpbmF0aW9uICk7XG5cbiAgICBcdHRoaXMuZmlsdGVyID0gbnVsbDtcblxuICAgIH1cblxuICAgIEF1ZGlvTGlzdGVuZXIucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggT2JqZWN0M0QucHJvdG90eXBlICksIHtcblxuICAgIFx0Y29uc3RydWN0b3I6IEF1ZGlvTGlzdGVuZXIsXG5cbiAgICBcdGdldElucHV0OiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMuZ2FpbjtcblxuICAgIFx0fSxcblxuICAgIFx0cmVtb3ZlRmlsdGVyOiBmdW5jdGlvbiAoICkge1xuXG4gICAgXHRcdGlmICggdGhpcy5maWx0ZXIgIT09IG51bGwgKSB7XG5cbiAgICBcdFx0XHR0aGlzLmdhaW4uZGlzY29ubmVjdCggdGhpcy5maWx0ZXIgKTtcbiAgICBcdFx0XHR0aGlzLmZpbHRlci5kaXNjb25uZWN0KCB0aGlzLmNvbnRleHQuZGVzdGluYXRpb24gKTtcbiAgICBcdFx0XHR0aGlzLmdhaW4uY29ubmVjdCggdGhpcy5jb250ZXh0LmRlc3RpbmF0aW9uICk7XG4gICAgXHRcdFx0dGhpcy5maWx0ZXIgPSBudWxsO1xuXG4gICAgXHRcdH1cblxuICAgIFx0fSxcblxuICAgIFx0Z2V0RmlsdGVyOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMuZmlsdGVyO1xuXG4gICAgXHR9LFxuXG4gICAgXHRzZXRGaWx0ZXI6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cbiAgICBcdFx0aWYgKCB0aGlzLmZpbHRlciAhPT0gbnVsbCApIHtcblxuICAgIFx0XHRcdHRoaXMuZ2Fpbi5kaXNjb25uZWN0KCB0aGlzLmZpbHRlciApO1xuICAgIFx0XHRcdHRoaXMuZmlsdGVyLmRpc2Nvbm5lY3QoIHRoaXMuY29udGV4dC5kZXN0aW5hdGlvbiApO1xuXG4gICAgXHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHR0aGlzLmdhaW4uZGlzY29ubmVjdCggdGhpcy5jb250ZXh0LmRlc3RpbmF0aW9uICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHRoaXMuZmlsdGVyID0gdmFsdWU7XG4gICAgXHRcdHRoaXMuZ2Fpbi5jb25uZWN0KCB0aGlzLmZpbHRlciApO1xuICAgIFx0XHR0aGlzLmZpbHRlci5jb25uZWN0KCB0aGlzLmNvbnRleHQuZGVzdGluYXRpb24gKTtcblxuICAgIFx0fSxcblxuICAgIFx0Z2V0TWFzdGVyVm9sdW1lOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMuZ2Fpbi5nYWluLnZhbHVlO1xuXG4gICAgXHR9LFxuXG4gICAgXHRzZXRNYXN0ZXJWb2x1bWU6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cbiAgICBcdFx0dGhpcy5nYWluLmdhaW4udmFsdWUgPSB2YWx1ZTtcblxuICAgIFx0fSxcblxuICAgIFx0dXBkYXRlTWF0cml4V29ybGQ6ICggZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHZhciBwb3NpdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG4gICAgXHRcdHZhciBxdWF0ZXJuaW9uID0gbmV3IFF1YXRlcm5pb24oKTtcbiAgICBcdFx0dmFyIHNjYWxlID0gbmV3IFZlY3RvcjMoKTtcblxuICAgIFx0XHR2YXIgb3JpZW50YXRpb24gPSBuZXcgVmVjdG9yMygpO1xuXG4gICAgXHRcdHJldHVybiBmdW5jdGlvbiB1cGRhdGVNYXRyaXhXb3JsZCggZm9yY2UgKSB7XG5cbiAgICBcdFx0XHRPYmplY3QzRC5wcm90b3R5cGUudXBkYXRlTWF0cml4V29ybGQuY2FsbCggdGhpcywgZm9yY2UgKTtcblxuICAgIFx0XHRcdHZhciBsaXN0ZW5lciA9IHRoaXMuY29udGV4dC5saXN0ZW5lcjtcbiAgICBcdFx0XHR2YXIgdXAgPSB0aGlzLnVwO1xuXG4gICAgXHRcdFx0dGhpcy5tYXRyaXhXb3JsZC5kZWNvbXBvc2UoIHBvc2l0aW9uLCBxdWF0ZXJuaW9uLCBzY2FsZSApO1xuXG4gICAgXHRcdFx0b3JpZW50YXRpb24uc2V0KCAwLCAwLCAtIDEgKS5hcHBseVF1YXRlcm5pb24oIHF1YXRlcm5pb24gKTtcblxuICAgIFx0XHRcdGxpc3RlbmVyLnNldFBvc2l0aW9uKCBwb3NpdGlvbi54LCBwb3NpdGlvbi55LCBwb3NpdGlvbi56ICk7XG4gICAgXHRcdFx0bGlzdGVuZXIuc2V0T3JpZW50YXRpb24oIG9yaWVudGF0aW9uLngsIG9yaWVudGF0aW9uLnksIG9yaWVudGF0aW9uLnosIHVwLngsIHVwLnksIHVwLnogKTtcblxuICAgIFx0XHR9O1xuXG4gICAgXHR9ICkoKVxuXG4gICAgfSApO1xuXG4gICAgZnVuY3Rpb24gQXVkaW8oIGxpc3RlbmVyICkge1xuXG4gICAgXHRPYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cbiAgICBcdHRoaXMudHlwZSA9ICdBdWRpbyc7XG5cbiAgICBcdHRoaXMuY29udGV4dCA9IGxpc3RlbmVyLmNvbnRleHQ7XG4gICAgXHR0aGlzLnNvdXJjZSA9IHRoaXMuY29udGV4dC5jcmVhdGVCdWZmZXJTb3VyY2UoKTtcbiAgICBcdHRoaXMuc291cmNlLm9uZW5kZWQgPSB0aGlzLm9uRW5kZWQuYmluZCggdGhpcyApO1xuXG4gICAgXHR0aGlzLmdhaW4gPSB0aGlzLmNvbnRleHQuY3JlYXRlR2FpbigpO1xuICAgIFx0dGhpcy5nYWluLmNvbm5lY3QoIGxpc3RlbmVyLmdldElucHV0KCkgKTtcblxuICAgIFx0dGhpcy5hdXRvcGxheSA9IGZhbHNlO1xuXG4gICAgXHR0aGlzLnN0YXJ0VGltZSA9IDA7XG4gICAgXHR0aGlzLnBsYXliYWNrUmF0ZSA9IDE7XG4gICAgXHR0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xuICAgIFx0dGhpcy5oYXNQbGF5YmFja0NvbnRyb2wgPSB0cnVlO1xuICAgIFx0dGhpcy5zb3VyY2VUeXBlID0gJ2VtcHR5JztcblxuICAgIFx0dGhpcy5maWx0ZXJzID0gW107XG5cbiAgICB9XG5cbiAgICBBdWRpby5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBPYmplY3QzRC5wcm90b3R5cGUgKSwge1xuXG4gICAgXHRjb25zdHJ1Y3RvcjogQXVkaW8sXG5cbiAgICBcdGdldE91dHB1dDogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHJldHVybiB0aGlzLmdhaW47XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldE5vZGVTb3VyY2U6IGZ1bmN0aW9uICggYXVkaW9Ob2RlICkge1xuXG4gICAgXHRcdHRoaXMuaGFzUGxheWJhY2tDb250cm9sID0gZmFsc2U7XG4gICAgXHRcdHRoaXMuc291cmNlVHlwZSA9ICdhdWRpb05vZGUnO1xuICAgIFx0XHR0aGlzLnNvdXJjZSA9IGF1ZGlvTm9kZTtcbiAgICBcdFx0dGhpcy5jb25uZWN0KCk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldEJ1ZmZlcjogZnVuY3Rpb24gKCBhdWRpb0J1ZmZlciApIHtcblxuICAgIFx0XHR0aGlzLnNvdXJjZS5idWZmZXIgPSBhdWRpb0J1ZmZlcjtcbiAgICBcdFx0dGhpcy5zb3VyY2VUeXBlID0gJ2J1ZmZlcic7XG5cbiAgICBcdFx0aWYgKCB0aGlzLmF1dG9wbGF5ICkgdGhpcy5wbGF5KCk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdHBsYXk6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHRpZiAoIHRoaXMuaXNQbGF5aW5nID09PSB0cnVlICkge1xuXG4gICAgXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQXVkaW86IEF1ZGlvIGlzIGFscmVhZHkgcGxheWluZy4nICk7XG4gICAgXHRcdFx0cmV0dXJuO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRpZiAoIHRoaXMuaGFzUGxheWJhY2tDb250cm9sID09PSBmYWxzZSApIHtcblxuICAgIFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkF1ZGlvOiB0aGlzIEF1ZGlvIGhhcyBubyBwbGF5YmFjayBjb250cm9sLicgKTtcbiAgICBcdFx0XHRyZXR1cm47XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHZhciBzb3VyY2UgPSB0aGlzLmNvbnRleHQuY3JlYXRlQnVmZmVyU291cmNlKCk7XG5cbiAgICBcdFx0c291cmNlLmJ1ZmZlciA9IHRoaXMuc291cmNlLmJ1ZmZlcjtcbiAgICBcdFx0c291cmNlLmxvb3AgPSB0aGlzLnNvdXJjZS5sb29wO1xuICAgIFx0XHRzb3VyY2Uub25lbmRlZCA9IHRoaXMuc291cmNlLm9uZW5kZWQ7XG4gICAgXHRcdHNvdXJjZS5zdGFydCggMCwgdGhpcy5zdGFydFRpbWUgKTtcbiAgICBcdFx0c291cmNlLnBsYXliYWNrUmF0ZS52YWx1ZSA9IHRoaXMucGxheWJhY2tSYXRlO1xuXG4gICAgXHRcdHRoaXMuaXNQbGF5aW5nID0gdHJ1ZTtcblxuICAgIFx0XHR0aGlzLnNvdXJjZSA9IHNvdXJjZTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcy5jb25uZWN0KCk7XG5cbiAgICBcdH0sXG5cbiAgICBcdHBhdXNlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0aWYgKCB0aGlzLmhhc1BsYXliYWNrQ29udHJvbCA9PT0gZmFsc2UgKSB7XG5cbiAgICBcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5BdWRpbzogdGhpcyBBdWRpbyBoYXMgbm8gcGxheWJhY2sgY29udHJvbC4nICk7XG4gICAgXHRcdFx0cmV0dXJuO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHR0aGlzLnNvdXJjZS5zdG9wKCk7XG4gICAgXHRcdHRoaXMuc3RhcnRUaW1lID0gdGhpcy5jb250ZXh0LmN1cnJlbnRUaW1lO1xuICAgIFx0XHR0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRzdG9wOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0aWYgKCB0aGlzLmhhc1BsYXliYWNrQ29udHJvbCA9PT0gZmFsc2UgKSB7XG5cbiAgICBcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5BdWRpbzogdGhpcyBBdWRpbyBoYXMgbm8gcGxheWJhY2sgY29udHJvbC4nICk7XG4gICAgXHRcdFx0cmV0dXJuO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHR0aGlzLnNvdXJjZS5zdG9wKCk7XG4gICAgXHRcdHRoaXMuc3RhcnRUaW1lID0gMDtcbiAgICBcdFx0dGhpcy5pc1BsYXlpbmcgPSBmYWxzZTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0Y29ubmVjdDogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdGlmICggdGhpcy5maWx0ZXJzLmxlbmd0aCA+IDAgKSB7XG5cbiAgICBcdFx0XHR0aGlzLnNvdXJjZS5jb25uZWN0KCB0aGlzLmZpbHRlcnNbIDAgXSApO1xuXG4gICAgXHRcdFx0Zm9yICggdmFyIGkgPSAxLCBsID0gdGhpcy5maWx0ZXJzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICBcdFx0XHRcdHRoaXMuZmlsdGVyc1sgaSAtIDEgXS5jb25uZWN0KCB0aGlzLmZpbHRlcnNbIGkgXSApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0dGhpcy5maWx0ZXJzWyB0aGlzLmZpbHRlcnMubGVuZ3RoIC0gMSBdLmNvbm5lY3QoIHRoaXMuZ2V0T3V0cHV0KCkgKTtcblxuICAgIFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0dGhpcy5zb3VyY2UuY29ubmVjdCggdGhpcy5nZXRPdXRwdXQoKSApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0ZGlzY29ubmVjdDogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdGlmICggdGhpcy5maWx0ZXJzLmxlbmd0aCA+IDAgKSB7XG5cbiAgICBcdFx0XHR0aGlzLnNvdXJjZS5kaXNjb25uZWN0KCB0aGlzLmZpbHRlcnNbIDAgXSApO1xuXG4gICAgXHRcdFx0Zm9yICggdmFyIGkgPSAxLCBsID0gdGhpcy5maWx0ZXJzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICBcdFx0XHRcdHRoaXMuZmlsdGVyc1sgaSAtIDEgXS5kaXNjb25uZWN0KCB0aGlzLmZpbHRlcnNbIGkgXSApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0dGhpcy5maWx0ZXJzWyB0aGlzLmZpbHRlcnMubGVuZ3RoIC0gMSBdLmRpc2Nvbm5lY3QoIHRoaXMuZ2V0T3V0cHV0KCkgKTtcblxuICAgIFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0dGhpcy5zb3VyY2UuZGlzY29ubmVjdCggdGhpcy5nZXRPdXRwdXQoKSApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0Z2V0RmlsdGVyczogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHJldHVybiB0aGlzLmZpbHRlcnM7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldEZpbHRlcnM6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cbiAgICBcdFx0aWYgKCAhIHZhbHVlICkgdmFsdWUgPSBbXTtcblxuICAgIFx0XHRpZiAoIHRoaXMuaXNQbGF5aW5nID09PSB0cnVlICkge1xuXG4gICAgXHRcdFx0dGhpcy5kaXNjb25uZWN0KCk7XG4gICAgXHRcdFx0dGhpcy5maWx0ZXJzID0gdmFsdWU7XG4gICAgXHRcdFx0dGhpcy5jb25uZWN0KCk7XG5cbiAgICBcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdHRoaXMuZmlsdGVycyA9IHZhbHVlO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0Z2V0RmlsdGVyOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMuZ2V0RmlsdGVycygpWyAwIF07XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldEZpbHRlcjogZnVuY3Rpb24gKCBmaWx0ZXIgKSB7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMuc2V0RmlsdGVycyggZmlsdGVyID8gWyBmaWx0ZXIgXSA6IFtdICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldFBsYXliYWNrUmF0ZTogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuICAgIFx0XHRpZiAoIHRoaXMuaGFzUGxheWJhY2tDb250cm9sID09PSBmYWxzZSApIHtcblxuICAgIFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkF1ZGlvOiB0aGlzIEF1ZGlvIGhhcyBubyBwbGF5YmFjayBjb250cm9sLicgKTtcbiAgICBcdFx0XHRyZXR1cm47XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHRoaXMucGxheWJhY2tSYXRlID0gdmFsdWU7XG5cbiAgICBcdFx0aWYgKCB0aGlzLmlzUGxheWluZyA9PT0gdHJ1ZSApIHtcblxuICAgIFx0XHRcdHRoaXMuc291cmNlLnBsYXliYWNrUmF0ZS52YWx1ZSA9IHRoaXMucGxheWJhY2tSYXRlO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0Z2V0UGxheWJhY2tSYXRlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMucGxheWJhY2tSYXRlO1xuXG4gICAgXHR9LFxuXG4gICAgXHRvbkVuZGVkOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dGhpcy5pc1BsYXlpbmcgPSBmYWxzZTtcblxuICAgIFx0fSxcblxuICAgIFx0Z2V0TG9vcDogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdGlmICggdGhpcy5oYXNQbGF5YmFja0NvbnRyb2wgPT09IGZhbHNlICkge1xuXG4gICAgXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQXVkaW86IHRoaXMgQXVkaW8gaGFzIG5vIHBsYXliYWNrIGNvbnRyb2wuJyApO1xuICAgIFx0XHRcdHJldHVybiBmYWxzZTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMuc291cmNlLmxvb3A7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldExvb3A6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cbiAgICBcdFx0aWYgKCB0aGlzLmhhc1BsYXliYWNrQ29udHJvbCA9PT0gZmFsc2UgKSB7XG5cbiAgICBcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5BdWRpbzogdGhpcyBBdWRpbyBoYXMgbm8gcGxheWJhY2sgY29udHJvbC4nICk7XG4gICAgXHRcdFx0cmV0dXJuO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHR0aGlzLnNvdXJjZS5sb29wID0gdmFsdWU7XG5cbiAgICBcdH0sXG5cbiAgICBcdGdldFZvbHVtZTogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHJldHVybiB0aGlzLmdhaW4uZ2Fpbi52YWx1ZTtcblxuICAgIFx0fSxcblxuXG4gICAgXHRzZXRWb2x1bWU6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cbiAgICBcdFx0dGhpcy5nYWluLmdhaW4udmFsdWUgPSB2YWx1ZTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fVxuXG4gICAgfSApO1xuXG4gICAgZnVuY3Rpb24gUG9zaXRpb25hbEF1ZGlvKCBsaXN0ZW5lciApIHtcblxuICAgIFx0QXVkaW8uY2FsbCggdGhpcywgbGlzdGVuZXIgKTtcblxuICAgIFx0dGhpcy5wYW5uZXIgPSB0aGlzLmNvbnRleHQuY3JlYXRlUGFubmVyKCk7XG4gICAgXHR0aGlzLnBhbm5lci5jb25uZWN0KCB0aGlzLmdhaW4gKTtcblxuICAgIH1cblxuICAgIFBvc2l0aW9uYWxBdWRpby5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBBdWRpby5wcm90b3R5cGUgKSwge1xuXG4gICAgXHRjb25zdHJ1Y3RvcjogUG9zaXRpb25hbEF1ZGlvLFxuXG4gICAgXHRnZXRPdXRwdXQ6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHRyZXR1cm4gdGhpcy5wYW5uZXI7XG5cbiAgICBcdH0sXG5cbiAgICBcdGdldFJlZkRpc3RhbmNlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMucGFubmVyLnJlZkRpc3RhbmNlO1xuXG4gICAgXHR9LFxuXG4gICAgXHRzZXRSZWZEaXN0YW5jZTogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuICAgIFx0XHR0aGlzLnBhbm5lci5yZWZEaXN0YW5jZSA9IHZhbHVlO1xuXG4gICAgXHR9LFxuXG4gICAgXHRnZXRSb2xsb2ZmRmFjdG9yOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMucGFubmVyLnJvbGxvZmZGYWN0b3I7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldFJvbGxvZmZGYWN0b3I6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cbiAgICBcdFx0dGhpcy5wYW5uZXIucm9sbG9mZkZhY3RvciA9IHZhbHVlO1xuXG4gICAgXHR9LFxuXG4gICAgXHRnZXREaXN0YW5jZU1vZGVsOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMucGFubmVyLmRpc3RhbmNlTW9kZWw7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldERpc3RhbmNlTW9kZWw6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cbiAgICBcdFx0dGhpcy5wYW5uZXIuZGlzdGFuY2VNb2RlbCA9IHZhbHVlO1xuXG4gICAgXHR9LFxuXG4gICAgXHRnZXRNYXhEaXN0YW5jZTogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHJldHVybiB0aGlzLnBhbm5lci5tYXhEaXN0YW5jZTtcblxuICAgIFx0fSxcblxuICAgIFx0c2V0TWF4RGlzdGFuY2U6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cbiAgICBcdFx0dGhpcy5wYW5uZXIubWF4RGlzdGFuY2UgPSB2YWx1ZTtcblxuICAgIFx0fSxcblxuICAgIFx0dXBkYXRlTWF0cml4V29ybGQ6ICggZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHZhciBwb3NpdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG5cbiAgICBcdFx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZU1hdHJpeFdvcmxkKCBmb3JjZSApIHtcblxuICAgIFx0XHRcdE9iamVjdDNELnByb3RvdHlwZS51cGRhdGVNYXRyaXhXb3JsZC5jYWxsKCB0aGlzLCBmb3JjZSApO1xuXG4gICAgXHRcdFx0cG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLm1hdHJpeFdvcmxkICk7XG5cbiAgICBcdFx0XHR0aGlzLnBhbm5lci5zZXRQb3NpdGlvbiggcG9zaXRpb24ueCwgcG9zaXRpb24ueSwgcG9zaXRpb24ueiApO1xuXG4gICAgXHRcdH07XG5cbiAgICBcdH0gKSgpXG5cblxuICAgIH0gKTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBBdWRpb0FuYWx5c2VyKCBhdWRpbywgZmZ0U2l6ZSApIHtcblxuICAgIFx0dGhpcy5hbmFseXNlciA9IGF1ZGlvLmNvbnRleHQuY3JlYXRlQW5hbHlzZXIoKTtcbiAgICBcdHRoaXMuYW5hbHlzZXIuZmZ0U2l6ZSA9IGZmdFNpemUgIT09IHVuZGVmaW5lZCA/IGZmdFNpemUgOiAyMDQ4O1xuXG4gICAgXHR0aGlzLmRhdGEgPSBuZXcgVWludDhBcnJheSggdGhpcy5hbmFseXNlci5mcmVxdWVuY3lCaW5Db3VudCApO1xuXG4gICAgXHRhdWRpby5nZXRPdXRwdXQoKS5jb25uZWN0KCB0aGlzLmFuYWx5c2VyICk7XG5cbiAgICB9XG5cbiAgICBPYmplY3QuYXNzaWduKCBBdWRpb0FuYWx5c2VyLnByb3RvdHlwZSwge1xuXG4gICAgXHRnZXRGcmVxdWVuY3lEYXRhOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dGhpcy5hbmFseXNlci5nZXRCeXRlRnJlcXVlbmN5RGF0YSggdGhpcy5kYXRhICk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMuZGF0YTtcblxuICAgIFx0fSxcblxuICAgIFx0Z2V0QXZlcmFnZUZyZXF1ZW5jeTogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHZhciB2YWx1ZSA9IDAsIGRhdGEgPSB0aGlzLmdldEZyZXF1ZW5jeURhdGEoKTtcblxuICAgIFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSArKyApIHtcblxuICAgIFx0XHRcdHZhbHVlICs9IGRhdGFbIGkgXTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIHZhbHVlIC8gZGF0YS5sZW5ndGg7XG5cbiAgICBcdH1cblxuICAgIH0gKTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQnVmZmVyZWQgc2NlbmUgZ3JhcGggcHJvcGVydHkgdGhhdCBhbGxvd3Mgd2VpZ2h0ZWQgYWNjdW11bGF0aW9uLlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAYXV0aG9yIEJlbiBIb3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvL1xuICAgICAqIEBhdXRob3IgRGF2aWQgU2Fybm8gLyBodHRwOi8vbGlnaHRoYXVzLnVzL1xuICAgICAqIEBhdXRob3IgdHNjaHdcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIFByb3BlcnR5TWl4ZXIoIGJpbmRpbmcsIHR5cGVOYW1lLCB2YWx1ZVNpemUgKSB7XG5cbiAgICBcdHRoaXMuYmluZGluZyA9IGJpbmRpbmc7XG4gICAgXHR0aGlzLnZhbHVlU2l6ZSA9IHZhbHVlU2l6ZTtcblxuICAgIFx0dmFyIGJ1ZmZlclR5cGUgPSBGbG9hdDY0QXJyYXksXG4gICAgXHRcdG1peEZ1bmN0aW9uO1xuXG4gICAgXHRzd2l0Y2ggKCB0eXBlTmFtZSApIHtcblxuICAgIFx0XHRjYXNlICdxdWF0ZXJuaW9uJzpcdFx0XHRtaXhGdW5jdGlvbiA9IHRoaXMuX3NsZXJwO1x0XHRicmVhaztcblxuICAgIFx0XHRjYXNlICdzdHJpbmcnOlxuICAgIFx0XHRjYXNlICdib29sJzpcblxuICAgIFx0XHRcdGJ1ZmZlclR5cGUgPSBBcnJheSxcdFx0bWl4RnVuY3Rpb24gPSB0aGlzLl9zZWxlY3Q7XHRcdGJyZWFrO1xuXG4gICAgXHRcdGRlZmF1bHQ6XHRcdFx0XHRcdG1peEZ1bmN0aW9uID0gdGhpcy5fbGVycDtcblxuICAgIFx0fVxuXG4gICAgXHR0aGlzLmJ1ZmZlciA9IG5ldyBidWZmZXJUeXBlKCB2YWx1ZVNpemUgKiA0ICk7XG4gICAgXHQvLyBsYXlvdXQ6IFsgaW5jb21pbmcgfCBhY2N1MCB8IGFjY3UxIHwgb3JpZyBdXG4gICAgXHQvL1xuICAgIFx0Ly8gaW50ZXJwb2xhdG9ycyBjYW4gdXNlIC5idWZmZXIgYXMgdGhlaXIgLnJlc3VsdFxuICAgIFx0Ly8gdGhlIGRhdGEgdGhlbiBnb2VzIHRvICdpbmNvbWluZydcbiAgICBcdC8vXG4gICAgXHQvLyAnYWNjdTAnIGFuZCAnYWNjdTEnIGFyZSB1c2VkIGZyYW1lLWludGVybGVhdmVkIGZvclxuICAgIFx0Ly8gdGhlIGN1bXVsYXRpdmUgcmVzdWx0IGFuZCBhcmUgY29tcGFyZWQgdG8gZGV0ZWN0XG4gICAgXHQvLyBjaGFuZ2VzXG4gICAgXHQvL1xuICAgIFx0Ly8gJ29yaWcnIHN0b3JlcyB0aGUgb3JpZ2luYWwgc3RhdGUgb2YgdGhlIHByb3BlcnR5XG5cbiAgICBcdHRoaXMuX21peEJ1ZmZlclJlZ2lvbiA9IG1peEZ1bmN0aW9uO1xuXG4gICAgXHR0aGlzLmN1bXVsYXRpdmVXZWlnaHQgPSAwO1xuXG4gICAgXHR0aGlzLnVzZUNvdW50ID0gMDtcbiAgICBcdHRoaXMucmVmZXJlbmNlQ291bnQgPSAwO1xuXG4gICAgfVxuXG4gICAgUHJvcGVydHlNaXhlci5wcm90b3R5cGUgPSB7XG5cbiAgICBcdGNvbnN0cnVjdG9yOiBQcm9wZXJ0eU1peGVyLFxuXG4gICAgXHQvLyBhY2N1bXVsYXRlIGRhdGEgaW4gdGhlICdpbmNvbWluZycgcmVnaW9uIGludG8gJ2FjY3U8aT4nXG4gICAgXHRhY2N1bXVsYXRlOiBmdW5jdGlvbiggYWNjdUluZGV4LCB3ZWlnaHQgKSB7XG5cbiAgICBcdFx0Ly8gbm90ZTogaGFwcGlseSBhY2N1bXVsYXRpbmcgbm90aGluZyB3aGVuIHdlaWdodCA9IDAsIHRoZSBjYWxsZXIga25vd3NcbiAgICBcdFx0Ly8gdGhlIHdlaWdodCBhbmQgc2hvdWxkbid0IGhhdmUgbWFkZSB0aGUgY2FsbCBpbiB0aGUgZmlyc3QgcGxhY2VcblxuICAgIFx0XHR2YXIgYnVmZmVyID0gdGhpcy5idWZmZXIsXG4gICAgXHRcdFx0c3RyaWRlID0gdGhpcy52YWx1ZVNpemUsXG4gICAgXHRcdFx0b2Zmc2V0ID0gYWNjdUluZGV4ICogc3RyaWRlICsgc3RyaWRlLFxuXG4gICAgXHRcdFx0Y3VycmVudFdlaWdodCA9IHRoaXMuY3VtdWxhdGl2ZVdlaWdodDtcblxuICAgIFx0XHRpZiAoIGN1cnJlbnRXZWlnaHQgPT09IDAgKSB7XG5cbiAgICBcdFx0XHQvLyBhY2N1TiA6PSBpbmNvbWluZyAqIHdlaWdodFxuXG4gICAgXHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpICE9PSBzdHJpZGU7ICsrIGkgKSB7XG5cbiAgICBcdFx0XHRcdGJ1ZmZlclsgb2Zmc2V0ICsgaSBdID0gYnVmZmVyWyBpIF07XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRjdXJyZW50V2VpZ2h0ID0gd2VpZ2h0O1xuXG4gICAgXHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHQvLyBhY2N1TiA6PSBhY2N1TiArIGluY29taW5nICogd2VpZ2h0XG5cbiAgICBcdFx0XHRjdXJyZW50V2VpZ2h0ICs9IHdlaWdodDtcbiAgICBcdFx0XHR2YXIgbWl4ID0gd2VpZ2h0IC8gY3VycmVudFdlaWdodDtcbiAgICBcdFx0XHR0aGlzLl9taXhCdWZmZXJSZWdpb24oIGJ1ZmZlciwgb2Zmc2V0LCAwLCBtaXgsIHN0cmlkZSApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHR0aGlzLmN1bXVsYXRpdmVXZWlnaHQgPSBjdXJyZW50V2VpZ2h0O1xuXG4gICAgXHR9LFxuXG4gICAgXHQvLyBhcHBseSB0aGUgc3RhdGUgb2YgJ2FjY3U8aT4nIHRvIHRoZSBiaW5kaW5nIHdoZW4gYWNjdXMgZGlmZmVyXG4gICAgXHRhcHBseTogZnVuY3Rpb24oIGFjY3VJbmRleCApIHtcblxuICAgIFx0XHR2YXIgc3RyaWRlID0gdGhpcy52YWx1ZVNpemUsXG4gICAgXHRcdFx0YnVmZmVyID0gdGhpcy5idWZmZXIsXG4gICAgXHRcdFx0b2Zmc2V0ID0gYWNjdUluZGV4ICogc3RyaWRlICsgc3RyaWRlLFxuXG4gICAgXHRcdFx0d2VpZ2h0ID0gdGhpcy5jdW11bGF0aXZlV2VpZ2h0LFxuXG4gICAgXHRcdFx0YmluZGluZyA9IHRoaXMuYmluZGluZztcblxuICAgIFx0XHR0aGlzLmN1bXVsYXRpdmVXZWlnaHQgPSAwO1xuXG4gICAgXHRcdGlmICggd2VpZ2h0IDwgMSApIHtcblxuICAgIFx0XHRcdC8vIGFjY3VOIDo9IGFjY3VOICsgb3JpZ2luYWwgKiAoIDEgLSBjdW11bGF0aXZlV2VpZ2h0IClcblxuICAgIFx0XHRcdHZhciBvcmlnaW5hbFZhbHVlT2Zmc2V0ID0gc3RyaWRlICogMztcblxuICAgIFx0XHRcdHRoaXMuX21peEJ1ZmZlclJlZ2lvbihcbiAgICBcdFx0XHRcdFx0YnVmZmVyLCBvZmZzZXQsIG9yaWdpbmFsVmFsdWVPZmZzZXQsIDEgLSB3ZWlnaHQsIHN0cmlkZSApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRmb3IgKCB2YXIgaSA9IHN0cmlkZSwgZSA9IHN0cmlkZSArIHN0cmlkZTsgaSAhPT0gZTsgKysgaSApIHtcblxuICAgIFx0XHRcdGlmICggYnVmZmVyWyBpIF0gIT09IGJ1ZmZlclsgaSArIHN0cmlkZSBdICkge1xuXG4gICAgXHRcdFx0XHQvLyB2YWx1ZSBoYXMgY2hhbmdlZCAtPiB1cGRhdGUgc2NlbmUgZ3JhcGhcblxuICAgIFx0XHRcdFx0YmluZGluZy5zZXRWYWx1ZSggYnVmZmVyLCBvZmZzZXQgKTtcbiAgICBcdFx0XHRcdGJyZWFrO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0fSxcblxuICAgIFx0Ly8gcmVtZW1iZXIgdGhlIHN0YXRlIG9mIHRoZSBib3VuZCBwcm9wZXJ0eSBhbmQgY29weSBpdCB0byBib3RoIGFjY3VzXG4gICAgXHRzYXZlT3JpZ2luYWxTdGF0ZTogZnVuY3Rpb24oKSB7XG5cbiAgICBcdFx0dmFyIGJpbmRpbmcgPSB0aGlzLmJpbmRpbmc7XG5cbiAgICBcdFx0dmFyIGJ1ZmZlciA9IHRoaXMuYnVmZmVyLFxuICAgIFx0XHRcdHN0cmlkZSA9IHRoaXMudmFsdWVTaXplLFxuXG4gICAgXHRcdFx0b3JpZ2luYWxWYWx1ZU9mZnNldCA9IHN0cmlkZSAqIDM7XG5cbiAgICBcdFx0YmluZGluZy5nZXRWYWx1ZSggYnVmZmVyLCBvcmlnaW5hbFZhbHVlT2Zmc2V0ICk7XG5cbiAgICBcdFx0Ly8gYWNjdVswLi4xXSA6PSBvcmlnIC0tIGluaXRpYWxseSBkZXRlY3QgY2hhbmdlcyBhZ2FpbnN0IHRoZSBvcmlnaW5hbFxuICAgIFx0XHRmb3IgKCB2YXIgaSA9IHN0cmlkZSwgZSA9IG9yaWdpbmFsVmFsdWVPZmZzZXQ7IGkgIT09IGU7ICsrIGkgKSB7XG5cbiAgICBcdFx0XHRidWZmZXJbIGkgXSA9IGJ1ZmZlclsgb3JpZ2luYWxWYWx1ZU9mZnNldCArICggaSAlIHN0cmlkZSApIF07XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHRoaXMuY3VtdWxhdGl2ZVdlaWdodCA9IDA7XG5cbiAgICBcdH0sXG5cbiAgICBcdC8vIGFwcGx5IHRoZSBzdGF0ZSBwcmV2aW91c2x5IHRha2VuIHZpYSAnc2F2ZU9yaWdpbmFsU3RhdGUnIHRvIHRoZSBiaW5kaW5nXG4gICAgXHRyZXN0b3JlT3JpZ2luYWxTdGF0ZTogZnVuY3Rpb24oKSB7XG5cbiAgICBcdFx0dmFyIG9yaWdpbmFsVmFsdWVPZmZzZXQgPSB0aGlzLnZhbHVlU2l6ZSAqIDM7XG4gICAgXHRcdHRoaXMuYmluZGluZy5zZXRWYWx1ZSggdGhpcy5idWZmZXIsIG9yaWdpbmFsVmFsdWVPZmZzZXQgKTtcblxuICAgIFx0fSxcblxuXG4gICAgXHQvLyBtaXggZnVuY3Rpb25zXG5cbiAgICBcdF9zZWxlY3Q6IGZ1bmN0aW9uKCBidWZmZXIsIGRzdE9mZnNldCwgc3JjT2Zmc2V0LCB0LCBzdHJpZGUgKSB7XG5cbiAgICBcdFx0aWYgKCB0ID49IDAuNSApIHtcblxuICAgIFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSAhPT0gc3RyaWRlOyArKyBpICkge1xuXG4gICAgXHRcdFx0XHRidWZmZXJbIGRzdE9mZnNldCArIGkgXSA9IGJ1ZmZlclsgc3JjT2Zmc2V0ICsgaSBdO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0fSxcblxuICAgIFx0X3NsZXJwOiBmdW5jdGlvbiggYnVmZmVyLCBkc3RPZmZzZXQsIHNyY09mZnNldCwgdCwgc3RyaWRlICkge1xuXG4gICAgXHRcdFF1YXRlcm5pb24uc2xlcnBGbGF0KCBidWZmZXIsIGRzdE9mZnNldCxcbiAgICBcdFx0XHRcdGJ1ZmZlciwgZHN0T2Zmc2V0LCBidWZmZXIsIHNyY09mZnNldCwgdCApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRfbGVycDogZnVuY3Rpb24oIGJ1ZmZlciwgZHN0T2Zmc2V0LCBzcmNPZmZzZXQsIHQsIHN0cmlkZSApIHtcblxuICAgIFx0XHR2YXIgcyA9IDEgLSB0O1xuXG4gICAgXHRcdGZvciAoIHZhciBpID0gMDsgaSAhPT0gc3RyaWRlOyArKyBpICkge1xuXG4gICAgXHRcdFx0dmFyIGogPSBkc3RPZmZzZXQgKyBpO1xuXG4gICAgXHRcdFx0YnVmZmVyWyBqIF0gPSBidWZmZXJbIGogXSAqIHMgKyBidWZmZXJbIHNyY09mZnNldCArIGkgXSAqIHQ7XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9XG5cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBBIHJlZmVyZW5jZSB0byBhIHJlYWwgcHJvcGVydHkgaW4gdGhlIHNjZW5lIGdyYXBoLlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAYXV0aG9yIEJlbiBIb3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvL1xuICAgICAqIEBhdXRob3IgRGF2aWQgU2Fybm8gLyBodHRwOi8vbGlnaHRoYXVzLnVzL1xuICAgICAqIEBhdXRob3IgdHNjaHdcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIFByb3BlcnR5QmluZGluZyggcm9vdE5vZGUsIHBhdGgsIHBhcnNlZFBhdGggKSB7XG5cbiAgICBcdHRoaXMucGF0aCA9IHBhdGg7XG4gICAgXHR0aGlzLnBhcnNlZFBhdGggPSBwYXJzZWRQYXRoIHx8XG4gICAgXHRcdFx0UHJvcGVydHlCaW5kaW5nLnBhcnNlVHJhY2tOYW1lKCBwYXRoICk7XG5cbiAgICBcdHRoaXMubm9kZSA9IFByb3BlcnR5QmluZGluZy5maW5kTm9kZShcbiAgICBcdFx0XHRyb290Tm9kZSwgdGhpcy5wYXJzZWRQYXRoLm5vZGVOYW1lICkgfHwgcm9vdE5vZGU7XG5cbiAgICBcdHRoaXMucm9vdE5vZGUgPSByb290Tm9kZTtcblxuICAgIH1cblxuICAgIFByb3BlcnR5QmluZGluZy5wcm90b3R5cGUgPSB7XG5cbiAgICBcdGNvbnN0cnVjdG9yOiBQcm9wZXJ0eUJpbmRpbmcsXG5cbiAgICBcdGdldFZhbHVlOiBmdW5jdGlvbiBnZXRWYWx1ZV91bmJvdW5kKCB0YXJnZXRBcnJheSwgb2Zmc2V0ICkge1xuXG4gICAgXHRcdHRoaXMuYmluZCgpO1xuICAgIFx0XHR0aGlzLmdldFZhbHVlKCB0YXJnZXRBcnJheSwgb2Zmc2V0ICk7XG5cbiAgICBcdFx0Ly8gTm90ZTogVGhpcyBjbGFzcyB1c2VzIGEgU3RhdGUgcGF0dGVybiBvbiBhIHBlci1tZXRob2QgYmFzaXM6XG4gICAgXHRcdC8vICdiaW5kJyBzZXRzICd0aGlzLmdldFZhbHVlJyAvICdzZXRWYWx1ZScgYW5kIHNoYWRvd3MgdGhlXG4gICAgXHRcdC8vIHByb3RvdHlwZSB2ZXJzaW9uIG9mIHRoZXNlIG1ldGhvZHMgd2l0aCBvbmUgdGhhdCByZXByZXNlbnRzXG4gICAgXHRcdC8vIHRoZSBib3VuZCBzdGF0ZS4gV2hlbiB0aGUgcHJvcGVydHkgaXMgbm90IGZvdW5kLCB0aGUgbWV0aG9kc1xuICAgIFx0XHQvLyBiZWNvbWUgbm8tb3BzLlxuXG4gICAgXHR9LFxuXG4gICAgXHRzZXRWYWx1ZTogZnVuY3Rpb24gZ2V0VmFsdWVfdW5ib3VuZCggc291cmNlQXJyYXksIG9mZnNldCApIHtcblxuICAgIFx0XHR0aGlzLmJpbmQoKTtcbiAgICBcdFx0dGhpcy5zZXRWYWx1ZSggc291cmNlQXJyYXksIG9mZnNldCApO1xuXG4gICAgXHR9LFxuXG4gICAgXHQvLyBjcmVhdGUgZ2V0dGVyIC8gc2V0dGVyIHBhaXIgZm9yIGEgcHJvcGVydHkgaW4gdGhlIHNjZW5lIGdyYXBoXG4gICAgXHRiaW5kOiBmdW5jdGlvbigpIHtcblxuICAgIFx0XHR2YXIgdGFyZ2V0T2JqZWN0ID0gdGhpcy5ub2RlLFxuICAgIFx0XHRcdHBhcnNlZFBhdGggPSB0aGlzLnBhcnNlZFBhdGgsXG5cbiAgICBcdFx0XHRvYmplY3ROYW1lID0gcGFyc2VkUGF0aC5vYmplY3ROYW1lLFxuICAgIFx0XHRcdHByb3BlcnR5TmFtZSA9IHBhcnNlZFBhdGgucHJvcGVydHlOYW1lLFxuICAgIFx0XHRcdHByb3BlcnR5SW5kZXggPSBwYXJzZWRQYXRoLnByb3BlcnR5SW5kZXg7XG5cbiAgICBcdFx0aWYgKCAhIHRhcmdldE9iamVjdCApIHtcblxuICAgIFx0XHRcdHRhcmdldE9iamVjdCA9IFByb3BlcnR5QmluZGluZy5maW5kTm9kZShcbiAgICBcdFx0XHRcdFx0dGhpcy5yb290Tm9kZSwgcGFyc2VkUGF0aC5ub2RlTmFtZSApIHx8IHRoaXMucm9vdE5vZGU7XG5cbiAgICBcdFx0XHR0aGlzLm5vZGUgPSB0YXJnZXRPYmplY3Q7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdC8vIHNldCBmYWlsIHN0YXRlIHNvIHdlIGNhbiBqdXN0ICdyZXR1cm4nIG9uIGVycm9yXG4gICAgXHRcdHRoaXMuZ2V0VmFsdWUgPSB0aGlzLl9nZXRWYWx1ZV91bmF2YWlsYWJsZTtcbiAgICBcdFx0dGhpcy5zZXRWYWx1ZSA9IHRoaXMuX3NldFZhbHVlX3VuYXZhaWxhYmxlO1xuXG4gICAgIFx0XHQvLyBlbnN1cmUgdGhlcmUgaXMgYSB2YWx1ZSBub2RlXG4gICAgXHRcdGlmICggISB0YXJnZXRPYmplY3QgKSB7XG5cbiAgICBcdFx0XHRjb25zb2xlLmVycm9yKCBcIiAgdHJ5aW5nIHRvIHVwZGF0ZSBub2RlIGZvciB0cmFjazogXCIgKyB0aGlzLnBhdGggKyBcIiBidXQgaXQgd2Fzbid0IGZvdW5kLlwiICk7XG4gICAgXHRcdFx0cmV0dXJuO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRpZiAoIG9iamVjdE5hbWUgKSB7XG5cbiAgICBcdFx0XHR2YXIgb2JqZWN0SW5kZXggPSBwYXJzZWRQYXRoLm9iamVjdEluZGV4O1xuXG4gICAgXHRcdFx0Ly8gc3BlY2lhbCBjYXNlcyB3ZXJlIHdlIG5lZWQgdG8gcmVhY2ggZGVlcGVyIGludG8gdGhlIGhpZXJhcmNoeSB0byBnZXQgdGhlIGZhY2UgbWF0ZXJpYWxzLi4uLlxuICAgIFx0XHRcdHN3aXRjaCAoIG9iamVjdE5hbWUgKSB7XG5cbiAgICBcdFx0XHRcdGNhc2UgJ21hdGVyaWFscyc6XG5cbiAgICBcdFx0XHRcdFx0aWYgKCAhIHRhcmdldE9iamVjdC5tYXRlcmlhbCApIHtcblxuICAgIFx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICcgIGNhbiBub3QgYmluZCB0byBtYXRlcmlhbCBhcyBub2RlIGRvZXMgbm90IGhhdmUgYSBtYXRlcmlhbCcsIHRoaXMgKTtcbiAgICBcdFx0XHRcdFx0XHRyZXR1cm47XG5cbiAgICBcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHRcdGlmICggISB0YXJnZXRPYmplY3QubWF0ZXJpYWwubWF0ZXJpYWxzICkge1xuXG4gICAgXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJyAgY2FuIG5vdCBiaW5kIHRvIG1hdGVyaWFsLm1hdGVyaWFscyBhcyBub2RlLm1hdGVyaWFsIGRvZXMgbm90IGhhdmUgYSBtYXRlcmlhbHMgYXJyYXknLCB0aGlzICk7XG4gICAgXHRcdFx0XHRcdFx0cmV0dXJuO1xuXG4gICAgXHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0XHR0YXJnZXRPYmplY3QgPSB0YXJnZXRPYmplY3QubWF0ZXJpYWwubWF0ZXJpYWxzO1xuXG4gICAgXHRcdFx0XHRcdGJyZWFrO1xuXG4gICAgXHRcdFx0XHRjYXNlICdib25lcyc6XG5cbiAgICBcdFx0XHRcdFx0aWYgKCAhIHRhcmdldE9iamVjdC5za2VsZXRvbiApIHtcblxuICAgIFx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICcgIGNhbiBub3QgYmluZCB0byBib25lcyBhcyBub2RlIGRvZXMgbm90IGhhdmUgYSBza2VsZXRvbicsIHRoaXMgKTtcbiAgICBcdFx0XHRcdFx0XHRyZXR1cm47XG5cbiAgICBcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHRcdC8vIHBvdGVudGlhbCBmdXR1cmUgb3B0aW1pemF0aW9uOiBza2lwIHRoaXMgaWYgcHJvcGVydHlJbmRleCBpcyBhbHJlYWR5IGFuIGludGVnZXJcbiAgICBcdFx0XHRcdFx0Ly8gYW5kIGNvbnZlcnQgdGhlIGludGVnZXIgc3RyaW5nIHRvIGEgdHJ1ZSBpbnRlZ2VyLlxuXG4gICAgXHRcdFx0XHRcdHRhcmdldE9iamVjdCA9IHRhcmdldE9iamVjdC5za2VsZXRvbi5ib25lcztcblxuICAgIFx0XHRcdFx0XHQvLyBzdXBwb3J0IHJlc29sdmluZyBtb3JwaFRhcmdldCBuYW1lcyBpbnRvIGluZGljZXMuXG4gICAgXHRcdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHRhcmdldE9iamVjdC5sZW5ndGg7IGkgKysgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHRpZiAoIHRhcmdldE9iamVjdFsgaSBdLm5hbWUgPT09IG9iamVjdEluZGV4ICkge1xuXG4gICAgXHRcdFx0XHRcdFx0XHRvYmplY3RJbmRleCA9IGk7XG4gICAgXHRcdFx0XHRcdFx0XHRicmVhaztcblxuICAgIFx0XHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdFx0YnJlYWs7XG5cbiAgICBcdFx0XHRcdGRlZmF1bHQ6XG5cbiAgICBcdFx0XHRcdFx0aWYgKCB0YXJnZXRPYmplY3RbIG9iamVjdE5hbWUgXSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvciggJyAgY2FuIG5vdCBiaW5kIHRvIG9iamVjdE5hbWUgb2Ygbm9kZSwgdW5kZWZpbmVkJywgdGhpcyApO1xuICAgIFx0XHRcdFx0XHRcdHJldHVybjtcblxuICAgIFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdFx0dGFyZ2V0T2JqZWN0ID0gdGFyZ2V0T2JqZWN0WyBvYmplY3ROYW1lIF07XG5cbiAgICBcdFx0XHR9XG5cblxuICAgIFx0XHRcdGlmICggb2JqZWN0SW5kZXggIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0aWYgKCB0YXJnZXRPYmplY3RbIG9iamVjdEluZGV4IF0gPT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCBcIiAgdHJ5aW5nIHRvIGJpbmQgdG8gb2JqZWN0SW5kZXggb2Ygb2JqZWN0TmFtZSwgYnV0IGlzIHVuZGVmaW5lZDpcIiwgdGhpcywgdGFyZ2V0T2JqZWN0ICk7XG4gICAgXHRcdFx0XHRcdHJldHVybjtcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHR0YXJnZXRPYmplY3QgPSB0YXJnZXRPYmplY3RbIG9iamVjdEluZGV4IF07XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdC8vIHJlc29sdmUgcHJvcGVydHlcbiAgICBcdFx0dmFyIG5vZGVQcm9wZXJ0eSA9IHRhcmdldE9iamVjdFsgcHJvcGVydHlOYW1lIF07XG5cbiAgICBcdFx0aWYgKCBub2RlUHJvcGVydHkgPT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdHZhciBub2RlTmFtZSA9IHBhcnNlZFBhdGgubm9kZU5hbWU7XG5cbiAgICBcdFx0XHRjb25zb2xlLmVycm9yKCBcIiAgdHJ5aW5nIHRvIHVwZGF0ZSBwcm9wZXJ0eSBmb3IgdHJhY2s6IFwiICsgbm9kZU5hbWUgK1xuICAgIFx0XHRcdFx0XHQnLicgKyBwcm9wZXJ0eU5hbWUgKyBcIiBidXQgaXQgd2Fzbid0IGZvdW5kLlwiLCB0YXJnZXRPYmplY3QgKTtcbiAgICBcdFx0XHRyZXR1cm47XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdC8vIGRldGVybWluZSB2ZXJzaW9uaW5nIHNjaGVtZVxuICAgIFx0XHR2YXIgdmVyc2lvbmluZyA9IHRoaXMuVmVyc2lvbmluZy5Ob25lO1xuXG4gICAgXHRcdGlmICggdGFyZ2V0T2JqZWN0Lm5lZWRzVXBkYXRlICE9PSB1bmRlZmluZWQgKSB7IC8vIG1hdGVyaWFsXG5cbiAgICBcdFx0XHR2ZXJzaW9uaW5nID0gdGhpcy5WZXJzaW9uaW5nLk5lZWRzVXBkYXRlO1xuICAgIFx0XHRcdHRoaXMudGFyZ2V0T2JqZWN0ID0gdGFyZ2V0T2JqZWN0O1xuXG4gICAgXHRcdH0gZWxzZSBpZiAoIHRhcmdldE9iamVjdC5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlICE9PSB1bmRlZmluZWQgKSB7IC8vIG5vZGUgdHJhbnNmb3JtXG5cbiAgICBcdFx0XHR2ZXJzaW9uaW5nID0gdGhpcy5WZXJzaW9uaW5nLk1hdHJpeFdvcmxkTmVlZHNVcGRhdGU7XG4gICAgXHRcdFx0dGhpcy50YXJnZXRPYmplY3QgPSB0YXJnZXRPYmplY3Q7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdC8vIGRldGVybWluZSBob3cgdGhlIHByb3BlcnR5IGdldHMgYm91bmRcbiAgICBcdFx0dmFyIGJpbmRpbmdUeXBlID0gdGhpcy5CaW5kaW5nVHlwZS5EaXJlY3Q7XG5cbiAgICBcdFx0aWYgKCBwcm9wZXJ0eUluZGV4ICE9PSB1bmRlZmluZWQgKSB7XG4gICAgXHRcdFx0Ly8gYWNjZXNzIGEgc3ViIGVsZW1lbnQgb2YgdGhlIHByb3BlcnR5IGFycmF5IChvbmx5IHByaW1pdGl2ZXMgYXJlIHN1cHBvcnRlZCByaWdodCBub3cpXG5cbiAgICBcdFx0XHRpZiAoIHByb3BlcnR5TmFtZSA9PT0gXCJtb3JwaFRhcmdldEluZmx1ZW5jZXNcIiApIHtcbiAgICBcdFx0XHRcdC8vIHBvdGVudGlhbCBvcHRpbWl6YXRpb24sIHNraXAgdGhpcyBpZiBwcm9wZXJ0eUluZGV4IGlzIGFscmVhZHkgYW4gaW50ZWdlciwgYW5kIGNvbnZlcnQgdGhlIGludGVnZXIgc3RyaW5nIHRvIGEgdHJ1ZSBpbnRlZ2VyLlxuXG4gICAgXHRcdFx0XHQvLyBzdXBwb3J0IHJlc29sdmluZyBtb3JwaFRhcmdldCBuYW1lcyBpbnRvIGluZGljZXMuXG4gICAgXHRcdFx0XHRpZiAoICEgdGFyZ2V0T2JqZWN0Lmdlb21ldHJ5ICkge1xuXG4gICAgXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoICcgIGNhbiBub3QgYmluZCB0byBtb3JwaFRhcmdldEluZmx1ZW5jZXMgYmVjYXN1c2Ugbm9kZSBkb2VzIG5vdCBoYXZlIGEgZ2VvbWV0cnknLCB0aGlzICk7XG4gICAgXHRcdFx0XHRcdHJldHVybjtcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHRpZiAoICEgdGFyZ2V0T2JqZWN0Lmdlb21ldHJ5Lm1vcnBoVGFyZ2V0cyApIHtcblxuICAgIFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCAnICBjYW4gbm90IGJpbmQgdG8gbW9ycGhUYXJnZXRJbmZsdWVuY2VzIGJlY2FzdXNlIG5vZGUgZG9lcyBub3QgaGF2ZSBhIGdlb21ldHJ5Lm1vcnBoVGFyZ2V0cycsIHRoaXMgKTtcbiAgICBcdFx0XHRcdFx0cmV0dXJuO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMubm9kZS5nZW9tZXRyeS5tb3JwaFRhcmdldHMubGVuZ3RoOyBpICsrICkge1xuXG4gICAgXHRcdFx0XHRcdGlmICggdGFyZ2V0T2JqZWN0Lmdlb21ldHJ5Lm1vcnBoVGFyZ2V0c1sgaSBdLm5hbWUgPT09IHByb3BlcnR5SW5kZXggKSB7XG5cbiAgICBcdFx0XHRcdFx0XHRwcm9wZXJ0eUluZGV4ID0gaTtcbiAgICBcdFx0XHRcdFx0XHRicmVhaztcblxuICAgIFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdGJpbmRpbmdUeXBlID0gdGhpcy5CaW5kaW5nVHlwZS5BcnJheUVsZW1lbnQ7XG5cbiAgICBcdFx0XHR0aGlzLnJlc29sdmVkUHJvcGVydHkgPSBub2RlUHJvcGVydHk7XG4gICAgXHRcdFx0dGhpcy5wcm9wZXJ0eUluZGV4ID0gcHJvcGVydHlJbmRleDtcblxuICAgIFx0XHR9IGVsc2UgaWYgKCBub2RlUHJvcGVydHkuZnJvbUFycmF5ICE9PSB1bmRlZmluZWQgJiYgbm9kZVByb3BlcnR5LnRvQXJyYXkgIT09IHVuZGVmaW5lZCApIHtcbiAgICBcdFx0XHQvLyBtdXN0IHVzZSBjb3B5IGZvciBPYmplY3QzRC5FdWxlci9RdWF0ZXJuaW9uXG5cbiAgICBcdFx0XHRiaW5kaW5nVHlwZSA9IHRoaXMuQmluZGluZ1R5cGUuSGFzRnJvbVRvQXJyYXk7XG5cbiAgICBcdFx0XHR0aGlzLnJlc29sdmVkUHJvcGVydHkgPSBub2RlUHJvcGVydHk7XG5cbiAgICBcdFx0fSBlbHNlIGlmICggbm9kZVByb3BlcnR5Lmxlbmd0aCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0YmluZGluZ1R5cGUgPSB0aGlzLkJpbmRpbmdUeXBlLkVudGlyZUFycmF5O1xuXG4gICAgXHRcdFx0dGhpcy5yZXNvbHZlZFByb3BlcnR5ID0gbm9kZVByb3BlcnR5O1xuXG4gICAgXHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHR0aGlzLnByb3BlcnR5TmFtZSA9IHByb3BlcnR5TmFtZTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0Ly8gc2VsZWN0IGdldHRlciAvIHNldHRlclxuICAgIFx0XHR0aGlzLmdldFZhbHVlID0gdGhpcy5HZXR0ZXJCeUJpbmRpbmdUeXBlWyBiaW5kaW5nVHlwZSBdO1xuICAgIFx0XHR0aGlzLnNldFZhbHVlID0gdGhpcy5TZXR0ZXJCeUJpbmRpbmdUeXBlQW5kVmVyc2lvbmluZ1sgYmluZGluZ1R5cGUgXVsgdmVyc2lvbmluZyBdO1xuXG4gICAgXHR9LFxuXG4gICAgXHR1bmJpbmQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgXHRcdHRoaXMubm9kZSA9IG51bGw7XG5cbiAgICBcdFx0Ly8gYmFjayB0byB0aGUgcHJvdG90eXBlIHZlcnNpb24gb2YgZ2V0VmFsdWUgLyBzZXRWYWx1ZVxuICAgIFx0XHQvLyBub3RlOiBhdm9pZGluZyB0byBtdXRhdGUgdGhlIHNoYXBlIG9mICd0aGlzJyB2aWEgJ2RlbGV0ZSdcbiAgICBcdFx0dGhpcy5nZXRWYWx1ZSA9IHRoaXMuX2dldFZhbHVlX3VuYm91bmQ7XG4gICAgXHRcdHRoaXMuc2V0VmFsdWUgPSB0aGlzLl9zZXRWYWx1ZV91bmJvdW5kO1xuXG4gICAgXHR9XG5cbiAgICB9O1xuXG4gICAgT2JqZWN0LmFzc2lnbiggUHJvcGVydHlCaW5kaW5nLnByb3RvdHlwZSwgeyAvLyBwcm90b3R5cGUsIGNvbnRpbnVlZFxuXG4gICAgXHQvLyB0aGVzZSBhcmUgdXNlZCB0byBcImJpbmRcIiBhIG5vbmV4aXN0ZW50IHByb3BlcnR5XG4gICAgXHRfZ2V0VmFsdWVfdW5hdmFpbGFibGU6IGZ1bmN0aW9uKCkge30sXG4gICAgXHRfc2V0VmFsdWVfdW5hdmFpbGFibGU6IGZ1bmN0aW9uKCkge30sXG5cbiAgICBcdC8vIGluaXRpYWwgc3RhdGUgb2YgdGhlc2UgbWV0aG9kcyB0aGF0IGNhbGxzICdiaW5kJ1xuICAgIFx0X2dldFZhbHVlX3VuYm91bmQ6IFByb3BlcnR5QmluZGluZy5wcm90b3R5cGUuZ2V0VmFsdWUsXG4gICAgXHRfc2V0VmFsdWVfdW5ib3VuZDogUHJvcGVydHlCaW5kaW5nLnByb3RvdHlwZS5zZXRWYWx1ZSxcblxuICAgIFx0QmluZGluZ1R5cGU6IHtcbiAgICBcdFx0RGlyZWN0OiAwLFxuICAgIFx0XHRFbnRpcmVBcnJheTogMSxcbiAgICBcdFx0QXJyYXlFbGVtZW50OiAyLFxuICAgIFx0XHRIYXNGcm9tVG9BcnJheTogM1xuICAgIFx0fSxcblxuICAgIFx0VmVyc2lvbmluZzoge1xuICAgIFx0XHROb25lOiAwLFxuICAgIFx0XHROZWVkc1VwZGF0ZTogMSxcbiAgICBcdFx0TWF0cml4V29ybGROZWVkc1VwZGF0ZTogMlxuICAgIFx0fSxcblxuICAgIFx0R2V0dGVyQnlCaW5kaW5nVHlwZTogW1xuXG4gICAgXHRcdGZ1bmN0aW9uIGdldFZhbHVlX2RpcmVjdCggYnVmZmVyLCBvZmZzZXQgKSB7XG5cbiAgICBcdFx0XHRidWZmZXJbIG9mZnNldCBdID0gdGhpcy5ub2RlWyB0aGlzLnByb3BlcnR5TmFtZSBdO1xuXG4gICAgXHRcdH0sXG5cbiAgICBcdFx0ZnVuY3Rpb24gZ2V0VmFsdWVfYXJyYXkoIGJ1ZmZlciwgb2Zmc2V0ICkge1xuXG4gICAgXHRcdFx0dmFyIHNvdXJjZSA9IHRoaXMucmVzb2x2ZWRQcm9wZXJ0eTtcblxuICAgIFx0XHRcdGZvciAoIHZhciBpID0gMCwgbiA9IHNvdXJjZS5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XG5cbiAgICBcdFx0XHRcdGJ1ZmZlclsgb2Zmc2V0ICsrIF0gPSBzb3VyY2VbIGkgXTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9LFxuXG4gICAgXHRcdGZ1bmN0aW9uIGdldFZhbHVlX2FycmF5RWxlbWVudCggYnVmZmVyLCBvZmZzZXQgKSB7XG5cbiAgICBcdFx0XHRidWZmZXJbIG9mZnNldCBdID0gdGhpcy5yZXNvbHZlZFByb3BlcnR5WyB0aGlzLnByb3BlcnR5SW5kZXggXTtcblxuICAgIFx0XHR9LFxuXG4gICAgXHRcdGZ1bmN0aW9uIGdldFZhbHVlX3RvQXJyYXkoIGJ1ZmZlciwgb2Zmc2V0ICkge1xuXG4gICAgXHRcdFx0dGhpcy5yZXNvbHZlZFByb3BlcnR5LnRvQXJyYXkoIGJ1ZmZlciwgb2Zmc2V0ICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRdLFxuXG4gICAgXHRTZXR0ZXJCeUJpbmRpbmdUeXBlQW5kVmVyc2lvbmluZzogW1xuXG4gICAgXHRcdFtcbiAgICBcdFx0XHQvLyBEaXJlY3RcblxuICAgIFx0XHRcdGZ1bmN0aW9uIHNldFZhbHVlX2RpcmVjdCggYnVmZmVyLCBvZmZzZXQgKSB7XG5cbiAgICBcdFx0XHRcdHRoaXMubm9kZVsgdGhpcy5wcm9wZXJ0eU5hbWUgXSA9IGJ1ZmZlclsgb2Zmc2V0IF07XG5cbiAgICBcdFx0XHR9LFxuXG4gICAgXHRcdFx0ZnVuY3Rpb24gc2V0VmFsdWVfZGlyZWN0X3NldE5lZWRzVXBkYXRlKCBidWZmZXIsIG9mZnNldCApIHtcblxuICAgIFx0XHRcdFx0dGhpcy5ub2RlWyB0aGlzLnByb3BlcnR5TmFtZSBdID0gYnVmZmVyWyBvZmZzZXQgXTtcbiAgICBcdFx0XHRcdHRoaXMudGFyZ2V0T2JqZWN0Lm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgIFx0XHRcdH0sXG5cbiAgICBcdFx0XHRmdW5jdGlvbiBzZXRWYWx1ZV9kaXJlY3Rfc2V0TWF0cml4V29ybGROZWVkc1VwZGF0ZSggYnVmZmVyLCBvZmZzZXQgKSB7XG5cbiAgICBcdFx0XHRcdHRoaXMubm9kZVsgdGhpcy5wcm9wZXJ0eU5hbWUgXSA9IGJ1ZmZlclsgb2Zmc2V0IF07XG4gICAgXHRcdFx0XHR0aGlzLnRhcmdldE9iamVjdC5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRdLCBbXG5cbiAgICBcdFx0XHQvLyBFbnRpcmVBcnJheVxuXG4gICAgXHRcdFx0ZnVuY3Rpb24gc2V0VmFsdWVfYXJyYXkoIGJ1ZmZlciwgb2Zmc2V0ICkge1xuXG4gICAgXHRcdFx0XHR2YXIgZGVzdCA9IHRoaXMucmVzb2x2ZWRQcm9wZXJ0eTtcblxuICAgIFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBuID0gZGVzdC5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XG5cbiAgICBcdFx0XHRcdFx0ZGVzdFsgaSBdID0gYnVmZmVyWyBvZmZzZXQgKysgXTtcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0fSxcblxuICAgIFx0XHRcdGZ1bmN0aW9uIHNldFZhbHVlX2FycmF5X3NldE5lZWRzVXBkYXRlKCBidWZmZXIsIG9mZnNldCApIHtcblxuICAgIFx0XHRcdFx0dmFyIGRlc3QgPSB0aGlzLnJlc29sdmVkUHJvcGVydHk7XG5cbiAgICBcdFx0XHRcdGZvciAoIHZhciBpID0gMCwgbiA9IGRlc3QubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xuXG4gICAgXHRcdFx0XHRcdGRlc3RbIGkgXSA9IGJ1ZmZlclsgb2Zmc2V0ICsrIF07XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0dGhpcy50YXJnZXRPYmplY3QubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgXHRcdFx0fSxcblxuICAgIFx0XHRcdGZ1bmN0aW9uIHNldFZhbHVlX2FycmF5X3NldE1hdHJpeFdvcmxkTmVlZHNVcGRhdGUoIGJ1ZmZlciwgb2Zmc2V0ICkge1xuXG4gICAgXHRcdFx0XHR2YXIgZGVzdCA9IHRoaXMucmVzb2x2ZWRQcm9wZXJ0eTtcblxuICAgIFx0XHRcdFx0Zm9yICggdmFyIGkgPSAwLCBuID0gZGVzdC5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XG5cbiAgICBcdFx0XHRcdFx0ZGVzdFsgaSBdID0gYnVmZmVyWyBvZmZzZXQgKysgXTtcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHR0aGlzLnRhcmdldE9iamVjdC5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRdLCBbXG5cbiAgICBcdFx0XHQvLyBBcnJheUVsZW1lbnRcblxuICAgIFx0XHRcdGZ1bmN0aW9uIHNldFZhbHVlX2FycmF5RWxlbWVudCggYnVmZmVyLCBvZmZzZXQgKSB7XG5cbiAgICBcdFx0XHRcdHRoaXMucmVzb2x2ZWRQcm9wZXJ0eVsgdGhpcy5wcm9wZXJ0eUluZGV4IF0gPSBidWZmZXJbIG9mZnNldCBdO1xuXG4gICAgXHRcdFx0fSxcblxuICAgIFx0XHRcdGZ1bmN0aW9uIHNldFZhbHVlX2FycmF5RWxlbWVudF9zZXROZWVkc1VwZGF0ZSggYnVmZmVyLCBvZmZzZXQgKSB7XG5cbiAgICBcdFx0XHRcdHRoaXMucmVzb2x2ZWRQcm9wZXJ0eVsgdGhpcy5wcm9wZXJ0eUluZGV4IF0gPSBidWZmZXJbIG9mZnNldCBdO1xuICAgIFx0XHRcdFx0dGhpcy50YXJnZXRPYmplY3QubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgXHRcdFx0fSxcblxuICAgIFx0XHRcdGZ1bmN0aW9uIHNldFZhbHVlX2FycmF5RWxlbWVudF9zZXRNYXRyaXhXb3JsZE5lZWRzVXBkYXRlKCBidWZmZXIsIG9mZnNldCApIHtcblxuICAgIFx0XHRcdFx0dGhpcy5yZXNvbHZlZFByb3BlcnR5WyB0aGlzLnByb3BlcnR5SW5kZXggXSA9IGJ1ZmZlclsgb2Zmc2V0IF07XG4gICAgXHRcdFx0XHR0aGlzLnRhcmdldE9iamVjdC5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRdLCBbXG5cbiAgICBcdFx0XHQvLyBIYXNUb0Zyb21BcnJheVxuXG4gICAgXHRcdFx0ZnVuY3Rpb24gc2V0VmFsdWVfZnJvbUFycmF5KCBidWZmZXIsIG9mZnNldCApIHtcblxuICAgIFx0XHRcdFx0dGhpcy5yZXNvbHZlZFByb3BlcnR5LmZyb21BcnJheSggYnVmZmVyLCBvZmZzZXQgKTtcblxuICAgIFx0XHRcdH0sXG5cbiAgICBcdFx0XHRmdW5jdGlvbiBzZXRWYWx1ZV9mcm9tQXJyYXlfc2V0TmVlZHNVcGRhdGUoIGJ1ZmZlciwgb2Zmc2V0ICkge1xuXG4gICAgXHRcdFx0XHR0aGlzLnJlc29sdmVkUHJvcGVydHkuZnJvbUFycmF5KCBidWZmZXIsIG9mZnNldCApO1xuICAgIFx0XHRcdFx0dGhpcy50YXJnZXRPYmplY3QubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgXHRcdFx0fSxcblxuICAgIFx0XHRcdGZ1bmN0aW9uIHNldFZhbHVlX2Zyb21BcnJheV9zZXRNYXRyaXhXb3JsZE5lZWRzVXBkYXRlKCBidWZmZXIsIG9mZnNldCApIHtcblxuICAgIFx0XHRcdFx0dGhpcy5yZXNvbHZlZFByb3BlcnR5LmZyb21BcnJheSggYnVmZmVyLCBvZmZzZXQgKTtcbiAgICBcdFx0XHRcdHRoaXMudGFyZ2V0T2JqZWN0Lm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdF1cblxuICAgIFx0XVxuXG4gICAgfSApO1xuXG4gICAgUHJvcGVydHlCaW5kaW5nLkNvbXBvc2l0ZSA9XG4gICAgXHRcdGZ1bmN0aW9uKCB0YXJnZXRHcm91cCwgcGF0aCwgb3B0aW9uYWxQYXJzZWRQYXRoICkge1xuXG4gICAgXHR2YXIgcGFyc2VkUGF0aCA9IG9wdGlvbmFsUGFyc2VkUGF0aCB8fFxuICAgIFx0XHRcdFByb3BlcnR5QmluZGluZy5wYXJzZVRyYWNrTmFtZSggcGF0aCApO1xuXG4gICAgXHR0aGlzLl90YXJnZXRHcm91cCA9IHRhcmdldEdyb3VwO1xuICAgIFx0dGhpcy5fYmluZGluZ3MgPSB0YXJnZXRHcm91cC5zdWJzY3JpYmVfKCBwYXRoLCBwYXJzZWRQYXRoICk7XG5cbiAgICB9O1xuXG4gICAgUHJvcGVydHlCaW5kaW5nLkNvbXBvc2l0ZS5wcm90b3R5cGUgPSB7XG5cbiAgICBcdGNvbnN0cnVjdG9yOiBQcm9wZXJ0eUJpbmRpbmcuQ29tcG9zaXRlLFxuXG4gICAgXHRnZXRWYWx1ZTogZnVuY3Rpb24oIGFycmF5LCBvZmZzZXQgKSB7XG5cbiAgICBcdFx0dGhpcy5iaW5kKCk7IC8vIGJpbmQgYWxsIGJpbmRpbmdcblxuICAgIFx0XHR2YXIgZmlyc3RWYWxpZEluZGV4ID0gdGhpcy5fdGFyZ2V0R3JvdXAubkNhY2hlZE9iamVjdHNfLFxuICAgIFx0XHRcdGJpbmRpbmcgPSB0aGlzLl9iaW5kaW5nc1sgZmlyc3RWYWxpZEluZGV4IF07XG5cbiAgICBcdFx0Ly8gYW5kIG9ubHkgY2FsbCAuZ2V0VmFsdWUgb24gdGhlIGZpcnN0XG4gICAgXHRcdGlmICggYmluZGluZyAhPT0gdW5kZWZpbmVkICkgYmluZGluZy5nZXRWYWx1ZSggYXJyYXksIG9mZnNldCApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRzZXRWYWx1ZTogZnVuY3Rpb24oIGFycmF5LCBvZmZzZXQgKSB7XG5cbiAgICBcdFx0dmFyIGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3M7XG5cbiAgICBcdFx0Zm9yICggdmFyIGkgPSB0aGlzLl90YXJnZXRHcm91cC5uQ2FjaGVkT2JqZWN0c18sXG4gICAgXHRcdFx0XHRuID0gYmluZGluZ3MubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xuXG4gICAgXHRcdFx0YmluZGluZ3NbIGkgXS5zZXRWYWx1ZSggYXJyYXksIG9mZnNldCApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0fSxcblxuICAgIFx0YmluZDogZnVuY3Rpb24oKSB7XG5cbiAgICBcdFx0dmFyIGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3M7XG5cbiAgICBcdFx0Zm9yICggdmFyIGkgPSB0aGlzLl90YXJnZXRHcm91cC5uQ2FjaGVkT2JqZWN0c18sXG4gICAgXHRcdFx0XHRuID0gYmluZGluZ3MubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xuXG4gICAgXHRcdFx0YmluZGluZ3NbIGkgXS5iaW5kKCk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9LFxuXG4gICAgXHR1bmJpbmQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgXHRcdHZhciBiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzO1xuXG4gICAgXHRcdGZvciAoIHZhciBpID0gdGhpcy5fdGFyZ2V0R3JvdXAubkNhY2hlZE9iamVjdHNfLFxuICAgIFx0XHRcdFx0biA9IGJpbmRpbmdzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcblxuICAgIFx0XHRcdGJpbmRpbmdzWyBpIF0udW5iaW5kKCk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9XG5cbiAgICB9O1xuXG4gICAgUHJvcGVydHlCaW5kaW5nLmNyZWF0ZSA9IGZ1bmN0aW9uKCByb290LCBwYXRoLCBwYXJzZWRQYXRoICkge1xuXG4gICAgXHRpZiAoICEgKCAocm9vdCAmJiByb290LmlzQW5pbWF0aW9uT2JqZWN0R3JvdXApICkgKSB7XG5cbiAgICBcdFx0cmV0dXJuIG5ldyBQcm9wZXJ0eUJpbmRpbmcoIHJvb3QsIHBhdGgsIHBhcnNlZFBhdGggKTtcblxuICAgIFx0fSBlbHNlIHtcblxuICAgIFx0XHRyZXR1cm4gbmV3IFByb3BlcnR5QmluZGluZy5Db21wb3NpdGUoIHJvb3QsIHBhdGgsIHBhcnNlZFBhdGggKTtcblxuICAgIFx0fVxuXG4gICAgfTtcblxuICAgIFByb3BlcnR5QmluZGluZy5wYXJzZVRyYWNrTmFtZSA9IGZ1bmN0aW9uKCB0cmFja05hbWUgKSB7XG5cbiAgICBcdC8vIG1hdGNoZXMgc3RyaW5ncyBpbiB0aGUgZm9ybSBvZjpcbiAgICBcdC8vICAgIG5vZGVOYW1lLnByb3BlcnR5XG4gICAgXHQvLyAgICBub2RlTmFtZS5wcm9wZXJ0eVthY2Nlc3Nvcl1cbiAgICBcdC8vICAgIG5vZGVOYW1lLm1hdGVyaWFsLnByb3BlcnR5W2FjY2Vzc29yXVxuICAgIFx0Ly8gICAgdXVpZC5wcm9wZXJ0eVthY2Nlc3Nvcl1cbiAgICBcdC8vICAgIHV1aWQub2JqZWN0TmFtZVtvYmplY3RJbmRleF0ucHJvcGVydHlOYW1lW3Byb3BlcnR5SW5kZXhdXG4gICAgXHQvLyAgICBwYXJlbnROYW1lL25vZGVOYW1lLnByb3BlcnR5XG4gICAgXHQvLyAgICBwYXJlbnROYW1lL3BhcmVudE5hbWUvbm9kZU5hbWUucHJvcGVydHlbaW5kZXhdXG4gICAgXHQvLyAgICAuYm9uZVtBcm1hdHVyZS5ERUZfY29nXS5wb3NpdGlvblxuICAgIFx0Ly8gICAgc2NlbmU6aGVsaXVtX2JhbGxvb25fbW9kZWw6aGVsaXVtX2JhbGxvb25fbW9kZWwucG9zaXRpb25cbiAgICBcdC8vIGNyZWF0ZWQgYW5kIHRlc3RlZCB2aWEgaHR0cHM6Ly9yZWdleDEwMS5jb20vI2phdmFzY3JpcHRcblxuICAgIFx0dmFyIHJlID0gL14oKD86XFx3K1tcXC86XSkqKShcXHcrKT8oPzpcXC4oXFx3KykoPzpcXFsoLispXFxdKT8pP1xcLihcXHcrKSg/OlxcWyguKylcXF0pPyQvO1xuICAgIFx0dmFyIG1hdGNoZXMgPSByZS5leGVjKCB0cmFja05hbWUgKTtcblxuICAgIFx0aWYgKCAhIG1hdGNoZXMgKSB7XG5cbiAgICBcdFx0dGhyb3cgbmV3IEVycm9yKCBcImNhbm5vdCBwYXJzZSB0cmFja05hbWUgYXQgYWxsOiBcIiArIHRyYWNrTmFtZSApO1xuXG4gICAgXHR9XG5cbiAgICBcdHZhciByZXN1bHRzID0ge1xuICAgIFx0XHQvLyBkaXJlY3RvcnlOYW1lOiBtYXRjaGVzWyAxIF0sIC8vICh0c2NodykgY3VycmVudGx5IHVudXNlZFxuICAgIFx0XHRub2RlTmFtZTogbWF0Y2hlc1sgMiBdLCBcdC8vIGFsbG93ZWQgdG8gYmUgbnVsbCwgc3BlY2lmaWVkIHJvb3Qgbm9kZS5cbiAgICBcdFx0b2JqZWN0TmFtZTogbWF0Y2hlc1sgMyBdLFxuICAgIFx0XHRvYmplY3RJbmRleDogbWF0Y2hlc1sgNCBdLFxuICAgIFx0XHRwcm9wZXJ0eU5hbWU6IG1hdGNoZXNbIDUgXSxcbiAgICBcdFx0cHJvcGVydHlJbmRleDogbWF0Y2hlc1sgNiBdXHQvLyBhbGxvd2VkIHRvIGJlIG51bGwsIHNwZWNpZmllcyB0aGF0IHRoZSB3aG9sZSBwcm9wZXJ0eSBpcyBzZXQuXG4gICAgXHR9O1xuXG4gICAgXHRpZiAoIHJlc3VsdHMucHJvcGVydHlOYW1lID09PSBudWxsIHx8IHJlc3VsdHMucHJvcGVydHlOYW1lLmxlbmd0aCA9PT0gMCApIHtcblxuICAgIFx0XHR0aHJvdyBuZXcgRXJyb3IoIFwiY2FuIG5vdCBwYXJzZSBwcm9wZXJ0eU5hbWUgZnJvbSB0cmFja05hbWU6IFwiICsgdHJhY2tOYW1lICk7XG5cbiAgICBcdH1cblxuICAgIFx0cmV0dXJuIHJlc3VsdHM7XG5cbiAgICB9O1xuXG4gICAgUHJvcGVydHlCaW5kaW5nLmZpbmROb2RlID0gZnVuY3Rpb24oIHJvb3QsIG5vZGVOYW1lICkge1xuXG4gICAgXHRpZiAoICEgbm9kZU5hbWUgfHwgbm9kZU5hbWUgPT09IFwiXCIgfHwgbm9kZU5hbWUgPT09IFwicm9vdFwiIHx8IG5vZGVOYW1lID09PSBcIi5cIiB8fCBub2RlTmFtZSA9PT0gLTEgfHwgbm9kZU5hbWUgPT09IHJvb3QubmFtZSB8fCBub2RlTmFtZSA9PT0gcm9vdC51dWlkICkge1xuXG4gICAgXHRcdHJldHVybiByb290O1xuXG4gICAgXHR9XG5cbiAgICBcdC8vIHNlYXJjaCBpbnRvIHNrZWxldG9uIGJvbmVzLlxuICAgIFx0aWYgKCByb290LnNrZWxldG9uICkge1xuXG4gICAgXHRcdHZhciBzZWFyY2hTa2VsZXRvbiA9IGZ1bmN0aW9uKCBza2VsZXRvbiApIHtcblxuICAgIFx0XHRcdGZvciggdmFyIGkgPSAwOyBpIDwgc2tlbGV0b24uYm9uZXMubGVuZ3RoOyBpICsrICkge1xuXG4gICAgXHRcdFx0XHR2YXIgYm9uZSA9IHNrZWxldG9uLmJvbmVzWyBpIF07XG5cbiAgICBcdFx0XHRcdGlmICggYm9uZS5uYW1lID09PSBub2RlTmFtZSApIHtcblxuICAgIFx0XHRcdFx0XHRyZXR1cm4gYm9uZTtcblxuICAgIFx0XHRcdFx0fVxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdHJldHVybiBudWxsO1xuXG4gICAgXHRcdH07XG5cbiAgICBcdFx0dmFyIGJvbmUgPSBzZWFyY2hTa2VsZXRvbiggcm9vdC5za2VsZXRvbiApO1xuXG4gICAgXHRcdGlmICggYm9uZSApIHtcblxuICAgIFx0XHRcdHJldHVybiBib25lO1xuXG4gICAgXHRcdH1cbiAgICBcdH1cblxuICAgIFx0Ly8gc2VhcmNoIGludG8gbm9kZSBzdWJ0cmVlLlxuICAgIFx0aWYgKCByb290LmNoaWxkcmVuICkge1xuXG4gICAgXHRcdHZhciBzZWFyY2hOb2RlU3VidHJlZSA9IGZ1bmN0aW9uKCBjaGlsZHJlbiApIHtcblxuICAgIFx0XHRcdGZvciggdmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpICsrICkge1xuXG4gICAgXHRcdFx0XHR2YXIgY2hpbGROb2RlID0gY2hpbGRyZW5bIGkgXTtcblxuICAgIFx0XHRcdFx0aWYgKCBjaGlsZE5vZGUubmFtZSA9PT0gbm9kZU5hbWUgfHwgY2hpbGROb2RlLnV1aWQgPT09IG5vZGVOYW1lICkge1xuXG4gICAgXHRcdFx0XHRcdHJldHVybiBjaGlsZE5vZGU7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0dmFyIHJlc3VsdCA9IHNlYXJjaE5vZGVTdWJ0cmVlKCBjaGlsZE5vZGUuY2hpbGRyZW4gKTtcblxuICAgIFx0XHRcdFx0aWYgKCByZXN1bHQgKSByZXR1cm4gcmVzdWx0O1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0cmV0dXJuIG51bGw7XG5cbiAgICBcdFx0fTtcblxuICAgIFx0XHR2YXIgc3ViVHJlZU5vZGUgPSBzZWFyY2hOb2RlU3VidHJlZSggcm9vdC5jaGlsZHJlbiApO1xuXG4gICAgXHRcdGlmICggc3ViVHJlZU5vZGUgKSB7XG5cbiAgICBcdFx0XHRyZXR1cm4gc3ViVHJlZU5vZGU7XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9XG5cbiAgICBcdHJldHVybiBudWxsO1xuXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQSBncm91cCBvZiBvYmplY3RzIHRoYXQgcmVjZWl2ZXMgYSBzaGFyZWQgYW5pbWF0aW9uIHN0YXRlLlxuICAgICAqXG4gICAgICogVXNhZ2U6XG4gICAgICpcbiAgICAgKiBcdC1cdEFkZCBvYmplY3RzIHlvdSB3b3VsZCBvdGhlcndpc2UgcGFzcyBhcyAncm9vdCcgdG8gdGhlXG4gICAgICogXHRcdGNvbnN0cnVjdG9yIG9yIHRoZSAuY2xpcEFjdGlvbiBtZXRob2Qgb2YgQW5pbWF0aW9uTWl4ZXIuXG4gICAgICpcbiAgICAgKiBcdC1cdEluc3RlYWQgcGFzcyB0aGlzIG9iamVjdCBhcyAncm9vdCcuXG4gICAgICpcbiAgICAgKiBcdC1cdFlvdSBjYW4gYWxzbyBhZGQgYW5kIHJlbW92ZSBvYmplY3RzIGxhdGVyIHdoZW4gdGhlIG1peGVyXG4gICAgICogXHRcdGlzIHJ1bm5pbmcuXG4gICAgICpcbiAgICAgKiBOb3RlOlxuICAgICAqXG4gICAgICogIFx0T2JqZWN0cyBvZiB0aGlzIGNsYXNzIGFwcGVhciBhcyBvbmUgb2JqZWN0IHRvIHRoZSBtaXhlcixcbiAgICAgKiAgXHRzbyBjYWNoZSBjb250cm9sIG9mIHRoZSBpbmRpdmlkdWFsIG9iamVjdHMgbXVzdCBiZSBkb25lXG4gICAgICogIFx0b24gdGhlIGdyb3VwLlxuICAgICAqXG4gICAgICogTGltaXRhdGlvbjpcbiAgICAgKlxuICAgICAqIFx0LSBcdFRoZSBhbmltYXRlZCBwcm9wZXJ0aWVzIG11c3QgYmUgY29tcGF0aWJsZSBhbW9uZyB0aGVcbiAgICAgKiBcdFx0YWxsIG9iamVjdHMgaW4gdGhlIGdyb3VwLlxuICAgICAqXG4gICAgICogIC1cdEEgc2luZ2xlIHByb3BlcnR5IGNhbiBlaXRoZXIgYmUgY29udHJvbGxlZCB0aHJvdWdoIGFcbiAgICAgKiAgXHR0YXJnZXQgZ3JvdXAgb3IgZGlyZWN0bHksIGJ1dCBub3QgYm90aC5cbiAgICAgKlxuICAgICAqIEBhdXRob3IgdHNjaHdcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIEFuaW1hdGlvbk9iamVjdEdyb3VwKCB2YXJfYXJncyApIHtcblxuICAgIFx0dGhpcy51dWlkID0gZXhwb3J0cy5NYXRoLmdlbmVyYXRlVVVJRCgpO1xuXG4gICAgXHQvLyBjYWNoZWQgb2JqZWN0cyBmb2xsb3dlZCBieSB0aGUgYWN0aXZlIG9uZXNcbiAgICBcdHRoaXMuX29iamVjdHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggYXJndW1lbnRzICk7XG5cbiAgICBcdHRoaXMubkNhY2hlZE9iamVjdHNfID0gMDtcdFx0XHQvLyB0aHJlc2hvbGRcbiAgICBcdC8vIG5vdGU6IHJlYWQgYnkgUHJvcGVydHlCaW5kaW5nLkNvbXBvc2l0ZVxuXG4gICAgXHR2YXIgaW5kaWNlcyA9IHt9O1xuICAgIFx0dGhpcy5faW5kaWNlc0J5VVVJRCA9IGluZGljZXM7XHRcdC8vIGZvciBib29ra2VlcGluZ1xuXG4gICAgXHRmb3IgKCB2YXIgaSA9IDAsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xuXG4gICAgXHRcdGluZGljZXNbIGFyZ3VtZW50c1sgaSBdLnV1aWQgXSA9IGk7XG5cbiAgICBcdH1cblxuICAgIFx0dGhpcy5fcGF0aHMgPSBbXTtcdFx0XHRcdFx0Ly8gaW5zaWRlOiBzdHJpbmdcbiAgICBcdHRoaXMuX3BhcnNlZFBhdGhzID0gW107XHRcdFx0XHQvLyBpbnNpZGU6IHsgd2UgZG9uJ3QgY2FyZSwgaGVyZSB9XG4gICAgXHR0aGlzLl9iaW5kaW5ncyA9IFtdOyBcdFx0XHRcdC8vIGluc2lkZTogQXJyYXk8IFByb3BlcnR5QmluZGluZyA+XG4gICAgXHR0aGlzLl9iaW5kaW5nc0luZGljZXNCeVBhdGggPSB7fTsgXHQvLyBpbnNpZGU6IGluZGljZXMgaW4gdGhlc2UgYXJyYXlzXG5cbiAgICBcdHZhciBzY29wZSA9IHRoaXM7XG5cbiAgICBcdHRoaXMuc3RhdHMgPSB7XG5cbiAgICBcdFx0b2JqZWN0czoge1xuICAgIFx0XHRcdGdldCB0b3RhbCgpIHsgcmV0dXJuIHNjb3BlLl9vYmplY3RzLmxlbmd0aDsgfSxcbiAgICBcdFx0XHRnZXQgaW5Vc2UoKSB7IHJldHVybiB0aGlzLnRvdGFsIC0gc2NvcGUubkNhY2hlZE9iamVjdHNfOyAgfVxuICAgIFx0XHR9LFxuXG4gICAgXHRcdGdldCBiaW5kaW5nc1Blck9iamVjdCgpIHsgcmV0dXJuIHNjb3BlLl9iaW5kaW5ncy5sZW5ndGg7IH1cblxuICAgIFx0fTtcblxuICAgIH1cblxuICAgIEFuaW1hdGlvbk9iamVjdEdyb3VwLnByb3RvdHlwZSA9IHtcblxuICAgIFx0Y29uc3RydWN0b3I6IEFuaW1hdGlvbk9iamVjdEdyb3VwLFxuXG4gICAgXHRpc0FuaW1hdGlvbk9iamVjdEdyb3VwOiB0cnVlLFxuXG4gICAgXHRhZGQ6IGZ1bmN0aW9uKCB2YXJfYXJncyApIHtcblxuICAgIFx0XHR2YXIgb2JqZWN0cyA9IHRoaXMuX29iamVjdHMsXG4gICAgXHRcdFx0bk9iamVjdHMgPSBvYmplY3RzLmxlbmd0aCxcbiAgICBcdFx0XHRuQ2FjaGVkT2JqZWN0cyA9IHRoaXMubkNhY2hlZE9iamVjdHNfLFxuICAgIFx0XHRcdGluZGljZXNCeVVVSUQgPSB0aGlzLl9pbmRpY2VzQnlVVUlELFxuICAgIFx0XHRcdHBhdGhzID0gdGhpcy5fcGF0aHMsXG4gICAgXHRcdFx0cGFyc2VkUGF0aHMgPSB0aGlzLl9wYXJzZWRQYXRocyxcbiAgICBcdFx0XHRiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzLFxuICAgIFx0XHRcdG5CaW5kaW5ncyA9IGJpbmRpbmdzLmxlbmd0aDtcblxuICAgIFx0XHRmb3IgKCB2YXIgaSA9IDAsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xuXG4gICAgXHRcdFx0dmFyIG9iamVjdCA9IGFyZ3VtZW50c1sgaSBdLFxuICAgIFx0XHRcdFx0dXVpZCA9IG9iamVjdC51dWlkLFxuICAgIFx0XHRcdFx0aW5kZXggPSBpbmRpY2VzQnlVVUlEWyB1dWlkIF07XG5cbiAgICBcdFx0XHRpZiAoIGluZGV4ID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRcdC8vIHVua25vd24gb2JqZWN0IC0+IGFkZCBpdCB0byB0aGUgQUNUSVZFIHJlZ2lvblxuXG4gICAgXHRcdFx0XHRpbmRleCA9IG5PYmplY3RzICsrO1xuICAgIFx0XHRcdFx0aW5kaWNlc0J5VVVJRFsgdXVpZCBdID0gaW5kZXg7XG4gICAgXHRcdFx0XHRvYmplY3RzLnB1c2goIG9iamVjdCApO1xuXG4gICAgXHRcdFx0XHQvLyBhY2NvdW50aW5nIGlzIGRvbmUsIG5vdyBkbyB0aGUgc2FtZSBmb3IgYWxsIGJpbmRpbmdzXG5cbiAgICBcdFx0XHRcdGZvciAoIHZhciBqID0gMCwgbSA9IG5CaW5kaW5nczsgaiAhPT0gbTsgKysgaiApIHtcblxuICAgIFx0XHRcdFx0XHRiaW5kaW5nc1sgaiBdLnB1c2goXG4gICAgXHRcdFx0XHRcdFx0XHRuZXcgUHJvcGVydHlCaW5kaW5nKFxuICAgIFx0XHRcdFx0XHRcdFx0XHRvYmplY3QsIHBhdGhzWyBqIF0sIHBhcnNlZFBhdGhzWyBqIF0gKSApO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHR9IGVsc2UgaWYgKCBpbmRleCA8IG5DYWNoZWRPYmplY3RzICkge1xuXG4gICAgXHRcdFx0XHR2YXIga25vd25PYmplY3QgPSBvYmplY3RzWyBpbmRleCBdO1xuXG4gICAgXHRcdFx0XHQvLyBtb3ZlIGV4aXN0aW5nIG9iamVjdCB0byB0aGUgQUNUSVZFIHJlZ2lvblxuXG4gICAgXHRcdFx0XHR2YXIgZmlyc3RBY3RpdmVJbmRleCA9IC0tIG5DYWNoZWRPYmplY3RzLFxuICAgIFx0XHRcdFx0XHRsYXN0Q2FjaGVkT2JqZWN0ID0gb2JqZWN0c1sgZmlyc3RBY3RpdmVJbmRleCBdO1xuXG4gICAgXHRcdFx0XHRpbmRpY2VzQnlVVUlEWyBsYXN0Q2FjaGVkT2JqZWN0LnV1aWQgXSA9IGluZGV4O1xuICAgIFx0XHRcdFx0b2JqZWN0c1sgaW5kZXggXSA9IGxhc3RDYWNoZWRPYmplY3Q7XG5cbiAgICBcdFx0XHRcdGluZGljZXNCeVVVSURbIHV1aWQgXSA9IGZpcnN0QWN0aXZlSW5kZXg7XG4gICAgXHRcdFx0XHRvYmplY3RzWyBmaXJzdEFjdGl2ZUluZGV4IF0gPSBvYmplY3Q7XG5cbiAgICBcdFx0XHRcdC8vIGFjY291bnRpbmcgaXMgZG9uZSwgbm93IGRvIHRoZSBzYW1lIGZvciBhbGwgYmluZGluZ3NcblxuICAgIFx0XHRcdFx0Zm9yICggdmFyIGogPSAwLCBtID0gbkJpbmRpbmdzOyBqICE9PSBtOyArKyBqICkge1xuXG4gICAgXHRcdFx0XHRcdHZhciBiaW5kaW5nc0ZvclBhdGggPSBiaW5kaW5nc1sgaiBdLFxuICAgIFx0XHRcdFx0XHRcdGxhc3RDYWNoZWQgPSBiaW5kaW5nc0ZvclBhdGhbIGZpcnN0QWN0aXZlSW5kZXggXSxcbiAgICBcdFx0XHRcdFx0XHRiaW5kaW5nID0gYmluZGluZ3NGb3JQYXRoWyBpbmRleCBdO1xuXG4gICAgXHRcdFx0XHRcdGJpbmRpbmdzRm9yUGF0aFsgaW5kZXggXSA9IGxhc3RDYWNoZWQ7XG5cbiAgICBcdFx0XHRcdFx0aWYgKCBiaW5kaW5nID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHQvLyBzaW5jZSB3ZSBkbyBub3QgYm90aGVyIHRvIGNyZWF0ZSBuZXcgYmluZGluZ3NcbiAgICBcdFx0XHRcdFx0XHQvLyBmb3Igb2JqZWN0cyB0aGF0IGFyZSBjYWNoZWQsIHRoZSBiaW5kaW5nIG1heVxuICAgIFx0XHRcdFx0XHRcdC8vIG9yIG1heSBub3QgZXhpc3RcblxuICAgIFx0XHRcdFx0XHRcdGJpbmRpbmcgPSBuZXcgUHJvcGVydHlCaW5kaW5nKFxuICAgIFx0XHRcdFx0XHRcdFx0XHRvYmplY3QsIHBhdGhzWyBqIF0sIHBhcnNlZFBhdGhzWyBqIF0gKTtcblxuICAgIFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdFx0YmluZGluZ3NGb3JQYXRoWyBmaXJzdEFjdGl2ZUluZGV4IF0gPSBiaW5kaW5nO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHR9IGVsc2UgaWYgKCBvYmplY3RzWyBpbmRleCBdICE9PSBrbm93bk9iamVjdCkge1xuXG4gICAgXHRcdFx0XHRjb25zb2xlLmVycm9yKCBcIkRpZmZlcmVudCBvYmplY3RzIHdpdGggdGhlIHNhbWUgVVVJRCBcIiArXG4gICAgXHRcdFx0XHRcdFx0XCJkZXRlY3RlZC4gQ2xlYW4gdGhlIGNhY2hlcyBvciByZWNyZWF0ZSB5b3VyIFwiICtcbiAgICBcdFx0XHRcdFx0XHRcImluZnJhc3RydWN0dXJlIHdoZW4gcmVsb2FkaW5nIHNjZW5lcy4uLlwiICk7XG5cbiAgICBcdFx0XHR9IC8vIGVsc2UgdGhlIG9iamVjdCBpcyBhbHJlYWR5IHdoZXJlIHdlIHdhbnQgaXQgdG8gYmVcblxuICAgIFx0XHR9IC8vIGZvciBhcmd1bWVudHNcblxuICAgIFx0XHR0aGlzLm5DYWNoZWRPYmplY3RzXyA9IG5DYWNoZWRPYmplY3RzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRyZW1vdmU6IGZ1bmN0aW9uKCB2YXJfYXJncyApIHtcblxuICAgIFx0XHR2YXIgb2JqZWN0cyA9IHRoaXMuX29iamVjdHMsXG4gICAgXHRcdFx0bkNhY2hlZE9iamVjdHMgPSB0aGlzLm5DYWNoZWRPYmplY3RzXyxcbiAgICBcdFx0XHRpbmRpY2VzQnlVVUlEID0gdGhpcy5faW5kaWNlc0J5VVVJRCxcbiAgICBcdFx0XHRiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzLFxuICAgIFx0XHRcdG5CaW5kaW5ncyA9IGJpbmRpbmdzLmxlbmd0aDtcblxuICAgIFx0XHRmb3IgKCB2YXIgaSA9IDAsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xuXG4gICAgXHRcdFx0dmFyIG9iamVjdCA9IGFyZ3VtZW50c1sgaSBdLFxuICAgIFx0XHRcdFx0dXVpZCA9IG9iamVjdC51dWlkLFxuICAgIFx0XHRcdFx0aW5kZXggPSBpbmRpY2VzQnlVVUlEWyB1dWlkIF07XG5cbiAgICBcdFx0XHRpZiAoIGluZGV4ICE9PSB1bmRlZmluZWQgJiYgaW5kZXggPj0gbkNhY2hlZE9iamVjdHMgKSB7XG5cbiAgICBcdFx0XHRcdC8vIG1vdmUgZXhpc3Rpbmcgb2JqZWN0IGludG8gdGhlIENBQ0hFRCByZWdpb25cblxuICAgIFx0XHRcdFx0dmFyIGxhc3RDYWNoZWRJbmRleCA9IG5DYWNoZWRPYmplY3RzICsrLFxuICAgIFx0XHRcdFx0XHRmaXJzdEFjdGl2ZU9iamVjdCA9IG9iamVjdHNbIGxhc3RDYWNoZWRJbmRleCBdO1xuXG4gICAgXHRcdFx0XHRpbmRpY2VzQnlVVUlEWyBmaXJzdEFjdGl2ZU9iamVjdC51dWlkIF0gPSBpbmRleDtcbiAgICBcdFx0XHRcdG9iamVjdHNbIGluZGV4IF0gPSBmaXJzdEFjdGl2ZU9iamVjdDtcblxuICAgIFx0XHRcdFx0aW5kaWNlc0J5VVVJRFsgdXVpZCBdID0gbGFzdENhY2hlZEluZGV4O1xuICAgIFx0XHRcdFx0b2JqZWN0c1sgbGFzdENhY2hlZEluZGV4IF0gPSBvYmplY3Q7XG5cbiAgICBcdFx0XHRcdC8vIGFjY291bnRpbmcgaXMgZG9uZSwgbm93IGRvIHRoZSBzYW1lIGZvciBhbGwgYmluZGluZ3NcblxuICAgIFx0XHRcdFx0Zm9yICggdmFyIGogPSAwLCBtID0gbkJpbmRpbmdzOyBqICE9PSBtOyArKyBqICkge1xuXG4gICAgXHRcdFx0XHRcdHZhciBiaW5kaW5nc0ZvclBhdGggPSBiaW5kaW5nc1sgaiBdLFxuICAgIFx0XHRcdFx0XHRcdGZpcnN0QWN0aXZlID0gYmluZGluZ3NGb3JQYXRoWyBsYXN0Q2FjaGVkSW5kZXggXSxcbiAgICBcdFx0XHRcdFx0XHRiaW5kaW5nID0gYmluZGluZ3NGb3JQYXRoWyBpbmRleCBdO1xuXG4gICAgXHRcdFx0XHRcdGJpbmRpbmdzRm9yUGF0aFsgaW5kZXggXSA9IGZpcnN0QWN0aXZlO1xuICAgIFx0XHRcdFx0XHRiaW5kaW5nc0ZvclBhdGhbIGxhc3RDYWNoZWRJbmRleCBdID0gYmluZGluZztcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH0gLy8gZm9yIGFyZ3VtZW50c1xuXG4gICAgXHRcdHRoaXMubkNhY2hlZE9iamVjdHNfID0gbkNhY2hlZE9iamVjdHM7XG5cbiAgICBcdH0sXG5cbiAgICBcdC8vIHJlbW92ZSAmIGZvcmdldFxuICAgIFx0dW5jYWNoZTogZnVuY3Rpb24oIHZhcl9hcmdzICkge1xuXG4gICAgXHRcdHZhciBvYmplY3RzID0gdGhpcy5fb2JqZWN0cyxcbiAgICBcdFx0XHRuT2JqZWN0cyA9IG9iamVjdHMubGVuZ3RoLFxuICAgIFx0XHRcdG5DYWNoZWRPYmplY3RzID0gdGhpcy5uQ2FjaGVkT2JqZWN0c18sXG4gICAgXHRcdFx0aW5kaWNlc0J5VVVJRCA9IHRoaXMuX2luZGljZXNCeVVVSUQsXG4gICAgXHRcdFx0YmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncyxcbiAgICBcdFx0XHRuQmluZGluZ3MgPSBiaW5kaW5ncy5sZW5ndGg7XG5cbiAgICBcdFx0Zm9yICggdmFyIGkgPSAwLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcblxuICAgIFx0XHRcdHZhciBvYmplY3QgPSBhcmd1bWVudHNbIGkgXSxcbiAgICBcdFx0XHRcdHV1aWQgPSBvYmplY3QudXVpZCxcbiAgICBcdFx0XHRcdGluZGV4ID0gaW5kaWNlc0J5VVVJRFsgdXVpZCBdO1xuXG4gICAgXHRcdFx0aWYgKCBpbmRleCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0XHRkZWxldGUgaW5kaWNlc0J5VVVJRFsgdXVpZCBdO1xuXG4gICAgXHRcdFx0XHRpZiAoIGluZGV4IDwgbkNhY2hlZE9iamVjdHMgKSB7XG5cbiAgICBcdFx0XHRcdFx0Ly8gb2JqZWN0IGlzIGNhY2hlZCwgc2hyaW5rIHRoZSBDQUNIRUQgcmVnaW9uXG5cbiAgICBcdFx0XHRcdFx0dmFyIGZpcnN0QWN0aXZlSW5kZXggPSAtLSBuQ2FjaGVkT2JqZWN0cyxcbiAgICBcdFx0XHRcdFx0XHRsYXN0Q2FjaGVkT2JqZWN0ID0gb2JqZWN0c1sgZmlyc3RBY3RpdmVJbmRleCBdLFxuICAgIFx0XHRcdFx0XHRcdGxhc3RJbmRleCA9IC0tIG5PYmplY3RzLFxuICAgIFx0XHRcdFx0XHRcdGxhc3RPYmplY3QgPSBvYmplY3RzWyBsYXN0SW5kZXggXTtcblxuICAgIFx0XHRcdFx0XHQvLyBsYXN0IGNhY2hlZCBvYmplY3QgdGFrZXMgdGhpcyBvYmplY3QncyBwbGFjZVxuICAgIFx0XHRcdFx0XHRpbmRpY2VzQnlVVUlEWyBsYXN0Q2FjaGVkT2JqZWN0LnV1aWQgXSA9IGluZGV4O1xuICAgIFx0XHRcdFx0XHRvYmplY3RzWyBpbmRleCBdID0gbGFzdENhY2hlZE9iamVjdDtcblxuICAgIFx0XHRcdFx0XHQvLyBsYXN0IG9iamVjdCBnb2VzIHRvIHRoZSBhY3RpdmF0ZWQgc2xvdCBhbmQgcG9wXG4gICAgXHRcdFx0XHRcdGluZGljZXNCeVVVSURbIGxhc3RPYmplY3QudXVpZCBdID0gZmlyc3RBY3RpdmVJbmRleDtcbiAgICBcdFx0XHRcdFx0b2JqZWN0c1sgZmlyc3RBY3RpdmVJbmRleCBdID0gbGFzdE9iamVjdDtcbiAgICBcdFx0XHRcdFx0b2JqZWN0cy5wb3AoKTtcblxuICAgIFx0XHRcdFx0XHQvLyBhY2NvdW50aW5nIGlzIGRvbmUsIG5vdyBkbyB0aGUgc2FtZSBmb3IgYWxsIGJpbmRpbmdzXG5cbiAgICBcdFx0XHRcdFx0Zm9yICggdmFyIGogPSAwLCBtID0gbkJpbmRpbmdzOyBqICE9PSBtOyArKyBqICkge1xuXG4gICAgXHRcdFx0XHRcdFx0dmFyIGJpbmRpbmdzRm9yUGF0aCA9IGJpbmRpbmdzWyBqIF0sXG4gICAgXHRcdFx0XHRcdFx0XHRsYXN0Q2FjaGVkID0gYmluZGluZ3NGb3JQYXRoWyBmaXJzdEFjdGl2ZUluZGV4IF0sXG4gICAgXHRcdFx0XHRcdFx0XHRsYXN0ID0gYmluZGluZ3NGb3JQYXRoWyBsYXN0SW5kZXggXTtcblxuICAgIFx0XHRcdFx0XHRcdGJpbmRpbmdzRm9yUGF0aFsgaW5kZXggXSA9IGxhc3RDYWNoZWQ7XG4gICAgXHRcdFx0XHRcdFx0YmluZGluZ3NGb3JQYXRoWyBmaXJzdEFjdGl2ZUluZGV4IF0gPSBsYXN0O1xuICAgIFx0XHRcdFx0XHRcdGJpbmRpbmdzRm9yUGF0aC5wb3AoKTtcblxuICAgIFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdFx0Ly8gb2JqZWN0IGlzIGFjdGl2ZSwganVzdCBzd2FwIHdpdGggdGhlIGxhc3QgYW5kIHBvcFxuXG4gICAgXHRcdFx0XHRcdHZhciBsYXN0SW5kZXggPSAtLSBuT2JqZWN0cyxcbiAgICBcdFx0XHRcdFx0XHRsYXN0T2JqZWN0ID0gb2JqZWN0c1sgbGFzdEluZGV4IF07XG5cbiAgICBcdFx0XHRcdFx0aW5kaWNlc0J5VVVJRFsgbGFzdE9iamVjdC51dWlkIF0gPSBpbmRleDtcbiAgICBcdFx0XHRcdFx0b2JqZWN0c1sgaW5kZXggXSA9IGxhc3RPYmplY3Q7XG4gICAgXHRcdFx0XHRcdG9iamVjdHMucG9wKCk7XG5cbiAgICBcdFx0XHRcdFx0Ly8gYWNjb3VudGluZyBpcyBkb25lLCBub3cgZG8gdGhlIHNhbWUgZm9yIGFsbCBiaW5kaW5nc1xuXG4gICAgXHRcdFx0XHRcdGZvciAoIHZhciBqID0gMCwgbSA9IG5CaW5kaW5nczsgaiAhPT0gbTsgKysgaiApIHtcblxuICAgIFx0XHRcdFx0XHRcdHZhciBiaW5kaW5nc0ZvclBhdGggPSBiaW5kaW5nc1sgaiBdO1xuXG4gICAgXHRcdFx0XHRcdFx0YmluZGluZ3NGb3JQYXRoWyBpbmRleCBdID0gYmluZGluZ3NGb3JQYXRoWyBsYXN0SW5kZXggXTtcbiAgICBcdFx0XHRcdFx0XHRiaW5kaW5nc0ZvclBhdGgucG9wKCk7XG5cbiAgICBcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHR9IC8vIGNhY2hlZCBvciBhY3RpdmVcblxuICAgIFx0XHRcdH0gLy8gaWYgb2JqZWN0IGlzIGtub3duXG5cbiAgICBcdFx0fSAvLyBmb3IgYXJndW1lbnRzXG5cbiAgICBcdFx0dGhpcy5uQ2FjaGVkT2JqZWN0c18gPSBuQ2FjaGVkT2JqZWN0cztcblxuICAgIFx0fSxcblxuICAgIFx0Ly8gSW50ZXJuYWwgaW50ZXJmYWNlIHVzZWQgYnkgYmVmcmllbmRlZCBQcm9wZXJ0eUJpbmRpbmcuQ29tcG9zaXRlOlxuXG4gICAgXHRzdWJzY3JpYmVfOiBmdW5jdGlvbiggcGF0aCwgcGFyc2VkUGF0aCApIHtcbiAgICBcdFx0Ly8gcmV0dXJucyBhbiBhcnJheSBvZiBiaW5kaW5ncyBmb3IgdGhlIGdpdmVuIHBhdGggdGhhdCBpcyBjaGFuZ2VkXG4gICAgXHRcdC8vIGFjY29yZGluZyB0byB0aGUgY29udGFpbmVkIG9iamVjdHMgaW4gdGhlIGdyb3VwXG5cbiAgICBcdFx0dmFyIGluZGljZXNCeVBhdGggPSB0aGlzLl9iaW5kaW5nc0luZGljZXNCeVBhdGgsXG4gICAgXHRcdFx0aW5kZXggPSBpbmRpY2VzQnlQYXRoWyBwYXRoIF0sXG4gICAgXHRcdFx0YmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncztcblxuICAgIFx0XHRpZiAoIGluZGV4ICE9PSB1bmRlZmluZWQgKSByZXR1cm4gYmluZGluZ3NbIGluZGV4IF07XG5cbiAgICBcdFx0dmFyIHBhdGhzID0gdGhpcy5fcGF0aHMsXG4gICAgXHRcdFx0cGFyc2VkUGF0aHMgPSB0aGlzLl9wYXJzZWRQYXRocyxcbiAgICBcdFx0XHRvYmplY3RzID0gdGhpcy5fb2JqZWN0cyxcbiAgICBcdFx0XHRuT2JqZWN0cyA9IG9iamVjdHMubGVuZ3RoLFxuICAgIFx0XHRcdG5DYWNoZWRPYmplY3RzID0gdGhpcy5uQ2FjaGVkT2JqZWN0c18sXG4gICAgXHRcdFx0YmluZGluZ3NGb3JQYXRoID0gbmV3IEFycmF5KCBuT2JqZWN0cyApO1xuXG4gICAgXHRcdGluZGV4ID0gYmluZGluZ3MubGVuZ3RoO1xuXG4gICAgXHRcdGluZGljZXNCeVBhdGhbIHBhdGggXSA9IGluZGV4O1xuXG4gICAgXHRcdHBhdGhzLnB1c2goIHBhdGggKTtcbiAgICBcdFx0cGFyc2VkUGF0aHMucHVzaCggcGFyc2VkUGF0aCApO1xuICAgIFx0XHRiaW5kaW5ncy5wdXNoKCBiaW5kaW5nc0ZvclBhdGggKTtcblxuICAgIFx0XHRmb3IgKCB2YXIgaSA9IG5DYWNoZWRPYmplY3RzLFxuICAgIFx0XHRcdFx0biA9IG9iamVjdHMubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xuXG4gICAgXHRcdFx0dmFyIG9iamVjdCA9IG9iamVjdHNbIGkgXTtcblxuICAgIFx0XHRcdGJpbmRpbmdzRm9yUGF0aFsgaSBdID1cbiAgICBcdFx0XHRcdFx0bmV3IFByb3BlcnR5QmluZGluZyggb2JqZWN0LCBwYXRoLCBwYXJzZWRQYXRoICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiBiaW5kaW5nc0ZvclBhdGg7XG5cbiAgICBcdH0sXG5cbiAgICBcdHVuc3Vic2NyaWJlXzogZnVuY3Rpb24oIHBhdGggKSB7XG4gICAgXHRcdC8vIHRlbGxzIHRoZSBncm91cCB0byBmb3JnZXQgYWJvdXQgYSBwcm9wZXJ0eSBwYXRoIGFuZCBubyBsb25nZXJcbiAgICBcdFx0Ly8gdXBkYXRlIHRoZSBhcnJheSBwcmV2aW91c2x5IG9idGFpbmVkIHdpdGggJ3N1YnNjcmliZV8nXG5cbiAgICBcdFx0dmFyIGluZGljZXNCeVBhdGggPSB0aGlzLl9iaW5kaW5nc0luZGljZXNCeVBhdGgsXG4gICAgXHRcdFx0aW5kZXggPSBpbmRpY2VzQnlQYXRoWyBwYXRoIF07XG5cbiAgICBcdFx0aWYgKCBpbmRleCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0dmFyIHBhdGhzID0gdGhpcy5fcGF0aHMsXG4gICAgXHRcdFx0XHRwYXJzZWRQYXRocyA9IHRoaXMuX3BhcnNlZFBhdGhzLFxuICAgIFx0XHRcdFx0YmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncyxcbiAgICBcdFx0XHRcdGxhc3RCaW5kaW5nc0luZGV4ID0gYmluZGluZ3MubGVuZ3RoIC0gMSxcbiAgICBcdFx0XHRcdGxhc3RCaW5kaW5ncyA9IGJpbmRpbmdzWyBsYXN0QmluZGluZ3NJbmRleCBdLFxuICAgIFx0XHRcdFx0bGFzdEJpbmRpbmdzUGF0aCA9IHBhdGhbIGxhc3RCaW5kaW5nc0luZGV4IF07XG5cbiAgICBcdFx0XHRpbmRpY2VzQnlQYXRoWyBsYXN0QmluZGluZ3NQYXRoIF0gPSBpbmRleDtcblxuICAgIFx0XHRcdGJpbmRpbmdzWyBpbmRleCBdID0gbGFzdEJpbmRpbmdzO1xuICAgIFx0XHRcdGJpbmRpbmdzLnBvcCgpO1xuXG4gICAgXHRcdFx0cGFyc2VkUGF0aHNbIGluZGV4IF0gPSBwYXJzZWRQYXRoc1sgbGFzdEJpbmRpbmdzSW5kZXggXTtcbiAgICBcdFx0XHRwYXJzZWRQYXRocy5wb3AoKTtcblxuICAgIFx0XHRcdHBhdGhzWyBpbmRleCBdID0gcGF0aHNbIGxhc3RCaW5kaW5nc0luZGV4IF07XG4gICAgXHRcdFx0cGF0aHMucG9wKCk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9XG5cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBBY3Rpb24gcHJvdmlkZWQgYnkgQW5pbWF0aW9uTWl4ZXIgZm9yIHNjaGVkdWxpbmcgY2xpcCBwbGF5YmFjayBvbiBzcGVjaWZpY1xuICAgICAqIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAYXV0aG9yIEJlbiBIb3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvL1xuICAgICAqIEBhdXRob3IgRGF2aWQgU2Fybm8gLyBodHRwOi8vbGlnaHRoYXVzLnVzL1xuICAgICAqIEBhdXRob3IgdHNjaHdcbiAgICAgKlxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gQW5pbWF0aW9uQWN0aW9uKCBtaXhlciwgY2xpcCwgbG9jYWxSb290ICkge1xuXG4gICAgXHR0aGlzLl9taXhlciA9IG1peGVyO1xuICAgIFx0dGhpcy5fY2xpcCA9IGNsaXA7XG4gICAgXHR0aGlzLl9sb2NhbFJvb3QgPSBsb2NhbFJvb3QgfHwgbnVsbDtcblxuICAgIFx0dmFyIHRyYWNrcyA9IGNsaXAudHJhY2tzLFxuICAgIFx0XHRuVHJhY2tzID0gdHJhY2tzLmxlbmd0aCxcbiAgICBcdFx0aW50ZXJwb2xhbnRzID0gbmV3IEFycmF5KCBuVHJhY2tzICk7XG5cbiAgICBcdHZhciBpbnRlcnBvbGFudFNldHRpbmdzID0ge1xuICAgIFx0XHRcdGVuZGluZ1N0YXJ0OiBcdFplcm9DdXJ2YXR1cmVFbmRpbmcsXG4gICAgXHRcdFx0ZW5kaW5nRW5kOlx0XHRaZXJvQ3VydmF0dXJlRW5kaW5nXG4gICAgXHR9O1xuXG4gICAgXHRmb3IgKCB2YXIgaSA9IDA7IGkgIT09IG5UcmFja3M7ICsrIGkgKSB7XG5cbiAgICBcdFx0dmFyIGludGVycG9sYW50ID0gdHJhY2tzWyBpIF0uY3JlYXRlSW50ZXJwb2xhbnQoIG51bGwgKTtcbiAgICBcdFx0aW50ZXJwb2xhbnRzWyBpIF0gPSBpbnRlcnBvbGFudDtcbiAgICBcdFx0aW50ZXJwb2xhbnQuc2V0dGluZ3MgPSBpbnRlcnBvbGFudFNldHRpbmdzO1xuXG4gICAgXHR9XG5cbiAgICBcdHRoaXMuX2ludGVycG9sYW50U2V0dGluZ3MgPSBpbnRlcnBvbGFudFNldHRpbmdzO1xuXG4gICAgXHR0aGlzLl9pbnRlcnBvbGFudHMgPSBpbnRlcnBvbGFudHM7XHQvLyBib3VuZCBieSB0aGUgbWl4ZXJcblxuICAgIFx0Ly8gaW5zaWRlOiBQcm9wZXJ0eU1peGVyIChtYW5hZ2VkIGJ5IHRoZSBtaXhlcilcbiAgICBcdHRoaXMuX3Byb3BlcnR5QmluZGluZ3MgPSBuZXcgQXJyYXkoIG5UcmFja3MgKTtcblxuICAgIFx0dGhpcy5fY2FjaGVJbmRleCA9IG51bGw7XHRcdFx0Ly8gZm9yIHRoZSBtZW1vcnkgbWFuYWdlclxuICAgIFx0dGhpcy5fYnlDbGlwQ2FjaGVJbmRleCA9IG51bGw7XHRcdC8vIGZvciB0aGUgbWVtb3J5IG1hbmFnZXJcblxuICAgIFx0dGhpcy5fdGltZVNjYWxlSW50ZXJwb2xhbnQgPSBudWxsO1xuICAgIFx0dGhpcy5fd2VpZ2h0SW50ZXJwb2xhbnQgPSBudWxsO1xuXG4gICAgXHR0aGlzLmxvb3AgPSBMb29wUmVwZWF0O1xuICAgIFx0dGhpcy5fbG9vcENvdW50ID0gLTE7XG5cbiAgICBcdC8vIGdsb2JhbCBtaXhlciB0aW1lIHdoZW4gdGhlIGFjdGlvbiBpcyB0byBiZSBzdGFydGVkXG4gICAgXHQvLyBpdCdzIHNldCBiYWNrIHRvICdudWxsJyB1cG9uIHN0YXJ0IG9mIHRoZSBhY3Rpb25cbiAgICBcdHRoaXMuX3N0YXJ0VGltZSA9IG51bGw7XG5cbiAgICBcdC8vIHNjYWxlZCBsb2NhbCB0aW1lIG9mIHRoZSBhY3Rpb25cbiAgICBcdC8vIGdldHMgY2xhbXBlZCBvciB3cmFwcGVkIHRvIDAuLmNsaXAuZHVyYXRpb24gYWNjb3JkaW5nIHRvIGxvb3BcbiAgICBcdHRoaXMudGltZSA9IDA7XG5cbiAgICBcdHRoaXMudGltZVNjYWxlID0gMTtcbiAgICBcdHRoaXMuX2VmZmVjdGl2ZVRpbWVTY2FsZSA9IDE7XG5cbiAgICBcdHRoaXMud2VpZ2h0ID0gMTtcbiAgICBcdHRoaXMuX2VmZmVjdGl2ZVdlaWdodCA9IDE7XG5cbiAgICBcdHRoaXMucmVwZXRpdGlvbnMgPSBJbmZpbml0eTsgXHRcdC8vIG5vLiBvZiByZXBldGl0aW9ucyB3aGVuIGxvb3BpbmdcblxuICAgIFx0dGhpcy5wYXVzZWQgPSBmYWxzZTtcdFx0XHRcdC8vIGZhbHNlIC0+IHplcm8gZWZmZWN0aXZlIHRpbWUgc2NhbGVcbiAgICBcdHRoaXMuZW5hYmxlZCA9IHRydWU7XHRcdFx0XHQvLyB0cnVlIC0+IHplcm8gZWZmZWN0aXZlIHdlaWdodFxuXG4gICAgXHR0aGlzLmNsYW1wV2hlbkZpbmlzaGVkIFx0PSBmYWxzZTtcdC8vIGtlZXAgZmVlZGluZyB0aGUgbGFzdCBmcmFtZT9cblxuICAgIFx0dGhpcy56ZXJvU2xvcGVBdFN0YXJ0IFx0PSB0cnVlO1x0XHQvLyBmb3Igc21vb3RoIGludGVycG9sYXRpb24gdy9vIHNlcGFyYXRlXG4gICAgXHR0aGlzLnplcm9TbG9wZUF0RW5kXHRcdD0gdHJ1ZTtcdFx0Ly8gY2xpcHMgZm9yIHN0YXJ0LCBsb29wIGFuZCBlbmRcblxuICAgIH07XG5cbiAgICBBbmltYXRpb25BY3Rpb24ucHJvdG90eXBlID0ge1xuXG4gICAgXHRjb25zdHJ1Y3RvcjogQW5pbWF0aW9uQWN0aW9uLFxuXG4gICAgXHQvLyBTdGF0ZSAmIFNjaGVkdWxpbmdcblxuICAgIFx0cGxheTogZnVuY3Rpb24oKSB7XG5cbiAgICBcdFx0dGhpcy5fbWl4ZXIuX2FjdGl2YXRlQWN0aW9uKCB0aGlzICk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdHN0b3A6IGZ1bmN0aW9uKCkge1xuXG4gICAgXHRcdHRoaXMuX21peGVyLl9kZWFjdGl2YXRlQWN0aW9uKCB0aGlzICk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMucmVzZXQoKTtcblxuICAgIFx0fSxcblxuICAgIFx0cmVzZXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgXHRcdHRoaXMucGF1c2VkID0gZmFsc2U7XG4gICAgXHRcdHRoaXMuZW5hYmxlZCA9IHRydWU7XG5cbiAgICBcdFx0dGhpcy50aW1lID0gMDtcdFx0XHQvLyByZXN0YXJ0IGNsaXBcbiAgICBcdFx0dGhpcy5fbG9vcENvdW50ID0gLTE7XHQvLyBmb3JnZXQgcHJldmlvdXMgbG9vcHNcbiAgICBcdFx0dGhpcy5fc3RhcnRUaW1lID0gbnVsbDtcdC8vIGZvcmdldCBzY2hlZHVsaW5nXG5cbiAgICBcdFx0cmV0dXJuIHRoaXMuc3RvcEZhZGluZygpLnN0b3BXYXJwaW5nKCk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGlzUnVubmluZzogZnVuY3Rpb24oKSB7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMuZW5hYmxlZCAmJiAhIHRoaXMucGF1c2VkICYmIHRoaXMudGltZVNjYWxlICE9PSAwICYmXG4gICAgXHRcdFx0XHR0aGlzLl9zdGFydFRpbWUgPT09IG51bGwgJiYgdGhpcy5fbWl4ZXIuX2lzQWN0aXZlQWN0aW9uKCB0aGlzICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdC8vIHJldHVybiB0cnVlIHdoZW4gcGxheSBoYXMgYmVlbiBjYWxsZWRcbiAgICBcdGlzU2NoZWR1bGVkOiBmdW5jdGlvbigpIHtcblxuICAgIFx0XHRyZXR1cm4gdGhpcy5fbWl4ZXIuX2lzQWN0aXZlQWN0aW9uKCB0aGlzICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdHN0YXJ0QXQ6IGZ1bmN0aW9uKCB0aW1lICkge1xuXG4gICAgXHRcdHRoaXMuX3N0YXJ0VGltZSA9IHRpbWU7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldExvb3A6IGZ1bmN0aW9uKCBtb2RlLCByZXBldGl0aW9ucyApIHtcblxuICAgIFx0XHR0aGlzLmxvb3AgPSBtb2RlO1xuICAgIFx0XHR0aGlzLnJlcGV0aXRpb25zID0gcmVwZXRpdGlvbnM7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdC8vIFdlaWdodFxuXG4gICAgXHQvLyBzZXQgdGhlIHdlaWdodCBzdG9wcGluZyBhbnkgc2NoZWR1bGVkIGZhZGluZ1xuICAgIFx0Ly8gYWx0aG91Z2ggLmVuYWJsZWQgPSBmYWxzZSB5aWVsZHMgYW4gZWZmZWN0aXZlIHdlaWdodCBvZiB6ZXJvLCB0aGlzXG4gICAgXHQvLyBtZXRob2QgZG9lcyAqbm90KiBjaGFuZ2UgLmVuYWJsZWQsIGJlY2F1c2UgaXQgd291bGQgYmUgY29uZnVzaW5nXG4gICAgXHRzZXRFZmZlY3RpdmVXZWlnaHQ6IGZ1bmN0aW9uKCB3ZWlnaHQgKSB7XG5cbiAgICBcdFx0dGhpcy53ZWlnaHQgPSB3ZWlnaHQ7XG5cbiAgICBcdFx0Ly8gbm90ZTogc2FtZSBsb2dpYyBhcyB3aGVuIHVwZGF0ZWQgYXQgcnVudGltZVxuICAgIFx0XHR0aGlzLl9lZmZlY3RpdmVXZWlnaHQgPSB0aGlzLmVuYWJsZWQgPyB3ZWlnaHQgOiAwO1xuXG4gICAgXHRcdHJldHVybiB0aGlzLnN0b3BGYWRpbmcoKTtcblxuICAgIFx0fSxcblxuICAgIFx0Ly8gcmV0dXJuIHRoZSB3ZWlnaHQgY29uc2lkZXJpbmcgZmFkaW5nIGFuZCAuZW5hYmxlZFxuICAgIFx0Z2V0RWZmZWN0aXZlV2VpZ2h0OiBmdW5jdGlvbigpIHtcblxuICAgIFx0XHRyZXR1cm4gdGhpcy5fZWZmZWN0aXZlV2VpZ2h0O1xuXG4gICAgXHR9LFxuXG4gICAgXHRmYWRlSW46IGZ1bmN0aW9uKCBkdXJhdGlvbiApIHtcblxuICAgIFx0XHRyZXR1cm4gdGhpcy5fc2NoZWR1bGVGYWRpbmcoIGR1cmF0aW9uLCAwLCAxICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGZhZGVPdXQ6IGZ1bmN0aW9uKCBkdXJhdGlvbiApIHtcblxuICAgIFx0XHRyZXR1cm4gdGhpcy5fc2NoZWR1bGVGYWRpbmcoIGR1cmF0aW9uLCAxLCAwICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGNyb3NzRmFkZUZyb206IGZ1bmN0aW9uKCBmYWRlT3V0QWN0aW9uLCBkdXJhdGlvbiwgd2FycCApIHtcblxuICAgIFx0XHRmYWRlT3V0QWN0aW9uLmZhZGVPdXQoIGR1cmF0aW9uICk7XG4gICAgXHRcdHRoaXMuZmFkZUluKCBkdXJhdGlvbiApO1xuXG4gICAgXHRcdGlmKCB3YXJwICkge1xuXG4gICAgXHRcdFx0dmFyIGZhZGVJbkR1cmF0aW9uID0gdGhpcy5fY2xpcC5kdXJhdGlvbixcbiAgICBcdFx0XHRcdGZhZGVPdXREdXJhdGlvbiA9IGZhZGVPdXRBY3Rpb24uX2NsaXAuZHVyYXRpb24sXG5cbiAgICBcdFx0XHRcdHN0YXJ0RW5kUmF0aW8gPSBmYWRlT3V0RHVyYXRpb24gLyBmYWRlSW5EdXJhdGlvbixcbiAgICBcdFx0XHRcdGVuZFN0YXJ0UmF0aW8gPSBmYWRlSW5EdXJhdGlvbiAvIGZhZGVPdXREdXJhdGlvbjtcblxuICAgIFx0XHRcdGZhZGVPdXRBY3Rpb24ud2FycCggMS4wLCBzdGFydEVuZFJhdGlvLCBkdXJhdGlvbiApO1xuICAgIFx0XHRcdHRoaXMud2FycCggZW5kU3RhcnRSYXRpbywgMS4wLCBkdXJhdGlvbiApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0Y3Jvc3NGYWRlVG86IGZ1bmN0aW9uKCBmYWRlSW5BY3Rpb24sIGR1cmF0aW9uLCB3YXJwICkge1xuXG4gICAgXHRcdHJldHVybiBmYWRlSW5BY3Rpb24uY3Jvc3NGYWRlRnJvbSggdGhpcywgZHVyYXRpb24sIHdhcnAgKTtcblxuICAgIFx0fSxcblxuICAgIFx0c3RvcEZhZGluZzogZnVuY3Rpb24oKSB7XG5cbiAgICBcdFx0dmFyIHdlaWdodEludGVycG9sYW50ID0gdGhpcy5fd2VpZ2h0SW50ZXJwb2xhbnQ7XG5cbiAgICBcdFx0aWYgKCB3ZWlnaHRJbnRlcnBvbGFudCAhPT0gbnVsbCApIHtcblxuICAgIFx0XHRcdHRoaXMuX3dlaWdodEludGVycG9sYW50ID0gbnVsbDtcbiAgICBcdFx0XHR0aGlzLl9taXhlci5fdGFrZUJhY2tDb250cm9sSW50ZXJwb2xhbnQoIHdlaWdodEludGVycG9sYW50ICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHQvLyBUaW1lIFNjYWxlIENvbnRyb2xcblxuICAgIFx0Ly8gc2V0IHRoZSB3ZWlnaHQgc3RvcHBpbmcgYW55IHNjaGVkdWxlZCB3YXJwaW5nXG4gICAgXHQvLyBhbHRob3VnaCAucGF1c2VkID0gdHJ1ZSB5aWVsZHMgYW4gZWZmZWN0aXZlIHRpbWUgc2NhbGUgb2YgemVybywgdGhpc1xuICAgIFx0Ly8gbWV0aG9kIGRvZXMgKm5vdCogY2hhbmdlIC5wYXVzZWQsIGJlY2F1c2UgaXQgd291bGQgYmUgY29uZnVzaW5nXG4gICAgXHRzZXRFZmZlY3RpdmVUaW1lU2NhbGU6IGZ1bmN0aW9uKCB0aW1lU2NhbGUgKSB7XG5cbiAgICBcdFx0dGhpcy50aW1lU2NhbGUgPSB0aW1lU2NhbGU7XG4gICAgXHRcdHRoaXMuX2VmZmVjdGl2ZVRpbWVTY2FsZSA9IHRoaXMucGF1c2VkID8gMCA6dGltZVNjYWxlO1xuXG4gICAgXHRcdHJldHVybiB0aGlzLnN0b3BXYXJwaW5nKCk7XG5cbiAgICBcdH0sXG5cbiAgICBcdC8vIHJldHVybiB0aGUgdGltZSBzY2FsZSBjb25zaWRlcmluZyB3YXJwaW5nIGFuZCAucGF1c2VkXG4gICAgXHRnZXRFZmZlY3RpdmVUaW1lU2NhbGU6IGZ1bmN0aW9uKCkge1xuXG4gICAgXHRcdHJldHVybiB0aGlzLl9lZmZlY3RpdmVUaW1lU2NhbGU7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldER1cmF0aW9uOiBmdW5jdGlvbiggZHVyYXRpb24gKSB7XG5cbiAgICBcdFx0dGhpcy50aW1lU2NhbGUgPSB0aGlzLl9jbGlwLmR1cmF0aW9uIC8gZHVyYXRpb247XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMuc3RvcFdhcnBpbmcoKTtcblxuICAgIFx0fSxcblxuICAgIFx0c3luY1dpdGg6IGZ1bmN0aW9uKCBhY3Rpb24gKSB7XG5cbiAgICBcdFx0dGhpcy50aW1lID0gYWN0aW9uLnRpbWU7XG4gICAgXHRcdHRoaXMudGltZVNjYWxlID0gYWN0aW9uLnRpbWVTY2FsZTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcy5zdG9wV2FycGluZygpO1xuXG4gICAgXHR9LFxuXG4gICAgXHRoYWx0OiBmdW5jdGlvbiggZHVyYXRpb24gKSB7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMud2FycCggdGhpcy5fZWZmZWN0aXZlVGltZVNjYWxlLCAwLCBkdXJhdGlvbiApO1xuXG4gICAgXHR9LFxuXG4gICAgXHR3YXJwOiBmdW5jdGlvbiggc3RhcnRUaW1lU2NhbGUsIGVuZFRpbWVTY2FsZSwgZHVyYXRpb24gKSB7XG5cbiAgICBcdFx0dmFyIG1peGVyID0gdGhpcy5fbWl4ZXIsIG5vdyA9IG1peGVyLnRpbWUsXG4gICAgXHRcdFx0aW50ZXJwb2xhbnQgPSB0aGlzLl90aW1lU2NhbGVJbnRlcnBvbGFudCxcblxuICAgIFx0XHRcdHRpbWVTY2FsZSA9IHRoaXMudGltZVNjYWxlO1xuXG4gICAgXHRcdGlmICggaW50ZXJwb2xhbnQgPT09IG51bGwgKSB7XG5cbiAgICBcdFx0XHRpbnRlcnBvbGFudCA9IG1peGVyLl9sZW5kQ29udHJvbEludGVycG9sYW50KCksXG4gICAgXHRcdFx0dGhpcy5fdGltZVNjYWxlSW50ZXJwb2xhbnQgPSBpbnRlcnBvbGFudDtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0dmFyIHRpbWVzID0gaW50ZXJwb2xhbnQucGFyYW1ldGVyUG9zaXRpb25zLFxuICAgIFx0XHRcdHZhbHVlcyA9IGludGVycG9sYW50LnNhbXBsZVZhbHVlcztcblxuICAgIFx0XHR0aW1lc1sgMCBdID0gbm93O1xuICAgIFx0XHR0aW1lc1sgMSBdID0gbm93ICsgZHVyYXRpb247XG5cbiAgICBcdFx0dmFsdWVzWyAwIF0gPSBzdGFydFRpbWVTY2FsZSAvIHRpbWVTY2FsZTtcbiAgICBcdFx0dmFsdWVzWyAxIF0gPSBlbmRUaW1lU2NhbGUgLyB0aW1lU2NhbGU7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdHN0b3BXYXJwaW5nOiBmdW5jdGlvbigpIHtcblxuICAgIFx0XHR2YXIgdGltZVNjYWxlSW50ZXJwb2xhbnQgPSB0aGlzLl90aW1lU2NhbGVJbnRlcnBvbGFudDtcblxuICAgIFx0XHRpZiAoIHRpbWVTY2FsZUludGVycG9sYW50ICE9PSBudWxsICkge1xuXG4gICAgXHRcdFx0dGhpcy5fdGltZVNjYWxlSW50ZXJwb2xhbnQgPSBudWxsO1xuICAgIFx0XHRcdHRoaXMuX21peGVyLl90YWtlQmFja0NvbnRyb2xJbnRlcnBvbGFudCggdGltZVNjYWxlSW50ZXJwb2xhbnQgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdC8vIE9iamVjdCBBY2Nlc3NvcnNcblxuICAgIFx0Z2V0TWl4ZXI6IGZ1bmN0aW9uKCkge1xuXG4gICAgXHRcdHJldHVybiB0aGlzLl9taXhlcjtcblxuICAgIFx0fSxcblxuICAgIFx0Z2V0Q2xpcDogZnVuY3Rpb24oKSB7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMuX2NsaXA7XG5cbiAgICBcdH0sXG5cbiAgICBcdGdldFJvb3Q6IGZ1bmN0aW9uKCkge1xuXG4gICAgXHRcdHJldHVybiB0aGlzLl9sb2NhbFJvb3QgfHwgdGhpcy5fbWl4ZXIuX3Jvb3Q7XG5cbiAgICBcdH0sXG5cbiAgICBcdC8vIEludGVybmFcblxuICAgIFx0X3VwZGF0ZTogZnVuY3Rpb24oIHRpbWUsIGRlbHRhVGltZSwgdGltZURpcmVjdGlvbiwgYWNjdUluZGV4ICkge1xuICAgIFx0XHQvLyBjYWxsZWQgYnkgdGhlIG1peGVyXG5cbiAgICBcdFx0dmFyIHN0YXJ0VGltZSA9IHRoaXMuX3N0YXJ0VGltZTtcblxuICAgIFx0XHRpZiAoIHN0YXJ0VGltZSAhPT0gbnVsbCApIHtcblxuICAgIFx0XHRcdC8vIGNoZWNrIGZvciBzY2hlZHVsZWQgc3RhcnQgb2YgYWN0aW9uXG5cbiAgICBcdFx0XHR2YXIgdGltZVJ1bm5pbmcgPSAoIHRpbWUgLSBzdGFydFRpbWUgKSAqIHRpbWVEaXJlY3Rpb247XG4gICAgXHRcdFx0aWYgKCB0aW1lUnVubmluZyA8IDAgfHwgdGltZURpcmVjdGlvbiA9PT0gMCApIHtcblxuICAgIFx0XHRcdFx0cmV0dXJuOyAvLyB5ZXQgdG8gY29tZSAvIGRvbid0IGRlY2lkZSB3aGVuIGRlbHRhID0gMFxuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0Ly8gc3RhcnRcblxuICAgIFx0XHRcdHRoaXMuX3N0YXJ0VGltZSA9IG51bGw7IC8vIHVuc2NoZWR1bGVcbiAgICBcdFx0XHRkZWx0YVRpbWUgPSB0aW1lRGlyZWN0aW9uICogdGltZVJ1bm5pbmc7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdC8vIGFwcGx5IHRpbWUgc2NhbGUgYW5kIGFkdmFuY2UgdGltZVxuXG4gICAgXHRcdGRlbHRhVGltZSAqPSB0aGlzLl91cGRhdGVUaW1lU2NhbGUoIHRpbWUgKTtcbiAgICBcdFx0dmFyIGNsaXBUaW1lID0gdGhpcy5fdXBkYXRlVGltZSggZGVsdGFUaW1lICk7XG5cbiAgICBcdFx0Ly8gbm90ZTogX3VwZGF0ZVRpbWUgbWF5IGRpc2FibGUgdGhlIGFjdGlvbiByZXN1bHRpbmcgaW5cbiAgICBcdFx0Ly8gYW4gZWZmZWN0aXZlIHdlaWdodCBvZiAwXG5cbiAgICBcdFx0dmFyIHdlaWdodCA9IHRoaXMuX3VwZGF0ZVdlaWdodCggdGltZSApO1xuXG4gICAgXHRcdGlmICggd2VpZ2h0ID4gMCApIHtcblxuICAgIFx0XHRcdHZhciBpbnRlcnBvbGFudHMgPSB0aGlzLl9pbnRlcnBvbGFudHM7XG4gICAgXHRcdFx0dmFyIHByb3BlcnR5TWl4ZXJzID0gdGhpcy5fcHJvcGVydHlCaW5kaW5ncztcblxuICAgIFx0XHRcdGZvciAoIHZhciBqID0gMCwgbSA9IGludGVycG9sYW50cy5sZW5ndGg7IGogIT09IG07ICsrIGogKSB7XG5cbiAgICBcdFx0XHRcdGludGVycG9sYW50c1sgaiBdLmV2YWx1YXRlKCBjbGlwVGltZSApO1xuICAgIFx0XHRcdFx0cHJvcGVydHlNaXhlcnNbIGogXS5hY2N1bXVsYXRlKCBhY2N1SW5kZXgsIHdlaWdodCApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0fSxcblxuICAgIFx0X3VwZGF0ZVdlaWdodDogZnVuY3Rpb24oIHRpbWUgKSB7XG5cbiAgICBcdFx0dmFyIHdlaWdodCA9IDA7XG5cbiAgICBcdFx0aWYgKCB0aGlzLmVuYWJsZWQgKSB7XG5cbiAgICBcdFx0XHR3ZWlnaHQgPSB0aGlzLndlaWdodDtcbiAgICBcdFx0XHR2YXIgaW50ZXJwb2xhbnQgPSB0aGlzLl93ZWlnaHRJbnRlcnBvbGFudDtcblxuICAgIFx0XHRcdGlmICggaW50ZXJwb2xhbnQgIT09IG51bGwgKSB7XG5cbiAgICBcdFx0XHRcdHZhciBpbnRlcnBvbGFudFZhbHVlID0gaW50ZXJwb2xhbnQuZXZhbHVhdGUoIHRpbWUgKVsgMCBdO1xuXG4gICAgXHRcdFx0XHR3ZWlnaHQgKj0gaW50ZXJwb2xhbnRWYWx1ZTtcblxuICAgIFx0XHRcdFx0aWYgKCB0aW1lID4gaW50ZXJwb2xhbnQucGFyYW1ldGVyUG9zaXRpb25zWyAxIF0gKSB7XG5cbiAgICBcdFx0XHRcdFx0dGhpcy5zdG9wRmFkaW5nKCk7XG5cbiAgICBcdFx0XHRcdFx0aWYgKCBpbnRlcnBvbGFudFZhbHVlID09PSAwICkge1xuXG4gICAgXHRcdFx0XHRcdFx0Ly8gZmFkZWQgb3V0LCBkaXNhYmxlXG4gICAgXHRcdFx0XHRcdFx0dGhpcy5lbmFibGVkID0gZmFsc2U7XG5cbiAgICBcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHRoaXMuX2VmZmVjdGl2ZVdlaWdodCA9IHdlaWdodDtcbiAgICBcdFx0cmV0dXJuIHdlaWdodDtcblxuICAgIFx0fSxcblxuICAgIFx0X3VwZGF0ZVRpbWVTY2FsZTogZnVuY3Rpb24oIHRpbWUgKSB7XG5cbiAgICBcdFx0dmFyIHRpbWVTY2FsZSA9IDA7XG5cbiAgICBcdFx0aWYgKCAhIHRoaXMucGF1c2VkICkge1xuXG4gICAgXHRcdFx0dGltZVNjYWxlID0gdGhpcy50aW1lU2NhbGU7XG5cbiAgICBcdFx0XHR2YXIgaW50ZXJwb2xhbnQgPSB0aGlzLl90aW1lU2NhbGVJbnRlcnBvbGFudDtcblxuICAgIFx0XHRcdGlmICggaW50ZXJwb2xhbnQgIT09IG51bGwgKSB7XG5cbiAgICBcdFx0XHRcdHZhciBpbnRlcnBvbGFudFZhbHVlID0gaW50ZXJwb2xhbnQuZXZhbHVhdGUoIHRpbWUgKVsgMCBdO1xuXG4gICAgXHRcdFx0XHR0aW1lU2NhbGUgKj0gaW50ZXJwb2xhbnRWYWx1ZTtcblxuICAgIFx0XHRcdFx0aWYgKCB0aW1lID4gaW50ZXJwb2xhbnQucGFyYW1ldGVyUG9zaXRpb25zWyAxIF0gKSB7XG5cbiAgICBcdFx0XHRcdFx0dGhpcy5zdG9wV2FycGluZygpO1xuXG4gICAgXHRcdFx0XHRcdGlmICggdGltZVNjYWxlID09PSAwICkge1xuXG4gICAgXHRcdFx0XHRcdFx0Ly8gbW90aW9uIGhhcyBoYWx0ZWQsIHBhdXNlXG4gICAgXHRcdFx0XHRcdFx0dGhpcy5wYXVzZWQgPSB0cnVlO1xuXG4gICAgXHRcdFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdFx0XHQvLyB3YXJwIGRvbmUgLSBhcHBseSBmaW5hbCB0aW1lIHNjYWxlXG4gICAgXHRcdFx0XHRcdFx0dGhpcy50aW1lU2NhbGUgPSB0aW1lU2NhbGU7XG5cbiAgICBcdFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHRoaXMuX2VmZmVjdGl2ZVRpbWVTY2FsZSA9IHRpbWVTY2FsZTtcbiAgICBcdFx0cmV0dXJuIHRpbWVTY2FsZTtcblxuICAgIFx0fSxcblxuICAgIFx0X3VwZGF0ZVRpbWU6IGZ1bmN0aW9uKCBkZWx0YVRpbWUgKSB7XG5cbiAgICBcdFx0dmFyIHRpbWUgPSB0aGlzLnRpbWUgKyBkZWx0YVRpbWU7XG5cbiAgICBcdFx0aWYgKCBkZWx0YVRpbWUgPT09IDAgKSByZXR1cm4gdGltZTtcblxuICAgIFx0XHR2YXIgZHVyYXRpb24gPSB0aGlzLl9jbGlwLmR1cmF0aW9uLFxuXG4gICAgXHRcdFx0bG9vcCA9IHRoaXMubG9vcCxcbiAgICBcdFx0XHRsb29wQ291bnQgPSB0aGlzLl9sb29wQ291bnQ7XG5cbiAgICBcdFx0aWYgKCBsb29wID09PSBMb29wT25jZSApIHtcblxuICAgIFx0XHRcdGlmICggbG9vcENvdW50ID09PSAtMSApIHtcbiAgICBcdFx0XHRcdC8vIGp1c3Qgc3RhcnRlZFxuXG4gICAgXHRcdFx0XHR0aGlzLmxvb3BDb3VudCA9IDA7XG4gICAgXHRcdFx0XHR0aGlzLl9zZXRFbmRpbmdzKCB0cnVlLCB0cnVlLCBmYWxzZSApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0aGFuZGxlX3N0b3A6IHtcblxuICAgIFx0XHRcdFx0aWYgKCB0aW1lID49IGR1cmF0aW9uICkge1xuXG4gICAgXHRcdFx0XHRcdHRpbWUgPSBkdXJhdGlvbjtcblxuICAgIFx0XHRcdFx0fSBlbHNlIGlmICggdGltZSA8IDAgKSB7XG5cbiAgICBcdFx0XHRcdFx0dGltZSA9IDA7XG5cbiAgICBcdFx0XHRcdH0gZWxzZSBicmVhayBoYW5kbGVfc3RvcDtcblxuICAgIFx0XHRcdFx0aWYgKCB0aGlzLmNsYW1wV2hlbkZpbmlzaGVkICkgdGhpcy5wYXVzZWQgPSB0cnVlO1xuICAgIFx0XHRcdFx0ZWxzZSB0aGlzLmVuYWJsZWQgPSBmYWxzZTtcblxuICAgIFx0XHRcdFx0dGhpcy5fbWl4ZXIuZGlzcGF0Y2hFdmVudCgge1xuICAgIFx0XHRcdFx0XHR0eXBlOiAnZmluaXNoZWQnLCBhY3Rpb246IHRoaXMsXG4gICAgXHRcdFx0XHRcdGRpcmVjdGlvbjogZGVsdGFUaW1lIDwgMCA/IC0xIDogMVxuICAgIFx0XHRcdFx0fSApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH0gZWxzZSB7IC8vIHJlcGV0aXRpdmUgUmVwZWF0IG9yIFBpbmdQb25nXG5cbiAgICBcdFx0XHR2YXIgcGluZ1BvbmcgPSAoIGxvb3AgPT09IExvb3BQaW5nUG9uZyApO1xuXG4gICAgXHRcdFx0aWYgKCBsb29wQ291bnQgPT09IC0xICkge1xuICAgIFx0XHRcdFx0Ly8ganVzdCBzdGFydGVkXG5cbiAgICBcdFx0XHRcdGlmICggZGVsdGFUaW1lID49IDAgKSB7XG5cbiAgICBcdFx0XHRcdFx0bG9vcENvdW50ID0gMDtcblxuICAgIFx0XHRcdFx0XHR0aGlzLl9zZXRFbmRpbmdzKFxuICAgIFx0XHRcdFx0XHRcdFx0dHJ1ZSwgdGhpcy5yZXBldGl0aW9ucyA9PT0gMCwgcGluZ1BvbmcgKTtcblxuICAgIFx0XHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0XHQvLyB3aGVuIGxvb3BpbmcgaW4gcmV2ZXJzZSBkaXJlY3Rpb24sIHRoZSBpbml0aWFsXG4gICAgXHRcdFx0XHRcdC8vIHRyYW5zaXRpb24gdGhyb3VnaCB6ZXJvIGNvdW50cyBhcyBhIHJlcGV0aXRpb24sXG4gICAgXHRcdFx0XHRcdC8vIHNvIGxlYXZlIGxvb3BDb3VudCBhdCAtMVxuXG4gICAgXHRcdFx0XHRcdHRoaXMuX3NldEVuZGluZ3MoXG4gICAgXHRcdFx0XHRcdFx0XHR0aGlzLnJlcGV0aXRpb25zID09PSAwLCB0cnVlLCBwaW5nUG9uZyApO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRpZiAoIHRpbWUgPj0gZHVyYXRpb24gfHwgdGltZSA8IDAgKSB7XG4gICAgXHRcdFx0XHQvLyB3cmFwIGFyb3VuZFxuXG4gICAgXHRcdFx0XHR2YXIgbG9vcERlbHRhID0gTWF0aC5mbG9vciggdGltZSAvIGR1cmF0aW9uICk7IC8vIHNpZ25lZFxuICAgIFx0XHRcdFx0dGltZSAtPSBkdXJhdGlvbiAqIGxvb3BEZWx0YTtcblxuICAgIFx0XHRcdFx0bG9vcENvdW50ICs9IE1hdGguYWJzKCBsb29wRGVsdGEgKTtcblxuICAgIFx0XHRcdFx0dmFyIHBlbmRpbmcgPSB0aGlzLnJlcGV0aXRpb25zIC0gbG9vcENvdW50O1xuXG4gICAgXHRcdFx0XHRpZiAoIHBlbmRpbmcgPCAwICkge1xuICAgIFx0XHRcdFx0XHQvLyBoYXZlIHRvIHN0b3AgKHN3aXRjaCBzdGF0ZSwgY2xhbXAgdGltZSwgZmlyZSBldmVudClcblxuICAgIFx0XHRcdFx0XHRpZiAoIHRoaXMuY2xhbXBXaGVuRmluaXNoZWQgKSB0aGlzLnBhdXNlZCA9IHRydWU7XG4gICAgXHRcdFx0XHRcdGVsc2UgdGhpcy5lbmFibGVkID0gZmFsc2U7XG5cbiAgICBcdFx0XHRcdFx0dGltZSA9IGRlbHRhVGltZSA+IDAgPyBkdXJhdGlvbiA6IDA7XG5cbiAgICBcdFx0XHRcdFx0dGhpcy5fbWl4ZXIuZGlzcGF0Y2hFdmVudCgge1xuICAgIFx0XHRcdFx0XHRcdHR5cGU6ICdmaW5pc2hlZCcsIGFjdGlvbjogdGhpcyxcbiAgICBcdFx0XHRcdFx0XHRkaXJlY3Rpb246IGRlbHRhVGltZSA+IDAgPyAxIDogLTFcbiAgICBcdFx0XHRcdFx0fSApO1xuXG4gICAgXHRcdFx0XHR9IGVsc2Uge1xuICAgIFx0XHRcdFx0XHQvLyBrZWVwIHJ1bm5pbmdcblxuICAgIFx0XHRcdFx0XHRpZiAoIHBlbmRpbmcgPT09IDAgKSB7XG4gICAgXHRcdFx0XHRcdFx0Ly8gZW50ZXJpbmcgdGhlIGxhc3Qgcm91bmRcblxuICAgIFx0XHRcdFx0XHRcdHZhciBhdFN0YXJ0ID0gZGVsdGFUaW1lIDwgMDtcbiAgICBcdFx0XHRcdFx0XHR0aGlzLl9zZXRFbmRpbmdzKCBhdFN0YXJ0LCAhIGF0U3RhcnQsIHBpbmdQb25nICk7XG5cbiAgICBcdFx0XHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0XHRcdHRoaXMuX3NldEVuZGluZ3MoIGZhbHNlLCBmYWxzZSwgcGluZ1BvbmcgKTtcblxuICAgIFx0XHRcdFx0XHR9XG5cbiAgICBcdFx0XHRcdFx0dGhpcy5fbG9vcENvdW50ID0gbG9vcENvdW50O1xuXG4gICAgXHRcdFx0XHRcdHRoaXMuX21peGVyLmRpc3BhdGNoRXZlbnQoIHtcbiAgICBcdFx0XHRcdFx0XHR0eXBlOiAnbG9vcCcsIGFjdGlvbjogdGhpcywgbG9vcERlbHRhOiBsb29wRGVsdGFcbiAgICBcdFx0XHRcdFx0fSApO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRpZiAoIHBpbmdQb25nICYmICggbG9vcENvdW50ICYgMSApID09PSAxICkge1xuICAgIFx0XHRcdFx0Ly8gaW52ZXJ0IHRpbWUgZm9yIHRoZSBcInBvbmcgcm91bmRcIlxuXG4gICAgXHRcdFx0XHR0aGlzLnRpbWUgPSB0aW1lO1xuICAgIFx0XHRcdFx0cmV0dXJuIGR1cmF0aW9uIC0gdGltZTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdFx0dGhpcy50aW1lID0gdGltZTtcbiAgICBcdFx0cmV0dXJuIHRpbWU7XG5cbiAgICBcdH0sXG5cbiAgICBcdF9zZXRFbmRpbmdzOiBmdW5jdGlvbiggYXRTdGFydCwgYXRFbmQsIHBpbmdQb25nICkge1xuXG4gICAgXHRcdHZhciBzZXR0aW5ncyA9IHRoaXMuX2ludGVycG9sYW50U2V0dGluZ3M7XG5cbiAgICBcdFx0aWYgKCBwaW5nUG9uZyApIHtcblxuICAgIFx0XHRcdHNldHRpbmdzLmVuZGluZ1N0YXJ0IFx0PSBaZXJvU2xvcGVFbmRpbmc7XG4gICAgXHRcdFx0c2V0dGluZ3MuZW5kaW5nRW5kXHRcdD0gWmVyb1Nsb3BlRW5kaW5nO1xuXG4gICAgXHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHQvLyBhc3N1bWluZyBmb3IgTG9vcE9uY2UgYXRTdGFydCA9PSBhdEVuZCA9PSB0cnVlXG5cbiAgICBcdFx0XHRpZiAoIGF0U3RhcnQgKSB7XG5cbiAgICBcdFx0XHRcdHNldHRpbmdzLmVuZGluZ1N0YXJ0ID0gdGhpcy56ZXJvU2xvcGVBdFN0YXJ0ID9cbiAgICBcdFx0XHRcdFx0XHRaZXJvU2xvcGVFbmRpbmcgOiBaZXJvQ3VydmF0dXJlRW5kaW5nO1xuXG4gICAgXHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0c2V0dGluZ3MuZW5kaW5nU3RhcnQgPSBXcmFwQXJvdW5kRW5kaW5nO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0aWYgKCBhdEVuZCApIHtcblxuICAgIFx0XHRcdFx0c2V0dGluZ3MuZW5kaW5nRW5kID0gdGhpcy56ZXJvU2xvcGVBdEVuZCA/XG4gICAgXHRcdFx0XHRcdFx0WmVyb1Nsb3BlRW5kaW5nIDogWmVyb0N1cnZhdHVyZUVuZGluZztcblxuICAgIFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdHNldHRpbmdzLmVuZGluZ0VuZCBcdCA9IFdyYXBBcm91bmRFbmRpbmc7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9LFxuXG4gICAgXHRfc2NoZWR1bGVGYWRpbmc6IGZ1bmN0aW9uKCBkdXJhdGlvbiwgd2VpZ2h0Tm93LCB3ZWlnaHRUaGVuICkge1xuXG4gICAgXHRcdHZhciBtaXhlciA9IHRoaXMuX21peGVyLCBub3cgPSBtaXhlci50aW1lLFxuICAgIFx0XHRcdGludGVycG9sYW50ID0gdGhpcy5fd2VpZ2h0SW50ZXJwb2xhbnQ7XG5cbiAgICBcdFx0aWYgKCBpbnRlcnBvbGFudCA9PT0gbnVsbCApIHtcblxuICAgIFx0XHRcdGludGVycG9sYW50ID0gbWl4ZXIuX2xlbmRDb250cm9sSW50ZXJwb2xhbnQoKSxcbiAgICBcdFx0XHR0aGlzLl93ZWlnaHRJbnRlcnBvbGFudCA9IGludGVycG9sYW50O1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHR2YXIgdGltZXMgPSBpbnRlcnBvbGFudC5wYXJhbWV0ZXJQb3NpdGlvbnMsXG4gICAgXHRcdFx0dmFsdWVzID0gaW50ZXJwb2xhbnQuc2FtcGxlVmFsdWVzO1xuXG4gICAgXHRcdHRpbWVzWyAwIF0gPSBub3c7IFx0XHRcdFx0dmFsdWVzWyAwIF0gPSB3ZWlnaHROb3c7XG4gICAgXHRcdHRpbWVzWyAxIF0gPSBub3cgKyBkdXJhdGlvbjtcdHZhbHVlc1sgMSBdID0gd2VpZ2h0VGhlbjtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fVxuXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogUGxheWVyIGZvciBBbmltYXRpb25DbGlwcy5cbiAgICAgKlxuICAgICAqXG4gICAgICogQGF1dGhvciBCZW4gSG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pby9cbiAgICAgKiBAYXV0aG9yIERhdmlkIFNhcm5vIC8gaHR0cDovL2xpZ2h0aGF1cy51cy9cbiAgICAgKiBAYXV0aG9yIHRzY2h3XG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBBbmltYXRpb25NaXhlciggcm9vdCApIHtcblxuICAgIFx0dGhpcy5fcm9vdCA9IHJvb3Q7XG4gICAgXHR0aGlzLl9pbml0TWVtb3J5TWFuYWdlcigpO1xuICAgIFx0dGhpcy5fYWNjdUluZGV4ID0gMDtcblxuICAgIFx0dGhpcy50aW1lID0gMDtcblxuICAgIFx0dGhpcy50aW1lU2NhbGUgPSAxLjA7XG5cbiAgICB9XG5cbiAgICBPYmplY3QuYXNzaWduKCBBbmltYXRpb25NaXhlci5wcm90b3R5cGUsIEV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUsIHtcblxuICAgIFx0Ly8gcmV0dXJuIGFuIGFjdGlvbiBmb3IgYSBjbGlwIG9wdGlvbmFsbHkgdXNpbmcgYSBjdXN0b20gcm9vdCB0YXJnZXRcbiAgICBcdC8vIG9iamVjdCAodGhpcyBtZXRob2QgYWxsb2NhdGVzIGEgbG90IG9mIGR5bmFtaWMgbWVtb3J5IGluIGNhc2UgYVxuICAgIFx0Ly8gcHJldmlvdXNseSB1bmtub3duIGNsaXAvcm9vdCBjb21iaW5hdGlvbiBpcyBzcGVjaWZpZWQpXG4gICAgXHRjbGlwQWN0aW9uOiBmdW5jdGlvbiggY2xpcCwgb3B0aW9uYWxSb290ICkge1xuXG4gICAgXHRcdHZhciByb290ID0gb3B0aW9uYWxSb290IHx8IHRoaXMuX3Jvb3QsXG4gICAgXHRcdFx0cm9vdFV1aWQgPSByb290LnV1aWQsXG5cbiAgICBcdFx0XHRjbGlwT2JqZWN0ID0gdHlwZW9mIGNsaXAgPT09ICdzdHJpbmcnID9cbiAgICBcdFx0XHRcdFx0QW5pbWF0aW9uQ2xpcC5maW5kQnlOYW1lKCByb290LCBjbGlwICkgOiBjbGlwLFxuXG4gICAgXHRcdFx0Y2xpcFV1aWQgPSBjbGlwT2JqZWN0ICE9PSBudWxsID8gY2xpcE9iamVjdC51dWlkIDogY2xpcCxcblxuICAgIFx0XHRcdGFjdGlvbnNGb3JDbGlwID0gdGhpcy5fYWN0aW9uc0J5Q2xpcFsgY2xpcFV1aWQgXSxcbiAgICBcdFx0XHRwcm90b3R5cGVBY3Rpb24gPSBudWxsO1xuXG4gICAgXHRcdGlmICggYWN0aW9uc0ZvckNsaXAgIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdHZhciBleGlzdGluZ0FjdGlvbiA9XG4gICAgXHRcdFx0XHRcdGFjdGlvbnNGb3JDbGlwLmFjdGlvbkJ5Um9vdFsgcm9vdFV1aWQgXTtcblxuICAgIFx0XHRcdGlmICggZXhpc3RpbmdBY3Rpb24gIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0cmV0dXJuIGV4aXN0aW5nQWN0aW9uO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0Ly8gd2Uga25vdyB0aGUgY2xpcCwgc28gd2UgZG9uJ3QgaGF2ZSB0byBwYXJzZSBhbGxcbiAgICBcdFx0XHQvLyB0aGUgYmluZGluZ3MgYWdhaW4gYnV0IGNhbiBqdXN0IGNvcHlcbiAgICBcdFx0XHRwcm90b3R5cGVBY3Rpb24gPSBhY3Rpb25zRm9yQ2xpcC5rbm93bkFjdGlvbnNbIDAgXTtcblxuICAgIFx0XHRcdC8vIGFsc28sIHRha2UgdGhlIGNsaXAgZnJvbSB0aGUgcHJvdG90eXBlIGFjdGlvblxuICAgIFx0XHRcdGlmICggY2xpcE9iamVjdCA9PT0gbnVsbCApXG4gICAgXHRcdFx0XHRjbGlwT2JqZWN0ID0gcHJvdG90eXBlQWN0aW9uLl9jbGlwO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHQvLyBjbGlwIG11c3QgYmUga25vd24gd2hlbiBzcGVjaWZpZWQgdmlhIHN0cmluZ1xuICAgIFx0XHRpZiAoIGNsaXBPYmplY3QgPT09IG51bGwgKSByZXR1cm4gbnVsbDtcblxuICAgIFx0XHQvLyBhbGxvY2F0ZSBhbGwgcmVzb3VyY2VzIHJlcXVpcmVkIHRvIHJ1biBpdFxuICAgIFx0XHR2YXIgbmV3QWN0aW9uID0gbmV3IEFuaW1hdGlvbkFjdGlvbiggdGhpcywgY2xpcE9iamVjdCwgb3B0aW9uYWxSb290ICk7XG5cbiAgICBcdFx0dGhpcy5fYmluZEFjdGlvbiggbmV3QWN0aW9uLCBwcm90b3R5cGVBY3Rpb24gKTtcblxuICAgIFx0XHQvLyBhbmQgbWFrZSB0aGUgYWN0aW9uIGtub3duIHRvIHRoZSBtZW1vcnkgbWFuYWdlclxuICAgIFx0XHR0aGlzLl9hZGRJbmFjdGl2ZUFjdGlvbiggbmV3QWN0aW9uLCBjbGlwVXVpZCwgcm9vdFV1aWQgKTtcblxuICAgIFx0XHRyZXR1cm4gbmV3QWN0aW9uO1xuXG4gICAgXHR9LFxuXG4gICAgXHQvLyBnZXQgYW4gZXhpc3RpbmcgYWN0aW9uXG4gICAgXHRleGlzdGluZ0FjdGlvbjogZnVuY3Rpb24oIGNsaXAsIG9wdGlvbmFsUm9vdCApIHtcblxuICAgIFx0XHR2YXIgcm9vdCA9IG9wdGlvbmFsUm9vdCB8fCB0aGlzLl9yb290LFxuICAgIFx0XHRcdHJvb3RVdWlkID0gcm9vdC51dWlkLFxuXG4gICAgXHRcdFx0Y2xpcE9iamVjdCA9IHR5cGVvZiBjbGlwID09PSAnc3RyaW5nJyA/XG4gICAgXHRcdFx0XHRcdEFuaW1hdGlvbkNsaXAuZmluZEJ5TmFtZSggcm9vdCwgY2xpcCApIDogY2xpcCxcblxuICAgIFx0XHRcdGNsaXBVdWlkID0gY2xpcE9iamVjdCA/IGNsaXBPYmplY3QudXVpZCA6IGNsaXAsXG5cbiAgICBcdFx0XHRhY3Rpb25zRm9yQ2xpcCA9IHRoaXMuX2FjdGlvbnNCeUNsaXBbIGNsaXBVdWlkIF07XG5cbiAgICBcdFx0aWYgKCBhY3Rpb25zRm9yQ2xpcCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0cmV0dXJuIGFjdGlvbnNGb3JDbGlwLmFjdGlvbkJ5Um9vdFsgcm9vdFV1aWQgXSB8fCBudWxsO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gbnVsbDtcblxuICAgIFx0fSxcblxuICAgIFx0Ly8gZGVhY3RpdmF0ZXMgYWxsIHByZXZpb3VzbHkgc2NoZWR1bGVkIGFjdGlvbnNcbiAgICBcdHN0b3BBbGxBY3Rpb246IGZ1bmN0aW9uKCkge1xuXG4gICAgXHRcdHZhciBhY3Rpb25zID0gdGhpcy5fYWN0aW9ucyxcbiAgICBcdFx0XHRuQWN0aW9ucyA9IHRoaXMuX25BY3RpdmVBY3Rpb25zLFxuICAgIFx0XHRcdGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3MsXG4gICAgXHRcdFx0bkJpbmRpbmdzID0gdGhpcy5fbkFjdGl2ZUJpbmRpbmdzO1xuXG4gICAgXHRcdHRoaXMuX25BY3RpdmVBY3Rpb25zID0gMDtcbiAgICBcdFx0dGhpcy5fbkFjdGl2ZUJpbmRpbmdzID0gMDtcblxuICAgIFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgIT09IG5BY3Rpb25zOyArKyBpICkge1xuXG4gICAgXHRcdFx0YWN0aW9uc1sgaSBdLnJlc2V0KCk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGZvciAoIHZhciBpID0gMDsgaSAhPT0gbkJpbmRpbmdzOyArKyBpICkge1xuXG4gICAgXHRcdFx0YmluZGluZ3NbIGkgXS51c2VDb3VudCA9IDA7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHQvLyBhZHZhbmNlIHRoZSB0aW1lIGFuZCB1cGRhdGUgYXBwbHkgdGhlIGFuaW1hdGlvblxuICAgIFx0dXBkYXRlOiBmdW5jdGlvbiggZGVsdGFUaW1lICkge1xuXG4gICAgXHRcdGRlbHRhVGltZSAqPSB0aGlzLnRpbWVTY2FsZTtcblxuICAgIFx0XHR2YXIgYWN0aW9ucyA9IHRoaXMuX2FjdGlvbnMsXG4gICAgXHRcdFx0bkFjdGlvbnMgPSB0aGlzLl9uQWN0aXZlQWN0aW9ucyxcblxuICAgIFx0XHRcdHRpbWUgPSB0aGlzLnRpbWUgKz0gZGVsdGFUaW1lLFxuICAgIFx0XHRcdHRpbWVEaXJlY3Rpb24gPSBNYXRoLnNpZ24oIGRlbHRhVGltZSApLFxuXG4gICAgXHRcdFx0YWNjdUluZGV4ID0gdGhpcy5fYWNjdUluZGV4IF49IDE7XG5cbiAgICBcdFx0Ly8gcnVuIGFjdGl2ZSBhY3Rpb25zXG5cbiAgICBcdFx0Zm9yICggdmFyIGkgPSAwOyBpICE9PSBuQWN0aW9uczsgKysgaSApIHtcblxuICAgIFx0XHRcdHZhciBhY3Rpb24gPSBhY3Rpb25zWyBpIF07XG5cbiAgICBcdFx0XHRpZiAoIGFjdGlvbi5lbmFibGVkICkge1xuXG4gICAgXHRcdFx0XHRhY3Rpb24uX3VwZGF0ZSggdGltZSwgZGVsdGFUaW1lLCB0aW1lRGlyZWN0aW9uLCBhY2N1SW5kZXggKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdFx0Ly8gdXBkYXRlIHNjZW5lIGdyYXBoXG5cbiAgICBcdFx0dmFyIGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3MsXG4gICAgXHRcdFx0bkJpbmRpbmdzID0gdGhpcy5fbkFjdGl2ZUJpbmRpbmdzO1xuXG4gICAgXHRcdGZvciAoIHZhciBpID0gMDsgaSAhPT0gbkJpbmRpbmdzOyArKyBpICkge1xuXG4gICAgXHRcdFx0YmluZGluZ3NbIGkgXS5hcHBseSggYWNjdUluZGV4ICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHQvLyByZXR1cm4gdGhpcyBtaXhlcidzIHJvb3QgdGFyZ2V0IG9iamVjdFxuICAgIFx0Z2V0Um9vdDogZnVuY3Rpb24oKSB7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMuX3Jvb3Q7XG5cbiAgICBcdH0sXG5cbiAgICBcdC8vIGZyZWUgYWxsIHJlc291cmNlcyBzcGVjaWZpYyB0byBhIHBhcnRpY3VsYXIgY2xpcFxuICAgIFx0dW5jYWNoZUNsaXA6IGZ1bmN0aW9uKCBjbGlwICkge1xuXG4gICAgXHRcdHZhciBhY3Rpb25zID0gdGhpcy5fYWN0aW9ucyxcbiAgICBcdFx0XHRjbGlwVXVpZCA9IGNsaXAudXVpZCxcbiAgICBcdFx0XHRhY3Rpb25zQnlDbGlwID0gdGhpcy5fYWN0aW9uc0J5Q2xpcCxcbiAgICBcdFx0XHRhY3Rpb25zRm9yQ2xpcCA9IGFjdGlvbnNCeUNsaXBbIGNsaXBVdWlkIF07XG5cbiAgICBcdFx0aWYgKCBhY3Rpb25zRm9yQ2xpcCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0Ly8gbm90ZToganVzdCBjYWxsaW5nIF9yZW1vdmVJbmFjdGl2ZUFjdGlvbiB3b3VsZCBtZXNzIHVwIHRoZVxuICAgIFx0XHRcdC8vIGl0ZXJhdGlvbiBzdGF0ZSBhbmQgYWxzbyByZXF1aXJlIHVwZGF0aW5nIHRoZSBzdGF0ZSB3ZSBjYW5cbiAgICBcdFx0XHQvLyBqdXN0IHRocm93IGF3YXlcblxuICAgIFx0XHRcdHZhciBhY3Rpb25zVG9SZW1vdmUgPSBhY3Rpb25zRm9yQ2xpcC5rbm93bkFjdGlvbnM7XG5cbiAgICBcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIG4gPSBhY3Rpb25zVG9SZW1vdmUubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xuXG4gICAgXHRcdFx0XHR2YXIgYWN0aW9uID0gYWN0aW9uc1RvUmVtb3ZlWyBpIF07XG5cbiAgICBcdFx0XHRcdHRoaXMuX2RlYWN0aXZhdGVBY3Rpb24oIGFjdGlvbiApO1xuXG4gICAgXHRcdFx0XHR2YXIgY2FjaGVJbmRleCA9IGFjdGlvbi5fY2FjaGVJbmRleCxcbiAgICBcdFx0XHRcdFx0bGFzdEluYWN0aXZlQWN0aW9uID0gYWN0aW9uc1sgYWN0aW9ucy5sZW5ndGggLSAxIF07XG5cbiAgICBcdFx0XHRcdGFjdGlvbi5fY2FjaGVJbmRleCA9IG51bGw7XG4gICAgXHRcdFx0XHRhY3Rpb24uX2J5Q2xpcENhY2hlSW5kZXggPSBudWxsO1xuXG4gICAgXHRcdFx0XHRsYXN0SW5hY3RpdmVBY3Rpb24uX2NhY2hlSW5kZXggPSBjYWNoZUluZGV4O1xuICAgIFx0XHRcdFx0YWN0aW9uc1sgY2FjaGVJbmRleCBdID0gbGFzdEluYWN0aXZlQWN0aW9uO1xuICAgIFx0XHRcdFx0YWN0aW9ucy5wb3AoKTtcblxuICAgIFx0XHRcdFx0dGhpcy5fcmVtb3ZlSW5hY3RpdmVCaW5kaW5nc0ZvckFjdGlvbiggYWN0aW9uICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHRkZWxldGUgYWN0aW9uc0J5Q2xpcFsgY2xpcFV1aWQgXTtcblxuICAgIFx0XHR9XG5cbiAgICBcdH0sXG5cbiAgICBcdC8vIGZyZWUgYWxsIHJlc291cmNlcyBzcGVjaWZpYyB0byBhIHBhcnRpY3VsYXIgcm9vdCB0YXJnZXQgb2JqZWN0XG4gICAgXHR1bmNhY2hlUm9vdDogZnVuY3Rpb24oIHJvb3QgKSB7XG5cbiAgICBcdFx0dmFyIHJvb3RVdWlkID0gcm9vdC51dWlkLFxuICAgIFx0XHRcdGFjdGlvbnNCeUNsaXAgPSB0aGlzLl9hY3Rpb25zQnlDbGlwO1xuXG4gICAgXHRcdGZvciAoIHZhciBjbGlwVXVpZCBpbiBhY3Rpb25zQnlDbGlwICkge1xuXG4gICAgXHRcdFx0dmFyIGFjdGlvbkJ5Um9vdCA9IGFjdGlvbnNCeUNsaXBbIGNsaXBVdWlkIF0uYWN0aW9uQnlSb290LFxuICAgIFx0XHRcdFx0YWN0aW9uID0gYWN0aW9uQnlSb290WyByb290VXVpZCBdO1xuXG4gICAgXHRcdFx0aWYgKCBhY3Rpb24gIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdFx0dGhpcy5fZGVhY3RpdmF0ZUFjdGlvbiggYWN0aW9uICk7XG4gICAgXHRcdFx0XHR0aGlzLl9yZW1vdmVJbmFjdGl2ZUFjdGlvbiggYWN0aW9uICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHZhciBiaW5kaW5nc0J5Um9vdCA9IHRoaXMuX2JpbmRpbmdzQnlSb290QW5kTmFtZSxcbiAgICBcdFx0XHRiaW5kaW5nQnlOYW1lID0gYmluZGluZ3NCeVJvb3RbIHJvb3RVdWlkIF07XG5cbiAgICBcdFx0aWYgKCBiaW5kaW5nQnlOYW1lICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRmb3IgKCB2YXIgdHJhY2tOYW1lIGluIGJpbmRpbmdCeU5hbWUgKSB7XG5cbiAgICBcdFx0XHRcdHZhciBiaW5kaW5nID0gYmluZGluZ0J5TmFtZVsgdHJhY2tOYW1lIF07XG4gICAgXHRcdFx0XHRiaW5kaW5nLnJlc3RvcmVPcmlnaW5hbFN0YXRlKCk7XG4gICAgXHRcdFx0XHR0aGlzLl9yZW1vdmVJbmFjdGl2ZUJpbmRpbmcoIGJpbmRpbmcgKTtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9XG5cbiAgICBcdH0sXG5cbiAgICBcdC8vIHJlbW92ZSBhIHRhcmdldGVkIGNsaXAgZnJvbSB0aGUgY2FjaGVcbiAgICBcdHVuY2FjaGVBY3Rpb246IGZ1bmN0aW9uKCBjbGlwLCBvcHRpb25hbFJvb3QgKSB7XG5cbiAgICBcdFx0dmFyIGFjdGlvbiA9IHRoaXMuZXhpc3RpbmdBY3Rpb24oIGNsaXAsIG9wdGlvbmFsUm9vdCApO1xuXG4gICAgXHRcdGlmICggYWN0aW9uICE9PSBudWxsICkge1xuXG4gICAgXHRcdFx0dGhpcy5fZGVhY3RpdmF0ZUFjdGlvbiggYWN0aW9uICk7XG4gICAgXHRcdFx0dGhpcy5fcmVtb3ZlSW5hY3RpdmVBY3Rpb24oIGFjdGlvbiApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0fVxuXG4gICAgfSApO1xuXG4gICAgLy8gSW1wbGVtZW50YXRpb24gZGV0YWlsczpcblxuICAgIE9iamVjdC5hc3NpZ24oIEFuaW1hdGlvbk1peGVyLnByb3RvdHlwZSwge1xuXG4gICAgXHRfYmluZEFjdGlvbjogZnVuY3Rpb24oIGFjdGlvbiwgcHJvdG90eXBlQWN0aW9uICkge1xuXG4gICAgXHRcdHZhciByb290ID0gYWN0aW9uLl9sb2NhbFJvb3QgfHwgdGhpcy5fcm9vdCxcbiAgICBcdFx0XHR0cmFja3MgPSBhY3Rpb24uX2NsaXAudHJhY2tzLFxuICAgIFx0XHRcdG5UcmFja3MgPSB0cmFja3MubGVuZ3RoLFxuICAgIFx0XHRcdGJpbmRpbmdzID0gYWN0aW9uLl9wcm9wZXJ0eUJpbmRpbmdzLFxuICAgIFx0XHRcdGludGVycG9sYW50cyA9IGFjdGlvbi5faW50ZXJwb2xhbnRzLFxuICAgIFx0XHRcdHJvb3RVdWlkID0gcm9vdC51dWlkLFxuICAgIFx0XHRcdGJpbmRpbmdzQnlSb290ID0gdGhpcy5fYmluZGluZ3NCeVJvb3RBbmROYW1lLFxuICAgIFx0XHRcdGJpbmRpbmdzQnlOYW1lID0gYmluZGluZ3NCeVJvb3RbIHJvb3RVdWlkIF07XG5cbiAgICBcdFx0aWYgKCBiaW5kaW5nc0J5TmFtZSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0YmluZGluZ3NCeU5hbWUgPSB7fTtcbiAgICBcdFx0XHRiaW5kaW5nc0J5Um9vdFsgcm9vdFV1aWQgXSA9IGJpbmRpbmdzQnlOYW1lO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgIT09IG5UcmFja3M7ICsrIGkgKSB7XG5cbiAgICBcdFx0XHR2YXIgdHJhY2sgPSB0cmFja3NbIGkgXSxcbiAgICBcdFx0XHRcdHRyYWNrTmFtZSA9IHRyYWNrLm5hbWUsXG4gICAgXHRcdFx0XHRiaW5kaW5nID0gYmluZGluZ3NCeU5hbWVbIHRyYWNrTmFtZSBdO1xuXG4gICAgXHRcdFx0aWYgKCBiaW5kaW5nICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRcdGJpbmRpbmdzWyBpIF0gPSBiaW5kaW5nO1xuXG4gICAgXHRcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdFx0YmluZGluZyA9IGJpbmRpbmdzWyBpIF07XG5cbiAgICBcdFx0XHRcdGlmICggYmluZGluZyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdFx0XHRcdC8vIGV4aXN0aW5nIGJpbmRpbmcsIG1ha2Ugc3VyZSB0aGUgY2FjaGUga25vd3NcblxuICAgIFx0XHRcdFx0XHRpZiAoIGJpbmRpbmcuX2NhY2hlSW5kZXggPT09IG51bGwgKSB7XG5cbiAgICBcdFx0XHRcdFx0XHQrKyBiaW5kaW5nLnJlZmVyZW5jZUNvdW50O1xuICAgIFx0XHRcdFx0XHRcdHRoaXMuX2FkZEluYWN0aXZlQmluZGluZyggYmluZGluZywgcm9vdFV1aWQsIHRyYWNrTmFtZSApO1xuXG4gICAgXHRcdFx0XHRcdH1cblxuICAgIFx0XHRcdFx0XHRjb250aW51ZTtcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0XHR2YXIgcGF0aCA9IHByb3RvdHlwZUFjdGlvbiAmJiBwcm90b3R5cGVBY3Rpb24uXG4gICAgXHRcdFx0XHRcdFx0X3Byb3BlcnR5QmluZGluZ3NbIGkgXS5iaW5kaW5nLnBhcnNlZFBhdGg7XG5cbiAgICBcdFx0XHRcdGJpbmRpbmcgPSBuZXcgUHJvcGVydHlNaXhlcihcbiAgICBcdFx0XHRcdFx0XHRQcm9wZXJ0eUJpbmRpbmcuY3JlYXRlKCByb290LCB0cmFja05hbWUsIHBhdGggKSxcbiAgICBcdFx0XHRcdFx0XHR0cmFjay5WYWx1ZVR5cGVOYW1lLCB0cmFjay5nZXRWYWx1ZVNpemUoKSApO1xuXG4gICAgXHRcdFx0XHQrKyBiaW5kaW5nLnJlZmVyZW5jZUNvdW50O1xuICAgIFx0XHRcdFx0dGhpcy5fYWRkSW5hY3RpdmVCaW5kaW5nKCBiaW5kaW5nLCByb290VXVpZCwgdHJhY2tOYW1lICk7XG5cbiAgICBcdFx0XHRcdGJpbmRpbmdzWyBpIF0gPSBiaW5kaW5nO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0aW50ZXJwb2xhbnRzWyBpIF0ucmVzdWx0QnVmZmVyID0gYmluZGluZy5idWZmZXI7XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9LFxuXG4gICAgXHRfYWN0aXZhdGVBY3Rpb246IGZ1bmN0aW9uKCBhY3Rpb24gKSB7XG5cbiAgICBcdFx0aWYgKCAhIHRoaXMuX2lzQWN0aXZlQWN0aW9uKCBhY3Rpb24gKSApIHtcblxuICAgIFx0XHRcdGlmICggYWN0aW9uLl9jYWNoZUluZGV4ID09PSBudWxsICkge1xuXG4gICAgXHRcdFx0XHQvLyB0aGlzIGFjdGlvbiBoYXMgYmVlbiBmb3Jnb3R0ZW4gYnkgdGhlIGNhY2hlLCBidXQgdGhlIHVzZXJcbiAgICBcdFx0XHRcdC8vIGFwcGVhcnMgdG8gYmUgc3RpbGwgdXNpbmcgaXQgLT4gcmViaW5kXG5cbiAgICBcdFx0XHRcdHZhciByb290VXVpZCA9ICggYWN0aW9uLl9sb2NhbFJvb3QgfHwgdGhpcy5fcm9vdCApLnV1aWQsXG4gICAgXHRcdFx0XHRcdGNsaXBVdWlkID0gYWN0aW9uLl9jbGlwLnV1aWQsXG4gICAgXHRcdFx0XHRcdGFjdGlvbnNGb3JDbGlwID0gdGhpcy5fYWN0aW9uc0J5Q2xpcFsgY2xpcFV1aWQgXTtcblxuICAgIFx0XHRcdFx0dGhpcy5fYmluZEFjdGlvbiggYWN0aW9uLFxuICAgIFx0XHRcdFx0XHRcdGFjdGlvbnNGb3JDbGlwICYmIGFjdGlvbnNGb3JDbGlwLmtub3duQWN0aW9uc1sgMCBdICk7XG5cbiAgICBcdFx0XHRcdHRoaXMuX2FkZEluYWN0aXZlQWN0aW9uKCBhY3Rpb24sIGNsaXBVdWlkLCByb290VXVpZCApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0dmFyIGJpbmRpbmdzID0gYWN0aW9uLl9wcm9wZXJ0eUJpbmRpbmdzO1xuXG4gICAgXHRcdFx0Ly8gaW5jcmVtZW50IHJlZmVyZW5jZSBjb3VudHMgLyBzb3J0IG91dCBzdGF0ZVxuICAgIFx0XHRcdGZvciAoIHZhciBpID0gMCwgbiA9IGJpbmRpbmdzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcblxuICAgIFx0XHRcdFx0dmFyIGJpbmRpbmcgPSBiaW5kaW5nc1sgaSBdO1xuXG4gICAgXHRcdFx0XHRpZiAoIGJpbmRpbmcudXNlQ291bnQgKysgPT09IDAgKSB7XG5cbiAgICBcdFx0XHRcdFx0dGhpcy5fbGVuZEJpbmRpbmcoIGJpbmRpbmcgKTtcbiAgICBcdFx0XHRcdFx0YmluZGluZy5zYXZlT3JpZ2luYWxTdGF0ZSgpO1xuXG4gICAgXHRcdFx0XHR9XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHR0aGlzLl9sZW5kQWN0aW9uKCBhY3Rpb24gKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdH0sXG5cbiAgICBcdF9kZWFjdGl2YXRlQWN0aW9uOiBmdW5jdGlvbiggYWN0aW9uICkge1xuXG4gICAgXHRcdGlmICggdGhpcy5faXNBY3RpdmVBY3Rpb24oIGFjdGlvbiApICkge1xuXG4gICAgXHRcdFx0dmFyIGJpbmRpbmdzID0gYWN0aW9uLl9wcm9wZXJ0eUJpbmRpbmdzO1xuXG4gICAgXHRcdFx0Ly8gZGVjcmVtZW50IHJlZmVyZW5jZSBjb3VudHMgLyBzb3J0IG91dCBzdGF0ZVxuICAgIFx0XHRcdGZvciAoIHZhciBpID0gMCwgbiA9IGJpbmRpbmdzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcblxuICAgIFx0XHRcdFx0dmFyIGJpbmRpbmcgPSBiaW5kaW5nc1sgaSBdO1xuXG4gICAgXHRcdFx0XHRpZiAoIC0tIGJpbmRpbmcudXNlQ291bnQgPT09IDAgKSB7XG5cbiAgICBcdFx0XHRcdFx0YmluZGluZy5yZXN0b3JlT3JpZ2luYWxTdGF0ZSgpO1xuICAgIFx0XHRcdFx0XHR0aGlzLl90YWtlQmFja0JpbmRpbmcoIGJpbmRpbmcgKTtcblxuICAgIFx0XHRcdFx0fVxuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0dGhpcy5fdGFrZUJhY2tBY3Rpb24oIGFjdGlvbiApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0fSxcblxuICAgIFx0Ly8gTWVtb3J5IG1hbmFnZXJcblxuICAgIFx0X2luaXRNZW1vcnlNYW5hZ2VyOiBmdW5jdGlvbigpIHtcblxuICAgIFx0XHR0aGlzLl9hY3Rpb25zID0gW107IC8vICduQWN0aXZlQWN0aW9ucycgZm9sbG93ZWQgYnkgaW5hY3RpdmUgb25lc1xuICAgIFx0XHR0aGlzLl9uQWN0aXZlQWN0aW9ucyA9IDA7XG5cbiAgICBcdFx0dGhpcy5fYWN0aW9uc0J5Q2xpcCA9IHt9O1xuICAgIFx0XHQvLyBpbnNpZGU6XG4gICAgXHRcdC8vIHtcbiAgICBcdFx0Ly8gXHRcdGtub3duQWN0aW9uczogQXJyYXk8IEFuaW1hdGlvbkFjdGlvbiA+XHQtIHVzZWQgYXMgcHJvdG90eXBlc1xuICAgIFx0XHQvLyBcdFx0YWN0aW9uQnlSb290OiBBbmltYXRpb25BY3Rpb25cdFx0XHQtIGxvb2t1cFxuICAgIFx0XHQvLyB9XG5cblxuICAgIFx0XHR0aGlzLl9iaW5kaW5ncyA9IFtdOyAvLyAnbkFjdGl2ZUJpbmRpbmdzJyBmb2xsb3dlZCBieSBpbmFjdGl2ZSBvbmVzXG4gICAgXHRcdHRoaXMuX25BY3RpdmVCaW5kaW5ncyA9IDA7XG5cbiAgICBcdFx0dGhpcy5fYmluZGluZ3NCeVJvb3RBbmROYW1lID0ge307IC8vIGluc2lkZTogTWFwPCBuYW1lLCBQcm9wZXJ0eU1peGVyID5cblxuXG4gICAgXHRcdHRoaXMuX2NvbnRyb2xJbnRlcnBvbGFudHMgPSBbXTsgLy8gc2FtZSBnYW1lIGFzIGFib3ZlXG4gICAgXHRcdHRoaXMuX25BY3RpdmVDb250cm9sSW50ZXJwb2xhbnRzID0gMDtcblxuICAgIFx0XHR2YXIgc2NvcGUgPSB0aGlzO1xuXG4gICAgXHRcdHRoaXMuc3RhdHMgPSB7XG5cbiAgICBcdFx0XHRhY3Rpb25zOiB7XG4gICAgXHRcdFx0XHRnZXQgdG90YWwoKSB7IHJldHVybiBzY29wZS5fYWN0aW9ucy5sZW5ndGg7IH0sXG4gICAgXHRcdFx0XHRnZXQgaW5Vc2UoKSB7IHJldHVybiBzY29wZS5fbkFjdGl2ZUFjdGlvbnM7IH1cbiAgICBcdFx0XHR9LFxuICAgIFx0XHRcdGJpbmRpbmdzOiB7XG4gICAgXHRcdFx0XHRnZXQgdG90YWwoKSB7IHJldHVybiBzY29wZS5fYmluZGluZ3MubGVuZ3RoOyB9LFxuICAgIFx0XHRcdFx0Z2V0IGluVXNlKCkgeyByZXR1cm4gc2NvcGUuX25BY3RpdmVCaW5kaW5nczsgfVxuICAgIFx0XHRcdH0sXG4gICAgXHRcdFx0Y29udHJvbEludGVycG9sYW50czoge1xuICAgIFx0XHRcdFx0Z2V0IHRvdGFsKCkgeyByZXR1cm4gc2NvcGUuX2NvbnRyb2xJbnRlcnBvbGFudHMubGVuZ3RoOyB9LFxuICAgIFx0XHRcdFx0Z2V0IGluVXNlKCkgeyByZXR1cm4gc2NvcGUuX25BY3RpdmVDb250cm9sSW50ZXJwb2xhbnRzOyB9XG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH07XG5cbiAgICBcdH0sXG5cbiAgICBcdC8vIE1lbW9yeSBtYW5hZ2VtZW50IGZvciBBbmltYXRpb25BY3Rpb24gb2JqZWN0c1xuXG4gICAgXHRfaXNBY3RpdmVBY3Rpb246IGZ1bmN0aW9uKCBhY3Rpb24gKSB7XG5cbiAgICBcdFx0dmFyIGluZGV4ID0gYWN0aW9uLl9jYWNoZUluZGV4O1xuICAgIFx0XHRyZXR1cm4gaW5kZXggIT09IG51bGwgJiYgaW5kZXggPCB0aGlzLl9uQWN0aXZlQWN0aW9ucztcblxuICAgIFx0fSxcblxuICAgIFx0X2FkZEluYWN0aXZlQWN0aW9uOiBmdW5jdGlvbiggYWN0aW9uLCBjbGlwVXVpZCwgcm9vdFV1aWQgKSB7XG5cbiAgICBcdFx0dmFyIGFjdGlvbnMgPSB0aGlzLl9hY3Rpb25zLFxuICAgIFx0XHRcdGFjdGlvbnNCeUNsaXAgPSB0aGlzLl9hY3Rpb25zQnlDbGlwLFxuICAgIFx0XHRcdGFjdGlvbnNGb3JDbGlwID0gYWN0aW9uc0J5Q2xpcFsgY2xpcFV1aWQgXTtcblxuICAgIFx0XHRpZiAoIGFjdGlvbnNGb3JDbGlwID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRhY3Rpb25zRm9yQ2xpcCA9IHtcblxuICAgIFx0XHRcdFx0a25vd25BY3Rpb25zOiBbIGFjdGlvbiBdLFxuICAgIFx0XHRcdFx0YWN0aW9uQnlSb290OiB7fVxuXG4gICAgXHRcdFx0fTtcblxuICAgIFx0XHRcdGFjdGlvbi5fYnlDbGlwQ2FjaGVJbmRleCA9IDA7XG5cbiAgICBcdFx0XHRhY3Rpb25zQnlDbGlwWyBjbGlwVXVpZCBdID0gYWN0aW9uc0ZvckNsaXA7XG5cbiAgICBcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdHZhciBrbm93bkFjdGlvbnMgPSBhY3Rpb25zRm9yQ2xpcC5rbm93bkFjdGlvbnM7XG5cbiAgICBcdFx0XHRhY3Rpb24uX2J5Q2xpcENhY2hlSW5kZXggPSBrbm93bkFjdGlvbnMubGVuZ3RoO1xuICAgIFx0XHRcdGtub3duQWN0aW9ucy5wdXNoKCBhY3Rpb24gKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0YWN0aW9uLl9jYWNoZUluZGV4ID0gYWN0aW9ucy5sZW5ndGg7XG4gICAgXHRcdGFjdGlvbnMucHVzaCggYWN0aW9uICk7XG5cbiAgICBcdFx0YWN0aW9uc0ZvckNsaXAuYWN0aW9uQnlSb290WyByb290VXVpZCBdID0gYWN0aW9uO1xuXG4gICAgXHR9LFxuXG4gICAgXHRfcmVtb3ZlSW5hY3RpdmVBY3Rpb246IGZ1bmN0aW9uKCBhY3Rpb24gKSB7XG5cbiAgICBcdFx0dmFyIGFjdGlvbnMgPSB0aGlzLl9hY3Rpb25zLFxuICAgIFx0XHRcdGxhc3RJbmFjdGl2ZUFjdGlvbiA9IGFjdGlvbnNbIGFjdGlvbnMubGVuZ3RoIC0gMSBdLFxuICAgIFx0XHRcdGNhY2hlSW5kZXggPSBhY3Rpb24uX2NhY2hlSW5kZXg7XG5cbiAgICBcdFx0bGFzdEluYWN0aXZlQWN0aW9uLl9jYWNoZUluZGV4ID0gY2FjaGVJbmRleDtcbiAgICBcdFx0YWN0aW9uc1sgY2FjaGVJbmRleCBdID0gbGFzdEluYWN0aXZlQWN0aW9uO1xuICAgIFx0XHRhY3Rpb25zLnBvcCgpO1xuXG4gICAgXHRcdGFjdGlvbi5fY2FjaGVJbmRleCA9IG51bGw7XG5cblxuICAgIFx0XHR2YXIgY2xpcFV1aWQgPSBhY3Rpb24uX2NsaXAudXVpZCxcbiAgICBcdFx0XHRhY3Rpb25zQnlDbGlwID0gdGhpcy5fYWN0aW9uc0J5Q2xpcCxcbiAgICBcdFx0XHRhY3Rpb25zRm9yQ2xpcCA9IGFjdGlvbnNCeUNsaXBbIGNsaXBVdWlkIF0sXG4gICAgXHRcdFx0a25vd25BY3Rpb25zRm9yQ2xpcCA9IGFjdGlvbnNGb3JDbGlwLmtub3duQWN0aW9ucyxcblxuICAgIFx0XHRcdGxhc3RLbm93bkFjdGlvbiA9XG4gICAgXHRcdFx0XHRrbm93bkFjdGlvbnNGb3JDbGlwWyBrbm93bkFjdGlvbnNGb3JDbGlwLmxlbmd0aCAtIDEgXSxcblxuICAgIFx0XHRcdGJ5Q2xpcENhY2hlSW5kZXggPSBhY3Rpb24uX2J5Q2xpcENhY2hlSW5kZXg7XG5cbiAgICBcdFx0bGFzdEtub3duQWN0aW9uLl9ieUNsaXBDYWNoZUluZGV4ID0gYnlDbGlwQ2FjaGVJbmRleDtcbiAgICBcdFx0a25vd25BY3Rpb25zRm9yQ2xpcFsgYnlDbGlwQ2FjaGVJbmRleCBdID0gbGFzdEtub3duQWN0aW9uO1xuICAgIFx0XHRrbm93bkFjdGlvbnNGb3JDbGlwLnBvcCgpO1xuXG4gICAgXHRcdGFjdGlvbi5fYnlDbGlwQ2FjaGVJbmRleCA9IG51bGw7XG5cblxuICAgIFx0XHR2YXIgYWN0aW9uQnlSb290ID0gYWN0aW9uc0ZvckNsaXAuYWN0aW9uQnlSb290LFxuICAgIFx0XHRcdHJvb3RVdWlkID0gKCBhY3Rpb25zLl9sb2NhbFJvb3QgfHwgdGhpcy5fcm9vdCApLnV1aWQ7XG5cbiAgICBcdFx0ZGVsZXRlIGFjdGlvbkJ5Um9vdFsgcm9vdFV1aWQgXTtcblxuICAgIFx0XHRpZiAoIGtub3duQWN0aW9uc0ZvckNsaXAubGVuZ3RoID09PSAwICkge1xuXG4gICAgXHRcdFx0ZGVsZXRlIGFjdGlvbnNCeUNsaXBbIGNsaXBVdWlkIF07XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHRoaXMuX3JlbW92ZUluYWN0aXZlQmluZGluZ3NGb3JBY3Rpb24oIGFjdGlvbiApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRfcmVtb3ZlSW5hY3RpdmVCaW5kaW5nc0ZvckFjdGlvbjogZnVuY3Rpb24oIGFjdGlvbiApIHtcblxuICAgIFx0XHR2YXIgYmluZGluZ3MgPSBhY3Rpb24uX3Byb3BlcnR5QmluZGluZ3M7XG4gICAgXHRcdGZvciAoIHZhciBpID0gMCwgbiA9IGJpbmRpbmdzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcblxuICAgIFx0XHRcdHZhciBiaW5kaW5nID0gYmluZGluZ3NbIGkgXTtcblxuICAgIFx0XHRcdGlmICggLS0gYmluZGluZy5yZWZlcmVuY2VDb3VudCA9PT0gMCApIHtcblxuICAgIFx0XHRcdFx0dGhpcy5fcmVtb3ZlSW5hY3RpdmVCaW5kaW5nKCBiaW5kaW5nICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9LFxuXG4gICAgXHRfbGVuZEFjdGlvbjogZnVuY3Rpb24oIGFjdGlvbiApIHtcblxuICAgIFx0XHQvLyBbIGFjdGl2ZSBhY3Rpb25zIHwgIGluYWN0aXZlIGFjdGlvbnMgIF1cbiAgICBcdFx0Ly8gWyAgYWN0aXZlIGFjdGlvbnMgPnwgaW5hY3RpdmUgYWN0aW9ucyBdXG4gICAgXHRcdC8vICAgICAgICAgICAgICAgICBzICAgICAgICBhXG4gICAgXHRcdC8vICAgICAgICAgICAgICAgICAgPC1zd2FwLT5cbiAgICBcdFx0Ly8gICAgICAgICAgICAgICAgIGEgICAgICAgIHNcblxuICAgIFx0XHR2YXIgYWN0aW9ucyA9IHRoaXMuX2FjdGlvbnMsXG4gICAgXHRcdFx0cHJldkluZGV4ID0gYWN0aW9uLl9jYWNoZUluZGV4LFxuXG4gICAgXHRcdFx0bGFzdEFjdGl2ZUluZGV4ID0gdGhpcy5fbkFjdGl2ZUFjdGlvbnMgKyssXG5cbiAgICBcdFx0XHRmaXJzdEluYWN0aXZlQWN0aW9uID0gYWN0aW9uc1sgbGFzdEFjdGl2ZUluZGV4IF07XG5cbiAgICBcdFx0YWN0aW9uLl9jYWNoZUluZGV4ID0gbGFzdEFjdGl2ZUluZGV4O1xuICAgIFx0XHRhY3Rpb25zWyBsYXN0QWN0aXZlSW5kZXggXSA9IGFjdGlvbjtcblxuICAgIFx0XHRmaXJzdEluYWN0aXZlQWN0aW9uLl9jYWNoZUluZGV4ID0gcHJldkluZGV4O1xuICAgIFx0XHRhY3Rpb25zWyBwcmV2SW5kZXggXSA9IGZpcnN0SW5hY3RpdmVBY3Rpb247XG5cbiAgICBcdH0sXG5cbiAgICBcdF90YWtlQmFja0FjdGlvbjogZnVuY3Rpb24oIGFjdGlvbiApIHtcblxuICAgIFx0XHQvLyBbICBhY3RpdmUgYWN0aW9ucyAgfCBpbmFjdGl2ZSBhY3Rpb25zIF1cbiAgICBcdFx0Ly8gWyBhY3RpdmUgYWN0aW9ucyB8PCBpbmFjdGl2ZSBhY3Rpb25zICBdXG4gICAgXHRcdC8vICAgICAgICBhICAgICAgICBzXG4gICAgXHRcdC8vICAgICAgICAgPC1zd2FwLT5cbiAgICBcdFx0Ly8gICAgICAgIHMgICAgICAgIGFcblxuICAgIFx0XHR2YXIgYWN0aW9ucyA9IHRoaXMuX2FjdGlvbnMsXG4gICAgXHRcdFx0cHJldkluZGV4ID0gYWN0aW9uLl9jYWNoZUluZGV4LFxuXG4gICAgXHRcdFx0Zmlyc3RJbmFjdGl2ZUluZGV4ID0gLS0gdGhpcy5fbkFjdGl2ZUFjdGlvbnMsXG5cbiAgICBcdFx0XHRsYXN0QWN0aXZlQWN0aW9uID0gYWN0aW9uc1sgZmlyc3RJbmFjdGl2ZUluZGV4IF07XG5cbiAgICBcdFx0YWN0aW9uLl9jYWNoZUluZGV4ID0gZmlyc3RJbmFjdGl2ZUluZGV4O1xuICAgIFx0XHRhY3Rpb25zWyBmaXJzdEluYWN0aXZlSW5kZXggXSA9IGFjdGlvbjtcblxuICAgIFx0XHRsYXN0QWN0aXZlQWN0aW9uLl9jYWNoZUluZGV4ID0gcHJldkluZGV4O1xuICAgIFx0XHRhY3Rpb25zWyBwcmV2SW5kZXggXSA9IGxhc3RBY3RpdmVBY3Rpb247XG5cbiAgICBcdH0sXG5cbiAgICBcdC8vIE1lbW9yeSBtYW5hZ2VtZW50IGZvciBQcm9wZXJ0eU1peGVyIG9iamVjdHNcblxuICAgIFx0X2FkZEluYWN0aXZlQmluZGluZzogZnVuY3Rpb24oIGJpbmRpbmcsIHJvb3RVdWlkLCB0cmFja05hbWUgKSB7XG5cbiAgICBcdFx0dmFyIGJpbmRpbmdzQnlSb290ID0gdGhpcy5fYmluZGluZ3NCeVJvb3RBbmROYW1lLFxuICAgIFx0XHRcdGJpbmRpbmdCeU5hbWUgPSBiaW5kaW5nc0J5Um9vdFsgcm9vdFV1aWQgXSxcblxuICAgIFx0XHRcdGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3M7XG5cbiAgICBcdFx0aWYgKCBiaW5kaW5nQnlOYW1lID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRiaW5kaW5nQnlOYW1lID0ge307XG4gICAgXHRcdFx0YmluZGluZ3NCeVJvb3RbIHJvb3RVdWlkIF0gPSBiaW5kaW5nQnlOYW1lO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRiaW5kaW5nQnlOYW1lWyB0cmFja05hbWUgXSA9IGJpbmRpbmc7XG5cbiAgICBcdFx0YmluZGluZy5fY2FjaGVJbmRleCA9IGJpbmRpbmdzLmxlbmd0aDtcbiAgICBcdFx0YmluZGluZ3MucHVzaCggYmluZGluZyApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRfcmVtb3ZlSW5hY3RpdmVCaW5kaW5nOiBmdW5jdGlvbiggYmluZGluZyApIHtcblxuICAgIFx0XHR2YXIgYmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncyxcbiAgICBcdFx0XHRwcm9wQmluZGluZyA9IGJpbmRpbmcuYmluZGluZyxcbiAgICBcdFx0XHRyb290VXVpZCA9IHByb3BCaW5kaW5nLnJvb3ROb2RlLnV1aWQsXG4gICAgXHRcdFx0dHJhY2tOYW1lID0gcHJvcEJpbmRpbmcucGF0aCxcbiAgICBcdFx0XHRiaW5kaW5nc0J5Um9vdCA9IHRoaXMuX2JpbmRpbmdzQnlSb290QW5kTmFtZSxcbiAgICBcdFx0XHRiaW5kaW5nQnlOYW1lID0gYmluZGluZ3NCeVJvb3RbIHJvb3RVdWlkIF0sXG5cbiAgICBcdFx0XHRsYXN0SW5hY3RpdmVCaW5kaW5nID0gYmluZGluZ3NbIGJpbmRpbmdzLmxlbmd0aCAtIDEgXSxcbiAgICBcdFx0XHRjYWNoZUluZGV4ID0gYmluZGluZy5fY2FjaGVJbmRleDtcblxuICAgIFx0XHRsYXN0SW5hY3RpdmVCaW5kaW5nLl9jYWNoZUluZGV4ID0gY2FjaGVJbmRleDtcbiAgICBcdFx0YmluZGluZ3NbIGNhY2hlSW5kZXggXSA9IGxhc3RJbmFjdGl2ZUJpbmRpbmc7XG4gICAgXHRcdGJpbmRpbmdzLnBvcCgpO1xuXG4gICAgXHRcdGRlbGV0ZSBiaW5kaW5nQnlOYW1lWyB0cmFja05hbWUgXTtcblxuICAgIFx0XHRyZW1vdmVfZW1wdHlfbWFwOiB7XG5cbiAgICBcdFx0XHRmb3IgKCB2YXIgXyBpbiBiaW5kaW5nQnlOYW1lICkgYnJlYWsgcmVtb3ZlX2VtcHR5X21hcDtcblxuICAgIFx0XHRcdGRlbGV0ZSBiaW5kaW5nc0J5Um9vdFsgcm9vdFV1aWQgXTtcblxuICAgIFx0XHR9XG5cbiAgICBcdH0sXG5cbiAgICBcdF9sZW5kQmluZGluZzogZnVuY3Rpb24oIGJpbmRpbmcgKSB7XG5cbiAgICBcdFx0dmFyIGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3MsXG4gICAgXHRcdFx0cHJldkluZGV4ID0gYmluZGluZy5fY2FjaGVJbmRleCxcblxuICAgIFx0XHRcdGxhc3RBY3RpdmVJbmRleCA9IHRoaXMuX25BY3RpdmVCaW5kaW5ncyArKyxcblxuICAgIFx0XHRcdGZpcnN0SW5hY3RpdmVCaW5kaW5nID0gYmluZGluZ3NbIGxhc3RBY3RpdmVJbmRleCBdO1xuXG4gICAgXHRcdGJpbmRpbmcuX2NhY2hlSW5kZXggPSBsYXN0QWN0aXZlSW5kZXg7XG4gICAgXHRcdGJpbmRpbmdzWyBsYXN0QWN0aXZlSW5kZXggXSA9IGJpbmRpbmc7XG5cbiAgICBcdFx0Zmlyc3RJbmFjdGl2ZUJpbmRpbmcuX2NhY2hlSW5kZXggPSBwcmV2SW5kZXg7XG4gICAgXHRcdGJpbmRpbmdzWyBwcmV2SW5kZXggXSA9IGZpcnN0SW5hY3RpdmVCaW5kaW5nO1xuXG4gICAgXHR9LFxuXG4gICAgXHRfdGFrZUJhY2tCaW5kaW5nOiBmdW5jdGlvbiggYmluZGluZyApIHtcblxuICAgIFx0XHR2YXIgYmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncyxcbiAgICBcdFx0XHRwcmV2SW5kZXggPSBiaW5kaW5nLl9jYWNoZUluZGV4LFxuXG4gICAgXHRcdFx0Zmlyc3RJbmFjdGl2ZUluZGV4ID0gLS0gdGhpcy5fbkFjdGl2ZUJpbmRpbmdzLFxuXG4gICAgXHRcdFx0bGFzdEFjdGl2ZUJpbmRpbmcgPSBiaW5kaW5nc1sgZmlyc3RJbmFjdGl2ZUluZGV4IF07XG5cbiAgICBcdFx0YmluZGluZy5fY2FjaGVJbmRleCA9IGZpcnN0SW5hY3RpdmVJbmRleDtcbiAgICBcdFx0YmluZGluZ3NbIGZpcnN0SW5hY3RpdmVJbmRleCBdID0gYmluZGluZztcblxuICAgIFx0XHRsYXN0QWN0aXZlQmluZGluZy5fY2FjaGVJbmRleCA9IHByZXZJbmRleDtcbiAgICBcdFx0YmluZGluZ3NbIHByZXZJbmRleCBdID0gbGFzdEFjdGl2ZUJpbmRpbmc7XG5cbiAgICBcdH0sXG5cblxuICAgIFx0Ly8gTWVtb3J5IG1hbmFnZW1lbnQgb2YgSW50ZXJwb2xhbnRzIGZvciB3ZWlnaHQgYW5kIHRpbWUgc2NhbGVcblxuICAgIFx0X2xlbmRDb250cm9sSW50ZXJwb2xhbnQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgXHRcdHZhciBpbnRlcnBvbGFudHMgPSB0aGlzLl9jb250cm9sSW50ZXJwb2xhbnRzLFxuICAgIFx0XHRcdGxhc3RBY3RpdmVJbmRleCA9IHRoaXMuX25BY3RpdmVDb250cm9sSW50ZXJwb2xhbnRzICsrLFxuICAgIFx0XHRcdGludGVycG9sYW50ID0gaW50ZXJwb2xhbnRzWyBsYXN0QWN0aXZlSW5kZXggXTtcblxuICAgIFx0XHRpZiAoIGludGVycG9sYW50ID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICBcdFx0XHRpbnRlcnBvbGFudCA9IG5ldyBMaW5lYXJJbnRlcnBvbGFudChcbiAgICBcdFx0XHRcdFx0bmV3IEZsb2F0MzJBcnJheSggMiApLCBuZXcgRmxvYXQzMkFycmF5KCAyICksXG4gICAgXHRcdFx0XHRcdFx0MSwgdGhpcy5fY29udHJvbEludGVycG9sYW50c1Jlc3VsdEJ1ZmZlciApO1xuXG4gICAgXHRcdFx0aW50ZXJwb2xhbnQuX19jYWNoZUluZGV4ID0gbGFzdEFjdGl2ZUluZGV4O1xuICAgIFx0XHRcdGludGVycG9sYW50c1sgbGFzdEFjdGl2ZUluZGV4IF0gPSBpbnRlcnBvbGFudDtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIGludGVycG9sYW50O1xuXG4gICAgXHR9LFxuXG4gICAgXHRfdGFrZUJhY2tDb250cm9sSW50ZXJwb2xhbnQ6IGZ1bmN0aW9uKCBpbnRlcnBvbGFudCApIHtcblxuICAgIFx0XHR2YXIgaW50ZXJwb2xhbnRzID0gdGhpcy5fY29udHJvbEludGVycG9sYW50cyxcbiAgICBcdFx0XHRwcmV2SW5kZXggPSBpbnRlcnBvbGFudC5fX2NhY2hlSW5kZXgsXG5cbiAgICBcdFx0XHRmaXJzdEluYWN0aXZlSW5kZXggPSAtLSB0aGlzLl9uQWN0aXZlQ29udHJvbEludGVycG9sYW50cyxcblxuICAgIFx0XHRcdGxhc3RBY3RpdmVJbnRlcnBvbGFudCA9IGludGVycG9sYW50c1sgZmlyc3RJbmFjdGl2ZUluZGV4IF07XG5cbiAgICBcdFx0aW50ZXJwb2xhbnQuX19jYWNoZUluZGV4ID0gZmlyc3RJbmFjdGl2ZUluZGV4O1xuICAgIFx0XHRpbnRlcnBvbGFudHNbIGZpcnN0SW5hY3RpdmVJbmRleCBdID0gaW50ZXJwb2xhbnQ7XG5cbiAgICBcdFx0bGFzdEFjdGl2ZUludGVycG9sYW50Ll9fY2FjaGVJbmRleCA9IHByZXZJbmRleDtcbiAgICBcdFx0aW50ZXJwb2xhbnRzWyBwcmV2SW5kZXggXSA9IGxhc3RBY3RpdmVJbnRlcnBvbGFudDtcblxuICAgIFx0fSxcblxuICAgIFx0X2NvbnRyb2xJbnRlcnBvbGFudHNSZXN1bHRCdWZmZXI6IG5ldyBGbG9hdDMyQXJyYXkoIDEgKVxuXG4gICAgfSApO1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIFVuaWZvcm0oIHZhbHVlICkge1xuXG4gICAgXHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgKSB7XG5cbiAgICBcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVW5pZm9ybTogVHlwZSBwYXJhbWV0ZXIgaXMgbm8gbG9uZ2VyIG5lZWRlZC4nICk7XG4gICAgXHRcdHZhbHVlID0gYXJndW1lbnRzWyAxIF07XG5cbiAgICBcdH1cblxuICAgIFx0dGhpcy52YWx1ZSA9IHZhbHVlO1xuXG4gICAgXHR0aGlzLmR5bmFtaWMgPSBmYWxzZTtcblxuICAgIH1cblxuICAgIFVuaWZvcm0ucHJvdG90eXBlID0ge1xuXG4gICAgXHRjb25zdHJ1Y3RvcjogVW5pZm9ybSxcblxuICAgIFx0b25VcGRhdGU6IGZ1bmN0aW9uICggY2FsbGJhY2sgKSB7XG5cbiAgICBcdFx0dGhpcy5keW5hbWljID0gdHJ1ZTtcbiAgICBcdFx0dGhpcy5vblVwZGF0ZUNhbGxiYWNrID0gY2FsbGJhY2s7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH1cblxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIGJlbmFhZGFtcyAvIGh0dHBzOi8vdHdpdHRlci5jb20vYmVuX2FfYWRhbXNcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIEluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5KCkge1xuXG4gICAgXHRCdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cbiAgICBcdHRoaXMudHlwZSA9ICdJbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSc7XG4gICAgXHR0aGlzLm1heEluc3RhbmNlZENvdW50ID0gdW5kZWZpbmVkO1xuXG4gICAgfVxuXG4gICAgSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XG4gICAgSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnk7XG5cbiAgICBJbnN0YW5jZWRCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuaXNJbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSA9IHRydWU7XG5cbiAgICBJbnN0YW5jZWRCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuYWRkR3JvdXAgPSBmdW5jdGlvbiAoIHN0YXJ0LCBjb3VudCwgaW5zdGFuY2VzICkge1xuXG4gICAgXHR0aGlzLmdyb3Vwcy5wdXNoKCB7XG5cbiAgICBcdFx0c3RhcnQ6IHN0YXJ0LFxuICAgIFx0XHRjb3VudDogY291bnQsXG4gICAgXHRcdGluc3RhbmNlczogaW5zdGFuY2VzXG5cbiAgICBcdH0gKTtcblxuICAgIH07XG5cbiAgICBJbnN0YW5jZWRCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xuXG4gICAgXHR2YXIgaW5kZXggPSBzb3VyY2UuaW5kZXg7XG5cbiAgICBcdGlmICggaW5kZXggIT09IG51bGwgKSB7XG5cbiAgICBcdFx0dGhpcy5zZXRJbmRleCggaW5kZXguY2xvbmUoKSApO1xuXG4gICAgXHR9XG5cbiAgICBcdHZhciBhdHRyaWJ1dGVzID0gc291cmNlLmF0dHJpYnV0ZXM7XG5cbiAgICBcdGZvciAoIHZhciBuYW1lIGluIGF0dHJpYnV0ZXMgKSB7XG5cbiAgICBcdFx0dmFyIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbIG5hbWUgXTtcbiAgICBcdFx0dGhpcy5hZGRBdHRyaWJ1dGUoIG5hbWUsIGF0dHJpYnV0ZS5jbG9uZSgpICk7XG5cbiAgICBcdH1cblxuICAgIFx0dmFyIGdyb3VwcyA9IHNvdXJjZS5ncm91cHM7XG5cbiAgICBcdGZvciAoIHZhciBpID0gMCwgbCA9IGdyb3Vwcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgXHRcdHZhciBncm91cCA9IGdyb3Vwc1sgaSBdO1xuICAgIFx0XHR0aGlzLmFkZEdyb3VwKCBncm91cC5zdGFydCwgZ3JvdXAuY291bnQsIGdyb3VwLmluc3RhbmNlcyApO1xuXG4gICAgXHR9XG5cbiAgICBcdHJldHVybiB0aGlzO1xuXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgYmVuYWFkYW1zIC8gaHR0cHM6Ly90d2l0dGVyLmNvbS9iZW5fYV9hZGFtc1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUoIGludGVybGVhdmVkQnVmZmVyLCBpdGVtU2l6ZSwgb2Zmc2V0LCBub3JtYWxpemVkICkge1xuXG4gICAgXHR0aGlzLnV1aWQgPSBleHBvcnRzLk1hdGguZ2VuZXJhdGVVVUlEKCk7XG5cbiAgICBcdHRoaXMuZGF0YSA9IGludGVybGVhdmVkQnVmZmVyO1xuICAgIFx0dGhpcy5pdGVtU2l6ZSA9IGl0ZW1TaXplO1xuICAgIFx0dGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG5cbiAgICBcdHRoaXMubm9ybWFsaXplZCA9IG5vcm1hbGl6ZWQgPT09IHRydWU7XG5cbiAgICB9XG5cblxuICAgIEludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSA9IHtcblxuICAgIFx0Y29uc3RydWN0b3I6IEludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlLFxuXG4gICAgXHRpc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlOiB0cnVlLFxuXG4gICAgXHRnZXQgY291bnQoKSB7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXMuZGF0YS5jb3VudDtcblxuICAgIFx0fSxcblxuICAgIFx0Z2V0IGFycmF5KCkge1xuXG4gICAgXHRcdHJldHVybiB0aGlzLmRhdGEuYXJyYXk7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldFg6IGZ1bmN0aW9uICggaW5kZXgsIHggKSB7XG5cbiAgICBcdFx0dGhpcy5kYXRhLmFycmF5WyBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldCBdID0geDtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0c2V0WTogZnVuY3Rpb24gKCBpbmRleCwgeSApIHtcblxuICAgIFx0XHR0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0ICsgMSBdID0geTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0c2V0WjogZnVuY3Rpb24gKCBpbmRleCwgeiApIHtcblxuICAgIFx0XHR0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0ICsgMiBdID0gejtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0c2V0VzogZnVuY3Rpb24gKCBpbmRleCwgdyApIHtcblxuICAgIFx0XHR0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0ICsgMyBdID0gdztcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0Z2V0WDogZnVuY3Rpb24gKCBpbmRleCApIHtcblxuICAgIFx0XHRyZXR1cm4gdGhpcy5kYXRhLmFycmF5WyBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldCBdO1xuXG4gICAgXHR9LFxuXG4gICAgXHRnZXRZOiBmdW5jdGlvbiAoIGluZGV4ICkge1xuXG4gICAgXHRcdHJldHVybiB0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0ICsgMSBdO1xuXG4gICAgXHR9LFxuXG4gICAgXHRnZXRaOiBmdW5jdGlvbiAoIGluZGV4ICkge1xuXG4gICAgXHRcdHJldHVybiB0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0ICsgMiBdO1xuXG4gICAgXHR9LFxuXG4gICAgXHRnZXRXOiBmdW5jdGlvbiAoIGluZGV4ICkge1xuXG4gICAgXHRcdHJldHVybiB0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0ICsgMyBdO1xuXG4gICAgXHR9LFxuXG4gICAgXHRzZXRYWTogZnVuY3Rpb24gKCBpbmRleCwgeCwgeSApIHtcblxuICAgIFx0XHRpbmRleCA9IGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0O1xuXG4gICAgXHRcdHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKyAwIF0gPSB4O1xuICAgIFx0XHR0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICsgMSBdID0geTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0c2V0WFlaOiBmdW5jdGlvbiAoIGluZGV4LCB4LCB5LCB6ICkge1xuXG4gICAgXHRcdGluZGV4ID0gaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQ7XG5cbiAgICBcdFx0dGhpcy5kYXRhLmFycmF5WyBpbmRleCArIDAgXSA9IHg7XG4gICAgXHRcdHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKyAxIF0gPSB5O1xuICAgIFx0XHR0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICsgMiBdID0gejtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0c2V0WFlaVzogZnVuY3Rpb24gKCBpbmRleCwgeCwgeSwgeiwgdyApIHtcblxuICAgIFx0XHRpbmRleCA9IGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0O1xuXG4gICAgXHRcdHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKyAwIF0gPSB4O1xuICAgIFx0XHR0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICsgMSBdID0geTtcbiAgICBcdFx0dGhpcy5kYXRhLmFycmF5WyBpbmRleCArIDIgXSA9IHo7XG4gICAgXHRcdHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKyAzIF0gPSB3O1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9XG5cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBiZW5hYWRhbXMgLyBodHRwczovL3R3aXR0ZXIuY29tL2Jlbl9hX2FkYW1zXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBJbnRlcmxlYXZlZEJ1ZmZlciggYXJyYXksIHN0cmlkZSApIHtcblxuICAgIFx0dGhpcy51dWlkID0gZXhwb3J0cy5NYXRoLmdlbmVyYXRlVVVJRCgpO1xuXG4gICAgXHR0aGlzLmFycmF5ID0gYXJyYXk7XG4gICAgXHR0aGlzLnN0cmlkZSA9IHN0cmlkZTtcbiAgICBcdHRoaXMuY291bnQgPSBhcnJheSAhPT0gdW5kZWZpbmVkID8gYXJyYXkubGVuZ3RoIC8gc3RyaWRlIDogMDtcblxuICAgIFx0dGhpcy5keW5hbWljID0gZmFsc2U7XG4gICAgXHR0aGlzLnVwZGF0ZVJhbmdlID0geyBvZmZzZXQ6IDAsIGNvdW50OiAtIDEgfTtcblxuICAgIFx0dGhpcy52ZXJzaW9uID0gMDtcblxuICAgIH1cblxuICAgIEludGVybGVhdmVkQnVmZmVyLnByb3RvdHlwZSA9IHtcblxuICAgIFx0Y29uc3RydWN0b3I6IEludGVybGVhdmVkQnVmZmVyLFxuXG4gICAgXHRpc0ludGVybGVhdmVkQnVmZmVyOiB0cnVlLFxuXG4gICAgXHRzZXQgbmVlZHNVcGRhdGUoIHZhbHVlICkge1xuXG4gICAgXHRcdGlmICggdmFsdWUgPT09IHRydWUgKSB0aGlzLnZlcnNpb24gKys7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldER5bmFtaWM6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cbiAgICBcdFx0dGhpcy5keW5hbWljID0gdmFsdWU7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xuXG4gICAgXHRcdHRoaXMuYXJyYXkgPSBuZXcgc291cmNlLmFycmF5LmNvbnN0cnVjdG9yKCBzb3VyY2UuYXJyYXkgKTtcbiAgICBcdFx0dGhpcy5jb3VudCA9IHNvdXJjZS5jb3VudDtcbiAgICBcdFx0dGhpcy5zdHJpZGUgPSBzb3VyY2Uuc3RyaWRlO1xuICAgIFx0XHR0aGlzLmR5bmFtaWMgPSBzb3VyY2UuZHluYW1pYztcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0Y29weUF0OiBmdW5jdGlvbiAoIGluZGV4MSwgYXR0cmlidXRlLCBpbmRleDIgKSB7XG5cbiAgICBcdFx0aW5kZXgxICo9IHRoaXMuc3RyaWRlO1xuICAgIFx0XHRpbmRleDIgKj0gYXR0cmlidXRlLnN0cmlkZTtcblxuICAgIFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLnN0cmlkZTsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICBcdFx0XHR0aGlzLmFycmF5WyBpbmRleDEgKyBpIF0gPSBhdHRyaWJ1dGUuYXJyYXlbIGluZGV4MiArIGkgXTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSwgb2Zmc2V0ICkge1xuXG4gICAgXHRcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG4gICAgXHRcdHRoaXMuYXJyYXkuc2V0KCB2YWx1ZSwgb2Zmc2V0ICk7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICBcdGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xuXG4gICAgXHR9XG5cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBiZW5hYWRhbXMgLyBodHRwczovL3R3aXR0ZXIuY29tL2Jlbl9hX2FkYW1zXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBJbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlciggYXJyYXksIHN0cmlkZSwgbWVzaFBlckF0dHJpYnV0ZSApIHtcblxuICAgIFx0SW50ZXJsZWF2ZWRCdWZmZXIuY2FsbCggdGhpcywgYXJyYXksIHN0cmlkZSApO1xuXG4gICAgXHR0aGlzLm1lc2hQZXJBdHRyaWJ1dGUgPSBtZXNoUGVyQXR0cmlidXRlIHx8IDE7XG5cbiAgICB9XG5cbiAgICBJbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBJbnRlcmxlYXZlZEJ1ZmZlci5wcm90b3R5cGUgKTtcbiAgICBJbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBJbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlcjtcblxuICAgIEluc3RhbmNlZEludGVybGVhdmVkQnVmZmVyLnByb3RvdHlwZS5pc0luc3RhbmNlZEludGVybGVhdmVkQnVmZmVyID0gdHJ1ZTtcblxuICAgIEluc3RhbmNlZEludGVybGVhdmVkQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XG5cbiAgICBcdEludGVybGVhdmVkQnVmZmVyLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xuXG4gICAgXHR0aGlzLm1lc2hQZXJBdHRyaWJ1dGUgPSBzb3VyY2UubWVzaFBlckF0dHJpYnV0ZTtcblxuICAgIFx0cmV0dXJuIHRoaXM7XG5cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBiZW5hYWRhbXMgLyBodHRwczovL3R3aXR0ZXIuY29tL2Jlbl9hX2FkYW1zXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUoIGFycmF5LCBpdGVtU2l6ZSwgbWVzaFBlckF0dHJpYnV0ZSApIHtcblxuICAgIFx0QnVmZmVyQXR0cmlidXRlLmNhbGwoIHRoaXMsIGFycmF5LCBpdGVtU2l6ZSApO1xuXG4gICAgXHR0aGlzLm1lc2hQZXJBdHRyaWJ1dGUgPSBtZXNoUGVyQXR0cmlidXRlIHx8IDE7XG5cbiAgICB9XG5cbiAgICBJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSApO1xuICAgIEluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGU7XG5cbiAgICBJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlLmlzSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlID0gdHJ1ZTtcblxuICAgIEluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xuXG4gICAgXHRCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XG5cbiAgICBcdHRoaXMubWVzaFBlckF0dHJpYnV0ZSA9IHNvdXJjZS5tZXNoUGVyQXR0cmlidXRlO1xuXG4gICAgXHRyZXR1cm4gdGhpcztcblxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICAgICAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW8vXG4gICAgICogQGF1dGhvciBzdGVwaG9taSAvIGh0dHA6Ly9zdGVwaGFuZWdpbmllci5jb20vXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBSYXljYXN0ZXIoIG9yaWdpbiwgZGlyZWN0aW9uLCBuZWFyLCBmYXIgKSB7XG5cbiAgICBcdHRoaXMucmF5ID0gbmV3IFJheSggb3JpZ2luLCBkaXJlY3Rpb24gKTtcbiAgICBcdC8vIGRpcmVjdGlvbiBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWQgKGZvciBhY2N1cmF0ZSBkaXN0YW5jZSBjYWxjdWxhdGlvbnMpXG5cbiAgICBcdHRoaXMubmVhciA9IG5lYXIgfHwgMDtcbiAgICBcdHRoaXMuZmFyID0gZmFyIHx8IEluZmluaXR5O1xuXG4gICAgXHR0aGlzLnBhcmFtcyA9IHtcbiAgICBcdFx0TWVzaDoge30sXG4gICAgXHRcdExpbmU6IHt9LFxuICAgIFx0XHRMT0Q6IHt9LFxuICAgIFx0XHRQb2ludHM6IHsgdGhyZXNob2xkOiAxIH0sXG4gICAgXHRcdFNwcml0ZToge31cbiAgICBcdH07XG5cbiAgICBcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCB0aGlzLnBhcmFtcywge1xuICAgIFx0XHRQb2ludENsb3VkOiB7XG4gICAgXHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgXHRcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5SYXljYXN0ZXI6IHBhcmFtcy5Qb2ludENsb3VkIGhhcyBiZWVuIHJlbmFtZWQgdG8gcGFyYW1zLlBvaW50cy4nICk7XG4gICAgXHRcdFx0XHRyZXR1cm4gdGhpcy5Qb2ludHM7XG4gICAgXHRcdFx0fVxuICAgIFx0XHR9XG4gICAgXHR9ICk7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhc2NTb3J0KCBhLCBiICkge1xuXG4gICAgXHRyZXR1cm4gYS5kaXN0YW5jZSAtIGIuZGlzdGFuY2U7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnRlcnNlY3RPYmplY3QoIG9iamVjdCwgcmF5Y2FzdGVyLCBpbnRlcnNlY3RzLCByZWN1cnNpdmUgKSB7XG5cbiAgICBcdGlmICggb2JqZWN0LnZpc2libGUgPT09IGZhbHNlICkgcmV0dXJuO1xuXG4gICAgXHRvYmplY3QucmF5Y2FzdCggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICk7XG5cbiAgICBcdGlmICggcmVjdXJzaXZlID09PSB0cnVlICkge1xuXG4gICAgXHRcdHZhciBjaGlsZHJlbiA9IG9iamVjdC5jaGlsZHJlbjtcblxuICAgIFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgXHRcdFx0aW50ZXJzZWN0T2JqZWN0KCBjaGlsZHJlblsgaSBdLCByYXljYXN0ZXIsIGludGVyc2VjdHMsIHRydWUgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdH1cblxuICAgIH1cblxuICAgIC8vXG5cbiAgICBSYXljYXN0ZXIucHJvdG90eXBlID0ge1xuXG4gICAgXHRjb25zdHJ1Y3RvcjogUmF5Y2FzdGVyLFxuXG4gICAgXHRsaW5lUHJlY2lzaW9uOiAxLFxuXG4gICAgXHRzZXQ6IGZ1bmN0aW9uICggb3JpZ2luLCBkaXJlY3Rpb24gKSB7XG5cbiAgICBcdFx0Ly8gZGlyZWN0aW9uIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZCAoZm9yIGFjY3VyYXRlIGRpc3RhbmNlIGNhbGN1bGF0aW9ucylcblxuICAgIFx0XHR0aGlzLnJheS5zZXQoIG9yaWdpbiwgZGlyZWN0aW9uICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdHNldEZyb21DYW1lcmE6IGZ1bmN0aW9uICggY29vcmRzLCBjYW1lcmEgKSB7XG5cbiAgICBcdFx0aWYgKCAoY2FtZXJhICYmIGNhbWVyYS5pc1BlcnNwZWN0aXZlQ2FtZXJhKSApIHtcblxuICAgIFx0XHRcdHRoaXMucmF5Lm9yaWdpbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGNhbWVyYS5tYXRyaXhXb3JsZCApO1xuICAgIFx0XHRcdHRoaXMucmF5LmRpcmVjdGlvbi5zZXQoIGNvb3Jkcy54LCBjb29yZHMueSwgMC41ICkudW5wcm9qZWN0KCBjYW1lcmEgKS5zdWIoIHRoaXMucmF5Lm9yaWdpbiApLm5vcm1hbGl6ZSgpO1xuXG4gICAgXHRcdH0gZWxzZSBpZiAoIChjYW1lcmEgJiYgY2FtZXJhLmlzT3J0aG9ncmFwaGljQ2FtZXJhKSApIHtcblxuICAgIFx0XHRcdHRoaXMucmF5Lm9yaWdpbi5zZXQoIGNvb3Jkcy54LCBjb29yZHMueSwgKCBjYW1lcmEubmVhciArIGNhbWVyYS5mYXIgKSAvICggY2FtZXJhLm5lYXIgLSBjYW1lcmEuZmFyICkgKS51bnByb2plY3QoIGNhbWVyYSApOyAvLyBzZXQgb3JpZ2luIGluIHBsYW5lIG9mIGNhbWVyYVxuICAgIFx0XHRcdHRoaXMucmF5LmRpcmVjdGlvbi5zZXQoIDAsIDAsIC0gMSApLnRyYW5zZm9ybURpcmVjdGlvbiggY2FtZXJhLm1hdHJpeFdvcmxkICk7XG5cbiAgICBcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5SYXljYXN0ZXI6IFVuc3VwcG9ydGVkIGNhbWVyYSB0eXBlLicgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdH0sXG5cbiAgICBcdGludGVyc2VjdE9iamVjdDogZnVuY3Rpb24gKCBvYmplY3QsIHJlY3Vyc2l2ZSApIHtcblxuICAgIFx0XHR2YXIgaW50ZXJzZWN0cyA9IFtdO1xuXG4gICAgXHRcdGludGVyc2VjdE9iamVjdCggb2JqZWN0LCB0aGlzLCBpbnRlcnNlY3RzLCByZWN1cnNpdmUgKTtcblxuICAgIFx0XHRpbnRlcnNlY3RzLnNvcnQoIGFzY1NvcnQgKTtcblxuICAgIFx0XHRyZXR1cm4gaW50ZXJzZWN0cztcblxuICAgIFx0fSxcblxuICAgIFx0aW50ZXJzZWN0T2JqZWN0czogZnVuY3Rpb24gKCBvYmplY3RzLCByZWN1cnNpdmUgKSB7XG5cbiAgICBcdFx0dmFyIGludGVyc2VjdHMgPSBbXTtcblxuICAgIFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIG9iamVjdHMgKSA9PT0gZmFsc2UgKSB7XG5cbiAgICBcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5SYXljYXN0ZXIuaW50ZXJzZWN0T2JqZWN0czogb2JqZWN0cyBpcyBub3QgYW4gQXJyYXkuJyApO1xuICAgIFx0XHRcdHJldHVybiBpbnRlcnNlY3RzO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBvYmplY3RzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICBcdFx0XHRpbnRlcnNlY3RPYmplY3QoIG9iamVjdHNbIGkgXSwgdGhpcywgaW50ZXJzZWN0cywgcmVjdXJzaXZlICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGludGVyc2VjdHMuc29ydCggYXNjU29ydCApO1xuXG4gICAgXHRcdHJldHVybiBpbnRlcnNlY3RzO1xuXG4gICAgXHR9XG5cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIENsb2NrKCBhdXRvU3RhcnQgKSB7XG5cbiAgICBcdHRoaXMuYXV0b1N0YXJ0ID0gKCBhdXRvU3RhcnQgIT09IHVuZGVmaW5lZCApID8gYXV0b1N0YXJ0IDogdHJ1ZTtcblxuICAgIFx0dGhpcy5zdGFydFRpbWUgPSAwO1xuICAgIFx0dGhpcy5vbGRUaW1lID0gMDtcbiAgICBcdHRoaXMuZWxhcHNlZFRpbWUgPSAwO1xuXG4gICAgXHR0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcblxuICAgIH1cblxuICAgIENsb2NrLnByb3RvdHlwZSA9IHtcblxuICAgIFx0Y29uc3RydWN0b3I6IENsb2NrLFxuXG4gICAgXHRzdGFydDogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHRoaXMuc3RhcnRUaW1lID0gKCBwZXJmb3JtYW5jZSB8fCBEYXRlICkubm93KCk7XG5cbiAgICBcdFx0dGhpcy5vbGRUaW1lID0gdGhpcy5zdGFydFRpbWU7XG4gICAgXHRcdHRoaXMucnVubmluZyA9IHRydWU7XG5cbiAgICBcdH0sXG5cbiAgICBcdHN0b3A6IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0XHR0aGlzLmdldEVsYXBzZWRUaW1lKCk7XG4gICAgXHRcdHRoaXMucnVubmluZyA9IGZhbHNlO1xuXG4gICAgXHR9LFxuXG4gICAgXHRnZXRFbGFwc2VkVGltZTogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHRoaXMuZ2V0RGVsdGEoKTtcbiAgICBcdFx0cmV0dXJuIHRoaXMuZWxhcHNlZFRpbWU7XG5cbiAgICBcdH0sXG5cbiAgICBcdGdldERlbHRhOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0dmFyIGRpZmYgPSAwO1xuXG4gICAgXHRcdGlmICggdGhpcy5hdXRvU3RhcnQgJiYgISB0aGlzLnJ1bm5pbmcgKSB7XG5cbiAgICBcdFx0XHR0aGlzLnN0YXJ0KCk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdGlmICggdGhpcy5ydW5uaW5nICkge1xuXG4gICAgXHRcdFx0dmFyIG5ld1RpbWUgPSAoIHBlcmZvcm1hbmNlIHx8IERhdGUgKS5ub3coKTtcblxuICAgIFx0XHRcdGRpZmYgPSAoIG5ld1RpbWUgLSB0aGlzLm9sZFRpbWUgKSAvIDEwMDA7XG4gICAgXHRcdFx0dGhpcy5vbGRUaW1lID0gbmV3VGltZTtcblxuICAgIFx0XHRcdHRoaXMuZWxhcHNlZFRpbWUgKz0gZGlmZjtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIGRpZmY7XG5cbiAgICBcdH1cblxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTcGxpbmUgZnJvbSBUd2Vlbi5qcywgc2xpZ2h0bHkgb3B0aW1pemVkIChhbmQgdHJhc2hlZClcbiAgICAgKiBodHRwOi8vc29sZS5naXRodWIuY29tL3R3ZWVuLmpzL2V4YW1wbGVzLzA1X3NwbGluZS5odG1sXG4gICAgICpcbiAgICAgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICAgICAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBTcGxpbmUoIHBvaW50cyApIHtcblxuICAgIFx0dGhpcy5wb2ludHMgPSBwb2ludHM7XG5cbiAgICBcdHZhciBjID0gW10sIHYzID0geyB4OiAwLCB5OiAwLCB6OiAwIH0sXG4gICAgXHRwb2ludCwgaW50UG9pbnQsIHdlaWdodCwgdzIsIHczLFxuICAgIFx0cGEsIHBiLCBwYywgcGQ7XG5cbiAgICBcdHRoaXMuaW5pdEZyb21BcnJheSA9IGZ1bmN0aW9uICggYSApIHtcblxuICAgIFx0XHR0aGlzLnBvaW50cyA9IFtdO1xuXG4gICAgXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpICsrICkge1xuXG4gICAgXHRcdFx0dGhpcy5wb2ludHNbIGkgXSA9IHsgeDogYVsgaSBdWyAwIF0sIHk6IGFbIGkgXVsgMSBdLCB6OiBhWyBpIF1bIDIgXSB9O1xuXG4gICAgXHRcdH1cblxuICAgIFx0fTtcblxuICAgIFx0dGhpcy5nZXRQb2ludCA9IGZ1bmN0aW9uICggayApIHtcblxuICAgIFx0XHRwb2ludCA9ICggdGhpcy5wb2ludHMubGVuZ3RoIC0gMSApICogaztcbiAgICBcdFx0aW50UG9pbnQgPSBNYXRoLmZsb29yKCBwb2ludCApO1xuICAgIFx0XHR3ZWlnaHQgPSBwb2ludCAtIGludFBvaW50O1xuXG4gICAgXHRcdGNbIDAgXSA9IGludFBvaW50ID09PSAwID8gaW50UG9pbnQgOiBpbnRQb2ludCAtIDE7XG4gICAgXHRcdGNbIDEgXSA9IGludFBvaW50O1xuICAgIFx0XHRjWyAyIF0gPSBpbnRQb2ludCAgPiB0aGlzLnBvaW50cy5sZW5ndGggLSAyID8gdGhpcy5wb2ludHMubGVuZ3RoIC0gMSA6IGludFBvaW50ICsgMTtcbiAgICBcdFx0Y1sgMyBdID0gaW50UG9pbnQgID4gdGhpcy5wb2ludHMubGVuZ3RoIC0gMyA/IHRoaXMucG9pbnRzLmxlbmd0aCAtIDEgOiBpbnRQb2ludCArIDI7XG5cbiAgICBcdFx0cGEgPSB0aGlzLnBvaW50c1sgY1sgMCBdIF07XG4gICAgXHRcdHBiID0gdGhpcy5wb2ludHNbIGNbIDEgXSBdO1xuICAgIFx0XHRwYyA9IHRoaXMucG9pbnRzWyBjWyAyIF0gXTtcbiAgICBcdFx0cGQgPSB0aGlzLnBvaW50c1sgY1sgMyBdIF07XG5cbiAgICBcdFx0dzIgPSB3ZWlnaHQgKiB3ZWlnaHQ7XG4gICAgXHRcdHczID0gd2VpZ2h0ICogdzI7XG5cbiAgICBcdFx0djMueCA9IGludGVycG9sYXRlKCBwYS54LCBwYi54LCBwYy54LCBwZC54LCB3ZWlnaHQsIHcyLCB3MyApO1xuICAgIFx0XHR2My55ID0gaW50ZXJwb2xhdGUoIHBhLnksIHBiLnksIHBjLnksIHBkLnksIHdlaWdodCwgdzIsIHczICk7XG4gICAgXHRcdHYzLnogPSBpbnRlcnBvbGF0ZSggcGEueiwgcGIueiwgcGMueiwgcGQueiwgd2VpZ2h0LCB3MiwgdzMgKTtcblxuICAgIFx0XHRyZXR1cm4gdjM7XG5cbiAgICBcdH07XG5cbiAgICBcdHRoaXMuZ2V0Q29udHJvbFBvaW50c0FycmF5ID0gZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHZhciBpLCBwLCBsID0gdGhpcy5wb2ludHMubGVuZ3RoLFxuICAgIFx0XHRcdGNvb3JkcyA9IFtdO1xuXG4gICAgXHRcdGZvciAoIGkgPSAwOyBpIDwgbDsgaSArKyApIHtcblxuICAgIFx0XHRcdHAgPSB0aGlzLnBvaW50c1sgaSBdO1xuICAgIFx0XHRcdGNvb3Jkc1sgaSBdID0gWyBwLngsIHAueSwgcC56IF07XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHJldHVybiBjb29yZHM7XG5cbiAgICBcdH07XG5cbiAgICBcdC8vIGFwcHJveGltYXRlIGxlbmd0aCBieSBzdW1taW5nIGxpbmVhciBzZWdtZW50c1xuXG4gICAgXHR0aGlzLmdldExlbmd0aCA9IGZ1bmN0aW9uICggblN1YkRpdmlzaW9ucyApIHtcblxuICAgIFx0XHR2YXIgaSwgaW5kZXgsIG5TYW1wbGVzLCBwb3NpdGlvbixcbiAgICBcdFx0XHRwb2ludCA9IDAsIGludFBvaW50ID0gMCwgb2xkSW50UG9pbnQgPSAwLFxuICAgIFx0XHRcdG9sZFBvc2l0aW9uID0gbmV3IFZlY3RvcjMoKSxcbiAgICBcdFx0XHR0bXBWZWMgPSBuZXcgVmVjdG9yMygpLFxuICAgIFx0XHRcdGNodW5rTGVuZ3RocyA9IFtdLFxuICAgIFx0XHRcdHRvdGFsTGVuZ3RoID0gMDtcblxuICAgIFx0XHQvLyBmaXJzdCBwb2ludCBoYXMgMCBsZW5ndGhcblxuICAgIFx0XHRjaHVua0xlbmd0aHNbIDAgXSA9IDA7XG5cbiAgICBcdFx0aWYgKCAhIG5TdWJEaXZpc2lvbnMgKSBuU3ViRGl2aXNpb25zID0gMTAwO1xuXG4gICAgXHRcdG5TYW1wbGVzID0gdGhpcy5wb2ludHMubGVuZ3RoICogblN1YkRpdmlzaW9ucztcblxuICAgIFx0XHRvbGRQb3NpdGlvbi5jb3B5KCB0aGlzLnBvaW50c1sgMCBdICk7XG5cbiAgICBcdFx0Zm9yICggaSA9IDE7IGkgPCBuU2FtcGxlczsgaSArKyApIHtcblxuICAgIFx0XHRcdGluZGV4ID0gaSAvIG5TYW1wbGVzO1xuXG4gICAgXHRcdFx0cG9zaXRpb24gPSB0aGlzLmdldFBvaW50KCBpbmRleCApO1xuICAgIFx0XHRcdHRtcFZlYy5jb3B5KCBwb3NpdGlvbiApO1xuXG4gICAgXHRcdFx0dG90YWxMZW5ndGggKz0gdG1wVmVjLmRpc3RhbmNlVG8oIG9sZFBvc2l0aW9uICk7XG5cbiAgICBcdFx0XHRvbGRQb3NpdGlvbi5jb3B5KCBwb3NpdGlvbiApO1xuXG4gICAgXHRcdFx0cG9pbnQgPSAoIHRoaXMucG9pbnRzLmxlbmd0aCAtIDEgKSAqIGluZGV4O1xuICAgIFx0XHRcdGludFBvaW50ID0gTWF0aC5mbG9vciggcG9pbnQgKTtcblxuICAgIFx0XHRcdGlmICggaW50UG9pbnQgIT09IG9sZEludFBvaW50ICkge1xuXG4gICAgXHRcdFx0XHRjaHVua0xlbmd0aHNbIGludFBvaW50IF0gPSB0b3RhbExlbmd0aDtcbiAgICBcdFx0XHRcdG9sZEludFBvaW50ID0gaW50UG9pbnQ7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdC8vIGxhc3QgcG9pbnQgZW5kcyB3aXRoIHRvdGFsIGxlbmd0aFxuXG4gICAgXHRcdGNodW5rTGVuZ3Roc1sgY2h1bmtMZW5ndGhzLmxlbmd0aCBdID0gdG90YWxMZW5ndGg7XG5cbiAgICBcdFx0cmV0dXJuIHsgY2h1bmtzOiBjaHVua0xlbmd0aHMsIHRvdGFsOiB0b3RhbExlbmd0aCB9O1xuXG4gICAgXHR9O1xuXG4gICAgXHR0aGlzLnJlcGFyYW1ldHJpemVCeUFyY0xlbmd0aCA9IGZ1bmN0aW9uICggc2FtcGxpbmdDb2VmICkge1xuXG4gICAgXHRcdHZhciBpLCBqLFxuICAgIFx0XHRcdGluZGV4LCBpbmRleEN1cnJlbnQsIGluZGV4TmV4dCxcbiAgICBcdFx0XHRyZWFsRGlzdGFuY2UsXG4gICAgXHRcdFx0c2FtcGxpbmcsIHBvc2l0aW9uLFxuICAgIFx0XHRcdG5ld3BvaW50cyA9IFtdLFxuICAgIFx0XHRcdHRtcFZlYyA9IG5ldyBWZWN0b3IzKCksXG4gICAgXHRcdFx0c2wgPSB0aGlzLmdldExlbmd0aCgpO1xuXG4gICAgXHRcdG5ld3BvaW50cy5wdXNoKCB0bXBWZWMuY29weSggdGhpcy5wb2ludHNbIDAgXSApLmNsb25lKCkgKTtcblxuICAgIFx0XHRmb3IgKCBpID0gMTsgaSA8IHRoaXMucG9pbnRzLmxlbmd0aDsgaSArKyApIHtcblxuICAgIFx0XHRcdC8vdG1wVmVjLmNvcHkoIHRoaXMucG9pbnRzWyBpIC0gMSBdICk7XG4gICAgXHRcdFx0Ly9saW5lYXJEaXN0YW5jZSA9IHRtcFZlYy5kaXN0YW5jZVRvKCB0aGlzLnBvaW50c1sgaSBdICk7XG5cbiAgICBcdFx0XHRyZWFsRGlzdGFuY2UgPSBzbC5jaHVua3NbIGkgXSAtIHNsLmNodW5rc1sgaSAtIDEgXTtcblxuICAgIFx0XHRcdHNhbXBsaW5nID0gTWF0aC5jZWlsKCBzYW1wbGluZ0NvZWYgKiByZWFsRGlzdGFuY2UgLyBzbC50b3RhbCApO1xuXG4gICAgXHRcdFx0aW5kZXhDdXJyZW50ID0gKCBpIC0gMSApIC8gKCB0aGlzLnBvaW50cy5sZW5ndGggLSAxICk7XG4gICAgXHRcdFx0aW5kZXhOZXh0ID0gaSAvICggdGhpcy5wb2ludHMubGVuZ3RoIC0gMSApO1xuXG4gICAgXHRcdFx0Zm9yICggaiA9IDE7IGogPCBzYW1wbGluZyAtIDE7IGogKysgKSB7XG5cbiAgICBcdFx0XHRcdGluZGV4ID0gaW5kZXhDdXJyZW50ICsgaiAqICggMSAvIHNhbXBsaW5nICkgKiAoIGluZGV4TmV4dCAtIGluZGV4Q3VycmVudCApO1xuXG4gICAgXHRcdFx0XHRwb3NpdGlvbiA9IHRoaXMuZ2V0UG9pbnQoIGluZGV4ICk7XG4gICAgXHRcdFx0XHRuZXdwb2ludHMucHVzaCggdG1wVmVjLmNvcHkoIHBvc2l0aW9uICkuY2xvbmUoKSApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0bmV3cG9pbnRzLnB1c2goIHRtcFZlYy5jb3B5KCB0aGlzLnBvaW50c1sgaSBdICkuY2xvbmUoKSApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHR0aGlzLnBvaW50cyA9IG5ld3BvaW50cztcblxuICAgIFx0fTtcblxuICAgIFx0Ly8gQ2F0bXVsbC1Sb21cblxuICAgIFx0ZnVuY3Rpb24gaW50ZXJwb2xhdGUoIHAwLCBwMSwgcDIsIHAzLCB0LCB0MiwgdDMgKSB7XG5cbiAgICBcdFx0dmFyIHYwID0gKCBwMiAtIHAwICkgKiAwLjUsXG4gICAgXHRcdFx0djEgPSAoIHAzIC0gcDEgKSAqIDAuNTtcblxuICAgIFx0XHRyZXR1cm4gKCAyICogKCBwMSAtIHAyICkgKyB2MCArIHYxICkgKiB0MyArICggLSAzICogKCBwMSAtIHAyICkgLSAyICogdjAgLSB2MSApICogdDIgKyB2MCAqIHQgKyBwMTtcblxuICAgIFx0fVxuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pb1xuICAgICAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuICAgICAqXG4gICAgICogUmVmOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TcGhlcmljYWxfY29vcmRpbmF0ZV9zeXN0ZW1cbiAgICAgKlxuICAgICAqIFRoZSBwb2xlcyAocGhpKSBhcmUgYXQgdGhlIHBvc2l0aXZlIGFuZCBuZWdhdGl2ZSB5IGF4aXMuXG4gICAgICogVGhlIGVxdWF0b3Igc3RhcnRzIGF0IHBvc2l0aXZlIHouXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBTcGhlcmljYWwoIHJhZGl1cywgcGhpLCB0aGV0YSApIHtcblxuICAgIFx0dGhpcy5yYWRpdXMgPSAoIHJhZGl1cyAhPT0gdW5kZWZpbmVkICkgPyByYWRpdXMgOiAxLjA7XG4gICAgXHR0aGlzLnBoaSA9ICggcGhpICE9PSB1bmRlZmluZWQgKSA/IHBoaSA6IDA7IC8vIHVwIC8gZG93biB0b3dhcmRzIHRvcCBhbmQgYm90dG9tIHBvbGVcbiAgICBcdHRoaXMudGhldGEgPSAoIHRoZXRhICE9PSB1bmRlZmluZWQgKSA/IHRoZXRhIDogMDsgLy8gYXJvdW5kIHRoZSBlcXVhdG9yIG9mIHRoZSBzcGhlcmVcblxuICAgIFx0cmV0dXJuIHRoaXM7XG5cbiAgICB9XG5cbiAgICBTcGhlcmljYWwucHJvdG90eXBlID0ge1xuXG4gICAgXHRjb25zdHJ1Y3RvcjogU3BoZXJpY2FsLFxuXG4gICAgXHRzZXQ6IGZ1bmN0aW9uICggcmFkaXVzLCBwaGksIHRoZXRhICkge1xuXG4gICAgXHRcdHRoaXMucmFkaXVzID0gcmFkaXVzO1xuICAgIFx0XHR0aGlzLnBoaSA9IHBoaTtcbiAgICBcdFx0dGhpcy50aGV0YSA9IHRoZXRhO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRjbG9uZTogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcblxuICAgIFx0fSxcblxuICAgIFx0Y29weTogZnVuY3Rpb24gKCBvdGhlciApIHtcblxuICAgIFx0XHR0aGlzLnJhZGl1cy5jb3B5KCBvdGhlci5yYWRpdXMgKTtcbiAgICBcdFx0dGhpcy5waGkuY29weSggb3RoZXIucGhpICk7XG4gICAgXHRcdHRoaXMudGhldGEuY29weSggb3RoZXIudGhldGEgKTtcblxuICAgIFx0XHRyZXR1cm4gdGhpcztcblxuICAgIFx0fSxcblxuICAgIFx0Ly8gcmVzdHJpY3QgcGhpIHRvIGJlIGJldHdlZSBFUFMgYW5kIFBJLUVQU1xuICAgIFx0bWFrZVNhZmU6IGZ1bmN0aW9uKCkge1xuXG4gICAgXHRcdHZhciBFUFMgPSAwLjAwMDAwMTtcbiAgICBcdFx0dGhpcy5waGkgPSBNYXRoLm1heCggRVBTLCBNYXRoLm1pbiggTWF0aC5QSSAtIEVQUywgdGhpcy5waGkgKSApO1xuXG4gICAgXHRcdHJldHVybiB0aGlzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRzZXRGcm9tVmVjdG9yMzogZnVuY3Rpb24oIHZlYzMgKSB7XG5cbiAgICBcdFx0dGhpcy5yYWRpdXMgPSB2ZWMzLmxlbmd0aCgpO1xuXG4gICAgXHRcdGlmICggdGhpcy5yYWRpdXMgPT09IDAgKSB7XG5cbiAgICBcdFx0XHR0aGlzLnRoZXRhID0gMDtcbiAgICBcdFx0XHR0aGlzLnBoaSA9IDA7XG5cbiAgICBcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdHRoaXMudGhldGEgPSBNYXRoLmF0YW4yKCB2ZWMzLngsIHZlYzMueiApOyAvLyBlcXVhdG9yIGFuZ2xlIGFyb3VuZCB5LXVwIGF4aXNcbiAgICBcdFx0XHR0aGlzLnBoaSA9IE1hdGguYWNvcyggZXhwb3J0cy5NYXRoLmNsYW1wKCB2ZWMzLnkgLyB0aGlzLnJhZGl1cywgLSAxLCAxICkgKTsgLy8gcG9sYXIgYW5nbGVcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH0sXG5cbiAgICB9O1xuXG4gICAgLyoqXHJcbiAgICAgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gICAgICovXHJcblxyXG4gICAgZnVuY3Rpb24gTW9ycGhCbGVuZE1lc2goIGdlb21ldHJ5LCBtYXRlcmlhbCApIHtcblxyXG4gICAgXHRNZXNoLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xyXG5cclxuICAgIFx0dGhpcy5hbmltYXRpb25zTWFwID0ge307XHJcbiAgICBcdHRoaXMuYW5pbWF0aW9uc0xpc3QgPSBbXTtcclxuXHJcbiAgICBcdC8vIHByZXBhcmUgZGVmYXVsdCBhbmltYXRpb25cclxuICAgIFx0Ly8gKGFsbCBmcmFtZXMgcGxheWVkIHRvZ2V0aGVyIGluIDEgc2Vjb25kKVxyXG5cclxuICAgIFx0dmFyIG51bUZyYW1lcyA9IHRoaXMuZ2VvbWV0cnkubW9ycGhUYXJnZXRzLmxlbmd0aDtcclxuXHJcbiAgICBcdHZhciBuYW1lID0gXCJfX2RlZmF1bHRcIjtcclxuXHJcbiAgICBcdHZhciBzdGFydEZyYW1lID0gMDtcclxuICAgIFx0dmFyIGVuZEZyYW1lID0gbnVtRnJhbWVzIC0gMTtcclxuXHJcbiAgICBcdHZhciBmcHMgPSBudW1GcmFtZXMgLyAxO1xyXG5cclxuICAgIFx0dGhpcy5jcmVhdGVBbmltYXRpb24oIG5hbWUsIHN0YXJ0RnJhbWUsIGVuZEZyYW1lLCBmcHMgKTtcclxuICAgIFx0dGhpcy5zZXRBbmltYXRpb25XZWlnaHQoIG5hbWUsIDEgKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTWVzaC5wcm90b3R5cGUgKTtcclxuICAgIE1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1vcnBoQmxlbmRNZXNoO1xyXG5cclxuICAgIE1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5jcmVhdGVBbmltYXRpb24gPSBmdW5jdGlvbiAoIG5hbWUsIHN0YXJ0LCBlbmQsIGZwcyApIHtcclxuXHJcbiAgICBcdHZhciBhbmltYXRpb24gPSB7XHJcblxyXG4gICAgXHRcdHN0YXJ0OiBzdGFydCxcclxuICAgIFx0XHRlbmQ6IGVuZCxcclxuXHJcbiAgICBcdFx0bGVuZ3RoOiBlbmQgLSBzdGFydCArIDEsXHJcblxyXG4gICAgXHRcdGZwczogZnBzLFxyXG4gICAgXHRcdGR1cmF0aW9uOiAoIGVuZCAtIHN0YXJ0ICkgLyBmcHMsXHJcblxyXG4gICAgXHRcdGxhc3RGcmFtZTogMCxcclxuICAgIFx0XHRjdXJyZW50RnJhbWU6IDAsXHJcblxyXG4gICAgXHRcdGFjdGl2ZTogZmFsc2UsXHJcblxyXG4gICAgXHRcdHRpbWU6IDAsXHJcbiAgICBcdFx0ZGlyZWN0aW9uOiAxLFxyXG4gICAgXHRcdHdlaWdodDogMSxcclxuXHJcbiAgICBcdFx0ZGlyZWN0aW9uQmFja3dhcmRzOiBmYWxzZSxcclxuICAgIFx0XHRtaXJyb3JlZExvb3A6IGZhbHNlXHJcblxyXG4gICAgXHR9O1xyXG5cclxuICAgIFx0dGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF0gPSBhbmltYXRpb247XHJcbiAgICBcdHRoaXMuYW5pbWF0aW9uc0xpc3QucHVzaCggYW5pbWF0aW9uICk7XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICBNb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuYXV0b0NyZWF0ZUFuaW1hdGlvbnMgPSBmdW5jdGlvbiAoIGZwcyApIHtcclxuXHJcbiAgICBcdHZhciBwYXR0ZXJuID0gLyhbYS16XSspXz8oXFxkKykvaTtcclxuXHJcbiAgICBcdHZhciBmaXJzdEFuaW1hdGlvbiwgZnJhbWVSYW5nZXMgPSB7fTtcclxuXHJcbiAgICBcdHZhciBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XHJcblxyXG4gICAgXHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuICAgIFx0XHR2YXIgbW9ycGggPSBnZW9tZXRyeS5tb3JwaFRhcmdldHNbIGkgXTtcclxuICAgIFx0XHR2YXIgY2h1bmtzID0gbW9ycGgubmFtZS5tYXRjaCggcGF0dGVybiApO1xyXG5cclxuICAgIFx0XHRpZiAoIGNodW5rcyAmJiBjaHVua3MubGVuZ3RoID4gMSApIHtcclxuXHJcbiAgICBcdFx0XHR2YXIgbmFtZSA9IGNodW5rc1sgMSBdO1xyXG5cclxuICAgIFx0XHRcdGlmICggISBmcmFtZVJhbmdlc1sgbmFtZSBdICkgZnJhbWVSYW5nZXNbIG5hbWUgXSA9IHsgc3RhcnQ6IEluZmluaXR5LCBlbmQ6IC0gSW5maW5pdHkgfTtcclxuXHJcbiAgICBcdFx0XHR2YXIgcmFuZ2UgPSBmcmFtZVJhbmdlc1sgbmFtZSBdO1xyXG5cclxuICAgIFx0XHRcdGlmICggaSA8IHJhbmdlLnN0YXJ0ICkgcmFuZ2Uuc3RhcnQgPSBpO1xyXG4gICAgXHRcdFx0aWYgKCBpID4gcmFuZ2UuZW5kICkgcmFuZ2UuZW5kID0gaTtcclxuXHJcbiAgICBcdFx0XHRpZiAoICEgZmlyc3RBbmltYXRpb24gKSBmaXJzdEFuaW1hdGlvbiA9IG5hbWU7XHJcblxyXG4gICAgXHRcdH1cclxuXHJcbiAgICBcdH1cclxuXHJcbiAgICBcdGZvciAoIHZhciBuYW1lIGluIGZyYW1lUmFuZ2VzICkge1xyXG5cclxuICAgIFx0XHR2YXIgcmFuZ2UgPSBmcmFtZVJhbmdlc1sgbmFtZSBdO1xyXG4gICAgXHRcdHRoaXMuY3JlYXRlQW5pbWF0aW9uKCBuYW1lLCByYW5nZS5zdGFydCwgcmFuZ2UuZW5kLCBmcHMgKTtcclxuXHJcbiAgICBcdH1cclxuXHJcbiAgICBcdHRoaXMuZmlyc3RBbmltYXRpb24gPSBmaXJzdEFuaW1hdGlvbjtcclxuXHJcbiAgICB9O1xyXG5cclxuICAgIE1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5zZXRBbmltYXRpb25EaXJlY3Rpb25Gb3J3YXJkID0gZnVuY3Rpb24gKCBuYW1lICkge1xyXG5cclxuICAgIFx0dmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uc01hcFsgbmFtZSBdO1xyXG5cclxuICAgIFx0aWYgKCBhbmltYXRpb24gKSB7XHJcblxyXG4gICAgXHRcdGFuaW1hdGlvbi5kaXJlY3Rpb24gPSAxO1xyXG4gICAgXHRcdGFuaW1hdGlvbi5kaXJlY3Rpb25CYWNrd2FyZHMgPSBmYWxzZTtcclxuXHJcbiAgICBcdH1cclxuXHJcbiAgICB9O1xyXG5cclxuICAgIE1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5zZXRBbmltYXRpb25EaXJlY3Rpb25CYWNrd2FyZCA9IGZ1bmN0aW9uICggbmFtZSApIHtcclxuXHJcbiAgICBcdHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNNYXBbIG5hbWUgXTtcclxuXHJcbiAgICBcdGlmICggYW5pbWF0aW9uICkge1xyXG5cclxuICAgIFx0XHRhbmltYXRpb24uZGlyZWN0aW9uID0gLSAxO1xyXG4gICAgXHRcdGFuaW1hdGlvbi5kaXJlY3Rpb25CYWNrd2FyZHMgPSB0cnVlO1xyXG5cclxuICAgIFx0fVxyXG5cclxuICAgIH07XHJcblxyXG4gICAgTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLnNldEFuaW1hdGlvbkZQUyA9IGZ1bmN0aW9uICggbmFtZSwgZnBzICkge1xyXG5cclxuICAgIFx0dmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uc01hcFsgbmFtZSBdO1xyXG5cclxuICAgIFx0aWYgKCBhbmltYXRpb24gKSB7XHJcblxyXG4gICAgXHRcdGFuaW1hdGlvbi5mcHMgPSBmcHM7XHJcbiAgICBcdFx0YW5pbWF0aW9uLmR1cmF0aW9uID0gKCBhbmltYXRpb24uZW5kIC0gYW5pbWF0aW9uLnN0YXJ0ICkgLyBhbmltYXRpb24uZnBzO1xyXG5cclxuICAgIFx0fVxyXG5cclxuICAgIH07XHJcblxyXG4gICAgTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLnNldEFuaW1hdGlvbkR1cmF0aW9uID0gZnVuY3Rpb24gKCBuYW1lLCBkdXJhdGlvbiApIHtcclxuXHJcbiAgICBcdHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNNYXBbIG5hbWUgXTtcclxuXHJcbiAgICBcdGlmICggYW5pbWF0aW9uICkge1xyXG5cclxuICAgIFx0XHRhbmltYXRpb24uZHVyYXRpb24gPSBkdXJhdGlvbjtcclxuICAgIFx0XHRhbmltYXRpb24uZnBzID0gKCBhbmltYXRpb24uZW5kIC0gYW5pbWF0aW9uLnN0YXJ0ICkgLyBhbmltYXRpb24uZHVyYXRpb247XHJcblxyXG4gICAgXHR9XHJcblxyXG4gICAgfTtcclxuXHJcbiAgICBNb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuc2V0QW5pbWF0aW9uV2VpZ2h0ID0gZnVuY3Rpb24gKCBuYW1lLCB3ZWlnaHQgKSB7XHJcblxyXG4gICAgXHR2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF07XHJcblxyXG4gICAgXHRpZiAoIGFuaW1hdGlvbiApIHtcclxuXHJcbiAgICBcdFx0YW5pbWF0aW9uLndlaWdodCA9IHdlaWdodDtcclxuXHJcbiAgICBcdH1cclxuXHJcbiAgICB9O1xyXG5cclxuICAgIE1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5zZXRBbmltYXRpb25UaW1lID0gZnVuY3Rpb24gKCBuYW1lLCB0aW1lICkge1xyXG5cclxuICAgIFx0dmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uc01hcFsgbmFtZSBdO1xyXG5cclxuICAgIFx0aWYgKCBhbmltYXRpb24gKSB7XHJcblxyXG4gICAgXHRcdGFuaW1hdGlvbi50aW1lID0gdGltZTtcclxuXHJcbiAgICBcdH1cclxuXHJcbiAgICB9O1xyXG5cclxuICAgIE1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5nZXRBbmltYXRpb25UaW1lID0gZnVuY3Rpb24gKCBuYW1lICkge1xyXG5cclxuICAgIFx0dmFyIHRpbWUgPSAwO1xyXG5cclxuICAgIFx0dmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uc01hcFsgbmFtZSBdO1xyXG5cclxuICAgIFx0aWYgKCBhbmltYXRpb24gKSB7XHJcblxyXG4gICAgXHRcdHRpbWUgPSBhbmltYXRpb24udGltZTtcclxuXHJcbiAgICBcdH1cclxuXHJcbiAgICBcdHJldHVybiB0aW1lO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLmdldEFuaW1hdGlvbkR1cmF0aW9uID0gZnVuY3Rpb24gKCBuYW1lICkge1xyXG5cclxuICAgIFx0dmFyIGR1cmF0aW9uID0gLSAxO1xyXG5cclxuICAgIFx0dmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uc01hcFsgbmFtZSBdO1xyXG5cclxuICAgIFx0aWYgKCBhbmltYXRpb24gKSB7XHJcblxyXG4gICAgXHRcdGR1cmF0aW9uID0gYW5pbWF0aW9uLmR1cmF0aW9uO1xyXG5cclxuICAgIFx0fVxyXG5cclxuICAgIFx0cmV0dXJuIGR1cmF0aW9uO1xyXG5cclxuICAgIH07XHJcblxyXG4gICAgTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLnBsYXlBbmltYXRpb24gPSBmdW5jdGlvbiAoIG5hbWUgKSB7XHJcblxyXG4gICAgXHR2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF07XHJcblxyXG4gICAgXHRpZiAoIGFuaW1hdGlvbiApIHtcclxuXHJcbiAgICBcdFx0YW5pbWF0aW9uLnRpbWUgPSAwO1xyXG4gICAgXHRcdGFuaW1hdGlvbi5hY3RpdmUgPSB0cnVlO1xyXG5cclxuICAgIFx0fSBlbHNlIHtcclxuXHJcbiAgICBcdFx0Y29uc29sZS53YXJuKCBcIlRIUkVFLk1vcnBoQmxlbmRNZXNoOiBhbmltYXRpb25bXCIgKyBuYW1lICsgXCJdIHVuZGVmaW5lZCBpbiAucGxheUFuaW1hdGlvbigpXCIgKTtcclxuXHJcbiAgICBcdH1cclxuXHJcbiAgICB9O1xyXG5cclxuICAgIE1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5zdG9wQW5pbWF0aW9uID0gZnVuY3Rpb24gKCBuYW1lICkge1xyXG5cclxuICAgIFx0dmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uc01hcFsgbmFtZSBdO1xyXG5cclxuICAgIFx0aWYgKCBhbmltYXRpb24gKSB7XHJcblxyXG4gICAgXHRcdGFuaW1hdGlvbi5hY3RpdmUgPSBmYWxzZTtcclxuXHJcbiAgICBcdH1cclxuXHJcbiAgICB9O1xyXG5cclxuICAgIE1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoIGRlbHRhICkge1xyXG5cclxuICAgIFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHRoaXMuYW5pbWF0aW9uc0xpc3QubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG4gICAgXHRcdHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNMaXN0WyBpIF07XHJcblxyXG4gICAgXHRcdGlmICggISBhbmltYXRpb24uYWN0aXZlICkgY29udGludWU7XHJcblxyXG4gICAgXHRcdHZhciBmcmFtZVRpbWUgPSBhbmltYXRpb24uZHVyYXRpb24gLyBhbmltYXRpb24ubGVuZ3RoO1xyXG5cclxuICAgIFx0XHRhbmltYXRpb24udGltZSArPSBhbmltYXRpb24uZGlyZWN0aW9uICogZGVsdGE7XHJcblxyXG4gICAgXHRcdGlmICggYW5pbWF0aW9uLm1pcnJvcmVkTG9vcCApIHtcclxuXHJcbiAgICBcdFx0XHRpZiAoIGFuaW1hdGlvbi50aW1lID4gYW5pbWF0aW9uLmR1cmF0aW9uIHx8IGFuaW1hdGlvbi50aW1lIDwgMCApIHtcclxuXHJcbiAgICBcdFx0XHRcdGFuaW1hdGlvbi5kaXJlY3Rpb24gKj0gLSAxO1xyXG5cclxuICAgIFx0XHRcdFx0aWYgKCBhbmltYXRpb24udGltZSA+IGFuaW1hdGlvbi5kdXJhdGlvbiApIHtcclxuXHJcbiAgICBcdFx0XHRcdFx0YW5pbWF0aW9uLnRpbWUgPSBhbmltYXRpb24uZHVyYXRpb247XHJcbiAgICBcdFx0XHRcdFx0YW5pbWF0aW9uLmRpcmVjdGlvbkJhY2t3YXJkcyA9IHRydWU7XHJcblxyXG4gICAgXHRcdFx0XHR9XHJcblxyXG4gICAgXHRcdFx0XHRpZiAoIGFuaW1hdGlvbi50aW1lIDwgMCApIHtcclxuXHJcbiAgICBcdFx0XHRcdFx0YW5pbWF0aW9uLnRpbWUgPSAwO1xyXG4gICAgXHRcdFx0XHRcdGFuaW1hdGlvbi5kaXJlY3Rpb25CYWNrd2FyZHMgPSBmYWxzZTtcclxuXHJcbiAgICBcdFx0XHRcdH1cclxuXHJcbiAgICBcdFx0XHR9XHJcblxyXG4gICAgXHRcdH0gZWxzZSB7XHJcblxyXG4gICAgXHRcdFx0YW5pbWF0aW9uLnRpbWUgPSBhbmltYXRpb24udGltZSAlIGFuaW1hdGlvbi5kdXJhdGlvbjtcclxuXHJcbiAgICBcdFx0XHRpZiAoIGFuaW1hdGlvbi50aW1lIDwgMCApIGFuaW1hdGlvbi50aW1lICs9IGFuaW1hdGlvbi5kdXJhdGlvbjtcclxuXHJcbiAgICBcdFx0fVxyXG5cclxuICAgIFx0XHR2YXIga2V5ZnJhbWUgPSBhbmltYXRpb24uc3RhcnQgKyBleHBvcnRzLk1hdGguY2xhbXAoIE1hdGguZmxvb3IoIGFuaW1hdGlvbi50aW1lIC8gZnJhbWVUaW1lICksIDAsIGFuaW1hdGlvbi5sZW5ndGggLSAxICk7XHJcbiAgICBcdFx0dmFyIHdlaWdodCA9IGFuaW1hdGlvbi53ZWlnaHQ7XHJcblxyXG4gICAgXHRcdGlmICgga2V5ZnJhbWUgIT09IGFuaW1hdGlvbi5jdXJyZW50RnJhbWUgKSB7XHJcblxyXG4gICAgXHRcdFx0dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXNbIGFuaW1hdGlvbi5sYXN0RnJhbWUgXSA9IDA7XHJcbiAgICBcdFx0XHR0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgYW5pbWF0aW9uLmN1cnJlbnRGcmFtZSBdID0gMSAqIHdlaWdodDtcclxuXHJcbiAgICBcdFx0XHR0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sga2V5ZnJhbWUgXSA9IDA7XHJcblxyXG4gICAgXHRcdFx0YW5pbWF0aW9uLmxhc3RGcmFtZSA9IGFuaW1hdGlvbi5jdXJyZW50RnJhbWU7XHJcbiAgICBcdFx0XHRhbmltYXRpb24uY3VycmVudEZyYW1lID0ga2V5ZnJhbWU7XHJcblxyXG4gICAgXHRcdH1cclxuXHJcbiAgICBcdFx0dmFyIG1peCA9ICggYW5pbWF0aW9uLnRpbWUgJSBmcmFtZVRpbWUgKSAvIGZyYW1lVGltZTtcclxuXHJcbiAgICBcdFx0aWYgKCBhbmltYXRpb24uZGlyZWN0aW9uQmFja3dhcmRzICkgbWl4ID0gMSAtIG1peDtcclxuXHJcbiAgICBcdFx0aWYgKCBhbmltYXRpb24uY3VycmVudEZyYW1lICE9PSBhbmltYXRpb24ubGFzdEZyYW1lICkge1xyXG5cclxuICAgIFx0XHRcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBhbmltYXRpb24uY3VycmVudEZyYW1lIF0gPSBtaXggKiB3ZWlnaHQ7XHJcbiAgICBcdFx0XHR0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgYW5pbWF0aW9uLmxhc3RGcmFtZSBdID0gKCAxIC0gbWl4ICkgKiB3ZWlnaHQ7XHJcblxyXG4gICAgXHRcdH0gZWxzZSB7XHJcblxyXG4gICAgXHRcdFx0dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXNbIGFuaW1hdGlvbi5jdXJyZW50RnJhbWUgXSA9IHdlaWdodDtcclxuXHJcbiAgICBcdFx0fVxyXG5cclxuICAgIFx0fVxyXG5cclxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gSW1tZWRpYXRlUmVuZGVyT2JqZWN0KCBtYXRlcmlhbCApIHtcblxuICAgIFx0T2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG4gICAgXHR0aGlzLm1hdGVyaWFsID0gbWF0ZXJpYWw7XG4gICAgXHR0aGlzLnJlbmRlciA9IGZ1bmN0aW9uICggcmVuZGVyQ2FsbGJhY2sgKSB7fTtcblxuICAgIH1cblxuICAgIEltbWVkaWF0ZVJlbmRlck9iamVjdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBPYmplY3QzRC5wcm90b3R5cGUgKTtcbiAgICBJbW1lZGlhdGVSZW5kZXJPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSW1tZWRpYXRlUmVuZGVyT2JqZWN0O1xuXG4gICAgSW1tZWRpYXRlUmVuZGVyT2JqZWN0LnByb3RvdHlwZS5pc0ltbWVkaWF0ZVJlbmRlck9iamVjdCA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICAgICAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuICAgICovXG5cbiAgICBmdW5jdGlvbiBWZXJ0ZXhOb3JtYWxzSGVscGVyKCBvYmplY3QsIHNpemUsIGhleCwgbGluZXdpZHRoICkge1xuXG4gICAgXHR0aGlzLm9iamVjdCA9IG9iamVjdDtcblxuICAgIFx0dGhpcy5zaXplID0gKCBzaXplICE9PSB1bmRlZmluZWQgKSA/IHNpemUgOiAxO1xuXG4gICAgXHR2YXIgY29sb3IgPSAoIGhleCAhPT0gdW5kZWZpbmVkICkgPyBoZXggOiAweGZmMDAwMDtcblxuICAgIFx0dmFyIHdpZHRoID0gKCBsaW5ld2lkdGggIT09IHVuZGVmaW5lZCApID8gbGluZXdpZHRoIDogMTtcblxuICAgIFx0Ly9cblxuICAgIFx0dmFyIG5Ob3JtYWxzID0gMDtcblxuICAgIFx0dmFyIG9iakdlb21ldHJ5ID0gdGhpcy5vYmplY3QuZ2VvbWV0cnk7XG5cbiAgICBcdGlmICggKG9iakdlb21ldHJ5ICYmIG9iakdlb21ldHJ5LmlzR2VvbWV0cnkpICkge1xuXG4gICAgXHRcdG5Ob3JtYWxzID0gb2JqR2VvbWV0cnkuZmFjZXMubGVuZ3RoICogMztcblxuICAgIFx0fSBlbHNlIGlmICggKG9iakdlb21ldHJ5ICYmIG9iakdlb21ldHJ5LmlzQnVmZmVyR2VvbWV0cnkpICkge1xuXG4gICAgXHRcdG5Ob3JtYWxzID0gb2JqR2VvbWV0cnkuYXR0cmlidXRlcy5ub3JtYWwuY291bnQ7XG5cbiAgICBcdH1cblxuICAgIFx0Ly9cblxuICAgIFx0dmFyIGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cbiAgICBcdHZhciBwb3NpdGlvbnMgPSBuZXcgRmxvYXQzMkF0dHJpYnV0ZSggbk5vcm1hbHMgKiAyICogMywgMyApO1xuXG4gICAgXHRnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIHBvc2l0aW9ucyApO1xuXG4gICAgXHRMaW5lU2VnbWVudHMuY2FsbCggdGhpcywgZ2VvbWV0cnksIG5ldyBMaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogY29sb3IsIGxpbmV3aWR0aDogd2lkdGggfSApICk7XG5cbiAgICBcdC8vXG5cbiAgICBcdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXG4gICAgXHR0aGlzLnVwZGF0ZSgpO1xuXG4gICAgfVxuXG4gICAgVmVydGV4Tm9ybWFsc0hlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBMaW5lU2VnbWVudHMucHJvdG90eXBlICk7XG4gICAgVmVydGV4Tm9ybWFsc0hlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBWZXJ0ZXhOb3JtYWxzSGVscGVyO1xuXG4gICAgVmVydGV4Tm9ybWFsc0hlbHBlci5wcm90b3R5cGUudXBkYXRlID0gKCBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCk7XG4gICAgXHR2YXIgdjIgPSBuZXcgVmVjdG9yMygpO1xuICAgIFx0dmFyIG5vcm1hbE1hdHJpeCA9IG5ldyBNYXRyaXgzKCk7XG5cbiAgICBcdHJldHVybiBmdW5jdGlvbiB1cGRhdGUoKSB7XG5cbiAgICBcdFx0dmFyIGtleXMgPSBbICdhJywgJ2InLCAnYycgXTtcblxuICAgIFx0XHR0aGlzLm9iamVjdC51cGRhdGVNYXRyaXhXb3JsZCggdHJ1ZSApO1xuXG4gICAgXHRcdG5vcm1hbE1hdHJpeC5nZXROb3JtYWxNYXRyaXgoIHRoaXMub2JqZWN0Lm1hdHJpeFdvcmxkICk7XG5cbiAgICBcdFx0dmFyIG1hdHJpeFdvcmxkID0gdGhpcy5vYmplY3QubWF0cml4V29ybGQ7XG5cbiAgICBcdFx0dmFyIHBvc2l0aW9uID0gdGhpcy5nZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXG4gICAgXHRcdC8vXG5cbiAgICBcdFx0dmFyIG9iakdlb21ldHJ5ID0gdGhpcy5vYmplY3QuZ2VvbWV0cnk7XG5cbiAgICBcdFx0aWYgKCAob2JqR2VvbWV0cnkgJiYgb2JqR2VvbWV0cnkuaXNHZW9tZXRyeSkgKSB7XG5cbiAgICBcdFx0XHR2YXIgdmVydGljZXMgPSBvYmpHZW9tZXRyeS52ZXJ0aWNlcztcblxuICAgIFx0XHRcdHZhciBmYWNlcyA9IG9iakdlb21ldHJ5LmZhY2VzO1xuXG4gICAgXHRcdFx0dmFyIGlkeCA9IDA7XG5cbiAgICBcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBmYWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgXHRcdFx0XHR2YXIgZmFjZSA9IGZhY2VzWyBpIF07XG5cbiAgICBcdFx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSBmYWNlLnZlcnRleE5vcm1hbHMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XG5cbiAgICBcdFx0XHRcdFx0dmFyIHZlcnRleCA9IHZlcnRpY2VzWyBmYWNlWyBrZXlzWyBqIF0gXSBdO1xuXG4gICAgXHRcdFx0XHRcdHZhciBub3JtYWwgPSBmYWNlLnZlcnRleE5vcm1hbHNbIGogXTtcblxuICAgIFx0XHRcdFx0XHR2MS5jb3B5KCB2ZXJ0ZXggKS5hcHBseU1hdHJpeDQoIG1hdHJpeFdvcmxkICk7XG5cbiAgICBcdFx0XHRcdFx0djIuY29weSggbm9ybWFsICkuYXBwbHlNYXRyaXgzKCBub3JtYWxNYXRyaXggKS5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhciggdGhpcy5zaXplICkuYWRkKCB2MSApO1xuXG4gICAgXHRcdFx0XHRcdHBvc2l0aW9uLnNldFhZWiggaWR4LCB2MS54LCB2MS55LCB2MS56ICk7XG5cbiAgICBcdFx0XHRcdFx0aWR4ID0gaWR4ICsgMTtcblxuICAgIFx0XHRcdFx0XHRwb3NpdGlvbi5zZXRYWVooIGlkeCwgdjIueCwgdjIueSwgdjIueiApO1xuXG4gICAgXHRcdFx0XHRcdGlkeCA9IGlkeCArIDE7XG5cbiAgICBcdFx0XHRcdH1cblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHR9IGVsc2UgaWYgKCAob2JqR2VvbWV0cnkgJiYgb2JqR2VvbWV0cnkuaXNCdWZmZXJHZW9tZXRyeSkgKSB7XG5cbiAgICBcdFx0XHR2YXIgb2JqUG9zID0gb2JqR2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcblxuICAgIFx0XHRcdHZhciBvYmpOb3JtID0gb2JqR2VvbWV0cnkuYXR0cmlidXRlcy5ub3JtYWw7XG5cbiAgICBcdFx0XHR2YXIgaWR4ID0gMDtcblxuICAgIFx0XHRcdC8vIGZvciBzaW1wbGljaXR5LCBpZ25vcmUgaW5kZXggYW5kIGRyYXdjYWxscywgYW5kIHJlbmRlciBldmVyeSBub3JtYWxcblxuICAgIFx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSBvYmpQb3MuY291bnQ7IGogPCBqbDsgaiArKyApIHtcblxuICAgIFx0XHRcdFx0djEuc2V0KCBvYmpQb3MuZ2V0WCggaiApLCBvYmpQb3MuZ2V0WSggaiApLCBvYmpQb3MuZ2V0WiggaiApICkuYXBwbHlNYXRyaXg0KCBtYXRyaXhXb3JsZCApO1xuXG4gICAgXHRcdFx0XHR2Mi5zZXQoIG9iak5vcm0uZ2V0WCggaiApLCBvYmpOb3JtLmdldFkoIGogKSwgb2JqTm9ybS5nZXRaKCBqICkgKTtcblxuICAgIFx0XHRcdFx0djIuYXBwbHlNYXRyaXgzKCBub3JtYWxNYXRyaXggKS5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhciggdGhpcy5zaXplICkuYWRkKCB2MSApO1xuXG4gICAgXHRcdFx0XHRwb3NpdGlvbi5zZXRYWVooIGlkeCwgdjEueCwgdjEueSwgdjEueiApO1xuXG4gICAgXHRcdFx0XHRpZHggPSBpZHggKyAxO1xuXG4gICAgXHRcdFx0XHRwb3NpdGlvbi5zZXRYWVooIGlkeCwgdjIueCwgdjIueSwgdjIueiApO1xuXG4gICAgXHRcdFx0XHRpZHggPSBpZHggKyAxO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0XHRwb3NpdGlvbi5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH07XG5cbiAgICB9KCkgKTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gICAgICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAgICAgKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAgICAqL1xuXG4gICAgZnVuY3Rpb24gU3BvdExpZ2h0SGVscGVyKCBsaWdodCApIHtcblxuICAgIFx0T2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG4gICAgXHR0aGlzLmxpZ2h0ID0gbGlnaHQ7XG4gICAgXHR0aGlzLmxpZ2h0LnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG5cbiAgICBcdHRoaXMubWF0cml4ID0gbGlnaHQubWF0cml4V29ybGQ7XG4gICAgXHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblxuICAgIFx0dmFyIGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG5cbiAgICBcdHZhciBwb3NpdGlvbnMgPSBbXG4gICAgXHRcdDAsIDAsIDAsICAgMCwgICAwLCAgIDEsXG4gICAgXHRcdDAsIDAsIDAsICAgMSwgICAwLCAgIDEsXG4gICAgXHRcdDAsIDAsIDAsIC0gMSwgICAwLCAgIDEsXG4gICAgXHRcdDAsIDAsIDAsICAgMCwgICAxLCAgIDEsXG4gICAgXHRcdDAsIDAsIDAsICAgMCwgLSAxLCAgIDFcbiAgICBcdF07XG5cbiAgICBcdGZvciAoIHZhciBpID0gMCwgaiA9IDEsIGwgPSAzMjsgaSA8IGw7IGkgKyssIGogKysgKSB7XG5cbiAgICBcdFx0dmFyIHAxID0gKCBpIC8gbCApICogTWF0aC5QSSAqIDI7XG4gICAgXHRcdHZhciBwMiA9ICggaiAvIGwgKSAqIE1hdGguUEkgKiAyO1xuXG4gICAgXHRcdHBvc2l0aW9ucy5wdXNoKFxuICAgIFx0XHRcdE1hdGguY29zKCBwMSApLCBNYXRoLnNpbiggcDEgKSwgMSxcbiAgICBcdFx0XHRNYXRoLmNvcyggcDIgKSwgTWF0aC5zaW4oIHAyICksIDFcbiAgICBcdFx0KTtcblxuICAgIFx0fVxuXG4gICAgXHRnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQXR0cmlidXRlKCBwb3NpdGlvbnMsIDMgKSApO1xuXG4gICAgXHR2YXIgbWF0ZXJpYWwgPSBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoIHsgZm9nOiBmYWxzZSB9ICk7XG5cbiAgICBcdHRoaXMuY29uZSA9IG5ldyBMaW5lU2VnbWVudHMoIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuICAgIFx0dGhpcy5hZGQoIHRoaXMuY29uZSApO1xuXG4gICAgXHR0aGlzLnVwZGF0ZSgpO1xuXG4gICAgfVxuXG4gICAgU3BvdExpZ2h0SGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE9iamVjdDNELnByb3RvdHlwZSApO1xuICAgIFNwb3RMaWdodEhlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTcG90TGlnaHRIZWxwZXI7XG5cbiAgICBTcG90TGlnaHRIZWxwZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdHRoaXMuY29uZS5nZW9tZXRyeS5kaXNwb3NlKCk7XG4gICAgXHR0aGlzLmNvbmUubWF0ZXJpYWwuZGlzcG9zZSgpO1xuXG4gICAgfTtcblxuICAgIFNwb3RMaWdodEhlbHBlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuXG4gICAgXHR2YXIgdmVjdG9yID0gbmV3IFZlY3RvcjMoKTtcbiAgICBcdHZhciB2ZWN0b3IyID0gbmV3IFZlY3RvcjMoKTtcblxuICAgIFx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSgpIHtcblxuICAgIFx0XHR2YXIgY29uZUxlbmd0aCA9IHRoaXMubGlnaHQuZGlzdGFuY2UgPyB0aGlzLmxpZ2h0LmRpc3RhbmNlIDogMTAwMDtcbiAgICBcdFx0dmFyIGNvbmVXaWR0aCA9IGNvbmVMZW5ndGggKiBNYXRoLnRhbiggdGhpcy5saWdodC5hbmdsZSApO1xuXG4gICAgXHRcdHRoaXMuY29uZS5zY2FsZS5zZXQoIGNvbmVXaWR0aCwgY29uZVdpZHRoLCBjb25lTGVuZ3RoICk7XG5cbiAgICBcdFx0dmVjdG9yLnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5saWdodC5tYXRyaXhXb3JsZCApO1xuICAgIFx0XHR2ZWN0b3IyLnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5saWdodC50YXJnZXQubWF0cml4V29ybGQgKTtcblxuICAgIFx0XHR0aGlzLmNvbmUubG9va0F0KCB2ZWN0b3IyLnN1YiggdmVjdG9yICkgKTtcblxuICAgIFx0XHR0aGlzLmNvbmUubWF0ZXJpYWwuY29sb3IuY29weSggdGhpcy5saWdodC5jb2xvciApLm11bHRpcGx5U2NhbGFyKCB0aGlzLmxpZ2h0LmludGVuc2l0eSApO1xuXG4gICAgXHR9O1xuXG4gICAgfSgpO1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBTZWFuIEdyaWZmaW4gLyBodHRwOi8vdHdpdHRlci5jb20vc2dyaWZcbiAgICAgKiBAYXV0aG9yIE1pY2hhZWwgR3VlcnJlcm8gLyBodHRwOi8vcmVhbGl0eW1lbHRkb3duLmNvbVxuICAgICAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gICAgICogQGF1dGhvciBpa2VyciAvIGh0dHA6Ly92ZXJvbGQuY29tXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBTa2VsZXRvbkhlbHBlciggb2JqZWN0ICkge1xuXG4gICAgXHR0aGlzLmJvbmVzID0gdGhpcy5nZXRCb25lTGlzdCggb2JqZWN0ICk7XG5cbiAgICBcdHZhciBnZW9tZXRyeSA9IG5ldyBHZW9tZXRyeSgpO1xuXG4gICAgXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmJvbmVzLmxlbmd0aDsgaSArKyApIHtcblxuICAgIFx0XHR2YXIgYm9uZSA9IHRoaXMuYm9uZXNbIGkgXTtcblxuICAgIFx0XHRpZiAoIChib25lLnBhcmVudCAmJiBib25lLnBhcmVudC5pc0JvbmUpICkge1xuXG4gICAgXHRcdFx0Z2VvbWV0cnkudmVydGljZXMucHVzaCggbmV3IFZlY3RvcjMoKSApO1xuICAgIFx0XHRcdGdlb21ldHJ5LnZlcnRpY2VzLnB1c2goIG5ldyBWZWN0b3IzKCkgKTtcbiAgICBcdFx0XHRnZW9tZXRyeS5jb2xvcnMucHVzaCggbmV3IENvbG9yKCAwLCAwLCAxICkgKTtcbiAgICBcdFx0XHRnZW9tZXRyeS5jb2xvcnMucHVzaCggbmV3IENvbG9yKCAwLCAxLCAwICkgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdH1cblxuICAgIFx0Z2VvbWV0cnkuZHluYW1pYyA9IHRydWU7XG5cbiAgICBcdHZhciBtYXRlcmlhbCA9IG5ldyBMaW5lQmFzaWNNYXRlcmlhbCggeyB2ZXJ0ZXhDb2xvcnM6IFZlcnRleENvbG9ycywgZGVwdGhUZXN0OiBmYWxzZSwgZGVwdGhXcml0ZTogZmFsc2UsIHRyYW5zcGFyZW50OiB0cnVlIH0gKTtcblxuICAgIFx0TGluZVNlZ21lbnRzLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG4gICAgXHR0aGlzLnJvb3QgPSBvYmplY3Q7XG5cbiAgICBcdHRoaXMubWF0cml4ID0gb2JqZWN0Lm1hdHJpeFdvcmxkO1xuICAgIFx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cbiAgICBcdHRoaXMudXBkYXRlKCk7XG5cbiAgICB9XG5cblxuICAgIFNrZWxldG9uSGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIExpbmVTZWdtZW50cy5wcm90b3R5cGUgKTtcbiAgICBTa2VsZXRvbkhlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTa2VsZXRvbkhlbHBlcjtcblxuICAgIFNrZWxldG9uSGVscGVyLnByb3RvdHlwZS5nZXRCb25lTGlzdCA9IGZ1bmN0aW9uKCBvYmplY3QgKSB7XG5cbiAgICBcdHZhciBib25lTGlzdCA9IFtdO1xuXG4gICAgXHRpZiAoIChvYmplY3QgJiYgb2JqZWN0LmlzQm9uZSkgKSB7XG5cbiAgICBcdFx0Ym9uZUxpc3QucHVzaCggb2JqZWN0ICk7XG5cbiAgICBcdH1cblxuICAgIFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgb2JqZWN0LmNoaWxkcmVuLmxlbmd0aDsgaSArKyApIHtcblxuICAgIFx0XHRib25lTGlzdC5wdXNoLmFwcGx5KCBib25lTGlzdCwgdGhpcy5nZXRCb25lTGlzdCggb2JqZWN0LmNoaWxkcmVuWyBpIF0gKSApO1xuXG4gICAgXHR9XG5cbiAgICBcdHJldHVybiBib25lTGlzdDtcblxuICAgIH07XG5cbiAgICBTa2VsZXRvbkhlbHBlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuXG4gICAgXHR2YXIgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuXG4gICAgXHR2YXIgbWF0cml4V29ybGRJbnYgPSBuZXcgTWF0cml4NCgpLmdldEludmVyc2UoIHRoaXMucm9vdC5tYXRyaXhXb3JsZCApO1xuXG4gICAgXHR2YXIgYm9uZU1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XG5cbiAgICBcdHZhciBqID0gMDtcblxuICAgIFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5ib25lcy5sZW5ndGg7IGkgKysgKSB7XG5cbiAgICBcdFx0dmFyIGJvbmUgPSB0aGlzLmJvbmVzWyBpIF07XG5cbiAgICBcdFx0aWYgKCAoYm9uZS5wYXJlbnQgJiYgYm9uZS5wYXJlbnQuaXNCb25lKSApIHtcblxuICAgIFx0XHRcdGJvbmVNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggbWF0cml4V29ybGRJbnYsIGJvbmUubWF0cml4V29ybGQgKTtcbiAgICBcdFx0XHRnZW9tZXRyeS52ZXJ0aWNlc1sgaiBdLnNldEZyb21NYXRyaXhQb3NpdGlvbiggYm9uZU1hdHJpeCApO1xuXG4gICAgXHRcdFx0Ym9uZU1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBtYXRyaXhXb3JsZEludiwgYm9uZS5wYXJlbnQubWF0cml4V29ybGQgKTtcbiAgICBcdFx0XHRnZW9tZXRyeS52ZXJ0aWNlc1sgaiArIDEgXS5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGJvbmVNYXRyaXggKTtcblxuICAgIFx0XHRcdGogKz0gMjtcblxuICAgIFx0XHR9XG5cbiAgICBcdH1cblxuICAgIFx0Z2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlID0gdHJ1ZTtcblxuICAgIFx0Z2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG5cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAgICAgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gUG9pbnRMaWdodEhlbHBlciggbGlnaHQsIHNwaGVyZVNpemUgKSB7XG5cbiAgICBcdHRoaXMubGlnaHQgPSBsaWdodDtcbiAgICBcdHRoaXMubGlnaHQudXBkYXRlTWF0cml4V29ybGQoKTtcblxuICAgIFx0dmFyIGdlb21ldHJ5ID0gbmV3IFNwaGVyZUJ1ZmZlckdlb21ldHJ5KCBzcGhlcmVTaXplLCA0LCAyICk7XG4gICAgXHR2YXIgbWF0ZXJpYWwgPSBuZXcgTWVzaEJhc2ljTWF0ZXJpYWwoIHsgd2lyZWZyYW1lOiB0cnVlLCBmb2c6IGZhbHNlIH0gKTtcbiAgICBcdG1hdGVyaWFsLmNvbG9yLmNvcHkoIHRoaXMubGlnaHQuY29sb3IgKS5tdWx0aXBseVNjYWxhciggdGhpcy5saWdodC5pbnRlbnNpdHkgKTtcblxuICAgIFx0TWVzaC5jYWxsKCB0aGlzLCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblxuICAgIFx0dGhpcy5tYXRyaXggPSB0aGlzLmxpZ2h0Lm1hdHJpeFdvcmxkO1xuICAgIFx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cbiAgICBcdC8qXG4gICAgXHR2YXIgZGlzdGFuY2VHZW9tZXRyeSA9IG5ldyBUSFJFRS5JY29zYWhlZHJvbkdlb21ldHJ5KCAxLCAyICk7XG4gICAgXHR2YXIgZGlzdGFuY2VNYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogaGV4Q29sb3IsIGZvZzogZmFsc2UsIHdpcmVmcmFtZTogdHJ1ZSwgb3BhY2l0eTogMC4xLCB0cmFuc3BhcmVudDogdHJ1ZSB9ICk7XG5cbiAgICBcdHRoaXMubGlnaHRTcGhlcmUgPSBuZXcgVEhSRUUuTWVzaCggYnVsYkdlb21ldHJ5LCBidWxiTWF0ZXJpYWwgKTtcbiAgICBcdHRoaXMubGlnaHREaXN0YW5jZSA9IG5ldyBUSFJFRS5NZXNoKCBkaXN0YW5jZUdlb21ldHJ5LCBkaXN0YW5jZU1hdGVyaWFsICk7XG5cbiAgICBcdHZhciBkID0gbGlnaHQuZGlzdGFuY2U7XG5cbiAgICBcdGlmICggZCA9PT0gMC4wICkge1xuXG4gICAgXHRcdHRoaXMubGlnaHREaXN0YW5jZS52aXNpYmxlID0gZmFsc2U7XG5cbiAgICBcdH0gZWxzZSB7XG5cbiAgICBcdFx0dGhpcy5saWdodERpc3RhbmNlLnNjYWxlLnNldCggZCwgZCwgZCApO1xuXG4gICAgXHR9XG5cbiAgICBcdHRoaXMuYWRkKCB0aGlzLmxpZ2h0RGlzdGFuY2UgKTtcbiAgICBcdCovXG5cbiAgICB9XG5cbiAgICBQb2ludExpZ2h0SGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE1lc2gucHJvdG90eXBlICk7XG4gICAgUG9pbnRMaWdodEhlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQb2ludExpZ2h0SGVscGVyO1xuXG4gICAgUG9pbnRMaWdodEhlbHBlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0dGhpcy5nZW9tZXRyeS5kaXNwb3NlKCk7XG4gICAgXHR0aGlzLm1hdGVyaWFsLmRpc3Bvc2UoKTtcblxuICAgIH07XG5cbiAgICBQb2ludExpZ2h0SGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdHRoaXMubWF0ZXJpYWwuY29sb3IuY29weSggdGhpcy5saWdodC5jb2xvciApLm11bHRpcGx5U2NhbGFyKCB0aGlzLmxpZ2h0LmludGVuc2l0eSApO1xuXG4gICAgXHQvKlxuICAgIFx0dmFyIGQgPSB0aGlzLmxpZ2h0LmRpc3RhbmNlO1xuXG4gICAgXHRpZiAoIGQgPT09IDAuMCApIHtcblxuICAgIFx0XHR0aGlzLmxpZ2h0RGlzdGFuY2UudmlzaWJsZSA9IGZhbHNlO1xuXG4gICAgXHR9IGVsc2Uge1xuXG4gICAgXHRcdHRoaXMubGlnaHREaXN0YW5jZS52aXNpYmxlID0gdHJ1ZTtcbiAgICBcdFx0dGhpcy5saWdodERpc3RhbmNlLnNjYWxlLnNldCggZCwgZCwgZCApO1xuXG4gICAgXHR9XG4gICAgXHQqL1xuXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gICAgICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIEhlbWlzcGhlcmVMaWdodEhlbHBlciggbGlnaHQsIHNwaGVyZVNpemUgKSB7XG5cbiAgICBcdE9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuICAgIFx0dGhpcy5saWdodCA9IGxpZ2h0O1xuICAgIFx0dGhpcy5saWdodC51cGRhdGVNYXRyaXhXb3JsZCgpO1xuXG4gICAgXHR0aGlzLm1hdHJpeCA9IGxpZ2h0Lm1hdHJpeFdvcmxkO1xuICAgIFx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cbiAgICBcdHRoaXMuY29sb3JzID0gWyBuZXcgQ29sb3IoKSwgbmV3IENvbG9yKCkgXTtcblxuICAgIFx0dmFyIGdlb21ldHJ5ID0gbmV3IFNwaGVyZUdlb21ldHJ5KCBzcGhlcmVTaXplLCA0LCAyICk7XG4gICAgXHRnZW9tZXRyeS5yb3RhdGVYKCAtIE1hdGguUEkgLyAyICk7XG5cbiAgICBcdGZvciAoIHZhciBpID0gMCwgaWwgPSA4OyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICBcdFx0Z2VvbWV0cnkuZmFjZXNbIGkgXS5jb2xvciA9IHRoaXMuY29sb3JzWyBpIDwgNCA/IDAgOiAxIF07XG5cbiAgICBcdH1cblxuICAgIFx0dmFyIG1hdGVyaWFsID0gbmV3IE1lc2hCYXNpY01hdGVyaWFsKCB7IHZlcnRleENvbG9yczogRmFjZUNvbG9ycywgd2lyZWZyYW1lOiB0cnVlIH0gKTtcblxuICAgIFx0dGhpcy5saWdodFNwaGVyZSA9IG5ldyBNZXNoKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcbiAgICBcdHRoaXMuYWRkKCB0aGlzLmxpZ2h0U3BoZXJlICk7XG5cbiAgICBcdHRoaXMudXBkYXRlKCk7XG5cbiAgICB9XG5cbiAgICBIZW1pc3BoZXJlTGlnaHRIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggT2JqZWN0M0QucHJvdG90eXBlICk7XG4gICAgSGVtaXNwaGVyZUxpZ2h0SGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEhlbWlzcGhlcmVMaWdodEhlbHBlcjtcblxuICAgIEhlbWlzcGhlcmVMaWdodEhlbHBlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0dGhpcy5saWdodFNwaGVyZS5nZW9tZXRyeS5kaXNwb3NlKCk7XG4gICAgXHR0aGlzLmxpZ2h0U3BoZXJlLm1hdGVyaWFsLmRpc3Bvc2UoKTtcblxuICAgIH07XG5cbiAgICBIZW1pc3BoZXJlTGlnaHRIZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0dmFyIHZlY3RvciA9IG5ldyBWZWN0b3IzKCk7XG5cbiAgICBcdHJldHVybiBmdW5jdGlvbiB1cGRhdGUoKSB7XG5cbiAgICBcdFx0dGhpcy5jb2xvcnNbIDAgXS5jb3B5KCB0aGlzLmxpZ2h0LmNvbG9yICkubXVsdGlwbHlTY2FsYXIoIHRoaXMubGlnaHQuaW50ZW5zaXR5ICk7XG4gICAgXHRcdHRoaXMuY29sb3JzWyAxIF0uY29weSggdGhpcy5saWdodC5ncm91bmRDb2xvciApLm11bHRpcGx5U2NhbGFyKCB0aGlzLmxpZ2h0LmludGVuc2l0eSApO1xuXG4gICAgXHRcdHRoaXMubGlnaHRTcGhlcmUubG9va0F0KCB2ZWN0b3Iuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLmxpZ2h0Lm1hdHJpeFdvcmxkICkubmVnYXRlKCkgKTtcbiAgICBcdFx0dGhpcy5saWdodFNwaGVyZS5nZW9tZXRyeS5jb2xvcnNOZWVkVXBkYXRlID0gdHJ1ZTtcblxuICAgIFx0fTtcblxuICAgIH0oKTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBHcmlkSGVscGVyKCBzaXplLCBkaXZpc2lvbnMsIGNvbG9yMSwgY29sb3IyICkge1xuXG4gICAgXHRkaXZpc2lvbnMgPSBkaXZpc2lvbnMgfHwgMTtcbiAgICBcdGNvbG9yMSA9IG5ldyBDb2xvciggY29sb3IxICE9PSB1bmRlZmluZWQgPyBjb2xvcjEgOiAweDQ0NDQ0NCApO1xuICAgIFx0Y29sb3IyID0gbmV3IENvbG9yKCBjb2xvcjIgIT09IHVuZGVmaW5lZCA/IGNvbG9yMiA6IDB4ODg4ODg4ICk7XG5cbiAgICBcdHZhciBjZW50ZXIgPSBkaXZpc2lvbnMgLyAyO1xuICAgIFx0dmFyIHN0ZXAgPSAoIHNpemUgKiAyICkgLyBkaXZpc2lvbnM7XG4gICAgXHR2YXIgdmVydGljZXMgPSBbXSwgY29sb3JzID0gW107XG5cbiAgICBcdGZvciAoIHZhciBpID0gMCwgaiA9IDAsIGsgPSAtIHNpemU7IGkgPD0gZGl2aXNpb25zOyBpICsrLCBrICs9IHN0ZXAgKSB7XG5cbiAgICBcdFx0dmVydGljZXMucHVzaCggLSBzaXplLCAwLCBrLCBzaXplLCAwLCBrICk7XG4gICAgXHRcdHZlcnRpY2VzLnB1c2goIGssIDAsIC0gc2l6ZSwgaywgMCwgc2l6ZSApO1xuXG4gICAgXHRcdHZhciBjb2xvciA9IGkgPT09IGNlbnRlciA/IGNvbG9yMSA6IGNvbG9yMjtcblxuICAgIFx0XHRjb2xvci50b0FycmF5KCBjb2xvcnMsIGogKTsgaiArPSAzO1xuICAgIFx0XHRjb2xvci50b0FycmF5KCBjb2xvcnMsIGogKTsgaiArPSAzO1xuICAgIFx0XHRjb2xvci50b0FycmF5KCBjb2xvcnMsIGogKTsgaiArPSAzO1xuICAgIFx0XHRjb2xvci50b0FycmF5KCBjb2xvcnMsIGogKTsgaiArPSAzO1xuXG4gICAgXHR9XG5cbiAgICBcdHZhciBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuICAgIFx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xuICAgIFx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCAnY29sb3InLCBuZXcgRmxvYXQzMkF0dHJpYnV0ZSggY29sb3JzLCAzICkgKTtcblxuICAgIFx0dmFyIG1hdGVyaWFsID0gbmV3IExpbmVCYXNpY01hdGVyaWFsKCB7IHZlcnRleENvbG9yczogVmVydGV4Q29sb3JzIH0gKTtcblxuICAgIFx0TGluZVNlZ21lbnRzLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG4gICAgfVxuXG4gICAgR3JpZEhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBMaW5lU2VnbWVudHMucHJvdG90eXBlICk7XG4gICAgR3JpZEhlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBHcmlkSGVscGVyO1xuXG4gICAgR3JpZEhlbHBlci5wcm90b3R5cGUuc2V0Q29sb3JzID0gZnVuY3Rpb24gKCkge1xuXG4gICAgXHRjb25zb2xlLmVycm9yKCAnVEhSRUUuR3JpZEhlbHBlcjogc2V0Q29sb3JzKCkgaGFzIGJlZW4gZGVwcmVjYXRlZCwgcGFzcyB0aGVtIGluIHRoZSBjb25zdHJ1Y3RvciBpbnN0ZWFkLicgKTtcblxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICAgICAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuICAgICovXG5cbiAgICBmdW5jdGlvbiBGYWNlTm9ybWFsc0hlbHBlciggb2JqZWN0LCBzaXplLCBoZXgsIGxpbmV3aWR0aCApIHtcblxuICAgIFx0Ly8gRmFjZU5vcm1hbHNIZWxwZXIgb25seSBzdXBwb3J0cyBUSFJFRS5HZW9tZXRyeVxuXG4gICAgXHR0aGlzLm9iamVjdCA9IG9iamVjdDtcblxuICAgIFx0dGhpcy5zaXplID0gKCBzaXplICE9PSB1bmRlZmluZWQgKSA/IHNpemUgOiAxO1xuXG4gICAgXHR2YXIgY29sb3IgPSAoIGhleCAhPT0gdW5kZWZpbmVkICkgPyBoZXggOiAweGZmZmYwMDtcblxuICAgIFx0dmFyIHdpZHRoID0gKCBsaW5ld2lkdGggIT09IHVuZGVmaW5lZCApID8gbGluZXdpZHRoIDogMTtcblxuICAgIFx0Ly9cblxuICAgIFx0dmFyIG5Ob3JtYWxzID0gMDtcblxuICAgIFx0dmFyIG9iakdlb21ldHJ5ID0gdGhpcy5vYmplY3QuZ2VvbWV0cnk7XG5cbiAgICBcdGlmICggKG9iakdlb21ldHJ5ICYmIG9iakdlb21ldHJ5LmlzR2VvbWV0cnkpICkge1xuXG4gICAgXHRcdG5Ob3JtYWxzID0gb2JqR2VvbWV0cnkuZmFjZXMubGVuZ3RoO1xuXG4gICAgXHR9IGVsc2Uge1xuXG4gICAgXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkZhY2VOb3JtYWxzSGVscGVyOiBvbmx5IFRIUkVFLkdlb21ldHJ5IGlzIHN1cHBvcnRlZC4gVXNlIFRIUkVFLlZlcnRleE5vcm1hbHNIZWxwZXIsIGluc3RlYWQuJyApO1xuXG4gICAgXHR9XG5cbiAgICBcdC8vXG5cbiAgICBcdHZhciBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xuXG4gICAgXHR2YXIgcG9zaXRpb25zID0gbmV3IEZsb2F0MzJBdHRyaWJ1dGUoIG5Ob3JtYWxzICogMiAqIDMsIDMgKTtcblxuICAgIFx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBwb3NpdGlvbnMgKTtcblxuICAgIFx0TGluZVNlZ21lbnRzLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGNvbG9yLCBsaW5ld2lkdGg6IHdpZHRoIH0gKSApO1xuXG4gICAgXHQvL1xuXG4gICAgXHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcbiAgICBcdHRoaXMudXBkYXRlKCk7XG5cbiAgICB9XG5cbiAgICBGYWNlTm9ybWFsc0hlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBMaW5lU2VnbWVudHMucHJvdG90eXBlICk7XG4gICAgRmFjZU5vcm1hbHNIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRmFjZU5vcm1hbHNIZWxwZXI7XG5cbiAgICBGYWNlTm9ybWFsc0hlbHBlci5wcm90b3R5cGUudXBkYXRlID0gKCBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCk7XG4gICAgXHR2YXIgdjIgPSBuZXcgVmVjdG9yMygpO1xuICAgIFx0dmFyIG5vcm1hbE1hdHJpeCA9IG5ldyBNYXRyaXgzKCk7XG5cbiAgICBcdHJldHVybiBmdW5jdGlvbiB1cGRhdGUoKSB7XG5cbiAgICBcdFx0dGhpcy5vYmplY3QudXBkYXRlTWF0cml4V29ybGQoIHRydWUgKTtcblxuICAgIFx0XHRub3JtYWxNYXRyaXguZ2V0Tm9ybWFsTWF0cml4KCB0aGlzLm9iamVjdC5tYXRyaXhXb3JsZCApO1xuXG4gICAgXHRcdHZhciBtYXRyaXhXb3JsZCA9IHRoaXMub2JqZWN0Lm1hdHJpeFdvcmxkO1xuXG4gICAgXHRcdHZhciBwb3NpdGlvbiA9IHRoaXMuZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcblxuICAgIFx0XHQvL1xuXG4gICAgXHRcdHZhciBvYmpHZW9tZXRyeSA9IHRoaXMub2JqZWN0Lmdlb21ldHJ5O1xuXG4gICAgXHRcdHZhciB2ZXJ0aWNlcyA9IG9iakdlb21ldHJ5LnZlcnRpY2VzO1xuXG4gICAgXHRcdHZhciBmYWNlcyA9IG9iakdlb21ldHJ5LmZhY2VzO1xuXG4gICAgXHRcdHZhciBpZHggPSAwO1xuXG4gICAgXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IGZhY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICBcdFx0XHR2YXIgZmFjZSA9IGZhY2VzWyBpIF07XG5cbiAgICBcdFx0XHR2YXIgbm9ybWFsID0gZmFjZS5ub3JtYWw7XG5cbiAgICBcdFx0XHR2MS5jb3B5KCB2ZXJ0aWNlc1sgZmFjZS5hIF0gKVxuICAgIFx0XHRcdFx0LmFkZCggdmVydGljZXNbIGZhY2UuYiBdIClcbiAgICBcdFx0XHRcdC5hZGQoIHZlcnRpY2VzWyBmYWNlLmMgXSApXG4gICAgXHRcdFx0XHQuZGl2aWRlU2NhbGFyKCAzIClcbiAgICBcdFx0XHRcdC5hcHBseU1hdHJpeDQoIG1hdHJpeFdvcmxkICk7XG5cbiAgICBcdFx0XHR2Mi5jb3B5KCBub3JtYWwgKS5hcHBseU1hdHJpeDMoIG5vcm1hbE1hdHJpeCApLm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKCB0aGlzLnNpemUgKS5hZGQoIHYxICk7XG5cbiAgICBcdFx0XHRwb3NpdGlvbi5zZXRYWVooIGlkeCwgdjEueCwgdjEueSwgdjEueiApO1xuXG4gICAgXHRcdFx0aWR4ID0gaWR4ICsgMTtcblxuICAgIFx0XHRcdHBvc2l0aW9uLnNldFhZWiggaWR4LCB2Mi54LCB2Mi55LCB2Mi56ICk7XG5cbiAgICBcdFx0XHRpZHggPSBpZHggKyAxO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRwb3NpdGlvbi5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICBcdFx0cmV0dXJuIHRoaXM7XG5cbiAgICBcdH07XG5cbiAgICB9KCkgKTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gICAgICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAgICAgKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIERpcmVjdGlvbmFsTGlnaHRIZWxwZXIoIGxpZ2h0LCBzaXplICkge1xuXG4gICAgXHRPYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cbiAgICBcdHRoaXMubGlnaHQgPSBsaWdodDtcbiAgICBcdHRoaXMubGlnaHQudXBkYXRlTWF0cml4V29ybGQoKTtcblxuICAgIFx0dGhpcy5tYXRyaXggPSBsaWdodC5tYXRyaXhXb3JsZDtcbiAgICBcdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXG4gICAgXHRpZiAoIHNpemUgPT09IHVuZGVmaW5lZCApIHNpemUgPSAxO1xuXG4gICAgXHR2YXIgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcbiAgICBcdGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJBdHRyaWJ1dGUoIFtcbiAgICBcdFx0LSBzaXplLCAgIHNpemUsIDAsXG4gICAgXHRcdCAgc2l6ZSwgICBzaXplLCAwLFxuICAgIFx0XHQgIHNpemUsIC0gc2l6ZSwgMCxcbiAgICBcdFx0LSBzaXplLCAtIHNpemUsIDAsXG4gICAgXHRcdC0gc2l6ZSwgICBzaXplLCAwXG4gICAgXHRdLCAzICkgKTtcblxuICAgIFx0dmFyIG1hdGVyaWFsID0gbmV3IExpbmVCYXNpY01hdGVyaWFsKCB7IGZvZzogZmFsc2UgfSApO1xuXG4gICAgXHR0aGlzLmFkZCggbmV3IExpbmUoIGdlb21ldHJ5LCBtYXRlcmlhbCApICk7XG5cbiAgICBcdGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG4gICAgXHRnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQXR0cmlidXRlKCBbIDAsIDAsIDAsIDAsIDAsIDEgXSwgMyApICk7XG5cbiAgICBcdHRoaXMuYWRkKCBuZXcgTGluZSggZ2VvbWV0cnksIG1hdGVyaWFsICkpO1xuXG4gICAgXHR0aGlzLnVwZGF0ZSgpO1xuXG4gICAgfVxuXG4gICAgRGlyZWN0aW9uYWxMaWdodEhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBPYmplY3QzRC5wcm90b3R5cGUgKTtcbiAgICBEaXJlY3Rpb25hbExpZ2h0SGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IERpcmVjdGlvbmFsTGlnaHRIZWxwZXI7XG5cbiAgICBEaXJlY3Rpb25hbExpZ2h0SGVscGVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXG4gICAgXHR2YXIgbGlnaHRQbGFuZSA9IHRoaXMuY2hpbGRyZW5bIDAgXTtcbiAgICBcdHZhciB0YXJnZXRMaW5lID0gdGhpcy5jaGlsZHJlblsgMSBdO1xuXG4gICAgXHRsaWdodFBsYW5lLmdlb21ldHJ5LmRpc3Bvc2UoKTtcbiAgICBcdGxpZ2h0UGxhbmUubWF0ZXJpYWwuZGlzcG9zZSgpO1xuICAgIFx0dGFyZ2V0TGluZS5nZW9tZXRyeS5kaXNwb3NlKCk7XG4gICAgXHR0YXJnZXRMaW5lLm1hdGVyaWFsLmRpc3Bvc2UoKTtcblxuICAgIH07XG5cbiAgICBEaXJlY3Rpb25hbExpZ2h0SGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCk7XG4gICAgXHR2YXIgdjIgPSBuZXcgVmVjdG9yMygpO1xuICAgIFx0dmFyIHYzID0gbmV3IFZlY3RvcjMoKTtcblxuICAgIFx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSgpIHtcblxuICAgIFx0XHR2MS5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubGlnaHQubWF0cml4V29ybGQgKTtcbiAgICBcdFx0djIuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLmxpZ2h0LnRhcmdldC5tYXRyaXhXb3JsZCApO1xuICAgIFx0XHR2My5zdWJWZWN0b3JzKCB2MiwgdjEgKTtcblxuICAgIFx0XHR2YXIgbGlnaHRQbGFuZSA9IHRoaXMuY2hpbGRyZW5bIDAgXTtcbiAgICBcdFx0dmFyIHRhcmdldExpbmUgPSB0aGlzLmNoaWxkcmVuWyAxIF07XG5cbiAgICBcdFx0bGlnaHRQbGFuZS5sb29rQXQoIHYzICk7XG4gICAgXHRcdGxpZ2h0UGxhbmUubWF0ZXJpYWwuY29sb3IuY29weSggdGhpcy5saWdodC5jb2xvciApLm11bHRpcGx5U2NhbGFyKCB0aGlzLmxpZ2h0LmludGVuc2l0eSApO1xuXG4gICAgXHRcdHRhcmdldExpbmUubG9va0F0KCB2MyApO1xuICAgIFx0XHR0YXJnZXRMaW5lLnNjYWxlLnogPSB2My5sZW5ndGgoKTtcblxuICAgIFx0fTtcblxuICAgIH0oKTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gICAgICpcbiAgICAgKlx0LSBzaG93cyBmcnVzdHVtLCBsaW5lIG9mIHNpZ2h0IGFuZCB1cCBvZiB0aGUgY2FtZXJhXG4gICAgICpcdC0gc3VpdGFibGUgZm9yIGZhc3QgdXBkYXRlc1xuICAgICAqIFx0LSBiYXNlZCBvbiBmcnVzdHVtIHZpc3VhbGl6YXRpb24gaW4gbGlnaHRnbC5qcyBzaGFkb3dtYXAgZXhhbXBsZVxuICAgICAqXHRcdGh0dHA6Ly9ldmFudy5naXRodWIuY29tL2xpZ2h0Z2wuanMvdGVzdHMvc2hhZG93bWFwLmh0bWxcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIENhbWVyYUhlbHBlciggY2FtZXJhICkge1xuXG4gICAgXHR2YXIgZ2VvbWV0cnkgPSBuZXcgR2VvbWV0cnkoKTtcbiAgICBcdHZhciBtYXRlcmlhbCA9IG5ldyBMaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogMHhmZmZmZmYsIHZlcnRleENvbG9yczogRmFjZUNvbG9ycyB9ICk7XG5cbiAgICBcdHZhciBwb2ludE1hcCA9IHt9O1xuXG4gICAgXHQvLyBjb2xvcnNcblxuICAgIFx0dmFyIGhleEZydXN0dW0gPSAweGZmYWEwMDtcbiAgICBcdHZhciBoZXhDb25lID0gMHhmZjAwMDA7XG4gICAgXHR2YXIgaGV4VXAgPSAweDAwYWFmZjtcbiAgICBcdHZhciBoZXhUYXJnZXQgPSAweGZmZmZmZjtcbiAgICBcdHZhciBoZXhDcm9zcyA9IDB4MzMzMzMzO1xuXG4gICAgXHQvLyBuZWFyXG5cbiAgICBcdGFkZExpbmUoIFwibjFcIiwgXCJuMlwiLCBoZXhGcnVzdHVtICk7XG4gICAgXHRhZGRMaW5lKCBcIm4yXCIsIFwibjRcIiwgaGV4RnJ1c3R1bSApO1xuICAgIFx0YWRkTGluZSggXCJuNFwiLCBcIm4zXCIsIGhleEZydXN0dW0gKTtcbiAgICBcdGFkZExpbmUoIFwibjNcIiwgXCJuMVwiLCBoZXhGcnVzdHVtICk7XG5cbiAgICBcdC8vIGZhclxuXG4gICAgXHRhZGRMaW5lKCBcImYxXCIsIFwiZjJcIiwgaGV4RnJ1c3R1bSApO1xuICAgIFx0YWRkTGluZSggXCJmMlwiLCBcImY0XCIsIGhleEZydXN0dW0gKTtcbiAgICBcdGFkZExpbmUoIFwiZjRcIiwgXCJmM1wiLCBoZXhGcnVzdHVtICk7XG4gICAgXHRhZGRMaW5lKCBcImYzXCIsIFwiZjFcIiwgaGV4RnJ1c3R1bSApO1xuXG4gICAgXHQvLyBzaWRlc1xuXG4gICAgXHRhZGRMaW5lKCBcIm4xXCIsIFwiZjFcIiwgaGV4RnJ1c3R1bSApO1xuICAgIFx0YWRkTGluZSggXCJuMlwiLCBcImYyXCIsIGhleEZydXN0dW0gKTtcbiAgICBcdGFkZExpbmUoIFwibjNcIiwgXCJmM1wiLCBoZXhGcnVzdHVtICk7XG4gICAgXHRhZGRMaW5lKCBcIm40XCIsIFwiZjRcIiwgaGV4RnJ1c3R1bSApO1xuXG4gICAgXHQvLyBjb25lXG5cbiAgICBcdGFkZExpbmUoIFwicFwiLCBcIm4xXCIsIGhleENvbmUgKTtcbiAgICBcdGFkZExpbmUoIFwicFwiLCBcIm4yXCIsIGhleENvbmUgKTtcbiAgICBcdGFkZExpbmUoIFwicFwiLCBcIm4zXCIsIGhleENvbmUgKTtcbiAgICBcdGFkZExpbmUoIFwicFwiLCBcIm40XCIsIGhleENvbmUgKTtcblxuICAgIFx0Ly8gdXBcblxuICAgIFx0YWRkTGluZSggXCJ1MVwiLCBcInUyXCIsIGhleFVwICk7XG4gICAgXHRhZGRMaW5lKCBcInUyXCIsIFwidTNcIiwgaGV4VXAgKTtcbiAgICBcdGFkZExpbmUoIFwidTNcIiwgXCJ1MVwiLCBoZXhVcCApO1xuXG4gICAgXHQvLyB0YXJnZXRcblxuICAgIFx0YWRkTGluZSggXCJjXCIsIFwidFwiLCBoZXhUYXJnZXQgKTtcbiAgICBcdGFkZExpbmUoIFwicFwiLCBcImNcIiwgaGV4Q3Jvc3MgKTtcblxuICAgIFx0Ly8gY3Jvc3NcblxuICAgIFx0YWRkTGluZSggXCJjbjFcIiwgXCJjbjJcIiwgaGV4Q3Jvc3MgKTtcbiAgICBcdGFkZExpbmUoIFwiY24zXCIsIFwiY240XCIsIGhleENyb3NzICk7XG5cbiAgICBcdGFkZExpbmUoIFwiY2YxXCIsIFwiY2YyXCIsIGhleENyb3NzICk7XG4gICAgXHRhZGRMaW5lKCBcImNmM1wiLCBcImNmNFwiLCBoZXhDcm9zcyApO1xuXG4gICAgXHRmdW5jdGlvbiBhZGRMaW5lKCBhLCBiLCBoZXggKSB7XG5cbiAgICBcdFx0YWRkUG9pbnQoIGEsIGhleCApO1xuICAgIFx0XHRhZGRQb2ludCggYiwgaGV4ICk7XG5cbiAgICBcdH1cblxuICAgIFx0ZnVuY3Rpb24gYWRkUG9pbnQoIGlkLCBoZXggKSB7XG5cbiAgICBcdFx0Z2VvbWV0cnkudmVydGljZXMucHVzaCggbmV3IFZlY3RvcjMoKSApO1xuICAgIFx0XHRnZW9tZXRyeS5jb2xvcnMucHVzaCggbmV3IENvbG9yKCBoZXggKSApO1xuXG4gICAgXHRcdGlmICggcG9pbnRNYXBbIGlkIF0gPT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdHBvaW50TWFwWyBpZCBdID0gW107XG5cbiAgICBcdFx0fVxuXG4gICAgXHRcdHBvaW50TWFwWyBpZCBdLnB1c2goIGdlb21ldHJ5LnZlcnRpY2VzLmxlbmd0aCAtIDEgKTtcblxuICAgIFx0fVxuXG4gICAgXHRMaW5lU2VnbWVudHMuY2FsbCggdGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cbiAgICBcdHRoaXMuY2FtZXJhID0gY2FtZXJhO1xuICAgIFx0aWYoIHRoaXMuY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXggKSB0aGlzLmNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG5cbiAgICBcdHRoaXMubWF0cml4ID0gY2FtZXJhLm1hdHJpeFdvcmxkO1xuICAgIFx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cbiAgICBcdHRoaXMucG9pbnRNYXAgPSBwb2ludE1hcDtcblxuICAgIFx0dGhpcy51cGRhdGUoKTtcblxuICAgIH1cblxuICAgIENhbWVyYUhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBMaW5lU2VnbWVudHMucHJvdG90eXBlICk7XG4gICAgQ2FtZXJhSGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENhbWVyYUhlbHBlcjtcblxuICAgIENhbWVyYUhlbHBlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuXG4gICAgXHR2YXIgZ2VvbWV0cnksIHBvaW50TWFwO1xuXG4gICAgXHR2YXIgdmVjdG9yID0gbmV3IFZlY3RvcjMoKTtcbiAgICBcdHZhciBjYW1lcmEgPSBuZXcgQ2FtZXJhKCk7XG5cbiAgICBcdGZ1bmN0aW9uIHNldFBvaW50KCBwb2ludCwgeCwgeSwgeiApIHtcblxuICAgIFx0XHR2ZWN0b3Iuc2V0KCB4LCB5LCB6ICkudW5wcm9qZWN0KCBjYW1lcmEgKTtcblxuICAgIFx0XHR2YXIgcG9pbnRzID0gcG9pbnRNYXBbIHBvaW50IF07XG5cbiAgICBcdFx0aWYgKCBwb2ludHMgIT09IHVuZGVmaW5lZCApIHtcblxuICAgIFx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICBcdFx0XHRcdGdlb21ldHJ5LnZlcnRpY2VzWyBwb2ludHNbIGkgXSBdLmNvcHkoIHZlY3RvciApO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdH1cblxuICAgIFx0fVxuXG4gICAgXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlKCkge1xuXG4gICAgXHRcdGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcbiAgICBcdFx0cG9pbnRNYXAgPSB0aGlzLnBvaW50TWFwO1xuXG4gICAgXHRcdHZhciB3ID0gMSwgaCA9IDE7XG5cbiAgICBcdFx0Ly8gd2UgbmVlZCBqdXN0IGNhbWVyYSBwcm9qZWN0aW9uIG1hdHJpeFxuICAgIFx0XHQvLyB3b3JsZCBtYXRyaXggbXVzdCBiZSBpZGVudGl0eVxuXG4gICAgXHRcdGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4LmNvcHkoIHRoaXMuY2FtZXJhLnByb2plY3Rpb25NYXRyaXggKTtcblxuICAgIFx0XHQvLyBjZW50ZXIgLyB0YXJnZXRcblxuICAgIFx0XHRzZXRQb2ludCggXCJjXCIsIDAsIDAsIC0gMSApO1xuICAgIFx0XHRzZXRQb2ludCggXCJ0XCIsIDAsIDAsICAxICk7XG5cbiAgICBcdFx0Ly8gbmVhclxuXG4gICAgXHRcdHNldFBvaW50KCBcIm4xXCIsIC0gdywgLSBoLCAtIDEgKTtcbiAgICBcdFx0c2V0UG9pbnQoIFwibjJcIiwgICB3LCAtIGgsIC0gMSApO1xuICAgIFx0XHRzZXRQb2ludCggXCJuM1wiLCAtIHcsICAgaCwgLSAxICk7XG4gICAgXHRcdHNldFBvaW50KCBcIm40XCIsICAgdywgICBoLCAtIDEgKTtcblxuICAgIFx0XHQvLyBmYXJcblxuICAgIFx0XHRzZXRQb2ludCggXCJmMVwiLCAtIHcsIC0gaCwgMSApO1xuICAgIFx0XHRzZXRQb2ludCggXCJmMlwiLCAgIHcsIC0gaCwgMSApO1xuICAgIFx0XHRzZXRQb2ludCggXCJmM1wiLCAtIHcsICAgaCwgMSApO1xuICAgIFx0XHRzZXRQb2ludCggXCJmNFwiLCAgIHcsICAgaCwgMSApO1xuXG4gICAgXHRcdC8vIHVwXG5cbiAgICBcdFx0c2V0UG9pbnQoIFwidTFcIiwgICB3ICogMC43LCBoICogMS4xLCAtIDEgKTtcbiAgICBcdFx0c2V0UG9pbnQoIFwidTJcIiwgLSB3ICogMC43LCBoICogMS4xLCAtIDEgKTtcbiAgICBcdFx0c2V0UG9pbnQoIFwidTNcIiwgICAgICAgICAwLCBoICogMiwgICAtIDEgKTtcblxuICAgIFx0XHQvLyBjcm9zc1xuXG4gICAgXHRcdHNldFBvaW50KCBcImNmMVwiLCAtIHcsICAgMCwgMSApO1xuICAgIFx0XHRzZXRQb2ludCggXCJjZjJcIiwgICB3LCAgIDAsIDEgKTtcbiAgICBcdFx0c2V0UG9pbnQoIFwiY2YzXCIsICAgMCwgLSBoLCAxICk7XG4gICAgXHRcdHNldFBvaW50KCBcImNmNFwiLCAgIDAsICAgaCwgMSApO1xuXG4gICAgXHRcdHNldFBvaW50KCBcImNuMVwiLCAtIHcsICAgMCwgLSAxICk7XG4gICAgXHRcdHNldFBvaW50KCBcImNuMlwiLCAgIHcsICAgMCwgLSAxICk7XG4gICAgXHRcdHNldFBvaW50KCBcImNuM1wiLCAgIDAsIC0gaCwgLSAxICk7XG4gICAgXHRcdHNldFBvaW50KCBcImNuNFwiLCAgIDAsICAgaCwgLSAxICk7XG5cbiAgICBcdFx0Z2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlID0gdHJ1ZTtcblxuICAgIFx0fTtcblxuICAgIH0oKTtcblxuICAgIC8qKlxuICAgICAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuICAgICAqL1xuXG4gICAgLy8gYSBoZWxwZXIgdG8gc2hvdyB0aGUgd29ybGQtYXhpcy1hbGlnbmVkIGJvdW5kaW5nIGJveCBmb3IgYW4gb2JqZWN0XG5cbiAgICBmdW5jdGlvbiBCb3VuZGluZ0JveEhlbHBlciggb2JqZWN0LCBoZXggKSB7XG5cbiAgICBcdHZhciBjb2xvciA9ICggaGV4ICE9PSB1bmRlZmluZWQgKSA/IGhleCA6IDB4ODg4ODg4O1xuXG4gICAgXHR0aGlzLm9iamVjdCA9IG9iamVjdDtcblxuICAgIFx0dGhpcy5ib3ggPSBuZXcgQm94MygpO1xuXG4gICAgXHRNZXNoLmNhbGwoIHRoaXMsIG5ldyBCb3hHZW9tZXRyeSggMSwgMSwgMSApLCBuZXcgTWVzaEJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGNvbG9yLCB3aXJlZnJhbWU6IHRydWUgfSApICk7XG5cbiAgICB9XG5cbiAgICBCb3VuZGluZ0JveEhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBNZXNoLnByb3RvdHlwZSApO1xuICAgIEJvdW5kaW5nQm94SGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEJvdW5kaW5nQm94SGVscGVyO1xuXG4gICAgQm91bmRpbmdCb3hIZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcblxuICAgIFx0dGhpcy5ib3guc2V0RnJvbU9iamVjdCggdGhpcy5vYmplY3QgKTtcblxuICAgIFx0dGhpcy5ib3guc2l6ZSggdGhpcy5zY2FsZSApO1xuXG4gICAgXHR0aGlzLmJveC5nZXRDZW50ZXIoIHRoaXMucG9zaXRpb24gKTtcblxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gQm94SGVscGVyKCBvYmplY3QsIGNvbG9yICkge1xuXG4gICAgXHRpZiAoIGNvbG9yID09PSB1bmRlZmluZWQgKSBjb2xvciA9IDB4ZmZmZjAwO1xuXG4gICAgXHR2YXIgaW5kaWNlcyA9IG5ldyBVaW50MTZBcnJheSggWyAwLCAxLCAxLCAyLCAyLCAzLCAzLCAwLCA0LCA1LCA1LCA2LCA2LCA3LCA3LCA0LCAwLCA0LCAxLCA1LCAyLCA2LCAzLCA3IF0gKTtcbiAgICBcdHZhciBwb3NpdGlvbnMgPSBuZXcgRmxvYXQzMkFycmF5KCA4ICogMyApO1xuXG4gICAgXHR2YXIgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcbiAgICBcdGdlb21ldHJ5LnNldEluZGV4KCBuZXcgQnVmZmVyQXR0cmlidXRlKCBpbmRpY2VzLCAxICkgKTtcbiAgICBcdGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25zLCAzICkgKTtcblxuICAgIFx0TGluZVNlZ21lbnRzLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGNvbG9yIH0gKSApO1xuXG4gICAgXHRpZiAoIG9iamVjdCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgXHRcdHRoaXMudXBkYXRlKCBvYmplY3QgKTtcblxuICAgIFx0fVxuXG4gICAgfVxuXG4gICAgQm94SGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIExpbmVTZWdtZW50cy5wcm90b3R5cGUgKTtcbiAgICBCb3hIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQm94SGVscGVyO1xuXG4gICAgQm94SGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSAoIGZ1bmN0aW9uICgpIHtcblxuICAgIFx0dmFyIGJveCA9IG5ldyBCb3gzKCk7XG5cbiAgICBcdHJldHVybiBmdW5jdGlvbiB1cGRhdGUoIG9iamVjdCApIHtcblxuICAgIFx0XHRpZiAoIChvYmplY3QgJiYgb2JqZWN0LmlzQm94MykgKSB7XG5cbiAgICBcdFx0XHRib3guY29weSggb2JqZWN0ICk7XG5cbiAgICBcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdGJveC5zZXRGcm9tT2JqZWN0KCBvYmplY3QgKTtcblxuICAgIFx0XHR9XG5cbiAgICBcdFx0aWYgKCBib3guaXNFbXB0eSgpICkgcmV0dXJuO1xuXG4gICAgXHRcdHZhciBtaW4gPSBib3gubWluO1xuICAgIFx0XHR2YXIgbWF4ID0gYm94Lm1heDtcblxuICAgIFx0XHQvKlxuICAgIFx0XHQgIDVfX19fNFxuICAgIFx0XHQxL19fXzAvfFxuICAgIFx0XHR8IDZfX3xfN1xuICAgIFx0XHQyL19fXzMvXG5cbiAgICBcdFx0MDogbWF4LngsIG1heC55LCBtYXguelxuICAgIFx0XHQxOiBtaW4ueCwgbWF4LnksIG1heC56XG4gICAgXHRcdDI6IG1pbi54LCBtaW4ueSwgbWF4LnpcbiAgICBcdFx0MzogbWF4LngsIG1pbi55LCBtYXguelxuICAgIFx0XHQ0OiBtYXgueCwgbWF4LnksIG1pbi56XG4gICAgXHRcdDU6IG1pbi54LCBtYXgueSwgbWluLnpcbiAgICBcdFx0NjogbWluLngsIG1pbi55LCBtaW4uelxuICAgIFx0XHQ3OiBtYXgueCwgbWluLnksIG1pbi56XG4gICAgXHRcdCovXG5cbiAgICBcdFx0dmFyIHBvc2l0aW9uID0gdGhpcy5nZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuICAgIFx0XHR2YXIgYXJyYXkgPSBwb3NpdGlvbi5hcnJheTtcblxuICAgIFx0XHRhcnJheVsgIDAgXSA9IG1heC54OyBhcnJheVsgIDEgXSA9IG1heC55OyBhcnJheVsgIDIgXSA9IG1heC56O1xuICAgIFx0XHRhcnJheVsgIDMgXSA9IG1pbi54OyBhcnJheVsgIDQgXSA9IG1heC55OyBhcnJheVsgIDUgXSA9IG1heC56O1xuICAgIFx0XHRhcnJheVsgIDYgXSA9IG1pbi54OyBhcnJheVsgIDcgXSA9IG1pbi55OyBhcnJheVsgIDggXSA9IG1heC56O1xuICAgIFx0XHRhcnJheVsgIDkgXSA9IG1heC54OyBhcnJheVsgMTAgXSA9IG1pbi55OyBhcnJheVsgMTEgXSA9IG1heC56O1xuICAgIFx0XHRhcnJheVsgMTIgXSA9IG1heC54OyBhcnJheVsgMTMgXSA9IG1heC55OyBhcnJheVsgMTQgXSA9IG1pbi56O1xuICAgIFx0XHRhcnJheVsgMTUgXSA9IG1pbi54OyBhcnJheVsgMTYgXSA9IG1heC55OyBhcnJheVsgMTcgXSA9IG1pbi56O1xuICAgIFx0XHRhcnJheVsgMTggXSA9IG1pbi54OyBhcnJheVsgMTkgXSA9IG1pbi55OyBhcnJheVsgMjAgXSA9IG1pbi56O1xuICAgIFx0XHRhcnJheVsgMjEgXSA9IG1heC54OyBhcnJheVsgMjIgXSA9IG1pbi55OyBhcnJheVsgMjMgXSA9IG1pbi56O1xuXG4gICAgXHRcdHBvc2l0aW9uLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgIFx0XHR0aGlzLmdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xuXG4gICAgXHR9O1xuXG4gICAgfSApKCk7XG5cbiAgICB2YXIgbGluZUdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG4gICAgbGluZUdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJBdHRyaWJ1dGUoIFsgMCwgMCwgMCwgMCwgMSwgMCBdLCAzICkgKTtcblxuICAgIHZhciBjb25lR2VvbWV0cnkgPSBuZXcgQ3lsaW5kZXJCdWZmZXJHZW9tZXRyeSggMCwgMC41LCAxLCA1LCAxICk7XG4gICAgY29uZUdlb21ldHJ5LnRyYW5zbGF0ZSggMCwgLSAwLjUsIDAgKTtcblxuICAgIGZ1bmN0aW9uIEFycm93SGVscGVyKCBkaXIsIG9yaWdpbiwgbGVuZ3RoLCBjb2xvciwgaGVhZExlbmd0aCwgaGVhZFdpZHRoICkge1xuXG4gICAgXHQvLyBkaXIgaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkXG5cbiAgICBcdE9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuICAgIFx0aWYgKCBjb2xvciA9PT0gdW5kZWZpbmVkICkgY29sb3IgPSAweGZmZmYwMDtcbiAgICBcdGlmICggbGVuZ3RoID09PSB1bmRlZmluZWQgKSBsZW5ndGggPSAxO1xuICAgIFx0aWYgKCBoZWFkTGVuZ3RoID09PSB1bmRlZmluZWQgKSBoZWFkTGVuZ3RoID0gMC4yICogbGVuZ3RoO1xuICAgIFx0aWYgKCBoZWFkV2lkdGggPT09IHVuZGVmaW5lZCApIGhlYWRXaWR0aCA9IDAuMiAqIGhlYWRMZW5ndGg7XG5cbiAgICBcdHRoaXMucG9zaXRpb24uY29weSggb3JpZ2luICk7XG5cbiAgICBcdHRoaXMubGluZSA9IG5ldyBMaW5lKCBsaW5lR2VvbWV0cnksIG5ldyBMaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogY29sb3IgfSApICk7XG4gICAgXHR0aGlzLmxpbmUubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuICAgIFx0dGhpcy5hZGQoIHRoaXMubGluZSApO1xuXG4gICAgXHR0aGlzLmNvbmUgPSBuZXcgTWVzaCggY29uZUdlb21ldHJ5LCBuZXcgTWVzaEJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGNvbG9yIH0gKSApO1xuICAgIFx0dGhpcy5jb25lLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcbiAgICBcdHRoaXMuYWRkKCB0aGlzLmNvbmUgKTtcblxuICAgIFx0dGhpcy5zZXREaXJlY3Rpb24oIGRpciApO1xuICAgIFx0dGhpcy5zZXRMZW5ndGgoIGxlbmd0aCwgaGVhZExlbmd0aCwgaGVhZFdpZHRoICk7XG5cbiAgICB9XG5cbiAgICBBcnJvd0hlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBPYmplY3QzRC5wcm90b3R5cGUgKTtcbiAgICBBcnJvd0hlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBBcnJvd0hlbHBlcjtcblxuICAgIEFycm93SGVscGVyLnByb3RvdHlwZS5zZXREaXJlY3Rpb24gPSAoIGZ1bmN0aW9uICgpIHtcblxuICAgIFx0dmFyIGF4aXMgPSBuZXcgVmVjdG9yMygpO1xuICAgIFx0dmFyIHJhZGlhbnM7XG5cbiAgICBcdHJldHVybiBmdW5jdGlvbiBzZXREaXJlY3Rpb24oIGRpciApIHtcblxuICAgIFx0XHQvLyBkaXIgaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkXG5cbiAgICBcdFx0aWYgKCBkaXIueSA+IDAuOTk5OTkgKSB7XG5cbiAgICBcdFx0XHR0aGlzLnF1YXRlcm5pb24uc2V0KCAwLCAwLCAwLCAxICk7XG5cbiAgICBcdFx0fSBlbHNlIGlmICggZGlyLnkgPCAtIDAuOTk5OTkgKSB7XG5cbiAgICBcdFx0XHR0aGlzLnF1YXRlcm5pb24uc2V0KCAxLCAwLCAwLCAwICk7XG5cbiAgICBcdFx0fSBlbHNlIHtcblxuICAgIFx0XHRcdGF4aXMuc2V0KCBkaXIueiwgMCwgLSBkaXIueCApLm5vcm1hbGl6ZSgpO1xuXG4gICAgXHRcdFx0cmFkaWFucyA9IE1hdGguYWNvcyggZGlyLnkgKTtcblxuICAgIFx0XHRcdHRoaXMucXVhdGVybmlvbi5zZXRGcm9tQXhpc0FuZ2xlKCBheGlzLCByYWRpYW5zICk7XG5cbiAgICBcdFx0fVxuXG4gICAgXHR9O1xuXG4gICAgfSgpICk7XG5cbiAgICBBcnJvd0hlbHBlci5wcm90b3R5cGUuc2V0TGVuZ3RoID0gZnVuY3Rpb24gKCBsZW5ndGgsIGhlYWRMZW5ndGgsIGhlYWRXaWR0aCApIHtcblxuICAgIFx0aWYgKCBoZWFkTGVuZ3RoID09PSB1bmRlZmluZWQgKSBoZWFkTGVuZ3RoID0gMC4yICogbGVuZ3RoO1xuICAgIFx0aWYgKCBoZWFkV2lkdGggPT09IHVuZGVmaW5lZCApIGhlYWRXaWR0aCA9IDAuMiAqIGhlYWRMZW5ndGg7XG5cbiAgICBcdHRoaXMubGluZS5zY2FsZS5zZXQoIDEsIE1hdGgubWF4KCAwLCBsZW5ndGggLSBoZWFkTGVuZ3RoICksIDEgKTtcbiAgICBcdHRoaXMubGluZS51cGRhdGVNYXRyaXgoKTtcblxuICAgIFx0dGhpcy5jb25lLnNjYWxlLnNldCggaGVhZFdpZHRoLCBoZWFkTGVuZ3RoLCBoZWFkV2lkdGggKTtcbiAgICBcdHRoaXMuY29uZS5wb3NpdGlvbi55ID0gbGVuZ3RoO1xuICAgIFx0dGhpcy5jb25lLnVwZGF0ZU1hdHJpeCgpO1xuXG4gICAgfTtcblxuICAgIEFycm93SGVscGVyLnByb3RvdHlwZS5zZXRDb2xvciA9IGZ1bmN0aW9uICggY29sb3IgKSB7XG5cbiAgICBcdHRoaXMubGluZS5tYXRlcmlhbC5jb2xvci5jb3B5KCBjb2xvciApO1xuICAgIFx0dGhpcy5jb25lLm1hdGVyaWFsLmNvbG9yLmNvcHkoIGNvbG9yICk7XG5cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGF1dGhvciBzcm91Y2hlcmF5IC8gaHR0cDovL3Nyb3VjaGVyYXkub3JnL1xuICAgICAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBBeGlzSGVscGVyKCBzaXplICkge1xuXG4gICAgXHRzaXplID0gc2l6ZSB8fCAxO1xuXG4gICAgXHR2YXIgdmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KCBbXG4gICAgXHRcdDAsIDAsIDAsICBzaXplLCAwLCAwLFxuICAgIFx0XHQwLCAwLCAwLCAgMCwgc2l6ZSwgMCxcbiAgICBcdFx0MCwgMCwgMCwgIDAsIDAsIHNpemVcbiAgICBcdF0gKTtcblxuICAgIFx0dmFyIGNvbG9ycyA9IG5ldyBGbG9hdDMyQXJyYXkoIFtcbiAgICBcdFx0MSwgMCwgMCwgIDEsIDAuNiwgMCxcbiAgICBcdFx0MCwgMSwgMCwgIDAuNiwgMSwgMCxcbiAgICBcdFx0MCwgMCwgMSwgIDAsIDAuNiwgMVxuICAgIFx0XSApO1xuXG4gICAgXHR2YXIgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcbiAgICBcdGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xuICAgIFx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCAnY29sb3InLCBuZXcgQnVmZmVyQXR0cmlidXRlKCBjb2xvcnMsIDMgKSApO1xuXG4gICAgXHR2YXIgbWF0ZXJpYWwgPSBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoIHsgdmVydGV4Q29sb3JzOiBWZXJ0ZXhDb2xvcnMgfSApO1xuXG4gICAgXHRMaW5lU2VnbWVudHMuY2FsbCggdGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cbiAgICB9XG5cbiAgICBBeGlzSGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIExpbmVTZWdtZW50cy5wcm90b3R5cGUgKTtcbiAgICBBeGlzSGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEF4aXNIZWxwZXI7XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIHp6ODUgaHR0cHM6Ly9naXRodWIuY29tL3p6ODVcbiAgICAgKlxuICAgICAqIENlbnRyaXBldGFsIENhdG11bGxSb20gQ3VydmUgLSB3aGljaCBpcyB1c2VmdWwgZm9yIGF2b2lkaW5nXG4gICAgICogY3VzcHMgYW5kIHNlbGYtaW50ZXJzZWN0aW9ucyBpbiBub24tdW5pZm9ybSBjYXRtdWxsIHJvbSBjdXJ2ZXMuXG4gICAgICogaHR0cDovL3d3dy5jZW15dWtzZWwuY29tL3Jlc2VhcmNoL2NhdG11bGxyb21fcGFyYW0vY2F0bXVsbHJvbS5wZGZcbiAgICAgKlxuICAgICAqIGN1cnZlLnR5cGUgYWNjZXB0cyBjZW50cmlwZXRhbChkZWZhdWx0KSwgY2hvcmRhbCBhbmQgY2F0bXVsbHJvbVxuICAgICAqIGN1cnZlLnRlbnNpb24gaXMgdXNlZCBmb3IgY2F0bXVsbHJvbSB3aGljaCBkZWZhdWx0cyB0byAwLjVcbiAgICAgKi9cblxuICAgIGV4cG9ydHMuQ2F0bXVsbFJvbUN1cnZlMyA9ICggZnVuY3Rpb24oKSB7XG5cbiAgICBcdHZhclxuICAgIFx0XHR0bXAgPSBuZXcgVmVjdG9yMygpLFxuICAgIFx0XHRweCA9IG5ldyBDdWJpY1BvbHkoKSxcbiAgICBcdFx0cHkgPSBuZXcgQ3ViaWNQb2x5KCksXG4gICAgXHRcdHB6ID0gbmV3IEN1YmljUG9seSgpO1xuXG4gICAgXHQvKlxuICAgIFx0QmFzZWQgb24gYW4gb3B0aW1pemVkIGMrKyBzb2x1dGlvbiBpblxuICAgIFx0IC0gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy85NDg5NzM2L2NhdG11bGwtcm9tLWN1cnZlLXdpdGgtbm8tY3VzcHMtYW5kLW5vLXNlbGYtaW50ZXJzZWN0aW9ucy9cbiAgICBcdCAtIGh0dHA6Ly9pZGVvbmUuY29tL05vRWJWTVxuXG4gICAgXHRUaGlzIEN1YmljUG9seSBjbGFzcyBjb3VsZCBiZSB1c2VkIGZvciByZXVzaW5nIHNvbWUgdmFyaWFibGVzIGFuZCBjYWxjdWxhdGlvbnMsXG4gICAgXHRidXQgZm9yIHRocmVlLmpzIGN1cnZlIHVzZSwgaXQgY291bGQgYmUgcG9zc2libGUgaW5saW5lZCBhbmQgZmxhdHRlbiBpbnRvIGEgc2luZ2xlIGZ1bmN0aW9uIGNhbGxcbiAgICBcdHdoaWNoIGNhbiBiZSBwbGFjZWQgaW4gQ3VydmVVdGlscy5cbiAgICBcdCovXG5cbiAgICBcdGZ1bmN0aW9uIEN1YmljUG9seSgpIHtcblxuICAgIFx0fVxuXG4gICAgXHQvKlxuICAgIFx0ICogQ29tcHV0ZSBjb2VmZmljaWVudHMgZm9yIGEgY3ViaWMgcG9seW5vbWlhbFxuICAgIFx0ICogICBwKHMpID0gYzAgKyBjMSpzICsgYzIqc14yICsgYzMqc14zXG4gICAgXHQgKiBzdWNoIHRoYXRcbiAgICBcdCAqICAgcCgwKSA9IHgwLCBwKDEpID0geDFcbiAgICBcdCAqICBhbmRcbiAgICBcdCAqICAgcCcoMCkgPSB0MCwgcCcoMSkgPSB0MS5cbiAgICBcdCAqL1xuICAgIFx0Q3ViaWNQb2x5LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oIHgwLCB4MSwgdDAsIHQxICkge1xuXG4gICAgXHRcdHRoaXMuYzAgPSB4MDtcbiAgICBcdFx0dGhpcy5jMSA9IHQwO1xuICAgIFx0XHR0aGlzLmMyID0gLSAzICogeDAgKyAzICogeDEgLSAyICogdDAgLSB0MTtcbiAgICBcdFx0dGhpcy5jMyA9IDIgKiB4MCAtIDIgKiB4MSArIHQwICsgdDE7XG5cbiAgICBcdH07XG5cbiAgICBcdEN1YmljUG9seS5wcm90b3R5cGUuaW5pdE5vbnVuaWZvcm1DYXRtdWxsUm9tID0gZnVuY3Rpb24oIHgwLCB4MSwgeDIsIHgzLCBkdDAsIGR0MSwgZHQyICkge1xuXG4gICAgXHRcdC8vIGNvbXB1dGUgdGFuZ2VudHMgd2hlbiBwYXJhbWV0ZXJpemVkIGluIFt0MSx0Ml1cbiAgICBcdFx0dmFyIHQxID0gKCB4MSAtIHgwICkgLyBkdDAgLSAoIHgyIC0geDAgKSAvICggZHQwICsgZHQxICkgKyAoIHgyIC0geDEgKSAvIGR0MTtcbiAgICBcdFx0dmFyIHQyID0gKCB4MiAtIHgxICkgLyBkdDEgLSAoIHgzIC0geDEgKSAvICggZHQxICsgZHQyICkgKyAoIHgzIC0geDIgKSAvIGR0MjtcblxuICAgIFx0XHQvLyByZXNjYWxlIHRhbmdlbnRzIGZvciBwYXJhbWV0cml6YXRpb24gaW4gWzAsMV1cbiAgICBcdFx0dDEgKj0gZHQxO1xuICAgIFx0XHR0MiAqPSBkdDE7XG5cbiAgICBcdFx0Ly8gaW5pdEN1YmljUG9seVxuICAgIFx0XHR0aGlzLmluaXQoIHgxLCB4MiwgdDEsIHQyICk7XG5cbiAgICBcdH07XG5cbiAgICBcdC8vIHN0YW5kYXJkIENhdG11bGwtUm9tIHNwbGluZTogaW50ZXJwb2xhdGUgYmV0d2VlbiB4MSBhbmQgeDIgd2l0aCBwcmV2aW91cy9mb2xsb3dpbmcgcG9pbnRzIHgxL3g0XG4gICAgXHRDdWJpY1BvbHkucHJvdG90eXBlLmluaXRDYXRtdWxsUm9tID0gZnVuY3Rpb24oIHgwLCB4MSwgeDIsIHgzLCB0ZW5zaW9uICkge1xuXG4gICAgXHRcdHRoaXMuaW5pdCggeDEsIHgyLCB0ZW5zaW9uICogKCB4MiAtIHgwICksIHRlbnNpb24gKiAoIHgzIC0geDEgKSApO1xuXG4gICAgXHR9O1xuXG4gICAgXHRDdWJpY1BvbHkucHJvdG90eXBlLmNhbGMgPSBmdW5jdGlvbiggdCApIHtcblxuICAgIFx0XHR2YXIgdDIgPSB0ICogdDtcbiAgICBcdFx0dmFyIHQzID0gdDIgKiB0O1xuICAgIFx0XHRyZXR1cm4gdGhpcy5jMCArIHRoaXMuYzEgKiB0ICsgdGhpcy5jMiAqIHQyICsgdGhpcy5jMyAqIHQzO1xuXG4gICAgXHR9O1xuXG4gICAgXHQvLyBTdWJjbGFzcyBUaHJlZS5qcyBjdXJ2ZVxuICAgIFx0cmV0dXJuIEN1cnZlLmNyZWF0ZShcblxuICAgIFx0XHRmdW5jdGlvbiAoIHAgLyogYXJyYXkgb2YgVmVjdG9yMyAqLyApIHtcblxuICAgIFx0XHRcdHRoaXMucG9pbnRzID0gcCB8fCBbXTtcbiAgICBcdFx0XHR0aGlzLmNsb3NlZCA9IGZhbHNlO1xuXG4gICAgXHRcdH0sXG5cbiAgICBcdFx0ZnVuY3Rpb24gKCB0ICkge1xuXG4gICAgXHRcdFx0dmFyIHBvaW50cyA9IHRoaXMucG9pbnRzLFxuICAgIFx0XHRcdFx0cG9pbnQsIGludFBvaW50LCB3ZWlnaHQsIGw7XG5cbiAgICBcdFx0XHRsID0gcG9pbnRzLmxlbmd0aDtcblxuICAgIFx0XHRcdGlmICggbCA8IDIgKSBjb25zb2xlLmxvZyggJ2R1aCwgeW91IG5lZWQgYXQgbGVhc3QgMiBwb2ludHMnICk7XG5cbiAgICBcdFx0XHRwb2ludCA9ICggbCAtICggdGhpcy5jbG9zZWQgPyAwIDogMSApICkgKiB0O1xuICAgIFx0XHRcdGludFBvaW50ID0gTWF0aC5mbG9vciggcG9pbnQgKTtcbiAgICBcdFx0XHR3ZWlnaHQgPSBwb2ludCAtIGludFBvaW50O1xuXG4gICAgXHRcdFx0aWYgKCB0aGlzLmNsb3NlZCApIHtcblxuICAgIFx0XHRcdFx0aW50UG9pbnQgKz0gaW50UG9pbnQgPiAwID8gMCA6ICggTWF0aC5mbG9vciggTWF0aC5hYnMoIGludFBvaW50ICkgLyBwb2ludHMubGVuZ3RoICkgKyAxICkgKiBwb2ludHMubGVuZ3RoO1xuXG4gICAgXHRcdFx0fSBlbHNlIGlmICggd2VpZ2h0ID09PSAwICYmIGludFBvaW50ID09PSBsIC0gMSApIHtcblxuICAgIFx0XHRcdFx0aW50UG9pbnQgPSBsIC0gMjtcbiAgICBcdFx0XHRcdHdlaWdodCA9IDE7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHR2YXIgcDAsIHAxLCBwMiwgcDM7IC8vIDQgcG9pbnRzXG5cbiAgICBcdFx0XHRpZiAoIHRoaXMuY2xvc2VkIHx8IGludFBvaW50ID4gMCApIHtcblxuICAgIFx0XHRcdFx0cDAgPSBwb2ludHNbICggaW50UG9pbnQgLSAxICkgJSBsIF07XG5cbiAgICBcdFx0XHR9IGVsc2Uge1xuXG4gICAgXHRcdFx0XHQvLyBleHRyYXBvbGF0ZSBmaXJzdCBwb2ludFxuICAgIFx0XHRcdFx0dG1wLnN1YlZlY3RvcnMoIHBvaW50c1sgMCBdLCBwb2ludHNbIDEgXSApLmFkZCggcG9pbnRzWyAwIF0gKTtcbiAgICBcdFx0XHRcdHAwID0gdG1wO1xuXG4gICAgXHRcdFx0fVxuXG4gICAgXHRcdFx0cDEgPSBwb2ludHNbIGludFBvaW50ICUgbCBdO1xuICAgIFx0XHRcdHAyID0gcG9pbnRzWyAoIGludFBvaW50ICsgMSApICUgbCBdO1xuXG4gICAgXHRcdFx0aWYgKCB0aGlzLmNsb3NlZCB8fCBpbnRQb2ludCArIDIgPCBsICkge1xuXG4gICAgXHRcdFx0XHRwMyA9IHBvaW50c1sgKCBpbnRQb2ludCArIDIgKSAlIGwgXTtcblxuICAgIFx0XHRcdH0gZWxzZSB7XG5cbiAgICBcdFx0XHRcdC8vIGV4dHJhcG9sYXRlIGxhc3QgcG9pbnRcbiAgICBcdFx0XHRcdHRtcC5zdWJWZWN0b3JzKCBwb2ludHNbIGwgLSAxIF0sIHBvaW50c1sgbCAtIDIgXSApLmFkZCggcG9pbnRzWyBsIC0gMSBdICk7XG4gICAgXHRcdFx0XHRwMyA9IHRtcDtcblxuICAgIFx0XHRcdH1cblxuICAgIFx0XHRcdGlmICggdGhpcy50eXBlID09PSB1bmRlZmluZWQgfHwgdGhpcy50eXBlID09PSAnY2VudHJpcGV0YWwnIHx8IHRoaXMudHlwZSA9PT0gJ2Nob3JkYWwnICkge1xuXG4gICAgXHRcdFx0XHQvLyBpbml0IENlbnRyaXBldGFsIC8gQ2hvcmRhbCBDYXRtdWxsLVJvbVxuICAgIFx0XHRcdFx0dmFyIHBvdyA9IHRoaXMudHlwZSA9PT0gJ2Nob3JkYWwnID8gMC41IDogMC4yNTtcbiAgICBcdFx0XHRcdHZhciBkdDAgPSBNYXRoLnBvdyggcDAuZGlzdGFuY2VUb1NxdWFyZWQoIHAxICksIHBvdyApO1xuICAgIFx0XHRcdFx0dmFyIGR0MSA9IE1hdGgucG93KCBwMS5kaXN0YW5jZVRvU3F1YXJlZCggcDIgKSwgcG93ICk7XG4gICAgXHRcdFx0XHR2YXIgZHQyID0gTWF0aC5wb3coIHAyLmRpc3RhbmNlVG9TcXVhcmVkKCBwMyApLCBwb3cgKTtcblxuICAgIFx0XHRcdFx0Ly8gc2FmZXR5IGNoZWNrIGZvciByZXBlYXRlZCBwb2ludHNcbiAgICBcdFx0XHRcdGlmICggZHQxIDwgMWUtNCApIGR0MSA9IDEuMDtcbiAgICBcdFx0XHRcdGlmICggZHQwIDwgMWUtNCApIGR0MCA9IGR0MTtcbiAgICBcdFx0XHRcdGlmICggZHQyIDwgMWUtNCApIGR0MiA9IGR0MTtcblxuICAgIFx0XHRcdFx0cHguaW5pdE5vbnVuaWZvcm1DYXRtdWxsUm9tKCBwMC54LCBwMS54LCBwMi54LCBwMy54LCBkdDAsIGR0MSwgZHQyICk7XG4gICAgXHRcdFx0XHRweS5pbml0Tm9udW5pZm9ybUNhdG11bGxSb20oIHAwLnksIHAxLnksIHAyLnksIHAzLnksIGR0MCwgZHQxLCBkdDIgKTtcbiAgICBcdFx0XHRcdHB6LmluaXROb251bmlmb3JtQ2F0bXVsbFJvbSggcDAueiwgcDEueiwgcDIueiwgcDMueiwgZHQwLCBkdDEsIGR0MiApO1xuXG4gICAgXHRcdFx0fSBlbHNlIGlmICggdGhpcy50eXBlID09PSAnY2F0bXVsbHJvbScgKSB7XG5cbiAgICBcdFx0XHRcdHZhciB0ZW5zaW9uID0gdGhpcy50ZW5zaW9uICE9PSB1bmRlZmluZWQgPyB0aGlzLnRlbnNpb24gOiAwLjU7XG4gICAgXHRcdFx0XHRweC5pbml0Q2F0bXVsbFJvbSggcDAueCwgcDEueCwgcDIueCwgcDMueCwgdGVuc2lvbiApO1xuICAgIFx0XHRcdFx0cHkuaW5pdENhdG11bGxSb20oIHAwLnksIHAxLnksIHAyLnksIHAzLnksIHRlbnNpb24gKTtcbiAgICBcdFx0XHRcdHB6LmluaXRDYXRtdWxsUm9tKCBwMC56LCBwMS56LCBwMi56LCBwMy56LCB0ZW5zaW9uICk7XG5cbiAgICBcdFx0XHR9XG5cbiAgICBcdFx0XHR2YXIgdiA9IG5ldyBWZWN0b3IzKFxuICAgIFx0XHRcdFx0cHguY2FsYyggd2VpZ2h0ICksXG4gICAgXHRcdFx0XHRweS5jYWxjKCB3ZWlnaHQgKSxcbiAgICBcdFx0XHRcdHB6LmNhbGMoIHdlaWdodCApXG4gICAgXHRcdFx0KTtcblxuICAgIFx0XHRcdHJldHVybiB2O1xuXG4gICAgXHRcdH1cblxuICAgIFx0KTtcblxuICAgIH0gKSgpO1xuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICpcdENsb3NlZCBTcGxpbmUgM0QgY3VydmVcbiAgICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblxuICAgIGZ1bmN0aW9uIENsb3NlZFNwbGluZUN1cnZlMyggcG9pbnRzICkge1xuXG4gICAgXHRjb25zb2xlLndhcm4oICdUSFJFRS5DbG9zZWRTcGxpbmVDdXJ2ZTMgaGFzIGJlZW4gZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBUSFJFRS5DYXRtdWxsUm9tQ3VydmUzLicgKTtcblxuICAgIFx0ZXhwb3J0cy5DYXRtdWxsUm9tQ3VydmUzLmNhbGwoIHRoaXMsIHBvaW50cyApO1xuICAgIFx0dGhpcy50eXBlID0gJ2NhdG11bGxyb20nO1xuICAgIFx0dGhpcy5jbG9zZWQgPSB0cnVlO1xuXG4gICAgfVxuXG4gICAgQ2xvc2VkU3BsaW5lQ3VydmUzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIGV4cG9ydHMuQ2F0bXVsbFJvbUN1cnZlMy5wcm90b3R5cGUgKTtcblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAqXHRTcGxpbmUgM0QgY3VydmVcbiAgICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblxuICAgIHZhciBTcGxpbmVDdXJ2ZTMgPSBDdXJ2ZS5jcmVhdGUoXG5cbiAgICBcdGZ1bmN0aW9uICggcG9pbnRzIC8qIGFycmF5IG9mIFZlY3RvcjMgKi8gKSB7XG5cbiAgICBcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuU3BsaW5lQ3VydmUzIHdpbGwgYmUgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBUSFJFRS5DYXRtdWxsUm9tQ3VydmUzJyApO1xuICAgIFx0XHR0aGlzLnBvaW50cyA9ICggcG9pbnRzID09PSB1bmRlZmluZWQgKSA/IFtdIDogcG9pbnRzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRmdW5jdGlvbiAoIHQgKSB7XG5cbiAgICBcdFx0dmFyIHBvaW50cyA9IHRoaXMucG9pbnRzO1xuICAgIFx0XHR2YXIgcG9pbnQgPSAoIHBvaW50cy5sZW5ndGggLSAxICkgKiB0O1xuXG4gICAgXHRcdHZhciBpbnRQb2ludCA9IE1hdGguZmxvb3IoIHBvaW50ICk7XG4gICAgXHRcdHZhciB3ZWlnaHQgPSBwb2ludCAtIGludFBvaW50O1xuXG4gICAgXHRcdHZhciBwb2ludDAgPSBwb2ludHNbIGludFBvaW50ID09IDAgPyBpbnRQb2ludCA6IGludFBvaW50IC0gMSBdO1xuICAgIFx0XHR2YXIgcG9pbnQxID0gcG9pbnRzWyBpbnRQb2ludCBdO1xuICAgIFx0XHR2YXIgcG9pbnQyID0gcG9pbnRzWyBpbnRQb2ludCA+IHBvaW50cy5sZW5ndGggLSAyID8gcG9pbnRzLmxlbmd0aCAtIDEgOiBpbnRQb2ludCArIDEgXTtcbiAgICBcdFx0dmFyIHBvaW50MyA9IHBvaW50c1sgaW50UG9pbnQgPiBwb2ludHMubGVuZ3RoIC0gMyA/IHBvaW50cy5sZW5ndGggLSAxIDogaW50UG9pbnQgKyAyIF07XG5cbiAgICBcdFx0dmFyIGludGVycG9sYXRlID0gZXhwb3J0cy5DdXJ2ZVV0aWxzLmludGVycG9sYXRlO1xuXG4gICAgXHRcdHJldHVybiBuZXcgVmVjdG9yMyhcbiAgICBcdFx0XHRpbnRlcnBvbGF0ZSggcG9pbnQwLngsIHBvaW50MS54LCBwb2ludDIueCwgcG9pbnQzLngsIHdlaWdodCApLFxuICAgIFx0XHRcdGludGVycG9sYXRlKCBwb2ludDAueSwgcG9pbnQxLnksIHBvaW50Mi55LCBwb2ludDMueSwgd2VpZ2h0ICksXG4gICAgXHRcdFx0aW50ZXJwb2xhdGUoIHBvaW50MC56LCBwb2ludDEueiwgcG9pbnQyLnosIHBvaW50My56LCB3ZWlnaHQgKVxuICAgIFx0XHQpO1xuXG4gICAgXHR9XG5cbiAgICApO1xuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICpcdEN1YmljIEJlemllciAzRCBjdXJ2ZVxuICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgIGV4cG9ydHMuQ3ViaWNCZXppZXJDdXJ2ZTMgPSBDdXJ2ZS5jcmVhdGUoXG5cbiAgICBcdGZ1bmN0aW9uICggdjAsIHYxLCB2MiwgdjMgKSB7XG5cbiAgICBcdFx0dGhpcy52MCA9IHYwO1xuICAgIFx0XHR0aGlzLnYxID0gdjE7XG4gICAgXHRcdHRoaXMudjIgPSB2MjtcbiAgICBcdFx0dGhpcy52MyA9IHYzO1xuXG4gICAgXHR9LFxuXG4gICAgXHRmdW5jdGlvbiAoIHQgKSB7XG5cbiAgICBcdFx0dmFyIGIzID0gZXhwb3J0cy5TaGFwZVV0aWxzLmIzO1xuXG4gICAgXHRcdHJldHVybiBuZXcgVmVjdG9yMyhcbiAgICBcdFx0XHRiMyggdCwgdGhpcy52MC54LCB0aGlzLnYxLngsIHRoaXMudjIueCwgdGhpcy52My54ICksXG4gICAgXHRcdFx0YjMoIHQsIHRoaXMudjAueSwgdGhpcy52MS55LCB0aGlzLnYyLnksIHRoaXMudjMueSApLFxuICAgIFx0XHRcdGIzKCB0LCB0aGlzLnYwLnosIHRoaXMudjEueiwgdGhpcy52Mi56LCB0aGlzLnYzLnogKVxuICAgIFx0XHQpO1xuXG4gICAgXHR9XG5cbiAgICApO1xuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICpcdFF1YWRyYXRpYyBCZXppZXIgM0QgY3VydmVcbiAgICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICBleHBvcnRzLlF1YWRyYXRpY0JlemllckN1cnZlMyA9IEN1cnZlLmNyZWF0ZShcblxuICAgIFx0ZnVuY3Rpb24gKCB2MCwgdjEsIHYyICkge1xuXG4gICAgXHRcdHRoaXMudjAgPSB2MDtcbiAgICBcdFx0dGhpcy52MSA9IHYxO1xuICAgIFx0XHR0aGlzLnYyID0gdjI7XG5cbiAgICBcdH0sXG5cbiAgICBcdGZ1bmN0aW9uICggdCApIHtcblxuICAgIFx0XHR2YXIgYjIgPSBleHBvcnRzLlNoYXBlVXRpbHMuYjI7XHRcdFxuXG4gICAgXHRcdHJldHVybiBuZXcgVmVjdG9yMyhcbiAgICBcdFx0XHRiMiggdCwgdGhpcy52MC54LCB0aGlzLnYxLngsIHRoaXMudjIueCApLFxuICAgIFx0XHRcdGIyKCB0LCB0aGlzLnYwLnksIHRoaXMudjEueSwgdGhpcy52Mi55ICksXG4gICAgXHRcdFx0YjIoIHQsIHRoaXMudjAueiwgdGhpcy52MS56LCB0aGlzLnYyLnogKVxuICAgIFx0XHQpO1xuXG4gICAgXHR9XG5cbiAgICApO1xuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICpcdExpbmUzRFxuICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgIGV4cG9ydHMuTGluZUN1cnZlMyA9IEN1cnZlLmNyZWF0ZShcblxuICAgIFx0ZnVuY3Rpb24gKCB2MSwgdjIgKSB7XG5cbiAgICBcdFx0dGhpcy52MSA9IHYxO1xuICAgIFx0XHR0aGlzLnYyID0gdjI7XG5cbiAgICBcdH0sXG5cbiAgICBcdGZ1bmN0aW9uICggdCApIHtcblxuICAgIFx0XHRpZiAoIHQgPT09IDEgKSB7XG5cbiAgICBcdFx0XHRyZXR1cm4gdGhpcy52Mi5jbG9uZSgpO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHR2YXIgdmVjdG9yID0gbmV3IFZlY3RvcjMoKTtcblxuICAgIFx0XHR2ZWN0b3Iuc3ViVmVjdG9ycyggdGhpcy52MiwgdGhpcy52MSApOyAvLyBkaWZmXG4gICAgXHRcdHZlY3Rvci5tdWx0aXBseVNjYWxhciggdCApO1xuICAgIFx0XHR2ZWN0b3IuYWRkKCB0aGlzLnYxICk7XG5cbiAgICBcdFx0cmV0dXJuIHZlY3RvcjtcblxuICAgIFx0fVxuXG4gICAgKTtcblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAqXHRBcmMgY3VydmVcbiAgICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICBmdW5jdGlvbiBBcmNDdXJ2ZSggYVgsIGFZLCBhUmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlICkge1xuXG4gICAgXHRFbGxpcHNlQ3VydmUuY2FsbCggdGhpcywgYVgsIGFZLCBhUmFkaXVzLCBhUmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlICk7XG5cbiAgICB9XG5cbiAgICBBcmNDdXJ2ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBFbGxpcHNlQ3VydmUucHJvdG90eXBlICk7XG4gICAgQXJjQ3VydmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQXJjQ3VydmU7XG5cbiAgICAvKipcbiAgICAgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICAgICAqL1xuXG4gICAgZXhwb3J0cy5TY2VuZVV0aWxzID0ge1xuXG4gICAgXHRjcmVhdGVNdWx0aU1hdGVyaWFsT2JqZWN0OiBmdW5jdGlvbiAoIGdlb21ldHJ5LCBtYXRlcmlhbHMgKSB7XG5cbiAgICBcdFx0dmFyIGdyb3VwID0gbmV3IEdyb3VwKCk7XG5cbiAgICBcdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gbWF0ZXJpYWxzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICBcdFx0XHRncm91cC5hZGQoIG5ldyBNZXNoKCBnZW9tZXRyeSwgbWF0ZXJpYWxzWyBpIF0gKSApO1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRyZXR1cm4gZ3JvdXA7XG5cbiAgICBcdH0sXG5cbiAgICBcdGRldGFjaDogZnVuY3Rpb24gKCBjaGlsZCwgcGFyZW50LCBzY2VuZSApIHtcblxuICAgIFx0XHRjaGlsZC5hcHBseU1hdHJpeCggcGFyZW50Lm1hdHJpeFdvcmxkICk7XG4gICAgXHRcdHBhcmVudC5yZW1vdmUoIGNoaWxkICk7XG4gICAgXHRcdHNjZW5lLmFkZCggY2hpbGQgKTtcblxuICAgIFx0fSxcblxuICAgIFx0YXR0YWNoOiBmdW5jdGlvbiAoIGNoaWxkLCBzY2VuZSwgcGFyZW50ICkge1xuXG4gICAgXHRcdHZhciBtYXRyaXhXb3JsZEludmVyc2UgPSBuZXcgTWF0cml4NCgpO1xuICAgIFx0XHRtYXRyaXhXb3JsZEludmVyc2UuZ2V0SW52ZXJzZSggcGFyZW50Lm1hdHJpeFdvcmxkICk7XG4gICAgXHRcdGNoaWxkLmFwcGx5TWF0cml4KCBtYXRyaXhXb3JsZEludmVyc2UgKTtcblxuICAgIFx0XHRzY2VuZS5yZW1vdmUoIGNoaWxkICk7XG4gICAgXHRcdHBhcmVudC5hZGQoIGNoaWxkICk7XG5cbiAgICBcdH1cblxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBGYWNlNCAoIGEsIGIsIGMsIGQsIG5vcm1hbCwgY29sb3IsIG1hdGVyaWFsSW5kZXggKSB7XG4gICAgXHRjb25zb2xlLndhcm4oICdUSFJFRS5GYWNlNCBoYXMgYmVlbiByZW1vdmVkLiBBIFRIUkVFLkZhY2UzIHdpbGwgYmUgY3JlYXRlZCBpbnN0ZWFkLicgKTtcbiAgICBcdHJldHVybiBuZXcgRmFjZTMoIGEsIGIsIGMsIG5vcm1hbCwgY29sb3IsIG1hdGVyaWFsSW5kZXggKTtcbiAgICB9XG5cbiAgICB2YXIgTGluZVN0cmlwID0gMDtcblxuICAgIHZhciBMaW5lUGllY2VzID0gMTtcblxuICAgIGZ1bmN0aW9uIFBvaW50Q2xvdWQgKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKSB7XG4gICAgXHRjb25zb2xlLndhcm4oICdUSFJFRS5Qb2ludENsb3VkIGhhcyBiZWVuIHJlbmFtZWQgdG8gVEhSRUUuUG9pbnRzLicgKTtcbiAgICBcdHJldHVybiBuZXcgUG9pbnRzKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBQYXJ0aWNsZVN5c3RlbSAoIGdlb21ldHJ5LCBtYXRlcmlhbCApIHtcbiAgICBcdGNvbnNvbGUud2FybiggJ1RIUkVFLlBhcnRpY2xlU3lzdGVtIGhhcyBiZWVuIHJlbmFtZWQgdG8gVEhSRUUuUG9pbnRzLicgKTtcbiAgICBcdHJldHVybiBuZXcgUG9pbnRzKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBQb2ludENsb3VkTWF0ZXJpYWwgKCBwYXJhbWV0ZXJzICkge1xuICAgIFx0Y29uc29sZS53YXJuKCAnVEhSRUUuUG9pbnRDbG91ZE1hdGVyaWFsIGhhcyBiZWVuIHJlbmFtZWQgdG8gVEhSRUUuUG9pbnRzTWF0ZXJpYWwuJyApO1xuICAgIFx0cmV0dXJuIG5ldyBQb2ludHNNYXRlcmlhbCggcGFyYW1ldGVycyApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFBhcnRpY2xlQmFzaWNNYXRlcmlhbCAoIHBhcmFtZXRlcnMgKSB7XG4gICAgXHRjb25zb2xlLndhcm4oICdUSFJFRS5QYXJ0aWNsZUJhc2ljTWF0ZXJpYWwgaGFzIGJlZW4gcmVuYW1lZCB0byBUSFJFRS5Qb2ludHNNYXRlcmlhbC4nICk7XG4gICAgXHRyZXR1cm4gbmV3IFBvaW50c01hdGVyaWFsKCBwYXJhbWV0ZXJzICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gUGFydGljbGVTeXN0ZW1NYXRlcmlhbCAoIHBhcmFtZXRlcnMgKSB7XG4gICAgXHRjb25zb2xlLndhcm4oICdUSFJFRS5QYXJ0aWNsZVN5c3RlbU1hdGVyaWFsIGhhcyBiZWVuIHJlbmFtZWQgdG8gVEhSRUUuUG9pbnRzTWF0ZXJpYWwuJyApO1xuICAgIFx0cmV0dXJuIG5ldyBQb2ludHNNYXRlcmlhbCggcGFyYW1ldGVycyApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFZlcnRleCAoIHgsIHksIHogKSB7XG4gICAgXHRjb25zb2xlLndhcm4oICdUSFJFRS5WZXJ0ZXggaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFRIUkVFLlZlY3RvcjMgaW5zdGVhZC4nICk7XG4gICAgXHRyZXR1cm4gbmV3IFZlY3RvcjMoIHgsIHksIHogKTtcbiAgICB9XG5cbiAgICAvL1xuXG4gICAgZnVuY3Rpb24gRWRnZXNIZWxwZXIoIG9iamVjdCwgaGV4ICkge1xuICAgIFx0Y29uc29sZS53YXJuKCAnVEhSRUUuRWRnZXNIZWxwZXIgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFRIUkVFLkVkZ2VzR2VvbWV0cnkgaW5zdGVhZC4nICk7XG4gICAgXHRyZXR1cm4gbmV3IExpbmVTZWdtZW50cyggbmV3IEVkZ2VzR2VvbWV0cnkoIG9iamVjdC5nZW9tZXRyeSApLCBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGhleCAhPT0gdW5kZWZpbmVkID8gaGV4IDogMHhmZmZmZmYgfSApICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gV2lyZWZyYW1lSGVscGVyKCBvYmplY3QsIGhleCApIHtcbiAgICBcdGNvbnNvbGUud2FybiggJ1RIUkVFLldpcmVmcmFtZUhlbHBlciBoYXMgYmVlbiByZW1vdmVkLiBVc2UgVEhSRUUuV2lyZWZyYW1lR2VvbWV0cnkgaW5zdGVhZC4nICk7XG4gICAgXHRyZXR1cm4gbmV3IExpbmVTZWdtZW50cyggbmV3IFdpcmVmcmFtZUdlb21ldHJ5KCBvYmplY3QuZ2VvbWV0cnkgKSwgbmV3IExpbmVCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBoZXggIT09IHVuZGVmaW5lZCA/IGhleCA6IDB4ZmZmZmZmIH0gKSApO1xuICAgIH1cblxuICAgIC8vXG5cbiAgICBPYmplY3QuYXNzaWduKCBCb3gyLnByb3RvdHlwZSwge1xuICAgIFx0Y2VudGVyOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuICAgIFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Cb3gyOiAuY2VudGVyKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuZ2V0Q2VudGVyKCkuJyApO1xuICAgIFx0XHRyZXR1cm4gdGhpcy5nZXRDZW50ZXIoIG9wdGlvbmFsVGFyZ2V0ICk7XG4gICAgXHR9LFxuICAgIFx0ZW1wdHk6IGZ1bmN0aW9uICgpIHtcbiAgICBcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQm94MjogLmVtcHR5KCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuaXNFbXB0eSgpLicgKTtcbiAgICBcdFx0cmV0dXJuIHRoaXMuaXNFbXB0eSgpO1xuICAgIFx0fSxcbiAgICBcdGlzSW50ZXJzZWN0aW9uQm94OiBmdW5jdGlvbiAoIGJveCApIHtcbiAgICBcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQm94MjogLmlzSW50ZXJzZWN0aW9uQm94KCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuaW50ZXJzZWN0c0JveCgpLicgKTtcbiAgICBcdFx0cmV0dXJuIHRoaXMuaW50ZXJzZWN0c0JveCggYm94ICk7XG4gICAgXHR9LFxuICAgIFx0c2l6ZTogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcbiAgICBcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQm94MjogLnNpemUoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5nZXRTaXplKCkuJyApO1xuICAgIFx0XHRyZXR1cm4gdGhpcy5nZXRTaXplKCBvcHRpb25hbFRhcmdldCApO1xuICAgIFx0fVxuICAgIH0gKTtcblxuICAgIE9iamVjdC5hc3NpZ24oIEJveDMucHJvdG90eXBlLCB7XG4gICAgXHRjZW50ZXI6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XG4gICAgXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJveDM6IC5jZW50ZXIoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5nZXRDZW50ZXIoKS4nICk7XG4gICAgXHRcdHJldHVybiB0aGlzLmdldENlbnRlciggb3B0aW9uYWxUYXJnZXQgKTtcbiAgICBcdH0sXG4gICAgXHRlbXB0eTogZnVuY3Rpb24gKCkge1xuICAgIFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Cb3gzOiAuZW1wdHkoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5pc0VtcHR5KCkuJyApO1xuICAgIFx0XHRyZXR1cm4gdGhpcy5pc0VtcHR5KCk7XG4gICAgXHR9LFxuICAgIFx0aXNJbnRlcnNlY3Rpb25Cb3g6IGZ1bmN0aW9uICggYm94ICkge1xuICAgIFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5Cb3gzOiAuaXNJbnRlcnNlY3Rpb25Cb3goKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5pbnRlcnNlY3RzQm94KCkuJyApO1xuICAgIFx0XHRyZXR1cm4gdGhpcy5pbnRlcnNlY3RzQm94KCBib3ggKTtcbiAgICBcdH0sXG4gICAgXHRpc0ludGVyc2VjdGlvblNwaGVyZTogZnVuY3Rpb24gKCBzcGhlcmUgKSB7XG4gICAgXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJveDM6IC5pc0ludGVyc2VjdGlvblNwaGVyZSgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmludGVyc2VjdHNTcGhlcmUoKS4nICk7XG4gICAgXHRcdHJldHVybiB0aGlzLmludGVyc2VjdHNTcGhlcmUoIHNwaGVyZSApO1xuICAgIFx0fSxcbiAgICBcdHNpemU6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XG4gICAgXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJveDM6IC5zaXplKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuZ2V0U2l6ZSgpLicgKTtcbiAgICBcdFx0cmV0dXJuIHRoaXMuZ2V0U2l6ZSggb3B0aW9uYWxUYXJnZXQgKTtcbiAgICBcdH1cbiAgICB9ICk7XG5cbiAgICBPYmplY3QuYXNzaWduKCBMaW5lMy5wcm90b3R5cGUsIHtcbiAgICBcdGNlbnRlcjogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcbiAgICBcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTGluZTM6IC5jZW50ZXIoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5nZXRDZW50ZXIoKS4nICk7XG4gICAgXHRcdHJldHVybiB0aGlzLmdldENlbnRlciggb3B0aW9uYWxUYXJnZXQgKTtcbiAgICBcdH1cbiAgICB9ICk7XG5cbiAgICBPYmplY3QuYXNzaWduKCBNYXRyaXgzLnByb3RvdHlwZSwge1xuICAgIFx0bXVsdGlwbHlWZWN0b3IzOiBmdW5jdGlvbiAoIHZlY3RvciApIHtcbiAgICBcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4MzogLm11bHRpcGx5VmVjdG9yMygpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSB2ZWN0b3IuYXBwbHlNYXRyaXgzKCBtYXRyaXggKSBpbnN0ZWFkLicgKTtcbiAgICBcdFx0cmV0dXJuIHZlY3Rvci5hcHBseU1hdHJpeDMoIHRoaXMgKTtcbiAgICBcdH0sXG4gICAgXHRtdWx0aXBseVZlY3RvcjNBcnJheTogZnVuY3Rpb24gKCBhICkge1xuICAgIFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXgzOiAubXVsdGlwbHlWZWN0b3IzQXJyYXkoKSBoYXMgYmVlbiByZW5hbWVkLiBVc2UgbWF0cml4LmFwcGx5VG9WZWN0b3IzQXJyYXkoIGFycmF5ICkgaW5zdGVhZC4nICk7XG4gICAgXHRcdHJldHVybiB0aGlzLmFwcGx5VG9WZWN0b3IzQXJyYXkoIGEgKTtcbiAgICBcdH1cbiAgICB9ICk7XG5cbiAgICBPYmplY3QuYXNzaWduKCBNYXRyaXg0LnByb3RvdHlwZSwge1xuICAgIFx0ZXh0cmFjdFBvc2l0aW9uOiBmdW5jdGlvbiAoIG0gKSB7XG4gICAgXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDQ6IC5leHRyYWN0UG9zaXRpb24oKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5jb3B5UG9zaXRpb24oKS4nICk7XG4gICAgXHRcdHJldHVybiB0aGlzLmNvcHlQb3NpdGlvbiggbSApO1xuICAgIFx0fSxcbiAgICBcdHNldFJvdGF0aW9uRnJvbVF1YXRlcm5pb246IGZ1bmN0aW9uICggcSApIHtcbiAgICBcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLnNldFJvdGF0aW9uRnJvbVF1YXRlcm5pb24oKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5tYWtlUm90YXRpb25Gcm9tUXVhdGVybmlvbigpLicgKTtcbiAgICBcdFx0cmV0dXJuIHRoaXMubWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb24oIHEgKTtcbiAgICBcdH0sXG4gICAgXHRtdWx0aXBseVZlY3RvcjM6IGZ1bmN0aW9uICggdmVjdG9yICkge1xuICAgIFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXg0OiAubXVsdGlwbHlWZWN0b3IzKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIHZlY3Rvci5hcHBseU1hdHJpeDQoIG1hdHJpeCApIG9yIHZlY3Rvci5hcHBseVByb2plY3Rpb24oIG1hdHJpeCApIGluc3RlYWQuJyApO1xuICAgIFx0XHRyZXR1cm4gdmVjdG9yLmFwcGx5UHJvamVjdGlvbiggdGhpcyApO1xuICAgIFx0fSxcbiAgICBcdG11bHRpcGx5VmVjdG9yNDogZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XG4gICAgXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDQ6IC5tdWx0aXBseVZlY3RvcjQoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgdmVjdG9yLmFwcGx5TWF0cml4NCggbWF0cml4ICkgaW5zdGVhZC4nICk7XG4gICAgXHRcdHJldHVybiB2ZWN0b3IuYXBwbHlNYXRyaXg0KCB0aGlzICk7XG4gICAgXHR9LFxuICAgIFx0bXVsdGlwbHlWZWN0b3IzQXJyYXk6IGZ1bmN0aW9uICggYSApIHtcbiAgICBcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLm11bHRpcGx5VmVjdG9yM0FycmF5KCkgaGFzIGJlZW4gcmVuYW1lZC4gVXNlIG1hdHJpeC5hcHBseVRvVmVjdG9yM0FycmF5KCBhcnJheSApIGluc3RlYWQuJyApO1xuICAgIFx0XHRyZXR1cm4gdGhpcy5hcHBseVRvVmVjdG9yM0FycmF5KCBhICk7XG4gICAgXHR9LFxuICAgIFx0cm90YXRlQXhpczogZnVuY3Rpb24gKCB2ICkge1xuICAgIFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXg0OiAucm90YXRlQXhpcygpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBWZWN0b3IzLnRyYW5zZm9ybURpcmVjdGlvbiggbWF0cml4ICkgaW5zdGVhZC4nICk7XG4gICAgXHRcdHYudHJhbnNmb3JtRGlyZWN0aW9uKCB0aGlzICk7XG4gICAgXHR9LFxuICAgIFx0Y3Jvc3NWZWN0b3I6IGZ1bmN0aW9uICggdmVjdG9yICkge1xuICAgIFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXg0OiAuY3Jvc3NWZWN0b3IoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgdmVjdG9yLmFwcGx5TWF0cml4NCggbWF0cml4ICkgaW5zdGVhZC4nICk7XG4gICAgXHRcdHJldHVybiB2ZWN0b3IuYXBwbHlNYXRyaXg0KCB0aGlzICk7XG4gICAgXHR9LFxuICAgIFx0dHJhbnNsYXRlOiBmdW5jdGlvbiAoIHYgKSB7XG4gICAgXHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5NYXRyaXg0OiAudHJhbnNsYXRlKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XG4gICAgXHR9LFxuICAgIFx0cm90YXRlWDogZnVuY3Rpb24gKCBhbmdsZSApIHtcbiAgICBcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLk1hdHJpeDQ6IC5yb3RhdGVYKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XG4gICAgXHR9LFxuICAgIFx0cm90YXRlWTogZnVuY3Rpb24gKCBhbmdsZSApIHtcbiAgICBcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLk1hdHJpeDQ6IC5yb3RhdGVZKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XG4gICAgXHR9LFxuICAgIFx0cm90YXRlWjogZnVuY3Rpb24gKCBhbmdsZSApIHtcbiAgICBcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLk1hdHJpeDQ6IC5yb3RhdGVaKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XG4gICAgXHR9LFxuICAgIFx0cm90YXRlQnlBeGlzOiBmdW5jdGlvbiAoIGF4aXMsIGFuZ2xlICkge1xuICAgIFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuTWF0cml4NDogLnJvdGF0ZUJ5QXhpcygpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xuICAgIFx0fVxuICAgIH0gKTtcblxuICAgIE9iamVjdC5hc3NpZ24oIFBsYW5lLnByb3RvdHlwZSwge1xuICAgIFx0aXNJbnRlcnNlY3Rpb25MaW5lOiBmdW5jdGlvbiAoIGxpbmUgKSB7XG4gICAgXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlBsYW5lOiAuaXNJbnRlcnNlY3Rpb25MaW5lKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuaW50ZXJzZWN0c0xpbmUoKS4nICk7XG4gICAgXHRcdHJldHVybiB0aGlzLmludGVyc2VjdHNMaW5lKCBsaW5lICk7XG4gICAgXHR9XG4gICAgfSApO1xuXG4gICAgT2JqZWN0LmFzc2lnbiggUXVhdGVybmlvbi5wcm90b3R5cGUsIHtcbiAgICBcdG11bHRpcGx5VmVjdG9yMzogZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XG4gICAgXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlF1YXRlcm5pb246IC5tdWx0aXBseVZlY3RvcjMoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgaXMgbm93IHZlY3Rvci5hcHBseVF1YXRlcm5pb24oIHF1YXRlcm5pb24gKSBpbnN0ZWFkLicgKTtcbiAgICBcdFx0cmV0dXJuIHZlY3Rvci5hcHBseVF1YXRlcm5pb24oIHRoaXMgKTtcbiAgICBcdH1cbiAgICB9ICk7XG5cbiAgICBPYmplY3QuYXNzaWduKCBSYXkucHJvdG90eXBlLCB7XG4gICAgXHRpc0ludGVyc2VjdGlvbkJveDogZnVuY3Rpb24gKCBib3ggKSB7XG4gICAgXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlJheTogLmlzSW50ZXJzZWN0aW9uQm94KCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuaW50ZXJzZWN0c0JveCgpLicgKTtcbiAgICBcdFx0cmV0dXJuIHRoaXMuaW50ZXJzZWN0c0JveCggYm94ICk7XG4gICAgXHR9LFxuICAgIFx0aXNJbnRlcnNlY3Rpb25QbGFuZTogZnVuY3Rpb24gKCBwbGFuZSApIHtcbiAgICBcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuUmF5OiAuaXNJbnRlcnNlY3Rpb25QbGFuZSgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmludGVyc2VjdHNQbGFuZSgpLicgKTtcbiAgICBcdFx0cmV0dXJuIHRoaXMuaW50ZXJzZWN0c1BsYW5lKCBwbGFuZSApO1xuICAgIFx0fSxcbiAgICBcdGlzSW50ZXJzZWN0aW9uU3BoZXJlOiBmdW5jdGlvbiAoIHNwaGVyZSApIHtcbiAgICBcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuUmF5OiAuaXNJbnRlcnNlY3Rpb25TcGhlcmUoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5pbnRlcnNlY3RzU3BoZXJlKCkuJyApO1xuICAgIFx0XHRyZXR1cm4gdGhpcy5pbnRlcnNlY3RzU3BoZXJlKCBzcGhlcmUgKTtcbiAgICBcdH1cbiAgICB9ICk7XG5cbiAgICBPYmplY3QuYXNzaWduKCBTaGFwZS5wcm90b3R5cGUsIHtcbiAgICBcdGV4dHJ1ZGU6IGZ1bmN0aW9uICggb3B0aW9ucyApIHtcbiAgICBcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuU2hhcGU6IC5leHRydWRlKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIEV4dHJ1ZGVHZW9tZXRyeSgpIGluc3RlYWQuJyApO1xuICAgIFx0XHRyZXR1cm4gbmV3IEV4dHJ1ZGVHZW9tZXRyeSggdGhpcywgb3B0aW9ucyApO1xuICAgIFx0fSxcbiAgICBcdG1ha2VHZW9tZXRyeTogZnVuY3Rpb24gKCBvcHRpb25zICkge1xuICAgIFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5TaGFwZTogLm1ha2VHZW9tZXRyeSgpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBTaGFwZUdlb21ldHJ5KCkgaW5zdGVhZC4nICk7XG4gICAgXHRcdHJldHVybiBuZXcgU2hhcGVHZW9tZXRyeSggdGhpcywgb3B0aW9ucyApO1xuICAgIFx0fVxuICAgIH0gKTtcblxuICAgIE9iamVjdC5hc3NpZ24oIFZlY3RvcjMucHJvdG90eXBlLCB7XG4gICAgXHRzZXRFdWxlckZyb21Sb3RhdGlvbk1hdHJpeDogZnVuY3Rpb24gKCkge1xuICAgIFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuVmVjdG9yMzogLnNldEV1bGVyRnJvbVJvdGF0aW9uTWF0cml4KCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIEV1bGVyLnNldEZyb21Sb3RhdGlvbk1hdHJpeCgpIGluc3RlYWQuJyApO1xuICAgIFx0fSxcbiAgICBcdHNldEV1bGVyRnJvbVF1YXRlcm5pb246IGZ1bmN0aW9uICgpIHtcbiAgICBcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlZlY3RvcjM6IC5zZXRFdWxlckZyb21RdWF0ZXJuaW9uKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIEV1bGVyLnNldEZyb21RdWF0ZXJuaW9uKCkgaW5zdGVhZC4nICk7XG4gICAgXHR9LFxuICAgIFx0Z2V0UG9zaXRpb25Gcm9tTWF0cml4OiBmdW5jdGlvbiAoIG0gKSB7XG4gICAgXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjM6IC5nZXRQb3NpdGlvbkZyb21NYXRyaXgoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5zZXRGcm9tTWF0cml4UG9zaXRpb24oKS4nICk7XG4gICAgXHRcdHJldHVybiB0aGlzLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbSApO1xuICAgIFx0fSxcbiAgICBcdGdldFNjYWxlRnJvbU1hdHJpeDogZnVuY3Rpb24gKCBtICkge1xuICAgIFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IzOiAuZ2V0U2NhbGVGcm9tTWF0cml4KCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuc2V0RnJvbU1hdHJpeFNjYWxlKCkuJyApO1xuICAgIFx0XHRyZXR1cm4gdGhpcy5zZXRGcm9tTWF0cml4U2NhbGUoIG0gKTtcbiAgICBcdH0sXG4gICAgXHRnZXRDb2x1bW5Gcm9tTWF0cml4OiBmdW5jdGlvbiAoIGluZGV4LCBtYXRyaXggKSB7XG4gICAgXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjM6IC5nZXRDb2x1bW5Gcm9tTWF0cml4KCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuc2V0RnJvbU1hdHJpeENvbHVtbigpLicgKTtcbiAgICBcdFx0cmV0dXJuIHRoaXMuc2V0RnJvbU1hdHJpeENvbHVtbiggbWF0cml4LCBpbmRleCApO1xuICAgIFx0fVxuICAgIH0gKTtcblxuICAgIC8vXG5cbiAgICBPYmplY3QuYXNzaWduKCBPYmplY3QzRC5wcm90b3R5cGUsIHtcbiAgICBcdGdldENoaWxkQnlOYW1lOiBmdW5jdGlvbiAoIG5hbWUgKSB7XG4gICAgXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdDNEOiAuZ2V0Q2hpbGRCeU5hbWUoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5nZXRPYmplY3RCeU5hbWUoKS4nICk7XG4gICAgXHRcdHJldHVybiB0aGlzLmdldE9iamVjdEJ5TmFtZSggbmFtZSApO1xuICAgIFx0fSxcbiAgICBcdHJlbmRlckRlcHRoOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuICAgIFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3QzRDogLnJlbmRlckRlcHRoIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSAucmVuZGVyT3JkZXIsIGluc3RlYWQuJyApO1xuICAgIFx0fSxcbiAgICBcdHRyYW5zbGF0ZTogZnVuY3Rpb24gKCBkaXN0YW5jZSwgYXhpcyApIHtcbiAgICBcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0M0Q6IC50cmFuc2xhdGUoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgLnRyYW5zbGF0ZU9uQXhpcyggYXhpcywgZGlzdGFuY2UgKSBpbnN0ZWFkLicgKTtcbiAgICBcdFx0cmV0dXJuIHRoaXMudHJhbnNsYXRlT25BeGlzKCBheGlzLCBkaXN0YW5jZSApO1xuICAgIFx0fVxuICAgIH0gKTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBPYmplY3QzRC5wcm90b3R5cGUsIHtcbiAgICBcdGV1bGVyT3JkZXI6IHtcbiAgICBcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0M0Q6IC5ldWxlck9yZGVyIGlzIG5vdyAucm90YXRpb24ub3JkZXIuJyApO1xuICAgIFx0XHRcdHJldHVybiB0aGlzLnJvdGF0aW9uLm9yZGVyO1xuICAgIFx0XHR9LFxuICAgIFx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG4gICAgXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0M0Q6IC5ldWxlck9yZGVyIGlzIG5vdyAucm90YXRpb24ub3JkZXIuJyApO1xuICAgIFx0XHRcdHRoaXMucm90YXRpb24ub3JkZXIgPSB2YWx1ZTtcbiAgICBcdFx0fVxuICAgIFx0fSxcbiAgICBcdHVzZVF1YXRlcm5pb246IHtcbiAgICBcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0M0Q6IC51c2VRdWF0ZXJuaW9uIGhhcyBiZWVuIHJlbW92ZWQuIFRoZSBsaWJyYXJ5IG5vdyB1c2VzIHF1YXRlcm5pb25zIGJ5IGRlZmF1bHQuJyApO1xuICAgIFx0XHR9LFxuICAgIFx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG4gICAgXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0M0Q6IC51c2VRdWF0ZXJuaW9uIGhhcyBiZWVuIHJlbW92ZWQuIFRoZSBsaWJyYXJ5IG5vdyB1c2VzIHF1YXRlcm5pb25zIGJ5IGRlZmF1bHQuJyApO1xuICAgIFx0XHR9XG4gICAgXHR9XG4gICAgfSApO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIExPRC5wcm90b3R5cGUsIHtcbiAgICBcdG9iamVjdHM6IHtcbiAgICBcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTE9EOiAub2JqZWN0cyBoYXMgYmVlbiByZW5hbWVkIHRvIC5sZXZlbHMuJyApO1xuICAgIFx0XHRcdHJldHVybiB0aGlzLmxldmVscztcbiAgICBcdFx0fVxuICAgIFx0fVxuICAgIH0gKTtcblxuICAgIC8vXG5cbiAgICBQZXJzcGVjdGl2ZUNhbWVyYS5wcm90b3R5cGUuc2V0TGVucyA9IGZ1bmN0aW9uICggZm9jYWxMZW5ndGgsIGZpbG1HYXVnZSApIHtcblxuICAgIFx0Y29uc29sZS53YXJuKCBcIlRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhLnNldExlbnMgaXMgZGVwcmVjYXRlZC4gXCIgK1xuICAgIFx0XHRcdFwiVXNlIC5zZXRGb2NhbExlbmd0aCBhbmQgLmZpbG1HYXVnZSBmb3IgYSBwaG90b2dyYXBoaWMgc2V0dXAuXCIgKTtcblxuICAgIFx0aWYgKCBmaWxtR2F1Z2UgIT09IHVuZGVmaW5lZCApIHRoaXMuZmlsbUdhdWdlID0gZmlsbUdhdWdlO1xuICAgIFx0dGhpcy5zZXRGb2NhbExlbmd0aCggZm9jYWxMZW5ndGggKTtcblxuICAgIH07XG5cbiAgICAvL1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIExpZ2h0LnByb3RvdHlwZSwge1xuICAgIFx0b25seVNoYWRvdzoge1xuICAgIFx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG4gICAgXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTGlnaHQ6IC5vbmx5U2hhZG93IGhhcyBiZWVuIHJlbW92ZWQuJyApO1xuICAgIFx0XHR9XG4gICAgXHR9LFxuICAgIFx0c2hhZG93Q2FtZXJhRm92OiB7XG4gICAgXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcbiAgICBcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5MaWdodDogLnNoYWRvd0NhbWVyYUZvdiBpcyBub3cgLnNoYWRvdy5jYW1lcmEuZm92LicgKTtcbiAgICBcdFx0XHR0aGlzLnNoYWRvdy5jYW1lcmEuZm92ID0gdmFsdWU7XG4gICAgXHRcdH1cbiAgICBcdH0sXG4gICAgXHRzaGFkb3dDYW1lcmFMZWZ0OiB7XG4gICAgXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcbiAgICBcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5MaWdodDogLnNoYWRvd0NhbWVyYUxlZnQgaXMgbm93IC5zaGFkb3cuY2FtZXJhLmxlZnQuJyApO1xuICAgIFx0XHRcdHRoaXMuc2hhZG93LmNhbWVyYS5sZWZ0ID0gdmFsdWU7XG4gICAgXHRcdH1cbiAgICBcdH0sXG4gICAgXHRzaGFkb3dDYW1lcmFSaWdodDoge1xuICAgIFx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG4gICAgXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTGlnaHQ6IC5zaGFkb3dDYW1lcmFSaWdodCBpcyBub3cgLnNoYWRvdy5jYW1lcmEucmlnaHQuJyApO1xuICAgIFx0XHRcdHRoaXMuc2hhZG93LmNhbWVyYS5yaWdodCA9IHZhbHVlO1xuICAgIFx0XHR9XG4gICAgXHR9LFxuICAgIFx0c2hhZG93Q2FtZXJhVG9wOiB7XG4gICAgXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcbiAgICBcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5MaWdodDogLnNoYWRvd0NhbWVyYVRvcCBpcyBub3cgLnNoYWRvdy5jYW1lcmEudG9wLicgKTtcbiAgICBcdFx0XHR0aGlzLnNoYWRvdy5jYW1lcmEudG9wID0gdmFsdWU7XG4gICAgXHRcdH1cbiAgICBcdH0sXG4gICAgXHRzaGFkb3dDYW1lcmFCb3R0b206IHtcbiAgICBcdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuICAgIFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkxpZ2h0OiAuc2hhZG93Q2FtZXJhQm90dG9tIGlzIG5vdyAuc2hhZG93LmNhbWVyYS5ib3R0b20uJyApO1xuICAgIFx0XHRcdHRoaXMuc2hhZG93LmNhbWVyYS5ib3R0b20gPSB2YWx1ZTtcbiAgICBcdFx0fVxuICAgIFx0fSxcbiAgICBcdHNoYWRvd0NhbWVyYU5lYXI6IHtcbiAgICBcdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuICAgIFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkxpZ2h0OiAuc2hhZG93Q2FtZXJhTmVhciBpcyBub3cgLnNoYWRvdy5jYW1lcmEubmVhci4nICk7XG4gICAgXHRcdFx0dGhpcy5zaGFkb3cuY2FtZXJhLm5lYXIgPSB2YWx1ZTtcbiAgICBcdFx0fVxuICAgIFx0fSxcbiAgICBcdHNoYWRvd0NhbWVyYUZhcjoge1xuICAgIFx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG4gICAgXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTGlnaHQ6IC5zaGFkb3dDYW1lcmFGYXIgaXMgbm93IC5zaGFkb3cuY2FtZXJhLmZhci4nICk7XG4gICAgXHRcdFx0dGhpcy5zaGFkb3cuY2FtZXJhLmZhciA9IHZhbHVlO1xuICAgIFx0XHR9XG4gICAgXHR9LFxuICAgIFx0c2hhZG93Q2FtZXJhVmlzaWJsZToge1xuICAgIFx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG4gICAgXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTGlnaHQ6IC5zaGFkb3dDYW1lcmFWaXNpYmxlIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBuZXcgVEhSRUUuQ2FtZXJhSGVscGVyKCBsaWdodC5zaGFkb3cuY2FtZXJhICkgaW5zdGVhZC4nICk7XG4gICAgXHRcdH1cbiAgICBcdH0sXG4gICAgXHRzaGFkb3dCaWFzOiB7XG4gICAgXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcbiAgICBcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5MaWdodDogLnNoYWRvd0JpYXMgaXMgbm93IC5zaGFkb3cuYmlhcy4nICk7XG4gICAgXHRcdFx0dGhpcy5zaGFkb3cuYmlhcyA9IHZhbHVlO1xuICAgIFx0XHR9XG4gICAgXHR9LFxuICAgIFx0c2hhZG93RGFya25lc3M6IHtcbiAgICBcdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuICAgIFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkxpZ2h0OiAuc2hhZG93RGFya25lc3MgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XG4gICAgXHRcdH1cbiAgICBcdH0sXG4gICAgXHRzaGFkb3dNYXBXaWR0aDoge1xuICAgIFx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG4gICAgXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTGlnaHQ6IC5zaGFkb3dNYXBXaWR0aCBpcyBub3cgLnNoYWRvdy5tYXBTaXplLndpZHRoLicgKTtcbiAgICBcdFx0XHR0aGlzLnNoYWRvdy5tYXBTaXplLndpZHRoID0gdmFsdWU7XG4gICAgXHRcdH1cbiAgICBcdH0sXG4gICAgXHRzaGFkb3dNYXBIZWlnaHQ6IHtcbiAgICBcdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuICAgIFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkxpZ2h0OiAuc2hhZG93TWFwSGVpZ2h0IGlzIG5vdyAuc2hhZG93Lm1hcFNpemUuaGVpZ2h0LicgKTtcbiAgICBcdFx0XHR0aGlzLnNoYWRvdy5tYXBTaXplLmhlaWdodCA9IHZhbHVlO1xuICAgIFx0XHR9XG4gICAgXHR9XG4gICAgfSApO1xuXG4gICAgLy9cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlLCB7XG4gICAgXHRsZW5ndGg6IHtcbiAgICBcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyQXR0cmlidXRlOiAubGVuZ3RoIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgLmNvdW50LicgKTtcbiAgICBcdFx0XHRyZXR1cm4gdGhpcy5hcnJheS5sZW5ndGg7XG4gICAgXHRcdH1cbiAgICBcdH1cbiAgICB9ICk7XG5cbiAgICBPYmplY3QuYXNzaWduKCBCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUsIHtcbiAgICBcdGFkZEluZGV4OiBmdW5jdGlvbiAoIGluZGV4ICkge1xuICAgIFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJHZW9tZXRyeTogLmFkZEluZGV4KCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuc2V0SW5kZXgoKS4nICk7XG4gICAgXHRcdHRoaXMuc2V0SW5kZXgoIGluZGV4ICk7XG4gICAgXHR9LFxuICAgIFx0YWRkRHJhd0NhbGw6IGZ1bmN0aW9uICggc3RhcnQsIGNvdW50LCBpbmRleE9mZnNldCApIHtcbiAgICBcdFx0aWYgKCBpbmRleE9mZnNldCAhPT0gdW5kZWZpbmVkICkge1xuICAgIFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5OiAuYWRkRHJhd0NhbGwoKSBubyBsb25nZXIgc3VwcG9ydHMgaW5kZXhPZmZzZXQuJyApO1xuICAgIFx0XHR9XG4gICAgXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5OiAuYWRkRHJhd0NhbGwoKSBpcyBub3cgLmFkZEdyb3VwKCkuJyApO1xuICAgIFx0XHR0aGlzLmFkZEdyb3VwKCBzdGFydCwgY291bnQgKTtcbiAgICBcdH0sXG4gICAgXHRjbGVhckRyYXdDYWxsczogZnVuY3Rpb24gKCkge1xuICAgIFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJHZW9tZXRyeTogLmNsZWFyRHJhd0NhbGxzKCkgaXMgbm93IC5jbGVhckdyb3VwcygpLicgKTtcbiAgICBcdFx0dGhpcy5jbGVhckdyb3VwcygpO1xuICAgIFx0fSxcbiAgICBcdGNvbXB1dGVUYW5nZW50czogZnVuY3Rpb24gKCkge1xuICAgIFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJHZW9tZXRyeTogLmNvbXB1dGVUYW5nZW50cygpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xuICAgIFx0fSxcbiAgICBcdGNvbXB1dGVPZmZzZXRzOiBmdW5jdGlvbiAoKSB7XG4gICAgXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5OiAuY29tcHV0ZU9mZnNldHMoKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcbiAgICBcdH1cbiAgICB9ICk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyggQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLCB7XG4gICAgXHRkcmF3Y2FsbHM6IHtcbiAgICBcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5OiAuZHJhd2NhbGxzIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmdyb3Vwcy4nICk7XG4gICAgXHRcdFx0cmV0dXJuIHRoaXMuZ3JvdXBzO1xuICAgIFx0XHR9XG4gICAgXHR9LFxuICAgIFx0b2Zmc2V0czoge1xuICAgIFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJHZW9tZXRyeTogLm9mZnNldHMgaGFzIGJlZW4gcmVuYW1lZCB0byAuZ3JvdXBzLicgKTtcbiAgICBcdFx0XHRyZXR1cm4gdGhpcy5ncm91cHM7XG4gICAgXHRcdH1cbiAgICBcdH1cbiAgICB9ICk7XG5cbiAgICAvL1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIE1hdGVyaWFsLnByb3RvdHlwZSwge1xuICAgIFx0d3JhcEFyb3VuZDoge1xuICAgIFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS4nICsgdGhpcy50eXBlICsgJzogLndyYXBBcm91bmQgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XG4gICAgXHRcdH0sXG4gICAgXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcbiAgICBcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS4nICsgdGhpcy50eXBlICsgJzogLndyYXBBcm91bmQgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XG4gICAgXHRcdH1cbiAgICBcdH0sXG4gICAgXHR3cmFwUkdCOiB7XG4gICAgXHRcdGdldDogZnVuY3Rpb24gKCkge1xuICAgIFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLicgKyB0aGlzLnR5cGUgKyAnOiAud3JhcFJHQiBoYXMgYmVlbiByZW1vdmVkLicgKTtcbiAgICBcdFx0XHRyZXR1cm4gbmV3IENvbG9yKCk7XG4gICAgXHRcdH1cbiAgICBcdH1cbiAgICB9ICk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyggTWVzaFBob25nTWF0ZXJpYWwucHJvdG90eXBlLCB7XG4gICAgXHRtZXRhbDoge1xuICAgIFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbDogLm1ldGFsIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBUSFJFRS5NZXNoU3RhbmRhcmRNYXRlcmlhbCBpbnN0ZWFkLicgKTtcbiAgICBcdFx0XHRyZXR1cm4gZmFsc2U7XG4gICAgXHRcdH0sXG4gICAgXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcbiAgICBcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbDogLm1ldGFsIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBUSFJFRS5NZXNoU3RhbmRhcmRNYXRlcmlhbCBpbnN0ZWFkJyApO1xuICAgIFx0XHR9XG4gICAgXHR9XG4gICAgfSApO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFNoYWRlck1hdGVyaWFsLnByb3RvdHlwZSwge1xuICAgIFx0ZGVyaXZhdGl2ZXM6IHtcbiAgICBcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuU2hhZGVyTWF0ZXJpYWw6IC5kZXJpdmF0aXZlcyBoYXMgYmVlbiBtb3ZlZCB0byAuZXh0ZW5zaW9ucy5kZXJpdmF0aXZlcy4nICk7XG4gICAgXHRcdFx0cmV0dXJuIHRoaXMuZXh0ZW5zaW9ucy5kZXJpdmF0aXZlcztcbiAgICBcdFx0fSxcbiAgICBcdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuICAgIFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLiBTaGFkZXJNYXRlcmlhbDogLmRlcml2YXRpdmVzIGhhcyBiZWVuIG1vdmVkIHRvIC5leHRlbnNpb25zLmRlcml2YXRpdmVzLicgKTtcbiAgICBcdFx0XHR0aGlzLmV4dGVuc2lvbnMuZGVyaXZhdGl2ZXMgPSB2YWx1ZTtcbiAgICBcdFx0fVxuICAgIFx0fVxuICAgIH0gKTtcblxuICAgIC8vXG5cbiAgICBFdmVudERpc3BhdGNoZXIucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSgge1xuXG4gICAgXHQvLyBOb3RlOiBFeHRyYSBiYXNlIGVuc3VyZXMgdGhlc2UgcHJvcGVydGllcyBhcmUgbm90ICdhc3NpZ24nZWQuXG5cbiAgICBcdGNvbnN0cnVjdG9yOiBFdmVudERpc3BhdGNoZXIsXG5cbiAgICBcdGFwcGx5OiBmdW5jdGlvbiAoIHRhcmdldCApIHtcblxuICAgIFx0XHRjb25zb2xlLndhcm4oIFwiVEhSRUUuRXZlbnREaXNwYXRjaGVyOiAuYXBwbHkgaXMgZGVwcmVjYXRlZCwgXCIgK1xuICAgIFx0XHRcdFx0XCJqdXN0IGluaGVyaXQgb3IgT2JqZWN0LmFzc2lnbiB0aGUgcHJvdG90eXBlIHRvIG1peC1pbi5cIiApO1xuXG4gICAgXHRcdE9iamVjdC5hc3NpZ24oIHRhcmdldCwgdGhpcyApO1xuXG4gICAgXHR9XG5cbiAgICB9ICksIEV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUgKTtcblxuICAgIC8vXG5cbiAgICBPYmplY3QuYXNzaWduKCBXZWJHTFJlbmRlcmVyLnByb3RvdHlwZSwge1xuICAgIFx0c3VwcG9ydHNGbG9hdFRleHR1cmVzOiBmdW5jdGlvbiAoKSB7XG4gICAgXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zdXBwb3J0c0Zsb2F0VGV4dHVyZXMoKSBpcyBub3cgLmV4dGVuc2lvbnMuZ2V0KCBcXCdPRVNfdGV4dHVyZV9mbG9hdFxcJyApLicgKTtcbiAgICBcdFx0cmV0dXJuIHRoaXMuZXh0ZW5zaW9ucy5nZXQoICdPRVNfdGV4dHVyZV9mbG9hdCcgKTtcbiAgICBcdH0sXG4gICAgXHRzdXBwb3J0c0hhbGZGbG9hdFRleHR1cmVzOiBmdW5jdGlvbiAoKSB7XG4gICAgXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zdXBwb3J0c0hhbGZGbG9hdFRleHR1cmVzKCkgaXMgbm93IC5leHRlbnNpb25zLmdldCggXFwnT0VTX3RleHR1cmVfaGFsZl9mbG9hdFxcJyApLicgKTtcbiAgICBcdFx0cmV0dXJuIHRoaXMuZXh0ZW5zaW9ucy5nZXQoICdPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0JyApO1xuICAgIFx0fSxcbiAgICBcdHN1cHBvcnRzU3RhbmRhcmREZXJpdmF0aXZlczogZnVuY3Rpb24gKCkge1xuICAgIFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc3VwcG9ydHNTdGFuZGFyZERlcml2YXRpdmVzKCkgaXMgbm93IC5leHRlbnNpb25zLmdldCggXFwnT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzXFwnICkuJyApO1xuICAgIFx0XHRyZXR1cm4gdGhpcy5leHRlbnNpb25zLmdldCggJ09FU19zdGFuZGFyZF9kZXJpdmF0aXZlcycgKTtcbiAgICBcdH0sXG4gICAgXHRzdXBwb3J0c0NvbXByZXNzZWRUZXh0dXJlUzNUQzogZnVuY3Rpb24gKCkge1xuICAgIFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc3VwcG9ydHNDb21wcmVzc2VkVGV4dHVyZVMzVEMoKSBpcyBub3cgLmV4dGVuc2lvbnMuZ2V0KCBcXCdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0Y1xcJyApLicgKTtcbiAgICBcdFx0cmV0dXJuIHRoaXMuZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0YycgKTtcbiAgICBcdH0sXG4gICAgXHRzdXBwb3J0c0NvbXByZXNzZWRUZXh0dXJlUFZSVEM6IGZ1bmN0aW9uICgpIHtcbiAgICBcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLnN1cHBvcnRzQ29tcHJlc3NlZFRleHR1cmVQVlJUQygpIGlzIG5vdyAuZXh0ZW5zaW9ucy5nZXQoIFxcJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0Y1xcJyApLicgKTtcbiAgICBcdFx0cmV0dXJuIHRoaXMuZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGMnICk7XG4gICAgXHR9LFxuICAgIFx0c3VwcG9ydHNCbGVuZE1pbk1heDogZnVuY3Rpb24gKCkge1xuICAgIFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc3VwcG9ydHNCbGVuZE1pbk1heCgpIGlzIG5vdyAuZXh0ZW5zaW9ucy5nZXQoIFxcJ0VYVF9ibGVuZF9taW5tYXhcXCcgKS4nICk7XG4gICAgXHRcdHJldHVybiB0aGlzLmV4dGVuc2lvbnMuZ2V0KCAnRVhUX2JsZW5kX21pbm1heCcgKTtcbiAgICBcdH0sXG4gICAgXHRzdXBwb3J0c1ZlcnRleFRleHR1cmVzOiBmdW5jdGlvbiAoKSB7XG4gICAgXHRcdHJldHVybiB0aGlzLmNhcGFiaWxpdGllcy52ZXJ0ZXhUZXh0dXJlcztcbiAgICBcdH0sXG4gICAgXHRzdXBwb3J0c0luc3RhbmNlZEFycmF5czogZnVuY3Rpb24gKCkge1xuICAgIFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc3VwcG9ydHNJbnN0YW5jZWRBcnJheXMoKSBpcyBub3cgLmV4dGVuc2lvbnMuZ2V0KCBcXCdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzXFwnICkuJyApO1xuICAgIFx0XHRyZXR1cm4gdGhpcy5leHRlbnNpb25zLmdldCggJ0FOR0xFX2luc3RhbmNlZF9hcnJheXMnICk7XG4gICAgXHR9LFxuICAgIFx0ZW5hYmxlU2Npc3NvclRlc3Q6IGZ1bmN0aW9uICggYm9vbGVhbiApIHtcbiAgICBcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLmVuYWJsZVNjaXNzb3JUZXN0KCkgaXMgbm93IC5zZXRTY2lzc29yVGVzdCgpLicgKTtcbiAgICBcdFx0dGhpcy5zZXRTY2lzc29yVGVzdCggYm9vbGVhbiApO1xuICAgIFx0fSxcbiAgICBcdGluaXRNYXRlcmlhbDogZnVuY3Rpb24gKCkge1xuICAgIFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuaW5pdE1hdGVyaWFsKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XG4gICAgXHR9LFxuICAgIFx0YWRkUHJlUGx1Z2luOiBmdW5jdGlvbiAoKSB7XG4gICAgXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5hZGRQcmVQbHVnaW4oKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcbiAgICBcdH0sXG4gICAgXHRhZGRQb3N0UGx1Z2luOiBmdW5jdGlvbiAoKSB7XG4gICAgXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5hZGRQb3N0UGx1Z2luKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XG4gICAgXHR9LFxuICAgIFx0dXBkYXRlU2hhZG93TWFwOiBmdW5jdGlvbiAoKSB7XG4gICAgXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC51cGRhdGVTaGFkb3dNYXAoKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcbiAgICBcdH1cbiAgICB9ICk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyggV2ViR0xSZW5kZXJlci5wcm90b3R5cGUsIHtcbiAgICBcdHNoYWRvd01hcEVuYWJsZWQ6IHtcbiAgICBcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgXHRcdFx0cmV0dXJuIHRoaXMuc2hhZG93TWFwLmVuYWJsZWQ7XG4gICAgXHRcdH0sXG4gICAgXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcbiAgICBcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc2hhZG93TWFwRW5hYmxlZCBpcyBub3cgLnNoYWRvd01hcC5lbmFibGVkLicgKTtcbiAgICBcdFx0XHR0aGlzLnNoYWRvd01hcC5lbmFibGVkID0gdmFsdWU7XG4gICAgXHRcdH1cbiAgICBcdH0sXG4gICAgXHRzaGFkb3dNYXBUeXBlOiB7XG4gICAgXHRcdGdldDogZnVuY3Rpb24gKCkge1xuICAgIFx0XHRcdHJldHVybiB0aGlzLnNoYWRvd01hcC50eXBlO1xuICAgIFx0XHR9LFxuICAgIFx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG4gICAgXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLnNoYWRvd01hcFR5cGUgaXMgbm93IC5zaGFkb3dNYXAudHlwZS4nICk7XG4gICAgXHRcdFx0dGhpcy5zaGFkb3dNYXAudHlwZSA9IHZhbHVlO1xuICAgIFx0XHR9XG4gICAgXHR9LFxuICAgIFx0c2hhZG93TWFwQ3VsbEZhY2U6IHtcbiAgICBcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgXHRcdFx0cmV0dXJuIHRoaXMuc2hhZG93TWFwLmN1bGxGYWNlO1xuICAgIFx0XHR9LFxuICAgIFx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG4gICAgXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLnNoYWRvd01hcEN1bGxGYWNlIGlzIG5vdyAuc2hhZG93TWFwLmN1bGxGYWNlLicgKTtcbiAgICBcdFx0XHR0aGlzLnNoYWRvd01hcC5jdWxsRmFjZSA9IHZhbHVlO1xuICAgIFx0XHR9XG4gICAgXHR9XG4gICAgfSApO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFdlYkdMU2hhZG93TWFwLnByb3RvdHlwZSwge1xuICAgIFx0Y3VsbEZhY2U6IHtcbiAgICBcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgXHRcdFx0cmV0dXJuIHRoaXMucmVuZGVyUmV2ZXJzZVNpZGVkID8gQ3VsbEZhY2VGcm9udCA6IEN1bGxGYWNlQmFjaztcbiAgICBcdFx0fSxcbiAgICBcdFx0c2V0OiBmdW5jdGlvbiAoIGN1bGxGYWNlICkge1xuICAgIFx0XHRcdHZhciB2YWx1ZSA9ICggY3VsbEZhY2UgIT09IEN1bGxGYWNlQmFjayApO1xuICAgIFx0XHRcdGNvbnNvbGUud2FybiggXCJXZWJHTFJlbmRlcmVyOiAuc2hhZG93TWFwLmN1bGxGYWNlIGlzIGRlcHJlY2F0ZWQuIFNldCAuc2hhZG93TWFwLnJlbmRlclJldmVyc2VTaWRlZCB0byBcIiArIHZhbHVlICsgXCIuXCIgKTtcbiAgICBcdFx0XHR0aGlzLnJlbmRlclJldmVyc2VTaWRlZCA9IHZhbHVlO1xuICAgIFx0XHR9XG4gICAgXHR9XG4gICAgfSApO1xuXG4gICAgLy9cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBXZWJHTFJlbmRlclRhcmdldC5wcm90b3R5cGUsIHtcbiAgICBcdHdyYXBTOiB7XG4gICAgXHRcdGdldDogZnVuY3Rpb24gKCkge1xuICAgIFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAud3JhcFMgaXMgbm93IC50ZXh0dXJlLndyYXBTLicgKTtcbiAgICBcdFx0XHRyZXR1cm4gdGhpcy50ZXh0dXJlLndyYXBTO1xuICAgIFx0XHR9LFxuICAgIFx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG4gICAgXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC53cmFwUyBpcyBub3cgLnRleHR1cmUud3JhcFMuJyApO1xuICAgIFx0XHRcdHRoaXMudGV4dHVyZS53cmFwUyA9IHZhbHVlO1xuICAgIFx0XHR9XG4gICAgXHR9LFxuICAgIFx0d3JhcFQ6IHtcbiAgICBcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC53cmFwVCBpcyBub3cgLnRleHR1cmUud3JhcFQuJyApO1xuICAgIFx0XHRcdHJldHVybiB0aGlzLnRleHR1cmUud3JhcFQ7XG4gICAgXHRcdH0sXG4gICAgXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcbiAgICBcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLndyYXBUIGlzIG5vdyAudGV4dHVyZS53cmFwVC4nICk7XG4gICAgXHRcdFx0dGhpcy50ZXh0dXJlLndyYXBUID0gdmFsdWU7XG4gICAgXHRcdH1cbiAgICBcdH0sXG4gICAgXHRtYWdGaWx0ZXI6IHtcbiAgICBcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5tYWdGaWx0ZXIgaXMgbm93IC50ZXh0dXJlLm1hZ0ZpbHRlci4nICk7XG4gICAgXHRcdFx0cmV0dXJuIHRoaXMudGV4dHVyZS5tYWdGaWx0ZXI7XG4gICAgXHRcdH0sXG4gICAgXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcbiAgICBcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLm1hZ0ZpbHRlciBpcyBub3cgLnRleHR1cmUubWFnRmlsdGVyLicgKTtcbiAgICBcdFx0XHR0aGlzLnRleHR1cmUubWFnRmlsdGVyID0gdmFsdWU7XG4gICAgXHRcdH1cbiAgICBcdH0sXG4gICAgXHRtaW5GaWx0ZXI6IHtcbiAgICBcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5taW5GaWx0ZXIgaXMgbm93IC50ZXh0dXJlLm1pbkZpbHRlci4nICk7XG4gICAgXHRcdFx0cmV0dXJuIHRoaXMudGV4dHVyZS5taW5GaWx0ZXI7XG4gICAgXHRcdH0sXG4gICAgXHRcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcbiAgICBcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLm1pbkZpbHRlciBpcyBub3cgLnRleHR1cmUubWluRmlsdGVyLicgKTtcbiAgICBcdFx0XHR0aGlzLnRleHR1cmUubWluRmlsdGVyID0gdmFsdWU7XG4gICAgXHRcdH1cbiAgICBcdH0sXG4gICAgXHRhbmlzb3Ryb3B5OiB7XG4gICAgXHRcdGdldDogZnVuY3Rpb24gKCkge1xuICAgIFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAuYW5pc290cm9weSBpcyBub3cgLnRleHR1cmUuYW5pc290cm9weS4nICk7XG4gICAgXHRcdFx0cmV0dXJuIHRoaXMudGV4dHVyZS5hbmlzb3Ryb3B5O1xuICAgIFx0XHR9LFxuICAgIFx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG4gICAgXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5hbmlzb3Ryb3B5IGlzIG5vdyAudGV4dHVyZS5hbmlzb3Ryb3B5LicgKTtcbiAgICBcdFx0XHR0aGlzLnRleHR1cmUuYW5pc290cm9weSA9IHZhbHVlO1xuICAgIFx0XHR9XG4gICAgXHR9LFxuICAgIFx0b2Zmc2V0OiB7XG4gICAgXHRcdGdldDogZnVuY3Rpb24gKCkge1xuICAgIFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAub2Zmc2V0IGlzIG5vdyAudGV4dHVyZS5vZmZzZXQuJyApO1xuICAgIFx0XHRcdHJldHVybiB0aGlzLnRleHR1cmUub2Zmc2V0O1xuICAgIFx0XHR9LFxuICAgIFx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG4gICAgXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5vZmZzZXQgaXMgbm93IC50ZXh0dXJlLm9mZnNldC4nICk7XG4gICAgXHRcdFx0dGhpcy50ZXh0dXJlLm9mZnNldCA9IHZhbHVlO1xuICAgIFx0XHR9XG4gICAgXHR9LFxuICAgIFx0cmVwZWF0OiB7XG4gICAgXHRcdGdldDogZnVuY3Rpb24gKCkge1xuICAgIFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAucmVwZWF0IGlzIG5vdyAudGV4dHVyZS5yZXBlYXQuJyApO1xuICAgIFx0XHRcdHJldHVybiB0aGlzLnRleHR1cmUucmVwZWF0O1xuICAgIFx0XHR9LFxuICAgIFx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG4gICAgXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5yZXBlYXQgaXMgbm93IC50ZXh0dXJlLnJlcGVhdC4nICk7XG4gICAgXHRcdFx0dGhpcy50ZXh0dXJlLnJlcGVhdCA9IHZhbHVlO1xuICAgIFx0XHR9XG4gICAgXHR9LFxuICAgIFx0Zm9ybWF0OiB7XG4gICAgXHRcdGdldDogZnVuY3Rpb24gKCkge1xuICAgIFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAuZm9ybWF0IGlzIG5vdyAudGV4dHVyZS5mb3JtYXQuJyApO1xuICAgIFx0XHRcdHJldHVybiB0aGlzLnRleHR1cmUuZm9ybWF0O1xuICAgIFx0XHR9LFxuICAgIFx0XHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG4gICAgXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5mb3JtYXQgaXMgbm93IC50ZXh0dXJlLmZvcm1hdC4nICk7XG4gICAgXHRcdFx0dGhpcy50ZXh0dXJlLmZvcm1hdCA9IHZhbHVlO1xuICAgIFx0XHR9XG4gICAgXHR9LFxuICAgIFx0dHlwZToge1xuICAgIFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLnR5cGUgaXMgbm93IC50ZXh0dXJlLnR5cGUuJyApO1xuICAgIFx0XHRcdHJldHVybiB0aGlzLnRleHR1cmUudHlwZTtcbiAgICBcdFx0fSxcbiAgICBcdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuICAgIFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAudHlwZSBpcyBub3cgLnRleHR1cmUudHlwZS4nICk7XG4gICAgXHRcdFx0dGhpcy50ZXh0dXJlLnR5cGUgPSB2YWx1ZTtcbiAgICBcdFx0fVxuICAgIFx0fSxcbiAgICBcdGdlbmVyYXRlTWlwbWFwczoge1xuICAgIFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBcdFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLmdlbmVyYXRlTWlwbWFwcyBpcyBub3cgLnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzLicgKTtcbiAgICBcdFx0XHRyZXR1cm4gdGhpcy50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcztcbiAgICBcdFx0fSxcbiAgICBcdFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuICAgIFx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAuZ2VuZXJhdGVNaXBtYXBzIGlzIG5vdyAudGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMuJyApO1xuICAgIFx0XHRcdHRoaXMudGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSB2YWx1ZTtcbiAgICBcdFx0fVxuICAgIFx0fVxuICAgIH0gKTtcblxuICAgIC8vXG5cbiAgICBPYmplY3QuYXNzaWduKCBBdWRpby5wcm90b3R5cGUsIHtcbiAgICBcdGxvYWQ6IGZ1bmN0aW9uICggZmlsZSApIHtcbiAgICBcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQXVkaW86IC5sb2FkIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgVEhSRUUuQXVkaW9Mb2FkZXIuJyApO1xuICAgIFx0XHR2YXIgc2NvcGUgPSB0aGlzO1xuICAgIFx0XHR2YXIgYXVkaW9Mb2FkZXIgPSBuZXcgQXVkaW9Mb2FkZXIoKTtcbiAgICBcdFx0YXVkaW9Mb2FkZXIubG9hZCggZmlsZSwgZnVuY3Rpb24gKCBidWZmZXIgKSB7XG4gICAgXHRcdFx0c2NvcGUuc2V0QnVmZmVyKCBidWZmZXIgKTtcbiAgICBcdFx0fSApO1xuICAgIFx0XHRyZXR1cm4gdGhpcztcbiAgICBcdH1cbiAgICB9ICk7XG5cbiAgICBPYmplY3QuYXNzaWduKCBBdWRpb0FuYWx5c2VyLnByb3RvdHlwZSwge1xuICAgIFx0Z2V0RGF0YTogZnVuY3Rpb24gKCBmaWxlICkge1xuICAgIFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5BdWRpb0FuYWx5c2VyOiAuZ2V0RGF0YSgpIGlzIG5vdyAuZ2V0RnJlcXVlbmN5RGF0YSgpLicgKTtcbiAgICBcdFx0cmV0dXJuIHRoaXMuZ2V0RnJlcXVlbmN5RGF0YSgpO1xuICAgIFx0fVxuICAgIH0gKTtcblxuICAgIC8vXG5cbiAgICB2YXIgR2VvbWV0cnlVdGlscyA9IHtcblxuICAgIFx0bWVyZ2U6IGZ1bmN0aW9uICggZ2VvbWV0cnkxLCBnZW9tZXRyeTIsIG1hdGVyaWFsSW5kZXhPZmZzZXQgKSB7XG5cbiAgICBcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuR2VvbWV0cnlVdGlsczogLm1lcmdlKCkgaGFzIGJlZW4gbW92ZWQgdG8gR2VvbWV0cnkuIFVzZSBnZW9tZXRyeS5tZXJnZSggZ2VvbWV0cnkyLCBtYXRyaXgsIG1hdGVyaWFsSW5kZXhPZmZzZXQgKSBpbnN0ZWFkLicgKTtcblxuICAgIFx0XHR2YXIgbWF0cml4O1xuXG4gICAgXHRcdGlmICggZ2VvbWV0cnkyLmlzTWVzaCApIHtcblxuICAgIFx0XHRcdGdlb21ldHJ5Mi5tYXRyaXhBdXRvVXBkYXRlICYmIGdlb21ldHJ5Mi51cGRhdGVNYXRyaXgoKTtcblxuICAgIFx0XHRcdG1hdHJpeCA9IGdlb21ldHJ5Mi5tYXRyaXg7XG4gICAgXHRcdFx0Z2VvbWV0cnkyID0gZ2VvbWV0cnkyLmdlb21ldHJ5O1xuXG4gICAgXHRcdH1cblxuICAgIFx0XHRnZW9tZXRyeTEubWVyZ2UoIGdlb21ldHJ5MiwgbWF0cml4LCBtYXRlcmlhbEluZGV4T2Zmc2V0ICk7XG5cbiAgICBcdH0sXG5cbiAgICBcdGNlbnRlcjogZnVuY3Rpb24gKCBnZW9tZXRyeSApIHtcblxuICAgIFx0XHRjb25zb2xlLndhcm4oICdUSFJFRS5HZW9tZXRyeVV0aWxzOiAuY2VudGVyKCkgaGFzIGJlZW4gbW92ZWQgdG8gR2VvbWV0cnkuIFVzZSBnZW9tZXRyeS5jZW50ZXIoKSBpbnN0ZWFkLicgKTtcbiAgICBcdFx0cmV0dXJuIGdlb21ldHJ5LmNlbnRlcigpO1xuXG4gICAgXHR9XG5cbiAgICB9O1xuXG4gICAgdmFyIEltYWdlVXRpbHMgPSB7XG5cbiAgICBcdGNyb3NzT3JpZ2luOiB1bmRlZmluZWQsXG5cbiAgICBcdGxvYWRUZXh0dXJlOiBmdW5jdGlvbiAoIHVybCwgbWFwcGluZywgb25Mb2FkLCBvbkVycm9yICkge1xuXG4gICAgXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLkltYWdlVXRpbHMubG9hZFRleHR1cmUgaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIFRIUkVFLlRleHR1cmVMb2FkZXIoKSBpbnN0ZWFkLicgKTtcblxuICAgIFx0XHR2YXIgbG9hZGVyID0gbmV3IFRleHR1cmVMb2FkZXIoKTtcbiAgICBcdFx0bG9hZGVyLnNldENyb3NzT3JpZ2luKCB0aGlzLmNyb3NzT3JpZ2luICk7XG5cbiAgICBcdFx0dmFyIHRleHR1cmUgPSBsb2FkZXIubG9hZCggdXJsLCBvbkxvYWQsIHVuZGVmaW5lZCwgb25FcnJvciApO1xuXG4gICAgXHRcdGlmICggbWFwcGluZyApIHRleHR1cmUubWFwcGluZyA9IG1hcHBpbmc7XG5cbiAgICBcdFx0cmV0dXJuIHRleHR1cmU7XG5cbiAgICBcdH0sXG5cbiAgICBcdGxvYWRUZXh0dXJlQ3ViZTogZnVuY3Rpb24gKCB1cmxzLCBtYXBwaW5nLCBvbkxvYWQsIG9uRXJyb3IgKSB7XG5cbiAgICBcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuSW1hZ2VVdGlscy5sb2FkVGV4dHVyZUN1YmUgaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIFRIUkVFLkN1YmVUZXh0dXJlTG9hZGVyKCkgaW5zdGVhZC4nICk7XG5cbiAgICBcdFx0dmFyIGxvYWRlciA9IG5ldyBDdWJlVGV4dHVyZUxvYWRlcigpO1xuICAgIFx0XHRsb2FkZXIuc2V0Q3Jvc3NPcmlnaW4oIHRoaXMuY3Jvc3NPcmlnaW4gKTtcblxuICAgIFx0XHR2YXIgdGV4dHVyZSA9IGxvYWRlci5sb2FkKCB1cmxzLCBvbkxvYWQsIHVuZGVmaW5lZCwgb25FcnJvciApO1xuXG4gICAgXHRcdGlmICggbWFwcGluZyApIHRleHR1cmUubWFwcGluZyA9IG1hcHBpbmc7XG5cbiAgICBcdFx0cmV0dXJuIHRleHR1cmU7XG5cbiAgICBcdH0sXG5cbiAgICBcdGxvYWRDb21wcmVzc2VkVGV4dHVyZTogZnVuY3Rpb24gKCkge1xuXG4gICAgXHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5JbWFnZVV0aWxzLmxvYWRDb21wcmVzc2VkVGV4dHVyZSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgVEhSRUUuRERTTG9hZGVyIGluc3RlYWQuJyApO1xuXG4gICAgXHR9LFxuXG4gICAgXHRsb2FkQ29tcHJlc3NlZFRleHR1cmVDdWJlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkltYWdlVXRpbHMubG9hZENvbXByZXNzZWRUZXh0dXJlQ3ViZSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgVEhSRUUuRERTTG9hZGVyIGluc3RlYWQuJyApO1xuXG4gICAgXHR9XG5cbiAgICB9O1xuXG4gICAgLy9cblxuICAgIGZ1bmN0aW9uIFByb2plY3RvciAoKSB7XG5cbiAgICBcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5Qcm9qZWN0b3IgaGFzIGJlZW4gbW92ZWQgdG8gL2V4YW1wbGVzL2pzL3JlbmRlcmVycy9Qcm9qZWN0b3IuanMuJyApO1xuXG4gICAgXHR0aGlzLnByb2plY3RWZWN0b3IgPSBmdW5jdGlvbiAoIHZlY3RvciwgY2FtZXJhICkge1xuXG4gICAgXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlByb2plY3RvcjogLnByb2plY3RWZWN0b3IoKSBpcyBub3cgdmVjdG9yLnByb2plY3QoKS4nICk7XG4gICAgXHRcdHZlY3Rvci5wcm9qZWN0KCBjYW1lcmEgKTtcblxuICAgIFx0fTtcblxuICAgIFx0dGhpcy51bnByb2plY3RWZWN0b3IgPSBmdW5jdGlvbiAoIHZlY3RvciwgY2FtZXJhICkge1xuXG4gICAgXHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLlByb2plY3RvcjogLnVucHJvamVjdFZlY3RvcigpIGlzIG5vdyB2ZWN0b3IudW5wcm9qZWN0KCkuJyApO1xuICAgIFx0XHR2ZWN0b3IudW5wcm9qZWN0KCBjYW1lcmEgKTtcblxuICAgIFx0fTtcblxuICAgIFx0dGhpcy5waWNraW5nUmF5ID0gZnVuY3Rpb24gKCB2ZWN0b3IsIGNhbWVyYSApIHtcblxuICAgIFx0XHRjb25zb2xlLmVycm9yKCAnVEhSRUUuUHJvamVjdG9yOiAucGlja2luZ1JheSgpIGlzIG5vdyByYXljYXN0ZXIuc2V0RnJvbUNhbWVyYSgpLicgKTtcblxuICAgIFx0fTtcblxuICAgIH1cblxuICAgIC8vXG5cbiAgICBmdW5jdGlvbiBDYW52YXNSZW5kZXJlciAoKSB7XG5cbiAgICBcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5DYW52YXNSZW5kZXJlciBoYXMgYmVlbiBtb3ZlZCB0byAvZXhhbXBsZXMvanMvcmVuZGVyZXJzL0NhbnZhc1JlbmRlcmVyLmpzJyApO1xuXG4gICAgXHR0aGlzLmRvbUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJywgJ2NhbnZhcycgKTtcbiAgICBcdHRoaXMuY2xlYXIgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICBcdHRoaXMucmVuZGVyID0gZnVuY3Rpb24gKCkge307XG4gICAgXHR0aGlzLnNldENsZWFyQ29sb3IgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICBcdHRoaXMuc2V0U2l6ZSA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgfVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCBleHBvcnRzLCAnQXVkaW9Db250ZXh0Jywge1xuICAgIFx0Z2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgXHRcdHJldHVybiBleHBvcnRzLmdldEF1ZGlvQ29udGV4dCgpO1xuICAgIFx0fVxuICAgIH0pO1xuXG4gICAgZXhwb3J0cy5XZWJHTFJlbmRlclRhcmdldEN1YmUgPSBXZWJHTFJlbmRlclRhcmdldEN1YmU7XG4gICAgZXhwb3J0cy5XZWJHTFJlbmRlclRhcmdldCA9IFdlYkdMUmVuZGVyVGFyZ2V0O1xuICAgIGV4cG9ydHMuV2ViR0xSZW5kZXJlciA9IFdlYkdMUmVuZGVyZXI7XG4gICAgZXhwb3J0cy5TaGFkZXJMaWIgPSBTaGFkZXJMaWI7XG4gICAgZXhwb3J0cy5Vbmlmb3Jtc0xpYiA9IFVuaWZvcm1zTGliO1xuICAgIGV4cG9ydHMuU2hhZGVyQ2h1bmsgPSBTaGFkZXJDaHVuaztcbiAgICBleHBvcnRzLkZvZ0V4cDIgPSBGb2dFeHAyO1xuICAgIGV4cG9ydHMuRm9nID0gRm9nO1xuICAgIGV4cG9ydHMuU2NlbmUgPSBTY2VuZTtcbiAgICBleHBvcnRzLkxlbnNGbGFyZSA9IExlbnNGbGFyZTtcbiAgICBleHBvcnRzLlNwcml0ZSA9IFNwcml0ZTtcbiAgICBleHBvcnRzLkxPRCA9IExPRDtcbiAgICBleHBvcnRzLlNraW5uZWRNZXNoID0gU2tpbm5lZE1lc2g7XG4gICAgZXhwb3J0cy5Ta2VsZXRvbiA9IFNrZWxldG9uO1xuICAgIGV4cG9ydHMuQm9uZSA9IEJvbmU7XG4gICAgZXhwb3J0cy5NZXNoID0gTWVzaDtcbiAgICBleHBvcnRzLkxpbmVTZWdtZW50cyA9IExpbmVTZWdtZW50cztcbiAgICBleHBvcnRzLkxpbmUgPSBMaW5lO1xuICAgIGV4cG9ydHMuUG9pbnRzID0gUG9pbnRzO1xuICAgIGV4cG9ydHMuR3JvdXAgPSBHcm91cDtcbiAgICBleHBvcnRzLlZpZGVvVGV4dHVyZSA9IFZpZGVvVGV4dHVyZTtcbiAgICBleHBvcnRzLkRhdGFUZXh0dXJlID0gRGF0YVRleHR1cmU7XG4gICAgZXhwb3J0cy5Db21wcmVzc2VkVGV4dHVyZSA9IENvbXByZXNzZWRUZXh0dXJlO1xuICAgIGV4cG9ydHMuQ3ViZVRleHR1cmUgPSBDdWJlVGV4dHVyZTtcbiAgICBleHBvcnRzLkNhbnZhc1RleHR1cmUgPSBDYW52YXNUZXh0dXJlO1xuICAgIGV4cG9ydHMuRGVwdGhUZXh0dXJlID0gRGVwdGhUZXh0dXJlO1xuICAgIGV4cG9ydHMuVGV4dHVyZUlkQ291bnQgPSBUZXh0dXJlSWRDb3VudDtcbiAgICBleHBvcnRzLlRleHR1cmUgPSBUZXh0dXJlO1xuICAgIGV4cG9ydHMuTWF0ZXJpYWxJZENvdW50ID0gTWF0ZXJpYWxJZENvdW50O1xuICAgIGV4cG9ydHMuQ29tcHJlc3NlZFRleHR1cmVMb2FkZXIgPSBDb21wcmVzc2VkVGV4dHVyZUxvYWRlcjtcbiAgICBleHBvcnRzLkJpbmFyeVRleHR1cmVMb2FkZXIgPSBCaW5hcnlUZXh0dXJlTG9hZGVyO1xuICAgIGV4cG9ydHMuRGF0YVRleHR1cmVMb2FkZXIgPSBEYXRhVGV4dHVyZUxvYWRlcjtcbiAgICBleHBvcnRzLkN1YmVUZXh0dXJlTG9hZGVyID0gQ3ViZVRleHR1cmVMb2FkZXI7XG4gICAgZXhwb3J0cy5UZXh0dXJlTG9hZGVyID0gVGV4dHVyZUxvYWRlcjtcbiAgICBleHBvcnRzLk9iamVjdExvYWRlciA9IE9iamVjdExvYWRlcjtcbiAgICBleHBvcnRzLk1hdGVyaWFsTG9hZGVyID0gTWF0ZXJpYWxMb2FkZXI7XG4gICAgZXhwb3J0cy5CdWZmZXJHZW9tZXRyeUxvYWRlciA9IEJ1ZmZlckdlb21ldHJ5TG9hZGVyO1xuICAgIGV4cG9ydHMuTG9hZGluZ01hbmFnZXIgPSBMb2FkaW5nTWFuYWdlcjtcbiAgICBleHBvcnRzLkpTT05Mb2FkZXIgPSBKU09OTG9hZGVyO1xuICAgIGV4cG9ydHMuSW1hZ2VMb2FkZXIgPSBJbWFnZUxvYWRlcjtcbiAgICBleHBvcnRzLkZvbnRMb2FkZXIgPSBGb250TG9hZGVyO1xuICAgIGV4cG9ydHMuWEhSTG9hZGVyID0gWEhSTG9hZGVyO1xuICAgIGV4cG9ydHMuTG9hZGVyID0gTG9hZGVyO1xuICAgIGV4cG9ydHMuQXVkaW9Mb2FkZXIgPSBBdWRpb0xvYWRlcjtcbiAgICBleHBvcnRzLlNwb3RMaWdodFNoYWRvdyA9IFNwb3RMaWdodFNoYWRvdztcbiAgICBleHBvcnRzLlNwb3RMaWdodCA9IFNwb3RMaWdodDtcbiAgICBleHBvcnRzLlBvaW50TGlnaHQgPSBQb2ludExpZ2h0O1xuICAgIGV4cG9ydHMuSGVtaXNwaGVyZUxpZ2h0ID0gSGVtaXNwaGVyZUxpZ2h0O1xuICAgIGV4cG9ydHMuRGlyZWN0aW9uYWxMaWdodFNoYWRvdyA9IERpcmVjdGlvbmFsTGlnaHRTaGFkb3c7XG4gICAgZXhwb3J0cy5EaXJlY3Rpb25hbExpZ2h0ID0gRGlyZWN0aW9uYWxMaWdodDtcbiAgICBleHBvcnRzLkFtYmllbnRMaWdodCA9IEFtYmllbnRMaWdodDtcbiAgICBleHBvcnRzLkxpZ2h0U2hhZG93ID0gTGlnaHRTaGFkb3c7XG4gICAgZXhwb3J0cy5MaWdodCA9IExpZ2h0O1xuICAgIGV4cG9ydHMuU3RlcmVvQ2FtZXJhID0gU3RlcmVvQ2FtZXJhO1xuICAgIGV4cG9ydHMuUGVyc3BlY3RpdmVDYW1lcmEgPSBQZXJzcGVjdGl2ZUNhbWVyYTtcbiAgICBleHBvcnRzLk9ydGhvZ3JhcGhpY0NhbWVyYSA9IE9ydGhvZ3JhcGhpY0NhbWVyYTtcbiAgICBleHBvcnRzLkN1YmVDYW1lcmEgPSBDdWJlQ2FtZXJhO1xuICAgIGV4cG9ydHMuQ2FtZXJhID0gQ2FtZXJhO1xuICAgIGV4cG9ydHMuQXVkaW9MaXN0ZW5lciA9IEF1ZGlvTGlzdGVuZXI7XG4gICAgZXhwb3J0cy5Qb3NpdGlvbmFsQXVkaW8gPSBQb3NpdGlvbmFsQXVkaW87XG4gICAgZXhwb3J0cy5nZXRBdWRpb0NvbnRleHQgPSBnZXRBdWRpb0NvbnRleHQ7XG4gICAgZXhwb3J0cy5BdWRpb0FuYWx5c2VyID0gQXVkaW9BbmFseXNlcjtcbiAgICBleHBvcnRzLkF1ZGlvID0gQXVkaW87XG4gICAgZXhwb3J0cy5WZWN0b3JLZXlmcmFtZVRyYWNrID0gVmVjdG9yS2V5ZnJhbWVUcmFjaztcbiAgICBleHBvcnRzLlN0cmluZ0tleWZyYW1lVHJhY2sgPSBTdHJpbmdLZXlmcmFtZVRyYWNrO1xuICAgIGV4cG9ydHMuUXVhdGVybmlvbktleWZyYW1lVHJhY2sgPSBRdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjaztcbiAgICBleHBvcnRzLk51bWJlcktleWZyYW1lVHJhY2sgPSBOdW1iZXJLZXlmcmFtZVRyYWNrO1xuICAgIGV4cG9ydHMuQ29sb3JLZXlmcmFtZVRyYWNrID0gQ29sb3JLZXlmcmFtZVRyYWNrO1xuICAgIGV4cG9ydHMuQm9vbGVhbktleWZyYW1lVHJhY2sgPSBCb29sZWFuS2V5ZnJhbWVUcmFjaztcbiAgICBleHBvcnRzLlByb3BlcnR5TWl4ZXIgPSBQcm9wZXJ0eU1peGVyO1xuICAgIGV4cG9ydHMuUHJvcGVydHlCaW5kaW5nID0gUHJvcGVydHlCaW5kaW5nO1xuICAgIGV4cG9ydHMuS2V5ZnJhbWVUcmFjayA9IEtleWZyYW1lVHJhY2s7XG4gICAgZXhwb3J0cy5BbmltYXRpb25PYmplY3RHcm91cCA9IEFuaW1hdGlvbk9iamVjdEdyb3VwO1xuICAgIGV4cG9ydHMuQW5pbWF0aW9uTWl4ZXIgPSBBbmltYXRpb25NaXhlcjtcbiAgICBleHBvcnRzLkFuaW1hdGlvbkNsaXAgPSBBbmltYXRpb25DbGlwO1xuICAgIGV4cG9ydHMuVW5pZm9ybSA9IFVuaWZvcm07XG4gICAgZXhwb3J0cy5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSA9IEluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5O1xuICAgIGV4cG9ydHMuQnVmZmVyR2VvbWV0cnkgPSBCdWZmZXJHZW9tZXRyeTtcbiAgICBleHBvcnRzLkdlb21ldHJ5SWRDb3VudCA9IEdlb21ldHJ5SWRDb3VudDtcbiAgICBleHBvcnRzLkdlb21ldHJ5ID0gR2VvbWV0cnk7XG4gICAgZXhwb3J0cy5JbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSA9IEludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlO1xuICAgIGV4cG9ydHMuSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXIgPSBJbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlcjtcbiAgICBleHBvcnRzLkludGVybGVhdmVkQnVmZmVyID0gSW50ZXJsZWF2ZWRCdWZmZXI7XG4gICAgZXhwb3J0cy5JbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUgPSBJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGU7XG4gICAgZXhwb3J0cy5EeW5hbWljQnVmZmVyQXR0cmlidXRlID0gRHluYW1pY0J1ZmZlckF0dHJpYnV0ZTtcbiAgICBleHBvcnRzLkZsb2F0NjRBdHRyaWJ1dGUgPSBGbG9hdDY0QXR0cmlidXRlO1xuICAgIGV4cG9ydHMuRmxvYXQzMkF0dHJpYnV0ZSA9IEZsb2F0MzJBdHRyaWJ1dGU7XG4gICAgZXhwb3J0cy5VaW50MzJBdHRyaWJ1dGUgPSBVaW50MzJBdHRyaWJ1dGU7XG4gICAgZXhwb3J0cy5JbnQzMkF0dHJpYnV0ZSA9IEludDMyQXR0cmlidXRlO1xuICAgIGV4cG9ydHMuVWludDE2QXR0cmlidXRlID0gVWludDE2QXR0cmlidXRlO1xuICAgIGV4cG9ydHMuSW50MTZBdHRyaWJ1dGUgPSBJbnQxNkF0dHJpYnV0ZTtcbiAgICBleHBvcnRzLlVpbnQ4Q2xhbXBlZEF0dHJpYnV0ZSA9IFVpbnQ4Q2xhbXBlZEF0dHJpYnV0ZTtcbiAgICBleHBvcnRzLlVpbnQ4QXR0cmlidXRlID0gVWludDhBdHRyaWJ1dGU7XG4gICAgZXhwb3J0cy5JbnQ4QXR0cmlidXRlID0gSW50OEF0dHJpYnV0ZTtcbiAgICBleHBvcnRzLkJ1ZmZlckF0dHJpYnV0ZSA9IEJ1ZmZlckF0dHJpYnV0ZTtcbiAgICBleHBvcnRzLkZhY2UzID0gRmFjZTM7XG4gICAgZXhwb3J0cy5PYmplY3QzRElkQ291bnQgPSBPYmplY3QzRElkQ291bnQ7XG4gICAgZXhwb3J0cy5PYmplY3QzRCA9IE9iamVjdDNEO1xuICAgIGV4cG9ydHMuUmF5Y2FzdGVyID0gUmF5Y2FzdGVyO1xuICAgIGV4cG9ydHMuTGF5ZXJzID0gTGF5ZXJzO1xuICAgIGV4cG9ydHMuRXZlbnREaXNwYXRjaGVyID0gRXZlbnREaXNwYXRjaGVyO1xuICAgIGV4cG9ydHMuQ2xvY2sgPSBDbG9jaztcbiAgICBleHBvcnRzLlF1YXRlcm5pb25MaW5lYXJJbnRlcnBvbGFudCA9IFF1YXRlcm5pb25MaW5lYXJJbnRlcnBvbGFudDtcbiAgICBleHBvcnRzLkxpbmVhckludGVycG9sYW50ID0gTGluZWFySW50ZXJwb2xhbnQ7XG4gICAgZXhwb3J0cy5EaXNjcmV0ZUludGVycG9sYW50ID0gRGlzY3JldGVJbnRlcnBvbGFudDtcbiAgICBleHBvcnRzLkN1YmljSW50ZXJwb2xhbnQgPSBDdWJpY0ludGVycG9sYW50O1xuICAgIGV4cG9ydHMuSW50ZXJwb2xhbnQgPSBJbnRlcnBvbGFudDtcbiAgICBleHBvcnRzLlRyaWFuZ2xlID0gVHJpYW5nbGU7XG4gICAgZXhwb3J0cy5TcGxpbmUgPSBTcGxpbmU7XG4gICAgZXhwb3J0cy5TcGhlcmljYWwgPSBTcGhlcmljYWw7XG4gICAgZXhwb3J0cy5QbGFuZSA9IFBsYW5lO1xuICAgIGV4cG9ydHMuRnJ1c3R1bSA9IEZydXN0dW07XG4gICAgZXhwb3J0cy5TcGhlcmUgPSBTcGhlcmU7XG4gICAgZXhwb3J0cy5SYXkgPSBSYXk7XG4gICAgZXhwb3J0cy5NYXRyaXg0ID0gTWF0cml4NDtcbiAgICBleHBvcnRzLk1hdHJpeDMgPSBNYXRyaXgzO1xuICAgIGV4cG9ydHMuQm94MyA9IEJveDM7XG4gICAgZXhwb3J0cy5Cb3gyID0gQm94MjtcbiAgICBleHBvcnRzLkxpbmUzID0gTGluZTM7XG4gICAgZXhwb3J0cy5FdWxlciA9IEV1bGVyO1xuICAgIGV4cG9ydHMuVmVjdG9yNCA9IFZlY3RvcjQ7XG4gICAgZXhwb3J0cy5WZWN0b3IzID0gVmVjdG9yMztcbiAgICBleHBvcnRzLlZlY3RvcjIgPSBWZWN0b3IyO1xuICAgIGV4cG9ydHMuUXVhdGVybmlvbiA9IFF1YXRlcm5pb247XG4gICAgZXhwb3J0cy5Db2xvciA9IENvbG9yO1xuICAgIGV4cG9ydHMuTW9ycGhCbGVuZE1lc2ggPSBNb3JwaEJsZW5kTWVzaDtcbiAgICBleHBvcnRzLkltbWVkaWF0ZVJlbmRlck9iamVjdCA9IEltbWVkaWF0ZVJlbmRlck9iamVjdDtcbiAgICBleHBvcnRzLlZlcnRleE5vcm1hbHNIZWxwZXIgPSBWZXJ0ZXhOb3JtYWxzSGVscGVyO1xuICAgIGV4cG9ydHMuU3BvdExpZ2h0SGVscGVyID0gU3BvdExpZ2h0SGVscGVyO1xuICAgIGV4cG9ydHMuU2tlbGV0b25IZWxwZXIgPSBTa2VsZXRvbkhlbHBlcjtcbiAgICBleHBvcnRzLlBvaW50TGlnaHRIZWxwZXIgPSBQb2ludExpZ2h0SGVscGVyO1xuICAgIGV4cG9ydHMuSGVtaXNwaGVyZUxpZ2h0SGVscGVyID0gSGVtaXNwaGVyZUxpZ2h0SGVscGVyO1xuICAgIGV4cG9ydHMuR3JpZEhlbHBlciA9IEdyaWRIZWxwZXI7XG4gICAgZXhwb3J0cy5GYWNlTm9ybWFsc0hlbHBlciA9IEZhY2VOb3JtYWxzSGVscGVyO1xuICAgIGV4cG9ydHMuRGlyZWN0aW9uYWxMaWdodEhlbHBlciA9IERpcmVjdGlvbmFsTGlnaHRIZWxwZXI7XG4gICAgZXhwb3J0cy5DYW1lcmFIZWxwZXIgPSBDYW1lcmFIZWxwZXI7XG4gICAgZXhwb3J0cy5Cb3VuZGluZ0JveEhlbHBlciA9IEJvdW5kaW5nQm94SGVscGVyO1xuICAgIGV4cG9ydHMuQm94SGVscGVyID0gQm94SGVscGVyO1xuICAgIGV4cG9ydHMuQXJyb3dIZWxwZXIgPSBBcnJvd0hlbHBlcjtcbiAgICBleHBvcnRzLkF4aXNIZWxwZXIgPSBBeGlzSGVscGVyO1xuICAgIGV4cG9ydHMuQ2xvc2VkU3BsaW5lQ3VydmUzID0gQ2xvc2VkU3BsaW5lQ3VydmUzO1xuICAgIGV4cG9ydHMuU3BsaW5lQ3VydmUzID0gU3BsaW5lQ3VydmUzO1xuICAgIGV4cG9ydHMuQXJjQ3VydmUgPSBBcmNDdXJ2ZTtcbiAgICBleHBvcnRzLkVsbGlwc2VDdXJ2ZSA9IEVsbGlwc2VDdXJ2ZTtcbiAgICBleHBvcnRzLlNwbGluZUN1cnZlID0gU3BsaW5lQ3VydmU7XG4gICAgZXhwb3J0cy5DdWJpY0JlemllckN1cnZlID0gQ3ViaWNCZXppZXJDdXJ2ZTtcbiAgICBleHBvcnRzLlF1YWRyYXRpY0JlemllckN1cnZlID0gUXVhZHJhdGljQmV6aWVyQ3VydmU7XG4gICAgZXhwb3J0cy5MaW5lQ3VydmUgPSBMaW5lQ3VydmU7XG4gICAgZXhwb3J0cy5TaGFwZSA9IFNoYXBlO1xuICAgIGV4cG9ydHMuU2hhcGVQYXRoID0gU2hhcGVQYXRoO1xuICAgIGV4cG9ydHMuUGF0aCA9IFBhdGg7XG4gICAgZXhwb3J0cy5Gb250ID0gRm9udDtcbiAgICBleHBvcnRzLkN1cnZlUGF0aCA9IEN1cnZlUGF0aDtcbiAgICBleHBvcnRzLkN1cnZlID0gQ3VydmU7XG4gICAgZXhwb3J0cy5XaXJlZnJhbWVHZW9tZXRyeSA9IFdpcmVmcmFtZUdlb21ldHJ5O1xuICAgIGV4cG9ydHMuUGFyYW1ldHJpY0dlb21ldHJ5ID0gUGFyYW1ldHJpY0dlb21ldHJ5O1xuICAgIGV4cG9ydHMuVGV0cmFoZWRyb25HZW9tZXRyeSA9IFRldHJhaGVkcm9uR2VvbWV0cnk7XG4gICAgZXhwb3J0cy5PY3RhaGVkcm9uR2VvbWV0cnkgPSBPY3RhaGVkcm9uR2VvbWV0cnk7XG4gICAgZXhwb3J0cy5JY29zYWhlZHJvbkdlb21ldHJ5ID0gSWNvc2FoZWRyb25HZW9tZXRyeTtcbiAgICBleHBvcnRzLkRvZGVjYWhlZHJvbkdlb21ldHJ5ID0gRG9kZWNhaGVkcm9uR2VvbWV0cnk7XG4gICAgZXhwb3J0cy5Qb2x5aGVkcm9uR2VvbWV0cnkgPSBQb2x5aGVkcm9uR2VvbWV0cnk7XG4gICAgZXhwb3J0cy5UdWJlR2VvbWV0cnkgPSBUdWJlR2VvbWV0cnk7XG4gICAgZXhwb3J0cy5Ub3J1c0tub3RHZW9tZXRyeSA9IFRvcnVzS25vdEdlb21ldHJ5O1xuICAgIGV4cG9ydHMuVG9ydXNLbm90QnVmZmVyR2VvbWV0cnkgPSBUb3J1c0tub3RCdWZmZXJHZW9tZXRyeTtcbiAgICBleHBvcnRzLlRvcnVzR2VvbWV0cnkgPSBUb3J1c0dlb21ldHJ5O1xuICAgIGV4cG9ydHMuVG9ydXNCdWZmZXJHZW9tZXRyeSA9IFRvcnVzQnVmZmVyR2VvbWV0cnk7XG4gICAgZXhwb3J0cy5UZXh0R2VvbWV0cnkgPSBUZXh0R2VvbWV0cnk7XG4gICAgZXhwb3J0cy5TcGhlcmVCdWZmZXJHZW9tZXRyeSA9IFNwaGVyZUJ1ZmZlckdlb21ldHJ5O1xuICAgIGV4cG9ydHMuU3BoZXJlR2VvbWV0cnkgPSBTcGhlcmVHZW9tZXRyeTtcbiAgICBleHBvcnRzLlJpbmdHZW9tZXRyeSA9IFJpbmdHZW9tZXRyeTtcbiAgICBleHBvcnRzLlJpbmdCdWZmZXJHZW9tZXRyeSA9IFJpbmdCdWZmZXJHZW9tZXRyeTtcbiAgICBleHBvcnRzLlBsYW5lQnVmZmVyR2VvbWV0cnkgPSBQbGFuZUJ1ZmZlckdlb21ldHJ5O1xuICAgIGV4cG9ydHMuUGxhbmVHZW9tZXRyeSA9IFBsYW5lR2VvbWV0cnk7XG4gICAgZXhwb3J0cy5MYXRoZUdlb21ldHJ5ID0gTGF0aGVHZW9tZXRyeTtcbiAgICBleHBvcnRzLkxhdGhlQnVmZmVyR2VvbWV0cnkgPSBMYXRoZUJ1ZmZlckdlb21ldHJ5O1xuICAgIGV4cG9ydHMuU2hhcGVHZW9tZXRyeSA9IFNoYXBlR2VvbWV0cnk7XG4gICAgZXhwb3J0cy5FeHRydWRlR2VvbWV0cnkgPSBFeHRydWRlR2VvbWV0cnk7XG4gICAgZXhwb3J0cy5FZGdlc0dlb21ldHJ5ID0gRWRnZXNHZW9tZXRyeTtcbiAgICBleHBvcnRzLkNvbmVHZW9tZXRyeSA9IENvbmVHZW9tZXRyeTtcbiAgICBleHBvcnRzLkNvbmVCdWZmZXJHZW9tZXRyeSA9IENvbmVCdWZmZXJHZW9tZXRyeTtcbiAgICBleHBvcnRzLkN5bGluZGVyR2VvbWV0cnkgPSBDeWxpbmRlckdlb21ldHJ5O1xuICAgIGV4cG9ydHMuQ3lsaW5kZXJCdWZmZXJHZW9tZXRyeSA9IEN5bGluZGVyQnVmZmVyR2VvbWV0cnk7XG4gICAgZXhwb3J0cy5DaXJjbGVCdWZmZXJHZW9tZXRyeSA9IENpcmNsZUJ1ZmZlckdlb21ldHJ5O1xuICAgIGV4cG9ydHMuQ2lyY2xlR2VvbWV0cnkgPSBDaXJjbGVHZW9tZXRyeTtcbiAgICBleHBvcnRzLkJveEJ1ZmZlckdlb21ldHJ5ID0gQm94QnVmZmVyR2VvbWV0cnk7XG4gICAgZXhwb3J0cy5Cb3hHZW9tZXRyeSA9IEJveEdlb21ldHJ5O1xuICAgIGV4cG9ydHMuU2hhZG93TWF0ZXJpYWwgPSBTaGFkb3dNYXRlcmlhbDtcbiAgICBleHBvcnRzLlNwcml0ZU1hdGVyaWFsID0gU3ByaXRlTWF0ZXJpYWw7XG4gICAgZXhwb3J0cy5SYXdTaGFkZXJNYXRlcmlhbCA9IFJhd1NoYWRlck1hdGVyaWFsO1xuICAgIGV4cG9ydHMuU2hhZGVyTWF0ZXJpYWwgPSBTaGFkZXJNYXRlcmlhbDtcbiAgICBleHBvcnRzLlBvaW50c01hdGVyaWFsID0gUG9pbnRzTWF0ZXJpYWw7XG4gICAgZXhwb3J0cy5NdWx0aU1hdGVyaWFsID0gTXVsdGlNYXRlcmlhbDtcbiAgICBleHBvcnRzLk1lc2hQaHlzaWNhbE1hdGVyaWFsID0gTWVzaFBoeXNpY2FsTWF0ZXJpYWw7XG4gICAgZXhwb3J0cy5NZXNoU3RhbmRhcmRNYXRlcmlhbCA9IE1lc2hTdGFuZGFyZE1hdGVyaWFsO1xuICAgIGV4cG9ydHMuTWVzaFBob25nTWF0ZXJpYWwgPSBNZXNoUGhvbmdNYXRlcmlhbDtcbiAgICBleHBvcnRzLk1lc2hOb3JtYWxNYXRlcmlhbCA9IE1lc2hOb3JtYWxNYXRlcmlhbDtcbiAgICBleHBvcnRzLk1lc2hMYW1iZXJ0TWF0ZXJpYWwgPSBNZXNoTGFtYmVydE1hdGVyaWFsO1xuICAgIGV4cG9ydHMuTWVzaERlcHRoTWF0ZXJpYWwgPSBNZXNoRGVwdGhNYXRlcmlhbDtcbiAgICBleHBvcnRzLk1lc2hCYXNpY01hdGVyaWFsID0gTWVzaEJhc2ljTWF0ZXJpYWw7XG4gICAgZXhwb3J0cy5MaW5lRGFzaGVkTWF0ZXJpYWwgPSBMaW5lRGFzaGVkTWF0ZXJpYWw7XG4gICAgZXhwb3J0cy5MaW5lQmFzaWNNYXRlcmlhbCA9IExpbmVCYXNpY01hdGVyaWFsO1xuICAgIGV4cG9ydHMuTWF0ZXJpYWwgPSBNYXRlcmlhbDtcbiAgICBleHBvcnRzLlJFVklTSU9OID0gUkVWSVNJT047XG4gICAgZXhwb3J0cy5NT1VTRSA9IE1PVVNFO1xuICAgIGV4cG9ydHMuQ3VsbEZhY2VOb25lID0gQ3VsbEZhY2VOb25lO1xuICAgIGV4cG9ydHMuQ3VsbEZhY2VCYWNrID0gQ3VsbEZhY2VCYWNrO1xuICAgIGV4cG9ydHMuQ3VsbEZhY2VGcm9udCA9IEN1bGxGYWNlRnJvbnQ7XG4gICAgZXhwb3J0cy5DdWxsRmFjZUZyb250QmFjayA9IEN1bGxGYWNlRnJvbnRCYWNrO1xuICAgIGV4cG9ydHMuRnJvbnRGYWNlRGlyZWN0aW9uQ1cgPSBGcm9udEZhY2VEaXJlY3Rpb25DVztcbiAgICBleHBvcnRzLkZyb250RmFjZURpcmVjdGlvbkNDVyA9IEZyb250RmFjZURpcmVjdGlvbkNDVztcbiAgICBleHBvcnRzLkJhc2ljU2hhZG93TWFwID0gQmFzaWNTaGFkb3dNYXA7XG4gICAgZXhwb3J0cy5QQ0ZTaGFkb3dNYXAgPSBQQ0ZTaGFkb3dNYXA7XG4gICAgZXhwb3J0cy5QQ0ZTb2Z0U2hhZG93TWFwID0gUENGU29mdFNoYWRvd01hcDtcbiAgICBleHBvcnRzLkZyb250U2lkZSA9IEZyb250U2lkZTtcbiAgICBleHBvcnRzLkJhY2tTaWRlID0gQmFja1NpZGU7XG4gICAgZXhwb3J0cy5Eb3VibGVTaWRlID0gRG91YmxlU2lkZTtcbiAgICBleHBvcnRzLkZsYXRTaGFkaW5nID0gRmxhdFNoYWRpbmc7XG4gICAgZXhwb3J0cy5TbW9vdGhTaGFkaW5nID0gU21vb3RoU2hhZGluZztcbiAgICBleHBvcnRzLk5vQ29sb3JzID0gTm9Db2xvcnM7XG4gICAgZXhwb3J0cy5GYWNlQ29sb3JzID0gRmFjZUNvbG9ycztcbiAgICBleHBvcnRzLlZlcnRleENvbG9ycyA9IFZlcnRleENvbG9ycztcbiAgICBleHBvcnRzLk5vQmxlbmRpbmcgPSBOb0JsZW5kaW5nO1xuICAgIGV4cG9ydHMuTm9ybWFsQmxlbmRpbmcgPSBOb3JtYWxCbGVuZGluZztcbiAgICBleHBvcnRzLkFkZGl0aXZlQmxlbmRpbmcgPSBBZGRpdGl2ZUJsZW5kaW5nO1xuICAgIGV4cG9ydHMuU3VidHJhY3RpdmVCbGVuZGluZyA9IFN1YnRyYWN0aXZlQmxlbmRpbmc7XG4gICAgZXhwb3J0cy5NdWx0aXBseUJsZW5kaW5nID0gTXVsdGlwbHlCbGVuZGluZztcbiAgICBleHBvcnRzLkN1c3RvbUJsZW5kaW5nID0gQ3VzdG9tQmxlbmRpbmc7XG4gICAgZXhwb3J0cy5CbGVuZGluZ01vZGUgPSBCbGVuZGluZ01vZGU7XG4gICAgZXhwb3J0cy5BZGRFcXVhdGlvbiA9IEFkZEVxdWF0aW9uO1xuICAgIGV4cG9ydHMuU3VidHJhY3RFcXVhdGlvbiA9IFN1YnRyYWN0RXF1YXRpb247XG4gICAgZXhwb3J0cy5SZXZlcnNlU3VidHJhY3RFcXVhdGlvbiA9IFJldmVyc2VTdWJ0cmFjdEVxdWF0aW9uO1xuICAgIGV4cG9ydHMuTWluRXF1YXRpb24gPSBNaW5FcXVhdGlvbjtcbiAgICBleHBvcnRzLk1heEVxdWF0aW9uID0gTWF4RXF1YXRpb247XG4gICAgZXhwb3J0cy5aZXJvRmFjdG9yID0gWmVyb0ZhY3RvcjtcbiAgICBleHBvcnRzLk9uZUZhY3RvciA9IE9uZUZhY3RvcjtcbiAgICBleHBvcnRzLlNyY0NvbG9yRmFjdG9yID0gU3JjQ29sb3JGYWN0b3I7XG4gICAgZXhwb3J0cy5PbmVNaW51c1NyY0NvbG9yRmFjdG9yID0gT25lTWludXNTcmNDb2xvckZhY3RvcjtcbiAgICBleHBvcnRzLlNyY0FscGhhRmFjdG9yID0gU3JjQWxwaGFGYWN0b3I7XG4gICAgZXhwb3J0cy5PbmVNaW51c1NyY0FscGhhRmFjdG9yID0gT25lTWludXNTcmNBbHBoYUZhY3RvcjtcbiAgICBleHBvcnRzLkRzdEFscGhhRmFjdG9yID0gRHN0QWxwaGFGYWN0b3I7XG4gICAgZXhwb3J0cy5PbmVNaW51c0RzdEFscGhhRmFjdG9yID0gT25lTWludXNEc3RBbHBoYUZhY3RvcjtcbiAgICBleHBvcnRzLkRzdENvbG9yRmFjdG9yID0gRHN0Q29sb3JGYWN0b3I7XG4gICAgZXhwb3J0cy5PbmVNaW51c0RzdENvbG9yRmFjdG9yID0gT25lTWludXNEc3RDb2xvckZhY3RvcjtcbiAgICBleHBvcnRzLlNyY0FscGhhU2F0dXJhdGVGYWN0b3IgPSBTcmNBbHBoYVNhdHVyYXRlRmFjdG9yO1xuICAgIGV4cG9ydHMuTmV2ZXJEZXB0aCA9IE5ldmVyRGVwdGg7XG4gICAgZXhwb3J0cy5BbHdheXNEZXB0aCA9IEFsd2F5c0RlcHRoO1xuICAgIGV4cG9ydHMuTGVzc0RlcHRoID0gTGVzc0RlcHRoO1xuICAgIGV4cG9ydHMuTGVzc0VxdWFsRGVwdGggPSBMZXNzRXF1YWxEZXB0aDtcbiAgICBleHBvcnRzLkVxdWFsRGVwdGggPSBFcXVhbERlcHRoO1xuICAgIGV4cG9ydHMuR3JlYXRlckVxdWFsRGVwdGggPSBHcmVhdGVyRXF1YWxEZXB0aDtcbiAgICBleHBvcnRzLkdyZWF0ZXJEZXB0aCA9IEdyZWF0ZXJEZXB0aDtcbiAgICBleHBvcnRzLk5vdEVxdWFsRGVwdGggPSBOb3RFcXVhbERlcHRoO1xuICAgIGV4cG9ydHMuTXVsdGlwbHlPcGVyYXRpb24gPSBNdWx0aXBseU9wZXJhdGlvbjtcbiAgICBleHBvcnRzLk1peE9wZXJhdGlvbiA9IE1peE9wZXJhdGlvbjtcbiAgICBleHBvcnRzLkFkZE9wZXJhdGlvbiA9IEFkZE9wZXJhdGlvbjtcbiAgICBleHBvcnRzLk5vVG9uZU1hcHBpbmcgPSBOb1RvbmVNYXBwaW5nO1xuICAgIGV4cG9ydHMuTGluZWFyVG9uZU1hcHBpbmcgPSBMaW5lYXJUb25lTWFwcGluZztcbiAgICBleHBvcnRzLlJlaW5oYXJkVG9uZU1hcHBpbmcgPSBSZWluaGFyZFRvbmVNYXBwaW5nO1xuICAgIGV4cG9ydHMuVW5jaGFydGVkMlRvbmVNYXBwaW5nID0gVW5jaGFydGVkMlRvbmVNYXBwaW5nO1xuICAgIGV4cG9ydHMuQ2luZW9uVG9uZU1hcHBpbmcgPSBDaW5lb25Ub25lTWFwcGluZztcbiAgICBleHBvcnRzLlVWTWFwcGluZyA9IFVWTWFwcGluZztcbiAgICBleHBvcnRzLkN1YmVSZWZsZWN0aW9uTWFwcGluZyA9IEN1YmVSZWZsZWN0aW9uTWFwcGluZztcbiAgICBleHBvcnRzLkN1YmVSZWZyYWN0aW9uTWFwcGluZyA9IEN1YmVSZWZyYWN0aW9uTWFwcGluZztcbiAgICBleHBvcnRzLkVxdWlyZWN0YW5ndWxhclJlZmxlY3Rpb25NYXBwaW5nID0gRXF1aXJlY3Rhbmd1bGFyUmVmbGVjdGlvbk1hcHBpbmc7XG4gICAgZXhwb3J0cy5FcXVpcmVjdGFuZ3VsYXJSZWZyYWN0aW9uTWFwcGluZyA9IEVxdWlyZWN0YW5ndWxhclJlZnJhY3Rpb25NYXBwaW5nO1xuICAgIGV4cG9ydHMuU3BoZXJpY2FsUmVmbGVjdGlvbk1hcHBpbmcgPSBTcGhlcmljYWxSZWZsZWN0aW9uTWFwcGluZztcbiAgICBleHBvcnRzLkN1YmVVVlJlZmxlY3Rpb25NYXBwaW5nID0gQ3ViZVVWUmVmbGVjdGlvbk1hcHBpbmc7XG4gICAgZXhwb3J0cy5DdWJlVVZSZWZyYWN0aW9uTWFwcGluZyA9IEN1YmVVVlJlZnJhY3Rpb25NYXBwaW5nO1xuICAgIGV4cG9ydHMuVGV4dHVyZU1hcHBpbmcgPSBUZXh0dXJlTWFwcGluZztcbiAgICBleHBvcnRzLlJlcGVhdFdyYXBwaW5nID0gUmVwZWF0V3JhcHBpbmc7XG4gICAgZXhwb3J0cy5DbGFtcFRvRWRnZVdyYXBwaW5nID0gQ2xhbXBUb0VkZ2VXcmFwcGluZztcbiAgICBleHBvcnRzLk1pcnJvcmVkUmVwZWF0V3JhcHBpbmcgPSBNaXJyb3JlZFJlcGVhdFdyYXBwaW5nO1xuICAgIGV4cG9ydHMuVGV4dHVyZVdyYXBwaW5nID0gVGV4dHVyZVdyYXBwaW5nO1xuICAgIGV4cG9ydHMuTmVhcmVzdEZpbHRlciA9IE5lYXJlc3RGaWx0ZXI7XG4gICAgZXhwb3J0cy5OZWFyZXN0TWlwTWFwTmVhcmVzdEZpbHRlciA9IE5lYXJlc3RNaXBNYXBOZWFyZXN0RmlsdGVyO1xuICAgIGV4cG9ydHMuTmVhcmVzdE1pcE1hcExpbmVhckZpbHRlciA9IE5lYXJlc3RNaXBNYXBMaW5lYXJGaWx0ZXI7XG4gICAgZXhwb3J0cy5MaW5lYXJGaWx0ZXIgPSBMaW5lYXJGaWx0ZXI7XG4gICAgZXhwb3J0cy5MaW5lYXJNaXBNYXBOZWFyZXN0RmlsdGVyID0gTGluZWFyTWlwTWFwTmVhcmVzdEZpbHRlcjtcbiAgICBleHBvcnRzLkxpbmVhck1pcE1hcExpbmVhckZpbHRlciA9IExpbmVhck1pcE1hcExpbmVhckZpbHRlcjtcbiAgICBleHBvcnRzLlRleHR1cmVGaWx0ZXIgPSBUZXh0dXJlRmlsdGVyO1xuICAgIGV4cG9ydHMuVW5zaWduZWRCeXRlVHlwZSA9IFVuc2lnbmVkQnl0ZVR5cGU7XG4gICAgZXhwb3J0cy5CeXRlVHlwZSA9IEJ5dGVUeXBlO1xuICAgIGV4cG9ydHMuU2hvcnRUeXBlID0gU2hvcnRUeXBlO1xuICAgIGV4cG9ydHMuVW5zaWduZWRTaG9ydFR5cGUgPSBVbnNpZ25lZFNob3J0VHlwZTtcbiAgICBleHBvcnRzLkludFR5cGUgPSBJbnRUeXBlO1xuICAgIGV4cG9ydHMuVW5zaWduZWRJbnRUeXBlID0gVW5zaWduZWRJbnRUeXBlO1xuICAgIGV4cG9ydHMuRmxvYXRUeXBlID0gRmxvYXRUeXBlO1xuICAgIGV4cG9ydHMuSGFsZkZsb2F0VHlwZSA9IEhhbGZGbG9hdFR5cGU7XG4gICAgZXhwb3J0cy5VbnNpZ25lZFNob3J0NDQ0NFR5cGUgPSBVbnNpZ25lZFNob3J0NDQ0NFR5cGU7XG4gICAgZXhwb3J0cy5VbnNpZ25lZFNob3J0NTU1MVR5cGUgPSBVbnNpZ25lZFNob3J0NTU1MVR5cGU7XG4gICAgZXhwb3J0cy5VbnNpZ25lZFNob3J0NTY1VHlwZSA9IFVuc2lnbmVkU2hvcnQ1NjVUeXBlO1xuICAgIGV4cG9ydHMuVW5zaWduZWRJbnQyNDhUeXBlID0gVW5zaWduZWRJbnQyNDhUeXBlO1xuICAgIGV4cG9ydHMuQWxwaGFGb3JtYXQgPSBBbHBoYUZvcm1hdDtcbiAgICBleHBvcnRzLlJHQkZvcm1hdCA9IFJHQkZvcm1hdDtcbiAgICBleHBvcnRzLlJHQkFGb3JtYXQgPSBSR0JBRm9ybWF0O1xuICAgIGV4cG9ydHMuTHVtaW5hbmNlRm9ybWF0ID0gTHVtaW5hbmNlRm9ybWF0O1xuICAgIGV4cG9ydHMuTHVtaW5hbmNlQWxwaGFGb3JtYXQgPSBMdW1pbmFuY2VBbHBoYUZvcm1hdDtcbiAgICBleHBvcnRzLlJHQkVGb3JtYXQgPSBSR0JFRm9ybWF0O1xuICAgIGV4cG9ydHMuRGVwdGhGb3JtYXQgPSBEZXB0aEZvcm1hdDtcbiAgICBleHBvcnRzLkRlcHRoU3RlbmNpbEZvcm1hdCA9IERlcHRoU3RlbmNpbEZvcm1hdDtcbiAgICBleHBvcnRzLlJHQl9TM1RDX0RYVDFfRm9ybWF0ID0gUkdCX1MzVENfRFhUMV9Gb3JtYXQ7XG4gICAgZXhwb3J0cy5SR0JBX1MzVENfRFhUMV9Gb3JtYXQgPSBSR0JBX1MzVENfRFhUMV9Gb3JtYXQ7XG4gICAgZXhwb3J0cy5SR0JBX1MzVENfRFhUM19Gb3JtYXQgPSBSR0JBX1MzVENfRFhUM19Gb3JtYXQ7XG4gICAgZXhwb3J0cy5SR0JBX1MzVENfRFhUNV9Gb3JtYXQgPSBSR0JBX1MzVENfRFhUNV9Gb3JtYXQ7XG4gICAgZXhwb3J0cy5SR0JfUFZSVENfNEJQUFYxX0Zvcm1hdCA9IFJHQl9QVlJUQ180QlBQVjFfRm9ybWF0O1xuICAgIGV4cG9ydHMuUkdCX1BWUlRDXzJCUFBWMV9Gb3JtYXQgPSBSR0JfUFZSVENfMkJQUFYxX0Zvcm1hdDtcbiAgICBleHBvcnRzLlJHQkFfUFZSVENfNEJQUFYxX0Zvcm1hdCA9IFJHQkFfUFZSVENfNEJQUFYxX0Zvcm1hdDtcbiAgICBleHBvcnRzLlJHQkFfUFZSVENfMkJQUFYxX0Zvcm1hdCA9IFJHQkFfUFZSVENfMkJQUFYxX0Zvcm1hdDtcbiAgICBleHBvcnRzLlJHQl9FVEMxX0Zvcm1hdCA9IFJHQl9FVEMxX0Zvcm1hdDtcbiAgICBleHBvcnRzLkxvb3BPbmNlID0gTG9vcE9uY2U7XG4gICAgZXhwb3J0cy5Mb29wUmVwZWF0ID0gTG9vcFJlcGVhdDtcbiAgICBleHBvcnRzLkxvb3BQaW5nUG9uZyA9IExvb3BQaW5nUG9uZztcbiAgICBleHBvcnRzLkludGVycG9sYXRlRGlzY3JldGUgPSBJbnRlcnBvbGF0ZURpc2NyZXRlO1xuICAgIGV4cG9ydHMuSW50ZXJwb2xhdGVMaW5lYXIgPSBJbnRlcnBvbGF0ZUxpbmVhcjtcbiAgICBleHBvcnRzLkludGVycG9sYXRlU21vb3RoID0gSW50ZXJwb2xhdGVTbW9vdGg7XG4gICAgZXhwb3J0cy5aZXJvQ3VydmF0dXJlRW5kaW5nID0gWmVyb0N1cnZhdHVyZUVuZGluZztcbiAgICBleHBvcnRzLlplcm9TbG9wZUVuZGluZyA9IFplcm9TbG9wZUVuZGluZztcbiAgICBleHBvcnRzLldyYXBBcm91bmRFbmRpbmcgPSBXcmFwQXJvdW5kRW5kaW5nO1xuICAgIGV4cG9ydHMuVHJpYW5nbGVzRHJhd01vZGUgPSBUcmlhbmdsZXNEcmF3TW9kZTtcbiAgICBleHBvcnRzLlRyaWFuZ2xlU3RyaXBEcmF3TW9kZSA9IFRyaWFuZ2xlU3RyaXBEcmF3TW9kZTtcbiAgICBleHBvcnRzLlRyaWFuZ2xlRmFuRHJhd01vZGUgPSBUcmlhbmdsZUZhbkRyYXdNb2RlO1xuICAgIGV4cG9ydHMuTGluZWFyRW5jb2RpbmcgPSBMaW5lYXJFbmNvZGluZztcbiAgICBleHBvcnRzLnNSR0JFbmNvZGluZyA9IHNSR0JFbmNvZGluZztcbiAgICBleHBvcnRzLkdhbW1hRW5jb2RpbmcgPSBHYW1tYUVuY29kaW5nO1xuICAgIGV4cG9ydHMuUkdCRUVuY29kaW5nID0gUkdCRUVuY29kaW5nO1xuICAgIGV4cG9ydHMuTG9nTHV2RW5jb2RpbmcgPSBMb2dMdXZFbmNvZGluZztcbiAgICBleHBvcnRzLlJHQk03RW5jb2RpbmcgPSBSR0JNN0VuY29kaW5nO1xuICAgIGV4cG9ydHMuUkdCTTE2RW5jb2RpbmcgPSBSR0JNMTZFbmNvZGluZztcbiAgICBleHBvcnRzLlJHQkRFbmNvZGluZyA9IFJHQkRFbmNvZGluZztcbiAgICBleHBvcnRzLkJhc2ljRGVwdGhQYWNraW5nID0gQmFzaWNEZXB0aFBhY2tpbmc7XG4gICAgZXhwb3J0cy5SR0JBRGVwdGhQYWNraW5nID0gUkdCQURlcHRoUGFja2luZztcbiAgICBleHBvcnRzLkN1YmVHZW9tZXRyeSA9IEJveEdlb21ldHJ5O1xuICAgIGV4cG9ydHMuRmFjZTQgPSBGYWNlNDtcbiAgICBleHBvcnRzLkxpbmVTdHJpcCA9IExpbmVTdHJpcDtcbiAgICBleHBvcnRzLkxpbmVQaWVjZXMgPSBMaW5lUGllY2VzO1xuICAgIGV4cG9ydHMuTWVzaEZhY2VNYXRlcmlhbCA9IE11bHRpTWF0ZXJpYWw7XG4gICAgZXhwb3J0cy5Qb2ludENsb3VkID0gUG9pbnRDbG91ZDtcbiAgICBleHBvcnRzLlBhcnRpY2xlID0gU3ByaXRlO1xuICAgIGV4cG9ydHMuUGFydGljbGVTeXN0ZW0gPSBQYXJ0aWNsZVN5c3RlbTtcbiAgICBleHBvcnRzLlBvaW50Q2xvdWRNYXRlcmlhbCA9IFBvaW50Q2xvdWRNYXRlcmlhbDtcbiAgICBleHBvcnRzLlBhcnRpY2xlQmFzaWNNYXRlcmlhbCA9IFBhcnRpY2xlQmFzaWNNYXRlcmlhbDtcbiAgICBleHBvcnRzLlBhcnRpY2xlU3lzdGVtTWF0ZXJpYWwgPSBQYXJ0aWNsZVN5c3RlbU1hdGVyaWFsO1xuICAgIGV4cG9ydHMuVmVydGV4ID0gVmVydGV4O1xuICAgIGV4cG9ydHMuRWRnZXNIZWxwZXIgPSBFZGdlc0hlbHBlcjtcbiAgICBleHBvcnRzLldpcmVmcmFtZUhlbHBlciA9IFdpcmVmcmFtZUhlbHBlcjtcbiAgICBleHBvcnRzLkdlb21ldHJ5VXRpbHMgPSBHZW9tZXRyeVV0aWxzO1xuICAgIGV4cG9ydHMuSW1hZ2VVdGlscyA9IEltYWdlVXRpbHM7XG4gICAgZXhwb3J0cy5Qcm9qZWN0b3IgPSBQcm9qZWN0b3I7XG4gICAgZXhwb3J0cy5DYW52YXNSZW5kZXJlciA9IENhbnZhc1JlbmRlcmVyO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTsiLCJpbXBvcnQgKiBhcyBUSFJFRSBmcm9tICd0aHJlZSdcbi8vIGltcG9ydCBhbmltZSBmcm9tICdhbmltZWpzJ1xuXG5cbmxldCBjYW1lcmEsIHNjZW5lLCByZW5kZXJlciwgbWVzaFxuXG5jb25zdCBpbml0ID0gKCkgPT4ge1xuXHRjYW1lcmEgPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoIDcwLCB3aW5kb3cuaW5uZXJXaWR0aCAvIHdpbmRvdy5pbm5lckhlaWdodCwgMSwgMTAwMCApXG5cdGNhbWVyYS5wb3NpdGlvbi56ID0gNDAwXG5cblx0c2NlbmUgPSBuZXcgVEhSRUUuU2NlbmUoKVxuXG5cdGNvbnN0IGdlb21ldHJ5ID0gbmV3IFRIUkVFLkJveEJ1ZmZlckdlb21ldHJ5KCAxMDAsIDEwMCwgMTAwIClcblx0Y29uc3QgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoKVxuXG5cdG1lc2ggPSBuZXcgVEhSRUUuTWVzaCggZ2VvbWV0cnksIG1hdGVyaWFsIClcblx0c2NlbmUuYWRkKG1lc2gpXG5cblx0cmVuZGVyZXIgPSBuZXcgVEhSRUUuV2ViR0xSZW5kZXJlcigpXG5cdHJlbmRlcmVyLnNldFBpeGVsUmF0aW8oIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIClcblx0cmVuZGVyZXIuc2V0U2l6ZSggd2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCApXG5cblx0ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCggcmVuZGVyZXIuZG9tRWxlbWVudCApXG5cblx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoICdyZXNpemUnLCBvbldpbmRvd1Jlc2l6ZSwgZmFsc2UgKVxufVxuXG5cbmNvbnN0IG9uV2luZG93UmVzaXplID0gKCkgPT4ge1xuXHRjYW1lcmEuYXNwZWN0ID0gd2luZG93LmlubmVyV2lkdGggLyB3aW5kb3cuaW5uZXJIZWlnaHRcblx0Y2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKVxuXHRyZW5kZXJlci5zZXRTaXplKCB3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0IClcbn1cblxuXG5jb25zdCBhbmltYXRlID0gKCkgPT4ge1xuXHRyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIGFuaW1hdGUgKVxuXHRtZXNoLnJvdGF0aW9uLnggKz0gMC4wMDFcblx0bWVzaC5yb3RhdGlvbi55ICs9IDAuMDAyXG5cdHJlbmRlcmVyLnJlbmRlciggc2NlbmUsIGNhbWVyYSApXG59XG5cbmluaXQoKVxuYW5pbWF0ZSgpXG4iXX0=
